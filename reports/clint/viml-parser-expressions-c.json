["src/nvim/viml/parser/expressions.c", ["    ret.data.cmp.type = ((ret.data.cmp.inv ^ haseqsign)", "                           ? kExprCmpGreaterOrEqual", "                           : kExprCmpGreater);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                           ? kExprCmpGreaterOrEqual", "                           : kExprCmpGreater);", "    break;"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                                        != kExprNodeConcatOrSubscript))))", "           ? kELFlagAllowFloat", "           : 0));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["           ? kELFlagAllowFloat", "           : 0));", "    LexExprToken cur_token = viml_pexpr_next_token(pstate,"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                                        != kExprNodeConcatOrSubscript))))", "           ? kELFlagAllowFloat", "           : 0));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["           ? kELFlagAllowFloat", "           : 0));", "    LexExprToken cur_token = viml_pexpr_next_token(pstate,"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              && (cur_token.type == kExprLexPlainIdentifier", "            ? (!cur_token.data.var.autoload", "               && cur_token.data.var.scope == kExprVarScopeMissing)"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["               && cur_token.data.var.scope == kExprVarScopeMissing)", "            : (cur_token.type == kExprLexNumber))", "                              && prev_token.type != kExprLexSpacing);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              && (cur_token.type == kExprLexPlainIdentifier", "            ? (!cur_token.data.var.autoload", "               && cur_token.data.var.scope == kExprVarScopeMissing)"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["               && cur_token.data.var.scope == kExprVarScopeMissing)", "            : (cur_token.type == kExprLexNumber))", "                              && prev_token.type != kExprLexSpacing);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["      const ExprVarScope scope = (cur_token.type == kExprLexInvalid", "                                    ? kExprVarScopeMissing", "                                    : cur_token.data.var.scope);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                    ? kExprVarScopeMissing", "                                    : cur_token.data.var.scope);", "      if (want_node == kENodeValue) {"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));", "        cur_node->data.var.scope = scope;"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));", "        cur_node->data.var.scope = scope;"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));", "      } else {"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));", "      } else {"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["        ERROR_FROM_TOKEN_AND_MSG(cur_token, (is_double", "                          ? _(\"E114: Missing double quote: %.*s\")", "                          : _(\"E115: Missing single quote: %.*s\")));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                          ? _(\"E114: Missing double quote: %.*s\")", "                          : _(\"E115: Missing single quote: %.*s\")));", "      }"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["      NEW_NODE_WITH_CUR_POS(cur_node, (is_double", "                       ? kExprNodeDoubleQuotedString", "                       : kExprNodeSingleQuotedString));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                       ? kExprNodeDoubleQuotedString", "                       : kExprNodeSingleQuotedString));", "      *top_node_p = cur_node;"], "whitespace/alignment"]
