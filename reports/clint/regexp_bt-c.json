["src/nvim/regexp_bt.c", ["", "/*", " *"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * The \"internal use only\" fields in regexp_defs.h are present to pass info from"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Structure for regexp \"program\".  This is essentially a linear encoding"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * The opcodes are:"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Flags to be passed up and down."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * When regcode is set to this value, code is not emitted and size is computed"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Structure used to save the current input state, when it needs to be"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * When there are alternatives a regstate_T is put on the regstack to remember"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * \"regstack\" and \"backpos\" are used by regmatch().  They are kept over calls"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Both for regstack and backpos tables we use the following strategy of"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Opcode notes:"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * A node is one char of opcode followed by two chars of \"next\" pointer."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Setup to parse the regexp.  Used once to get the length and once to do it."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Emit (if appropriate) a byte of code"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Emit (if appropriate) a multi-byte character of code"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Produce the bytes for equivalence class \"c\"."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Emit a node."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Write a four bytes number at \"p\" and return pointer to the next char."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * regnext - dig the \"next\" pointer out of a node"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Like regtail, on item after a BRANCH; nop if none."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Insert an operator in front of already-emitted operand"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Insert an operator in front of already-emitted operand."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Insert an operator in front of already-emitted operand."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Parse the lowest level."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["          // 'cpoptions' is not included.", "          else if (*regparse == '\\\\'", "                   && (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["              } else if ((c_class =", "                            get_coll_element(&regparse)) != 0) {", "                // produce a collating element"], "whitespace/alignment"]
["src/nvim/regexp_bt.c", ["                                   && !one_exactly", "                                   && !is_Magic(c))); ++len) {", "      c = no_Magic(c);"], "readability/increment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Parse something followed by possible [*+=]."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Parse one alternative of an | or & operator."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Parse one alternative of an | operator."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * bt_regcomp() - compile a regular expression into internal code for the"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Check if during the previous call to vim_regcomp the EOL item \"$\" has been"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Get a number after a backslash that is inside []."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Free a compiled regexp program, returned by bt_regcomp()."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * The arguments from BRACE_LIMITS are stored here.  They are actually local"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Tentatively set the sub-expression start to the current position (after"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Push an item onto the regstack."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Pop an item from the regstack."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["          reg_restore(&rp->rs_un.regsave, &backpos);", "          --brace_count[rp->rs_no];             // decrement match count", "        }"], "readability/increment"]
["src/nvim/regexp_bt.c", ["          reg_restore(&rp->rs_un.regsave, &backpos);", "          --brace_count[rp->rs_no];", "          // continue with the items after \"\\{}\""], "readability/increment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * regdump - dump a regexp onto stdout in vaguely comprehensible form"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * regprop - printable representation of opcode"], "readability/old_style_comment"]
