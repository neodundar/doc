["src/nvim/assert.h", ["// _Static_assert but we need to suppress warnings, this is pretty ugly.", "#elif (!defined(__clang__) && !defined(__INTEL_COMPILER)) && \\", "  (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))"], "whitespace/parens"]
["src/nvim/eval/executor.c", ["      const float_T f = (tv2->v_type == VAR_FLOAT", "                           ? tv2->vval.v_float", "                           : (float_T)tv_get_number(tv2));"], "whitespace/alignment"]
["src/nvim/eval/executor.c", ["                           ? tv2->vval.v_float", "                           : (float_T)tv_get_number(tv2));", "      switch (*op) {"], "whitespace/alignment"]
["src/nvim/eval/typval.h", ["#define TV_LIST_ITER(l, li, code) \\", "  _TV_LIST_ITER_MOD( , l, li, code)", ""], "whitespace/parens"]
["src/nvim/eval/typval_defs.h", ["    uint8_t di_flags;  /* Flags. */ \\", "    char_u di_key[__VA_ARGS__];  /* Key value. */ \\", "  }"], "runtime/arrays"]
["src/nvim/eval/typval_encode.c.h", ["                                                      const char *const objname)", "REAL_FATTR_NONNULL_ARG(2, 3, 4, 7) REAL_FATTR_WARN_UNUSED_RESULT", "  REAL_FATTR_ALWAYS_INLINE;"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                            const char *const objname)", "REAL_FATTR_NONNULL_ARG(2, 4, 6) REAL_FATTR_WARN_UNUSED_RESULT;", ""], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["        },", "      }));", "    break;"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["        },", "      }));", "    TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START(tv, _mp_last(*mpstack));"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["            || ((highest_bits", "                   = TV_LIST_ITEM_TV(highest_bits_li)->vval.v_number)", "                < 0)) {"], "whitespace/alignment"]
["src/nvim/eval/typval_encode.c.h", ["            || ((highest_bits", "                   = TV_LIST_ITEM_TV(highest_bits_li)->vval.v_number)", "                < 0)) {"], "whitespace/alignment"]
["src/nvim/eval/typval_encode.c.h", ["              },", "            }));", "        break;"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["              },", "            }));", "        break;"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["            || ((type", "                   = TV_LIST_ITEM_TV(tv_list_first(val_list))->vval.v_number)", "                > INT8_MAX)"], "whitespace/alignment"]
["src/nvim/eval/typval_encode.c.h", ["            || ((type", "                   = TV_LIST_ITEM_TV(tv_list_first(val_list))->vval.v_number)", "                > INT8_MAX)"], "whitespace/alignment"]
["src/nvim/eval/typval_encode.c.h", ["        },", "      }));", "    TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START(tv, tv->vval.v_dict,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                              typval_T *const tv, const char *const objname)", "REAL_FATTR_NONNULL_ARG(2, 3) REAL_FATTR_WARN_UNUSED_RESULT;", ""], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["              },", "            }));", "        }"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                },", "              }));", "          TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START(NULL, pt->pt_dict,"], "whitespace/indent"]
["src/nvim/globals.h", ["#define FOR_ALL_WINDOWS_IN_TAB(wp, tp) \\", "  for (win_T *wp = ((tp) == curtab) \\", "              ? firstwin : (tp)->tp_firstwin; wp != NULL; wp = wp->w_next)"], "readability/braces"]
["src/nvim/globals.h", ["  for (win_T *wp = ((tp) == curtab) \\", "              ? firstwin : (tp)->tp_firstwin; wp != NULL; wp = wp->w_next)", ""], "whitespace/alignment"]
["src/nvim/globals.h", ["#define FOR_ALL_BUFFERS(buf) \\", "  for (buf_T *buf = firstbuf; buf != NULL; buf = buf->b_next)", "#define FOR_ALL_BUFFERS_BACKWARDS(buf) \\"], "readability/braces"]
["src/nvim/globals.h", ["#define FOR_ALL_BUFFERS_BACKWARDS(buf) \\", "  for (buf_T *buf = lastbuf; buf != NULL; buf = buf->b_prev)", ""], "readability/braces"]
["src/nvim/hardcopy.c", ["          assert(prtpos.bytes_printed <= SIZE_MAX / 100);", "          sprintf((char *)IObuff, _(\"Printing page %d (%zu%%)\"),", "                  page_count + 1 + side,"], "runtime/printf"]
["src/nvim/hardcopy.c", ["          for (page_line = 0; page_line < settings.lines_per_page;", "               ++page_line) {", "            prtpos.column = hardcopy_line(&settings,"], "readability/increment"]
["src/nvim/hardcopy.c", ["    prt_dsc_font_resource((prt_use_courier ? NULL", "                                           : \"DocumentNeededResources\"), &prt_ps_mb_font);", "    if (!prt_custom_cmap) {"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["      default:", "        sprintf((char *)ch_buff, \"%03o\", (unsigned int)ch);", "        ga_append(&prt_ps_buffer, (char)ch_buff[0]);"], "runtime/printf"]
["src/nvim/indent_c.c", ["  if (lookfor == LOOKFOR_IF) {", "    elselevel = 1;", "    whilelevel = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["  } else {", "    elselevel = 0;", "    whilelevel = 1;"], "readability/braces"]
["src/nvim/lib/ringbuf.h", ["  ((rb)->first == NULL ? 0 \\", "                       : ((rb)->next == (rb)->first) ? (size_t)((rb)->buf_end - (rb)->buf) + 1 \\", "                                                     : ((rb)->next > \\"], "whitespace/alignment"]
["src/nvim/lib/ringbuf.h", ["                       : ((rb)->next == (rb)->first) ? (size_t)((rb)->buf_end - (rb)->buf) + 1 \\", "                                                     : ((rb)->next > \\", "                                                        (rb)->first) ? (size_t)((rb)->next - \\"], "whitespace/alignment"]
["src/nvim/lib/ringbuf.h", ["                                                                                (rb)->first) \\", "                                                                     : (size_t)((rb)-> \\", "                                                                                next - (rb)->buf + \\"], "whitespace/alignment"]
["src/nvim/lib/ringbuf.h", ["  size_t varname##_length_fa_ = _RINGBUF_LENGTH(rb); \\", "  for (RBType *varname = ((rb)->first == NULL ? (rb)->next : (rb)->first); \\", "       varname##_length_fa_; \\"], "readability/braces"]
["src/nvim/lib/ringbuf.h", ["  size_t varname##_length_ib_ = _RINGBUF_LENGTH(rb); \\", "  for (varname = ((rb)->next == (rb)->buf ? (rb)->buf_end : (rb)->next - 1); \\", "       varname##_length_ib_; \\"], "readability/braces"]
["src/nvim/macros.h", ["  do { \\", "    if (*p_langmap \\", "        && (condition) \\"], "readability/braces"]
["src/nvim/macros.h", ["    { \\", "      if ((c) < 256) \\", "      c = langmap_mapchar[c]; \\"], "readability/braces"]
["src/nvim/macros.h", ["      c = langmap_mapchar[c]; \\", "      else \\", "      c = langmap_adjust_mb(c); \\"], "readability/braces"]
["src/nvim/macros.h", ["      c = langmap_mapchar[c]; \\", "      else \\", "      c = langmap_adjust_mb(c); \\"], "whitespace/newline"]
["src/nvim/mbyte.c", ["  static struct interval nonprint[] =", "  {", "    { 0x070f, 0x070f }, { 0x180b, 0x180e }, { 0x200b, 0x200f }, { 0x202a, 0x202e },"], "whitespace/braces"]
["src/nvim/mbyte.c", ["    }", "    sprintf((char *)IObuff + rlen, \"%02x \",", "            (line[i] == NL) ? NUL : line[i]);          // NUL is stored as NL"], "runtime/printf"]
["src/nvim/mbyte.c", ["#ifdef HAVE_NL_LANGINFO_CODESET", "  if (!(s = nl_langinfo(CODESET)) || *s == NUL)", "#endif"], "readability/braces"]
["src/nvim/mbyte.c", ["#if defined(HAVE_LOCALE_H)", "    if (!(s = setlocale(LC_CTYPE, NULL)) || *s == NUL)", "#endif"], "readability/braces"]
["src/nvim/memline.c", ["      fname_res = fname_buf;", "    } else", "#endif"], "readability/braces"]
["src/nvim/memline.c", ["        if (lineadd) {", "          --(buf->b_ml.ml_stack_top);", "          // fix line count for rest of blocks in the stack"], "readability/increment"]
["src/nvim/memline.c", ["            lineadd;", "          ++(buf->b_ml.ml_stack_top);", "        }"], "readability/increment"]
["src/nvim/memline.c", ["        }", "        ++(buf->b_ml.ml_stack_top);", ""], "readability/increment"]
["src/nvim/memline.c", ["      if (action == ML_INSERT) {", "        ++(buf->b_ml.ml_locked_lineadd);", "        ++(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["        ++(buf->b_ml.ml_locked_lineadd);", "        ++(buf->b_ml.ml_locked_high);", "      } else if (action == ML_DELETE) {"], "readability/increment"]
["src/nvim/memline.c", ["      } else if (action == ML_DELETE) {", "        --(buf->b_ml.ml_locked_lineadd);", "        --(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["        --(buf->b_ml.ml_locked_lineadd);", "        --(buf->b_ml.ml_locked_high);", "      }"], "readability/increment"]
["src/nvim/msgpack_rpc/helpers.c", ["      .data = (obj->via.attr.ptr == NULL || obj->via.attr.size == 0 \\", "                   ? xmemdupz(\"\", 0) \\", "                   : xmemdupz(obj->via.attr.ptr, obj->via.attr.size)), \\"], "whitespace/alignment"]
["src/nvim/msgpack_rpc/helpers.c", ["                   ? xmemdupz(\"\", 0) \\", "                   : xmemdupz(obj->via.attr.ptr, obj->via.attr.size)), \\", "    })); \\"], "whitespace/alignment"]
["src/nvim/msgpack_rpc/helpers.c", ["                   : xmemdupz(obj->via.attr.ptr, obj->via.attr.size)), \\", "    })); \\", "      break; \\"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["      .data = (obj->via.attr.ptr == NULL || obj->via.attr.size == 0 \\", "                   ? xmemdupz(\"\", 0) \\", "                   : xmemdupz(obj->via.attr.ptr, obj->via.attr.size)), \\"], "whitespace/alignment"]
["src/nvim/msgpack_rpc/helpers.c", ["                   ? xmemdupz(\"\", 0) \\", "                   : xmemdupz(obj->via.attr.ptr, obj->via.attr.size)), \\", "    })); \\"], "whitespace/alignment"]
["src/nvim/msgpack_rpc/helpers.c", ["              .container = false,", "            }));", "        }"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["                      : NULL),", "          }));", "        cur.container = true;"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["                .container = false,", "              }));", "          }"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["                      : NULL),", "          }));", "        cur.container = true;"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["              .container = false,", "            }));", "        }"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["              .container = false,", "            }));", "        }"], "whitespace/indent"]
["src/nvim/normal.c", ["  assert(len <= INT_MAX);", "  sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",", "          (int)len, ptr);"], "runtime/printf"]
["src/nvim/option_defs.h", ["    0, \\", "  })", ""], "whitespace/indent"]
["src/nvim/option_defs.h", ["    0, \\", "  })", ""], "whitespace/indent"]
["src/nvim/path.h", ["#endif", "#endif", ""], "build/header_guard"]
["src/nvim/profile.h", ["#define TIME_MSG(s) do { \\", "  if (time_fd != NULL) time_msg(s, NULL); \\", "} while (0)"], "readability/braces"]
["src/nvim/regexp.c", ["", "/*", " * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Magic characters have a special meaning, they don't match literally."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * We should define ftpr as a pointer to a function returning a pointer to"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * REGEXP_INRANGE contains all characters which are always special in a []"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Translate '\\x' to its control character, except \"\\n\", which is Magic."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  static const char *(class_names[]) =", "  {", "    \"alnum:]\","], "whitespace/braces"]
["src/nvim/regexp.c", ["", "/*", " * Specific version of character class functions."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * META contains all characters that may be magic, except '^' and '$'."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check for a collating element \"[.a.]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Start parsing at \"str\"."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Save the current parse state, so that it can be restored and parsing"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Restore a previously saved parse state."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get the next character without advancing."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    } else if (vim_strchr(REGEXP_ABBR, c)) {", "      /*", "       * Handle abbreviations, like \"\\t\" for TAB -- webb"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Eat one lexed character.  Do this in a way that we can undo it."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Skip a character while keeping the value of prev_at_start for at_start."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get the next character from the pattern. We know about magic and such, so"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * put character back.  Works only once!"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get and return the value of the hex string at the current position."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get and return the value of the decimal string immediately after the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * get and return the value of the octal string immediately after the current"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * read_limits - Read two integers to be taken as a minimum and maximum."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /*", "   * Reverse the range if there was a '-', or make sure it is in the right"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * vim_regexec and friends"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Global work variables for vim_regexec()."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\"."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Create a new extmatch and mark it as referenced once."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Add a reference to an extmatch."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Remove a reference to an extmatch.  If there are no references left, free"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check the regexp program for its magic number."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Cleanup the subexpressions, if this wasn't done yet."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check whether a backreference matches."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "      /* decompose the character if necessary, into 'base' characters", "       * because I don't care about Arabic, I will hard-code the Hebrew"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  for (p = newsub; *p; ++p) {", "    if ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic)) {"], "readability/increment"]
["src/nvim/regexp.c", ["            s++;", "            /* Change NL to CR here too, so that this works:", "             * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /*", "     * First round: compute the length and allocate memory."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        if (round == 2) {", "          STRNCPY(retval + len, reg_getline_submatch(lnum),", "                  rsm.sm_mmatch->endpos[no].col);"], "runtime/printf"]
["src/nvim/regexp.c", ["", "/*", " * Compile a regular expression into internal code."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Free a compiled regexp program, returned by vim_regcomp()."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " *"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * The \"internal use only\" fields in regexp_defs.h are present to pass info from"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Structure for regexp \"program\".  This is essentially a linear encoding"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * The opcodes are:"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Flags to be passed up and down."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * When regcode is set to this value, code is not emitted and size is computed"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Structure used to save the current input state, when it needs to be"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * When there are alternatives a regstate_T is put on the regstack to remember"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * \"regstack\" and \"backpos\" are used by regmatch().  They are kept over calls"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Both for regstack and backpos tables we use the following strategy of"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Opcode notes:"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * A node is one char of opcode followed by two chars of \"next\" pointer."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Setup to parse the regexp.  Used once to get the length and once to do it."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Emit (if appropriate) a byte of code"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Emit (if appropriate) a multi-byte character of code"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Produce the bytes for equivalence class \"c\"."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Emit a node."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Write a four bytes number at \"p\" and return pointer to the next char."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * regnext - dig the \"next\" pointer out of a node"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Like regtail, on item after a BRANCH; nop if none."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Insert an operator in front of already-emitted operand"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Insert an operator in front of already-emitted operand."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Insert an operator in front of already-emitted operand."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Parse the lowest level."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["          // 'cpoptions' is not included.", "          else if (*regparse == '\\\\'", "                   && (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["              } else if ((c_class =", "                            get_coll_element(&regparse)) != 0) {", "                // produce a collating element"], "whitespace/alignment"]
["src/nvim/regexp_bt.c", ["                                   && !one_exactly", "                                   && !is_Magic(c))); ++len) {", "      c = no_Magic(c);"], "readability/increment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Parse something followed by possible [*+=]."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Parse one alternative of an | or & operator."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Parse one alternative of an | operator."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * bt_regcomp() - compile a regular expression into internal code for the"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Check if during the previous call to vim_regcomp the EOL item \"$\" has been"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Get a number after a backslash that is inside []."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Free a compiled regexp program, returned by bt_regcomp()."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * The arguments from BRACE_LIMITS are stored here.  They are actually local"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Tentatively set the sub-expression start to the current position (after"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Push an item onto the regstack."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Pop an item from the regstack."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["          reg_restore(&rp->rs_un.regsave, &backpos);", "          --brace_count[rp->rs_no];             // decrement match count", "        }"], "readability/increment"]
["src/nvim/regexp_bt.c", ["          reg_restore(&rp->rs_un.regsave, &backpos);", "          --brace_count[rp->rs_no];", "          // continue with the items after \"\\{}\""], "readability/increment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * regdump - dump a regexp onto stdout in vaguely comprehensible form"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * regprop - printable representation of opcode"], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["// marker so line numbers and indices both start at 1", "/*", " * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE"], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * The number of sub-matches is limited to 10."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * In the NFA engine: how many braces are allowed."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure returned by vim_regcomp() to pass on to vim_regexec()."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure used by the back track matcher."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure used by the NFA matcher."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure to be used for single-line matching."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure used to store external references: \"\\z\\(\\)\" to \"\\z\\1\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * NFA regular expression implementation."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list starts with an anchor, must match at start"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list starts with a character which must match"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list contains just literal text and nothing"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Allocate more space for post_start.  Called when"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Search between \"start\" and \"end\" and try to recognize a"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Produce the bytes for equivalence class \"c\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    case 0x1ef9:", "      EMIT2('y') EMIT2(y_acute) EMIT2(y_diaeresis)", "      EMIT2(0x177) EMIT2(0x1b4) EMIT2(0x233) EMIT2(0x24f)"], "whitespace/cast"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Code to parse regular expression."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse the lowest level."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * Character classes."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["collection:", "    /*", "     * [abc]  uses NFA_START_COLL - NFA_END_COLL"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (*endp == ']') {", "      /*", "       * Try to reverse engineer character classes. For example,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      }", "      /*", "       * Failed to recognize a character class. Use the simple"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse something followed by possible [*+=]."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case Magic('+'):", "    /*", "     * Trick: Normally, (a*)\\+ would match the whole input \"aaa\".  The"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse one or more pieces, concatenated.  It matches a match for the"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse a branch, one or more concats, separated by \"\\&\".  It matches the"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the postfix notation of the current regexp."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the NFA starting with a root node \"state\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    STRNCPY(save, &p[last], 2);", "    STRNCPY(&p[last], \"+-\", 2);"], "runtime/printf"]
["src/nvim/regexp_nfa.c", ["    STRNCPY(save, &p[last], 2);", "    STRNCPY(&p[last], \"+-\", 2);", "    fprintf(debugf, \" %s\", p);"], "runtime/printf"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the NFA state machine."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["}", "#endif      /* REGEXP_DEBUG */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse r.e. @expr and convert it into postfix form."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Represents an NFA state plus zero or one or two arrows exiting."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Allocate and initialize nfa_state_T."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * A partially built NFA without the matching state filled in."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Initialize a Frag_T struct and return it."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Create singleton list containing just outp."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Patch the list of states at out to point to start."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Join the two lists l1 and l2, returning the combination."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Stack used for transforming postfix form into NFA."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Push an item onto the stack."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Pop an item from the stack."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Estimate the maximum byte length of anything matching \"state\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Convert a postfix form into its equivalent NFA."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  for (p = postfix; p < end; ++p) {", "    switch (*p) {"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * After building the NFA program, inspect it to add optimization hints."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  for (i = 0; i < prog->nstate; ++i) {", "    c = prog->state[i].c;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Copy the submatches from \"from\" to \"to\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Like copy_sub() but exclude the main match."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Like copy_sub() but only do the end of the main match if \\ze is present."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        if (add_here) {", "          for (k = 0; k < l->n && k < listindex; ++k) {", "            if (l->t[k].state->id == state->id) {"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["        save_in_use = sub->in_use;", "        for (i = sub->in_use; i < subidx; ++i) {", "          sub->list.multi[i].start_lnum = -1;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["        save_in_use = sub->in_use;", "        for (i = sub->in_use; i < subidx; ++i) {", "          sub->list.line[i].start = NULL;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["  }", "  --l->n;", "  *ip = listidx - 1;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check character class \"class\" against current character c."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Save list IDs for all NFA states of \"prog\" into \"list\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Restore list IDs from \"list\" to all NFA states."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Recursively call nfa_regmatch()"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Estimate the chance of a match with \"state\" failing."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Skip until the char \"c\" we know a match must start with."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check for a match with match_text."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * Run for each character."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["#endif", "    /*", "     * If the state lists are empty we can stop."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      /*", "       * Handle the possible codes of the current state."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Compile a regular expression into internal code for the NFA matcher."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * In order to build the NFA, we parse the input regexp twice:"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * PASS 1"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * PASS 2"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Free a compiled regexp program, returned by nfa_regcomp()."], "readability/old_style_comment"]
["src/nvim/spell_defs.h", ["#define SPELL_TOUPPER(c) ((c) >= 128 ? mb_toupper(c) \\", "                                     : (int)spelltab.st_upper[c])", ""], "whitespace/alignment"]
["src/nvim/spellfile.c", ["  char buf[VIMSPELLMAGICL];", "  SPELL_READ_BYTES(buf, VIMSPELLMAGICL, fd,; );", "  if (memcmp(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0) {"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  }", "  SPELL_READ_NONNUL_BYTES((char *)lp->sl_regions, (size_t)len, fd,; );", "  lp->sl_regions[len] = NUL;"], "whitespace/parens"]
["src/nvim/spellfile.c", ["      buf[0] = '^';  // always match at one position only", "      SPELL_READ_NONNUL_BYTES(buf + 1, (size_t)n, fd,; );", "      buf[n + 1] = NUL;"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  // <rep> : <repfromlen> <repfrom> <reptolen> <repto>", "  for (; gap->ga_len < cnt; ++gap->ga_len) {", "    int c;"], "readability/increment"]
["src/nvim/spellfile.c", ["            if (*items[0] == 'P') {", "              sprintf((char *)buf, \"^%s\", items[4]);", "            } else {"], "runtime/printf"]
["src/nvim/spellfile.c", ["            } else {", "              sprintf((char *)buf, \"%s$\", items[4]);", "            }"], "runtime/printf"]
["src/nvim/spellfile.c", ["                    if (aff_entry->ae_cond != NULL) {", "                      sprintf((char *)buf, \"^%s\",", "                              aff_entry->ae_cond);"], "runtime/printf"]
["src/nvim/spellfile.c", ["      // Accept \"SAL from to\" and \"SAL from to  #comment\".", "      else if (is_aff_rule(items, itemcnt, \"SAL\", 3)) {", "        if (do_sal) {"], "whitespace/newline"]
["src/nvim/spellfile.c", ["    if (!ascii_isdigit(**pp)) {", "      ++*pp;            // always advance, avoid getting stuck", "      return 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["                                 use_condit & (xht == NULL", "                                    ? ~0 :  ~CONDIT_SUF),", "                                 use_flags, use_pfxlist, pfxlen) == FAIL) {"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                                 use_condit & (xht == NULL", "                                    ? ~0 :  ~CONDIT_SUF),", "                                 use_flags, use_pfxlist, pfxlen) == FAIL) {"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["#ifndef SPELL_PRINTTREE", "    if (spin->si_verbose || p_verbose > 2)", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["      }", "    } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["    *d++ = '\"';", "  } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["      }", "    } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["    *d++ = '\"';", "  } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["            arg = (tvs", "                       ? (ptrdiff_t)tv_nr(tvs, &arg_idx)", "                       : va_arg(ap, ptrdiff_t));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                       ? (ptrdiff_t)tv_nr(tvs, &arg_idx)", "                       : va_arg(ap, ptrdiff_t));", "            break;"], "whitespace/alignment"]
["src/nvim/strings.c", ["            uarg = (unsigned int)(tvs", "                                      ? tv_nr(tvs, &arg_idx)", "                                      : va_arg(ap, unsigned int));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                                      ? tv_nr(tvs, &arg_idx)", "                                      : va_arg(ap, unsigned int));", "            break;"], "whitespace/alignment"]
["src/nvim/strings.c", ["            uarg = (uint16_t)(tvs", "                                  ? tv_nr(tvs, &arg_idx)", "                                  : va_arg(ap, unsigned int));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                                  ? tv_nr(tvs, &arg_idx)", "                                  : va_arg(ap, unsigned int));", "            break;"], "whitespace/alignment"]
["src/nvim/strings.c", ["            uarg = (tvs", "                        ? (unsigned long)tv_nr(tvs, &arg_idx)", "                        : va_arg(ap, unsigned long));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                        ? (unsigned long)tv_nr(tvs, &arg_idx)", "                        : va_arg(ap, unsigned long));", "            break;"], "whitespace/alignment"]
["src/nvim/strings.c", ["            uarg = (tvs", "                        ? (size_t)tv_nr(tvs, &arg_idx)", "                        : va_arg(ap, size_t));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                        ? (size_t)tv_nr(tvs, &arg_idx)", "                        : va_arg(ap, size_t));", "            break;"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                && (current_next_list != NULL", "                           ? in_id_list(NULL, current_next_list,", "                                        &spp->sp_syn, 0)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                        &spp->sp_syn, 0)", "                           : (cur_si == NULL", "                              ? !(spp->sp_flags & HL_CONTAINED)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                && (current_next_list != NULL", "                           ? in_id_list(NULL, current_next_list,", "                                        &spp->sp_syn, 0)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                        &spp->sp_syn, 0)", "                           : (cur_si == NULL", "                              ? !(spp->sp_flags & HL_CONTAINED)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["          : (cur_si == NULL", "            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,", "                         &kp->k_syn, kp->flags & HL_CONTAINED))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["          : (cur_si == NULL", "            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,", "                         &kp->k_syn, kp->flags & HL_CONTAINED))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["  static struct name_list namelist1[] =", "  {", "    { HL_DISPLAY, \"display\" },"], "whitespace/braces"]
["src/nvim/syntax.c", ["  static struct name_list namelist2[] =", "  {", "    { HL_SKIPWHITE, \"skipwhite\" },"], "whitespace/braces"]
["src/nvim/vim.h", ["#endif", "#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))", "#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))"], "runtime/printf"]
["src/nvim/vim.h", ["#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))", "#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))", "#define STRLCPY(d, s, n)    xstrlcpy((char *)(d), (char *)(s), (size_t)(n))"], "runtime/printf"]
["src/nvim/viml/parser/expressions.c", ["    ret.data.cmp.type = ((ret.data.cmp.inv ^ haseqsign)", "                           ? kExprCmpGreaterOrEqual", "                           : kExprCmpGreater);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                           ? kExprCmpGreaterOrEqual", "                           : kExprCmpGreater);", "    break;"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                                        != kExprNodeConcatOrSubscript))))", "           ? kELFlagAllowFloat", "           : 0));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["           ? kELFlagAllowFloat", "           : 0));", "    LexExprToken cur_token = viml_pexpr_next_token(pstate,"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                                        != kExprNodeConcatOrSubscript))))", "           ? kELFlagAllowFloat", "           : 0));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["           ? kELFlagAllowFloat", "           : 0));", "    LexExprToken cur_token = viml_pexpr_next_token(pstate,"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              && (cur_token.type == kExprLexPlainIdentifier", "            ? (!cur_token.data.var.autoload", "               && cur_token.data.var.scope == kExprVarScopeMissing)"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["               && cur_token.data.var.scope == kExprVarScopeMissing)", "            : (cur_token.type == kExprLexNumber))", "                              && prev_token.type != kExprLexSpacing);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              && (cur_token.type == kExprLexPlainIdentifier", "            ? (!cur_token.data.var.autoload", "               && cur_token.data.var.scope == kExprVarScopeMissing)"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["               && cur_token.data.var.scope == kExprVarScopeMissing)", "            : (cur_token.type == kExprLexNumber))", "                              && prev_token.type != kExprLexSpacing);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["      const ExprVarScope scope = (cur_token.type == kExprLexInvalid", "                                    ? kExprVarScopeMissing", "                                    : cur_token.data.var.scope);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                    ? kExprVarScopeMissing", "                                    : cur_token.data.var.scope);", "      if (want_node == kENodeValue) {"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));", "        cur_node->data.var.scope = scope;"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));", "        cur_node->data.var.scope = scope;"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));", "      } else {"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));", "      } else {"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["        ERROR_FROM_TOKEN_AND_MSG(cur_token, (is_double", "                          ? _(\"E114: Missing double quote: %.*s\")", "                          : _(\"E115: Missing single quote: %.*s\")));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                          ? _(\"E114: Missing double quote: %.*s\")", "                          : _(\"E115: Missing single quote: %.*s\")));", "      }"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["      NEW_NODE_WITH_CUR_POS(cur_node, (is_double", "                       ? kExprNodeDoubleQuotedString", "                       : kExprNodeSingleQuotedString));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                       ? kExprNodeDoubleQuotedString", "                       : kExprNodeSingleQuotedString));", "      *top_node_p = cur_node;"], "whitespace/alignment"]
