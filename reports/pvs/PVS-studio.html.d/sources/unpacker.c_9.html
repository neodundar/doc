<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>unpacker.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln5">#include &quot;nvim/log.h&quot;</a>
<a name="ln6">#include &quot;nvim/memory.h&quot;</a>
<a name="ln7">#include &quot;nvim/msgpack_rpc/helpers.h&quot;</a>
<a name="ln8">#include &quot;nvim/msgpack_rpc/unpacker.h&quot;</a>
<a name="ln9">#include &quot;nvim/ui_client.h&quot;</a>
<a name="ln10"> </a>
<a name="ln11">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln12"># include &quot;msgpack_rpc/unpacker.c.generated.h&quot;</a>
<a name="ln13">#endif</a>
<a name="ln14"> </a>
<a name="ln15">Object unpack(const char *data, size_t size, Error *err)</a>
<a name="ln16">{</a>
<a name="ln17">  Unpacker unpacker;</a>
<a name="ln18">  mpack_parser_init(&amp;unpacker.parser, 0);</a>
<a name="ln19">  unpacker.parser.data.p = &amp;unpacker;</a>
<a name="ln20"> </a>
<a name="ln21">  int result = mpack_parse(&amp;unpacker.parser, &amp;data, &amp;size,</a>
<a name="ln22">                           api_parse_enter, api_parse_exit);</a>
<a name="ln23"> </a>
<a name="ln24">  if (result == MPACK_NOMEM) {</a>
<a name="ln25">    api_set_error(err, kErrorTypeException, &quot;object was too deep to unpack&quot;);</a>
<a name="ln26">  } else if (result == MPACK_EOF) {</a>
<a name="ln27">    api_set_error(err, kErrorTypeException, &quot;incomplete msgpack string&quot;);</a>
<a name="ln28">  } else if (result == MPACK_ERROR) {</a>
<a name="ln29">    api_set_error(err, kErrorTypeException, &quot;invalid msgpack string&quot;);</a>
<a name="ln30">  } else if (result == MPACK_OK &amp;&amp; size) {</a>
<a name="ln31">    api_set_error(err, kErrorTypeException, &quot;trailing data in msgpack string&quot;);</a>
<a name="ln32">  }</a>
<a name="ln33"> </a>
<a name="ln34">  return unpacker.result;</a>
<a name="ln35">}</a>
<a name="ln36"> </a>
<a name="ln37">static void api_parse_enter(mpack_parser_t *parser, mpack_node_t *node)</a>
<a name="ln38">{</a>
<a name="ln39">  Unpacker *p = parser-&gt;data.p;</a>
<a name="ln40">  Object *result = NULL;</a>
<a name="ln41">  String *key_location = NULL;</a>
<a name="ln42"> </a>
<a name="ln43">  mpack_node_t *parent = MPACK_PARENT_NODE(node);</a>
<a name="ln44">  if (parent) {</a>
<a name="ln45">    switch (parent-&gt;tok.type) {</a>
<a name="ln46">    case MPACK_TOKEN_ARRAY: {</a>
<a name="ln47">      Object *obj = parent-&gt;data[0].p;</a>
<a name="ln48">      result = &amp;kv_A(obj-&gt;data.array, parent-&gt;pos);</a>
<a name="ln49">      break;</a>
<a name="ln50">    }</a>
<a name="ln51">    case MPACK_TOKEN_MAP: {</a>
<a name="ln52">      Object *obj = parent-&gt;data[0].p;</a>
<a name="ln53">      KeyValuePair *kv = &amp;kv_A(obj-&gt;data.dictionary, parent-&gt;pos);</a>
<a name="ln54">      if (!parent-&gt;key_visited) {</a>
<a name="ln55">        // TODO(bfredl): when implementing interrupt parse on error,</a>
<a name="ln56">        // stop parsing here when node is not a STR/BIN</a>
<a name="ln57">        kv-&gt;key = (String)STRING_INIT;</a>
<a name="ln58">        key_location = &amp;kv-&gt;key;</a>
<a name="ln59">      }</a>
<a name="ln60">      result = &amp;kv-&gt;value;</a>
<a name="ln61">      break;</a>
<a name="ln62">    }</a>
<a name="ln63"> </a>
<a name="ln64">    case MPACK_TOKEN_STR:</a>
<a name="ln65">    case MPACK_TOKEN_BIN:</a>
<a name="ln66">    case MPACK_TOKEN_EXT:</a>
<a name="ln67">      assert(node-&gt;tok.type == MPACK_TOKEN_CHUNK);</a>
<a name="ln68">      break;</a>
<a name="ln69"> </a>
<a name="ln70">    default:</a>
<a name="ln71">      abort();</a>
<a name="ln72">    }</a>
<a name="ln73">  } else {</a>
<a name="ln74">    result = &amp;p-&gt;result;</a>
<a name="ln75">  }</a>
<a name="ln76"> </a>
<a name="ln77">  switch (node-&gt;tok.type) {</a>
<a name="ln78">  case MPACK_TOKEN_NIL:</a>
<a name="ln79">    *result = NIL;</a>
<a name="ln80">    break;</a>
<a name="ln81">  case MPACK_TOKEN_BOOLEAN:</a>
<a name="ln82">    *result = BOOL(mpack_unpack_boolean(node-&gt;tok));</a>
<a name="ln83">    break;</a>
<a name="ln84">  case MPACK_TOKEN_SINT:</a>
<a name="ln85">    *result = INTEGER_OBJ(mpack_unpack_sint(node-&gt;tok));</a>
<a name="ln86">    break;</a>
<a name="ln87">  case MPACK_TOKEN_UINT:</a>
<a name="ln88">    *result = INTEGER_OBJ((Integer)mpack_unpack_uint(node-&gt;tok));</a>
<a name="ln89">    break;</a>
<a name="ln90">  case MPACK_TOKEN_FLOAT:</a>
<a name="ln91">    *result = FLOAT_OBJ(mpack_unpack_float(node-&gt;tok));</a>
<a name="ln92">    break;</a>
<a name="ln93"> </a>
<a name="ln94">  case MPACK_TOKEN_BIN:</a>
<a name="ln95">  case MPACK_TOKEN_STR: {</a>
<a name="ln96">    char *mem = arena_alloc(&amp;p-&gt;arena, node-&gt;tok.length + 1, false);</a>
<a name="ln97">    mem[node-&gt;tok.length] = NUL;</a>
<a name="ln98">    String str = { .data = mem, .size = node-&gt;tok.length };</a>
<a name="ln99">    if (key_location) {</a>
<a name="ln100">      *key_location = str;</a>
<a name="ln101">    } else {</a>
<a name="ln102">      *result = STRING_OBJ(str);</a>
<a name="ln103">    }</a>
<a name="ln104">    node-&gt;data[0].p = str.data;</a>
<a name="ln105">    break;</a>
<a name="ln106">  }</a>
<a name="ln107">  case MPACK_TOKEN_EXT:</a>
<a name="ln108">    // handled in chunk; but save result location</a>
<a name="ln109">    node-&gt;data[0].p = result;</a>
<a name="ln110">    break;</a>
<a name="ln111">  case MPACK_TOKEN_CHUNK:</a>
<a name="ln112">    assert(parent);</a>
<a name="ln113">    if (parent-&gt;tok.type == MPACK_TOKEN_STR || parent-&gt;tok.type == MPACK_TOKEN_BIN) {</a>
<a name="ln114">      char *data = parent-&gt;data[0].p;</a>
<a name="ln115">      memcpy(data + parent-&gt;pos,</a>
<a name="ln116">             node-&gt;tok.data.chunk_ptr, node-&gt;tok.length);</a>
<a name="ln117">    } else {</a>
<a name="ln118">      Object *res = parent-&gt;data[0].p;</a>
<a name="ln119"> </a>
<a name="ln120">      size_t endlen = parent-&gt;pos + node-&gt;tok.length;</a>
<a name="ln121">      if (endlen &gt; MAX_EXT_LEN) {</a>
<a name="ln122">        *res = NIL;</a>
<a name="ln123">        break;</a>
<a name="ln124">      }</a>
<a name="ln125">      memcpy(p-&gt;ext_buf + parent-&gt;pos,</a>
<a name="ln126">             node-&gt;tok.data.chunk_ptr, node-&gt;tok.length);</a>
<a name="ln127">      if (parent-&gt;pos + node-&gt;tok.length &lt; parent-&gt;tok.length) {</a>
<a name="ln128">        break;  // EOF, let's get back to it later</a>
<a name="ln129">      }</a>
<a name="ln130">      const char *buf = p-&gt;ext_buf;</a>
<a name="ln131">      size_t size = parent-&gt;tok.length;</a>
<a name="ln132">      mpack_token_t ext_tok;</a>
<a name="ln133">      int status = mpack_rtoken(&amp;buf, &amp;size, &amp;ext_tok);</a>
<a name="ln134">      if (status || ext_tok.type != MPACK_TOKEN_UINT) {</a>
<a name="ln135">        // TODO(bfredl): once we fixed memory management, we can set</a>
<a name="ln136">        // p-&gt;unpack_error and a flag like p-&gt;interrupted</a>
<a name="ln137">        *res = NIL;</a>
<a name="ln138">        break;</a>
<a name="ln139">      }</a>
<a name="ln140">      int ext_type = parent-&gt;tok.data.ext_type;</a>
<a name="ln141">      if (0 &lt;= ext_type &amp;&amp; ext_type &lt;= EXT_OBJECT_TYPE_MAX) {</a>
<a name="ln142">        res-&gt;type = (ObjectType)(ext_type + EXT_OBJECT_TYPE_SHIFT);</a>
<a name="ln143">        res-&gt;data.integer = (int64_t)mpack_unpack_uint(ext_tok);</a>
<a name="ln144">      } else {</a>
<a name="ln145">        *res = NIL;</a>
<a name="ln146">        break;</a>
<a name="ln147">      }</a>
<a name="ln148">    }</a>
<a name="ln149">    break;</a>
<a name="ln150"> </a>
<a name="ln151">  case MPACK_TOKEN_ARRAY: {</a>
<a name="ln152">    Array arr = KV_INITIAL_VALUE;</a>
<a name="ln153">    kv_fixsize_arena(&amp;p-&gt;arena, arr, node-&gt;tok.length);</a>
<a name="ln154">    kv_size(arr) = node-&gt;tok.length;</a>
<a name="ln155">    *result = ARRAY_OBJ(arr);</a>
<a name="ln156">    node-&gt;data[0].p = result;</a>
<a name="ln157">    break;</a>
<a name="ln158">  }</a>
<a name="ln159">  case MPACK_TOKEN_MAP: {</a>
<a name="ln160">    Dictionary dict = KV_INITIAL_VALUE;</a>
<a name="ln161">    kv_fixsize_arena(&amp;p-&gt;arena, dict, node-&gt;tok.length);</a>
<a name="ln162">    kv_size(dict) = node-&gt;tok.length;</a>
<a name="ln163">    *result = DICTIONARY_OBJ(dict);</a>
<a name="ln164">    node-&gt;data[0].p = result;</a>
<a name="ln165">    break;</a>
<a name="ln166">  }</a>
<a name="ln167"> </a>
<a name="ln168">  default:</a>
<a name="ln169">    abort();</a>
<a name="ln170">  }</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">static void api_parse_exit(mpack_parser_t *parser, mpack_node_t *node)</a>
<a name="ln174">{}</a>
<a name="ln175"> </a>
<a name="ln176">void unpacker_init(Unpacker *p)</a>
<a name="ln177">{</a>
<a name="ln178">  mpack_parser_init(&amp;p-&gt;parser, 0);</a>
<a name="ln179">  p-&gt;parser.data.p = p;</a>
<a name="ln180">  mpack_tokbuf_init(&amp;p-&gt;reader);</a>
<a name="ln181">  p-&gt;unpack_error = (Error)ERROR_INIT;</a>
<a name="ln182"> </a>
<a name="ln183">  p-&gt;arena = (Arena)ARENA_EMPTY;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">void unpacker_teardown(Unpacker *p)</a>
<a name="ln187">{</a>
<a name="ln188">  arena_mem_free(arena_finish(&amp;p-&gt;arena));</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">bool unpacker_parse_header(Unpacker *p)</a>
<a name="ln192">{</a>
<a name="ln193">  mpack_token_t tok;</a>
<a name="ln194">  int result;</a>
<a name="ln195"> </a>
<a name="ln196">  const char *data = p-&gt;read_ptr;</a>
<a name="ln197">  size_t size = p-&gt;read_size;</a>
<a name="ln198"> </a>
<a name="ln199">  assert(!ERROR_SET(&amp;p-&gt;unpack_error));</a>
<a name="ln200"> </a>
<a name="ln201">#define NEXT(tok) \</a>
<a name="ln202">  result = mpack_read(&amp;p-&gt;reader, &amp;data, &amp;size, &amp;tok); \</a>
<a name="ln203">  if (result) { goto error; }</a>
<a name="ln204"> </a>
<a name="ln205">  NEXT(tok);</a>
<a name="ln206">  if (tok.type != MPACK_TOKEN_ARRAY || tok.length &lt; 3 || tok.length &gt; 4) {</a>
<a name="ln207">    goto error;</a>
<a name="ln208">  }</a>
<a name="ln209">  size_t array_length = tok.length;</a>
<a name="ln210"> </a>
<a name="ln211">  NEXT(tok);</a>
<a name="ln212">  if (tok.type != MPACK_TOKEN_UINT) {</a>
<a name="ln213">    goto error;</a>
<a name="ln214">  }</a>
<a name="ln215">  uint32_t type = (uint32_t)mpack_unpack_uint(tok);</a>
<a name="ln216">  if ((array_length == 3) ? type != 2 : (type &gt;= 2)) {</a>
<a name="ln217">    goto error;</a>
<a name="ln218">  }</a>
<a name="ln219">  p-&gt;type = (MessageType)type;</a>
<a name="ln220">  p-&gt;request_id = 0;</a>
<a name="ln221"> </a>
<a name="ln222">  if (p-&gt;type != kMessageTypeNotification) {</a>
<a name="ln223">    NEXT(tok);</a>
<a name="ln224">    if (tok.type != MPACK_TOKEN_UINT) {</a>
<a name="ln225">      goto error;</a>
<a name="ln226">    }</a>
<a name="ln227">    p-&gt;request_id = (uint32_t)mpack_unpack_uint(tok);</a>
<a name="ln228">  }</a>
<a name="ln229"> </a>
<a name="ln230">  if (p-&gt;type != kMessageTypeResponse) {</a>
<a name="ln231">    NEXT(tok);</a>
<a name="ln232">    if ((tok.type != MPACK_TOKEN_STR &amp;&amp; tok.type != MPACK_TOKEN_BIN)</a>
<a name="ln233">        || tok.length &gt; 100) {</a>
<a name="ln234">      goto error;</a>
<a name="ln235">    }</a>
<a name="ln236">    p-&gt;method_name_len = tok.length;</a>
<a name="ln237"> </a>
<a name="ln238">    if (p-&gt;method_name_len &gt; 0) {</a>
<a name="ln239">      NEXT(tok);</a>
<a name="ln240">      assert(tok.type == MPACK_TOKEN_CHUNK);</a>
<a name="ln241">    }</a>
<a name="ln242">    if (tok.length &lt; p-&gt;method_name_len) {</a>
<a name="ln243">      result = MPACK_EOF;</a>
<a name="ln244">      goto error;</a>
<a name="ln245">    }</a>
<a name="ln246">    // if this fails, p-&gt;handler.fn will be NULL</a>
<a name="ln247">    p-&gt;handler = msgpack_rpc_get_handler_for(tok.length ? tok.data.chunk_ptr : &quot;&quot;,</a>
<a name="ln248">                                             tok.length, &amp;p-&gt;unpack_error);</a>
<a name="ln249">  }</a>
<a name="ln250"> </a>
<a name="ln251">  p-&gt;read_ptr = data;</a>
<a name="ln252">  p-&gt;read_size = size;</a>
<a name="ln253">  return true;</a>
<a name="ln254">#undef NEXT</a>
<a name="ln255"> </a>
<a name="ln256">error:</a>
<a name="ln257">  if (result == MPACK_EOF) {</a>
<a name="ln258">    // recover later by retrying from scratch</a>
<a name="ln259">    // when more data is available.</a>
<a name="ln260">    mpack_tokbuf_init(&amp;p-&gt;reader);</a>
<a name="ln261">  } else {</a>
<a name="ln262">    api_set_error(&amp;p-&gt;unpack_error, kErrorTypeValidation, &quot;failed to decode msgpack&quot;);</a>
<a name="ln263">    p-&gt;state = -1;</a>
<a name="ln264">  }</a>
<a name="ln265">  return false;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">// BASIC BITCH STATE MACHINE</a>
<a name="ln269">//</a>
<a name="ln270">// With some basic assumptions, we can parse the overall structure of msgpack-rpc</a>
<a name="ln271">// messages with a hand-rolled FSM of just 3 states (&lt;x&gt; = p-&gt;state):</a>
<a name="ln272">//</a>
<a name="ln273">// &lt;0&gt;[0, request_id, method_name, &lt;2&gt;args]</a>
<a name="ln274">// &lt;0&gt;[1, request_id, &lt;1&gt;err, &lt;2&gt;result]</a>
<a name="ln275">// &lt;0&gt;[2, method_name, &lt;2&gt;args]</a>
<a name="ln276">//</a>
<a name="ln277">// The assumption here is that the header of the message, which we define as the</a>
<a name="ln278">// initial array head, the kind integer, request_id and/or method name (when needed),</a>
<a name="ln279">// is relatively small, just ~10 bytes + the method name. Thus we can simply refuse</a>
<a name="ln280">// to advance the stream beyond the header until it can be parsed in its entirety.</a>
<a name="ln281">//</a>
<a name="ln282">// Later on, we want to specialize state 2 into more sub-states depending</a>
<a name="ln283">// on the specific method. &quot;nvim_exec_lua&quot; should just decode direct into lua</a>
<a name="ln284">// objects. For the moment &quot;redraw/grid_line&quot; uses a hand-rolled decoder,</a>
<a name="ln285">// to avoid a blizzard of small objects for each screen cell.</a>
<a name="ln286">//</a>
<a name="ln287">// &lt;0&gt;[2, &quot;redraw&quot;, &lt;10&gt;[{11}[&quot;method&quot;, &lt;12&gt;[args], &lt;12&gt;[args], ...], &lt;11&gt;[...], ...]]</a>
<a name="ln288">//</a>
<a name="ln289">// Where [args] gets unpacked as an Array. Note: first {11} is not saved as a state.</a>
<a name="ln290">//</a>
<a name="ln291">// When method is &quot;grid_line&quot;, we furthermore decode a cell at a time like:</a>
<a name="ln292">//</a>
<a name="ln293">// &lt;0&gt;[2, &quot;redraw&quot;, &lt;10&gt;[{11}[&quot;grid_line&quot;, &lt;13&gt;[g, r, c, [&lt;14&gt;[cell], &lt;14&gt;[cell], ...]], ...], &lt;11&gt;[...], ...]]</a>
<a name="ln294">//</a>
<a name="ln295">// where [cell] is [char, repeat, attr], where 'repeat' and 'attr' is optional</a>
<a name="ln296"> </a>
<a name="ln297">bool unpacker_advance(Unpacker *p)</a>
<a name="ln298">{</a>
<a name="ln299">  assert(p-&gt;state &gt;= 0);</a>
<a name="ln300">  if (p-&gt;state == 0) {</a>
<a name="ln301">    if (!unpacker_parse_header(p)) {</a>
<a name="ln302">      return false;</a>
<a name="ln303">    }</a>
<a name="ln304">    if (p-&gt;type == kMessageTypeNotification &amp;&amp; p-&gt;handler.fn == handle_ui_client_redraw) {</a>
<a name="ln305">      p-&gt;type = kMessageTypeRedrawEvent;</a>
<a name="ln306">      p-&gt;state = 10;</a>
<a name="ln307">    } else {</a>
<a name="ln308">      p-&gt;state = p-&gt;type == kMessageTypeResponse ? 1 : 2;</a>
<a name="ln309">      p-&gt;arena = (Arena)ARENA_EMPTY;</a>
<a name="ln310">    }</a>
<a name="ln311">  }</a>
<a name="ln312"> </a>
<a name="ln313">  if (p-&gt;state &gt;= 10 &amp;&amp; p-&gt;state != 12) {</a>
<a name="ln314">    if (!unpacker_parse_redraw(p)) {</a>
<a name="ln315">      return false;</a>
<a name="ln316">    }</a>
<a name="ln317"> </a>
<a name="ln318">    if (p-&gt;state == 14) {</a>
<a name="ln319">      // grid_line event already unpacked</a>
<a name="ln320">      goto done;</a>
<a name="ln321">    } else {</a>
<a name="ln322">      // unpack other ui events using mpack_parse()</a>
<a name="ln323">      p-&gt;arena = (Arena)ARENA_EMPTY;</a>
<a name="ln324">    }</a>
<a name="ln325">  }</a>
<a name="ln326"> </a>
<a name="ln327">  int result;</a>
<a name="ln328"> </a>
<a name="ln329">rerun:</a>
<a name="ln330">  result = mpack_parse(&amp;p-&gt;parser, &amp;p-&gt;read_ptr, &amp;p-&gt;read_size,</a>
<a name="ln331">                       api_parse_enter, api_parse_exit);</a>
<a name="ln332"> </a>
<a name="ln333">  if (result == MPACK_EOF) {</a>
<a name="ln334">    return false;</a>
<a name="ln335">  } else if (result != MPACK_OK) {</a>
<a name="ln336">    api_set_error(&amp;p-&gt;unpack_error, kErrorTypeValidation, &quot;failed to parse msgpack&quot;);</a>
<a name="ln337">    p-&gt;state = -1;</a>
<a name="ln338">    return false;</a>
<a name="ln339">  }</a>
<a name="ln340"> </a>
<a name="ln341">done:</a>
<a name="ln342">  switch (p-&gt;state) {</a>
<a name="ln343">  case 1:</a>
<a name="ln344">    p-&gt;error = p-&gt;result;</a>
<a name="ln345">    p-&gt;state = 2;</a>
<a name="ln346">    goto rerun;</a>
<a name="ln347">  case 2:</a>
<a name="ln348">    p-&gt;state = 0;</a>
<a name="ln349">    return true;</a>
<a name="ln350">  case 12:</a>
<a name="ln351">  case 14:</a>
<a name="ln352">    p-&gt;ncalls--;</a>
<a name="ln353">    if (p-&gt;ncalls &gt; 0) {</a>
<a name="ln354">      p-&gt;state = (p-&gt;state == 14) ? 13 : 12;</a>
<a name="ln355">    } else if (p-&gt;nevents &gt; 0) {</a>
<a name="ln356">      p-&gt;state = 11;</a>
<a name="ln357">    } else {</a>
<a name="ln358">      p-&gt;state = 0;</a>
<a name="ln359">    }</a>
<a name="ln360">    return true;</a>
<a name="ln361">  default:</a>
<a name="ln362">    abort();</a>
<a name="ln363">  }</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">bool unpacker_parse_redraw(Unpacker *p)</a>
<a name="ln367">{</a>
<a name="ln368">  mpack_token_t tok;</a>
<a name="ln369">  int result;</a>
<a name="ln370"> </a>
<a name="ln371">  const char *data = p-&gt;read_ptr;</a>
<a name="ln372">  size_t size = p-&gt;read_size;</a>
<a name="ln373">  GridLineEvent *g = p-&gt;grid_line_event;</a>
<a name="ln374"> </a>
<a name="ln375">#define NEXT_TYPE(tok, typ) \</a>
<a name="ln376">  result = mpack_rtoken(&amp;data, &amp;size, &amp;tok); \</a>
<a name="ln377">  if (result == MPACK_EOF) { \</a>
<a name="ln378">    return false; \</a>
<a name="ln379">  } else if (result || (tok.type != typ \</a>
<a name="ln380">                        &amp;&amp; !(typ == MPACK_TOKEN_STR &amp;&amp; tok.type == MPACK_TOKEN_BIN) \</a>
<a name="ln381">                        &amp;&amp; !(typ == MPACK_TOKEN_SINT &amp;&amp; tok.type == MPACK_TOKEN_UINT))) { \</a>
<a name="ln382">    p-&gt;state = -1; \</a>
<a name="ln383">    return false; \</a>
<a name="ln384">  }</a>
<a name="ln385"> </a>
<a name="ln386">redo:</a>
<a name="ln387">  switch (p-&gt;state) {</a>
<a name="ln388">  case 10:</a>
<a name="ln389">    NEXT_TYPE(tok, MPACK_TOKEN_ARRAY);</a>
<a name="ln390">    p-&gt;nevents = (int)tok.length;</a>
<a name="ln391">    FALLTHROUGH;</a>
<a name="ln392"> </a>
<a name="ln393">  case 11:</a>
<a name="ln394">    NEXT_TYPE(tok, MPACK_TOKEN_ARRAY);</a>
<a name="ln395">    p-&gt;ncalls = (int)tok.length;</a>
<a name="ln396"> </a>
<a name="ln397">    if (p-&gt;ncalls-- == 0) {</a>
<a name="ln398">      p-&gt;state = -1;</a>
<a name="ln399">      return false;</a>
<a name="ln400">    }</a>
<a name="ln401"> </a>
<a name="ln402">    NEXT_TYPE(tok, MPACK_TOKEN_STR);</a>
<a name="ln403">    if (tok.length &gt; size) {</a>
<a name="ln404">      return false;</a>
<a name="ln405">    }</a>
<a name="ln406"> </a>
<a name="ln407">    p-&gt;ui_handler = ui_client_get_redraw_handler(data, tok.length, NULL);</a>
<a name="ln408">    data += tok.length;</a>
<a name="ln409">    size -= tok.length;</a>
<a name="ln410"> </a>
<a name="ln411">    p-&gt;nevents--;</a>
<a name="ln412">    p-&gt;read_ptr = data;</a>
<a name="ln413">    p-&gt;read_size = size;</a>
<a name="ln414">    if (p-&gt;ui_handler.fn != ui_client_event_grid_line) {</a>
<a name="ln415">      p-&gt;state = 12;</a>
<a name="ln416">      if (p-&gt;grid_line_event) {</a>
<a name="ln417">        arena_mem_free(arena_finish(&amp;p-&gt;arena));</a>
<a name="ln418">        p-&gt;grid_line_event = NULL;</a>
<a name="ln419">      }</a>
<a name="ln420">      return true;</a>
<a name="ln421">    } else {</a>
<a name="ln422">      p-&gt;state = 13;</a>
<a name="ln423">      p-&gt;arena = (Arena)ARENA_EMPTY;</a>
<a name="ln424">      p-&gt;grid_line_event = arena_alloc(&amp;p-&gt;arena, sizeof *p-&gt;grid_line_event, true);</a>
<a name="ln425">      g = p-&gt;grid_line_event;</a>
<a name="ln426">    }</a>
<a name="ln427">    FALLTHROUGH;</a>
<a name="ln428"> </a>
<a name="ln429">  case 13:</a>
<a name="ln430">    NEXT_TYPE(tok, MPACK_TOKEN_ARRAY);</a>
<a name="ln431">    int eventarrsize = (int)tok.length;</a>
<a name="ln432">    if (eventarrsize != 4) {</a>
<a name="ln433">      p-&gt;state = -1;</a>
<a name="ln434">      return false;</a>
<a name="ln435">    }</a>
<a name="ln436"> </a>
<a name="ln437">    for (int i = 0; i &lt; 3; i++) {</a>
<a name="ln438">      NEXT_TYPE(tok, MPACK_TOKEN_UINT);</a>
<a name="ln439">      g-&gt;args[i] = (int)tok.data.value.lo;</a>
<a name="ln440">    }</a>
<a name="ln441"> </a>
<a name="ln442">    NEXT_TYPE(tok, MPACK_TOKEN_ARRAY);</a>
<a name="ln443">    g-&gt;ncells = (int)tok.length;</a>
<a name="ln444">    g-&gt;icell = 0;</a>
<a name="ln445">    g-&gt;coloff = 0;</a>
<a name="ln446">    g-&gt;cur_attr = -1;</a>
<a name="ln447"> </a>
<a name="ln448">    p-&gt;read_ptr = data;</a>
<a name="ln449">    p-&gt;read_size = size;</a>
<a name="ln450">    p-&gt;state = 14;</a>
<a name="ln451">    FALLTHROUGH;</a>
<a name="ln452"> </a>
<a name="ln453">  case 14:</a>
<a name="ln454">    assert(g-&gt;icell &lt; g-&gt;ncells);</a>
<a name="ln455"> </a>
<a name="ln456">    NEXT_TYPE(tok, MPACK_TOKEN_ARRAY);</a>
<a name="ln457">    int cellarrsize = (int)tok.length;</a>
<a name="ln458">    if (cellarrsize &lt; 1 || cellarrsize &gt; 3) {</a>
<a name="ln459">      p-&gt;state = -1;</a>
<a name="ln460">      return false;</a>
<a name="ln461">    }</a>
<a name="ln462"> </a>
<a name="ln463">    NEXT_TYPE(tok, MPACK_TOKEN_STR);</a>
<a name="ln464">    if (tok.length &gt; size) {</a>
<a name="ln465">      return false;</a>
<a name="ln466">    }</a>
<a name="ln467"> </a>
<a name="ln468">    const char *cellbuf = data;</a>
<a name="ln469">    size_t cellsize = tok.length;</a>
<a name="ln470">    data += cellsize;</a>
<a name="ln471">    size -= cellsize;</a>
<a name="ln472"> </a>
<a name="ln473">    if (cellarrsize &gt;= 2) {</a>
<a name="ln474">      NEXT_TYPE(tok, MPACK_TOKEN_SINT);</a>
<a name="ln475">      g-&gt;cur_attr = (int)tok.data.value.lo;</a>
<a name="ln476">    }</a>
<a name="ln477"> </a>
<a name="ln478">    int repeat = 1;</a>
<a name="ln479">    if (cellarrsize &gt;= 3) {</a>
<a name="ln480">      NEXT_TYPE(tok, MPACK_TOKEN_UINT);</a>
<a name="ln481">      repeat = (int)tok.data.value.lo;</a>
<a name="ln482">    }</a>
<a name="ln483"> </a>
<a name="ln484">    g-&gt;clear_width = 0;</a>
<a name="ln485">    if (g-&gt;icell == g-&gt;ncells - 1 &amp;&amp; cellsize == 1 &amp;&amp; cellbuf[0] == ' ' &amp;&amp; repeat &gt; 1) {</a>
<a name="ln486">      g-&gt;clear_width = repeat;</a>
<a name="ln487">    } else {</a>
<a name="ln488">      for (int r = 0; r &lt; repeat; r++) {</a>
<a name="ln489">        if (g-&gt;coloff &gt;= (int)grid_line_buf_size) {</a>
<a name="ln490">          p-&gt;state = -1;</a>
<a name="ln491">          return false;</a>
<a name="ln492">        }</a>
<a name="ln493">        memcpy(grid_line_buf_char[g-&gt;coloff], cellbuf, cellsize);</a>
<a name="ln494">        grid_line_buf_char[g-&gt;coloff][cellsize] = NUL;</a>
<a name="ln495">        grid_line_buf_attr[g-&gt;coloff++] = g-&gt;cur_attr;</a>
<a name="ln496">      }</a>
<a name="ln497">    }</a>
<a name="ln498"> </a>
<a name="ln499">    g-&gt;icell++;</a>
<a name="ln500">    p-&gt;read_ptr = data;</a>
<a name="ln501">    p-&gt;read_size = size;</a>
<a name="ln502">    if (g-&gt;icell == g-&gt;ncells) {</a>
<a name="ln503">      return true;</a>
<a name="ln504">    }</a>
<a name="ln505">    goto redo;</a>
<a name="ln506"> </a>
<a name="ln507">  default:</a>
<a name="ln508">    abort();</a>
<a name="ln509">  }</a>
<a name="ln510">}</a>
</code></pre>
<div class="balloon" rel="402"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v501/" target="_blank">V501</a> There are identical sub-expressions to the left and to the right of the '==' operator: MPACK_TOKEN_STR == MPACK_TOKEN_STR</p></div>
<div class="balloon" rel="463"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v501/" target="_blank">V501</a> There are identical sub-expressions to the left and to the right of the '==' operator: MPACK_TOKEN_STR == MPACK_TOKEN_STR</p></div>
<div class="balloon" rel="474"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v501/" target="_blank">V501</a> There are identical sub-expressions to the left and to the right of the '==' operator: MPACK_TOKEN_SINT == MPACK_TOKEN_SINT</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>