<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>option.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// User-settable options. Checklist for adding a new option:</a>
<a name="ln5">// - Put it in options.lua</a>
<a name="ln6">// - For a global option: Add a variable for it in option_defs.h.</a>
<a name="ln7">// - For a buffer or window local option:</a>
<a name="ln8">//   - Add a BV_XX or WV_XX entry to option_defs.h</a>
<a name="ln9">//   - Add a variable to the window or buffer struct in buffer_defs.h.</a>
<a name="ln10">//   - For a window option, add some code to copy_winopt().</a>
<a name="ln11">//   - For a window string option, add code to check_winopt()</a>
<a name="ln12">//     and clear_winopt(). If setting the option needs parsing,</a>
<a name="ln13">//     add some code to didset_window_options().</a>
<a name="ln14">//   - For a buffer option, add some code to buf_copy_options().</a>
<a name="ln15">//   - For a buffer string option, add code to check_buf_options().</a>
<a name="ln16">// - If it's a numeric option, add any necessary bounds checks to</a>
<a name="ln17">//   set_num_option().</a>
<a name="ln18">// - If it's a list of flags, add some code in do_set(), search for WW_ALL.</a>
<a name="ln19">// - Add documentation! doc/options.txt, and any other related places.</a>
<a name="ln20">// - Add an entry in runtime/optwin.vim.</a>
<a name="ln21"> </a>
<a name="ln22">#define IN_OPTION_C</a>
<a name="ln23">#include &lt;assert.h&gt;</a>
<a name="ln24">#include &lt;inttypes.h&gt;</a>
<a name="ln25">#include &lt;limits.h&gt;</a>
<a name="ln26">#include &lt;stdbool.h&gt;</a>
<a name="ln27">#include &lt;stdlib.h&gt;</a>
<a name="ln28">#include &lt;string.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;nvim/arglist.h&quot;</a>
<a name="ln31">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln32">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln33">#include &quot;nvim/change.h&quot;</a>
<a name="ln34">#include &quot;nvim/charset.h&quot;</a>
<a name="ln35">#include &quot;nvim/cursor_shape.h&quot;</a>
<a name="ln36">#include &quot;nvim/decoration_provider.h&quot;</a>
<a name="ln37">#include &quot;nvim/diff.h&quot;</a>
<a name="ln38">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln39">#include &quot;nvim/edit.h&quot;</a>
<a name="ln40">#include &quot;nvim/eval.h&quot;</a>
<a name="ln41">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln42">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln43">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln44">#include &quot;nvim/ex_session.h&quot;</a>
<a name="ln45">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln46">#include &quot;nvim/fold.h&quot;</a>
<a name="ln47">#include &quot;nvim/garray.h&quot;</a>
<a name="ln48">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln49">#include &quot;nvim/hardcopy.h&quot;</a>
<a name="ln50">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln51">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln52">#include &quot;nvim/indent.h&quot;</a>
<a name="ln53">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln54">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln55">#include &quot;nvim/locale.h&quot;</a>
<a name="ln56">#include &quot;nvim/macros.h&quot;</a>
<a name="ln57">#include &quot;nvim/mapping.h&quot;</a>
<a name="ln58">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln59">#include &quot;nvim/memfile.h&quot;</a>
<a name="ln60">#include &quot;nvim/memline.h&quot;</a>
<a name="ln61">#include &quot;nvim/memory.h&quot;</a>
<a name="ln62">#include &quot;nvim/message.h&quot;</a>
<a name="ln63">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln64">#include &quot;nvim/move.h&quot;</a>
<a name="ln65">#include &quot;nvim/normal.h&quot;</a>
<a name="ln66">#include &quot;nvim/ops.h&quot;</a>
<a name="ln67">#include &quot;nvim/option.h&quot;</a>
<a name="ln68">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln69">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln70">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln71">#include &quot;nvim/path.h&quot;</a>
<a name="ln72">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln73">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln74">#include &quot;nvim/screen.h&quot;</a>
<a name="ln75">#include &quot;nvim/search.h&quot;</a>
<a name="ln76">#include &quot;nvim/spell.h&quot;</a>
<a name="ln77">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln78">#include &quot;nvim/spellsuggest.h&quot;</a>
<a name="ln79">#include &quot;nvim/strings.h&quot;</a>
<a name="ln80">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln81">#include &quot;nvim/ui.h&quot;</a>
<a name="ln82">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln83">#include &quot;nvim/undo.h&quot;</a>
<a name="ln84">#include &quot;nvim/vim.h&quot;</a>
<a name="ln85">#include &quot;nvim/window.h&quot;</a>
<a name="ln86">#ifdef MSWIN</a>
<a name="ln87"># include &quot;nvim/os/pty_conpty_win.h&quot;</a>
<a name="ln88">#endif</a>
<a name="ln89">#include &quot;nvim/api/extmark.h&quot;</a>
<a name="ln90">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln91">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln92">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln93">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln94">#include &quot;nvim/os/lang.h&quot;</a>
<a name="ln95"> </a>
<a name="ln96">static char e_unknown_option[]</a>
<a name="ln97">  = N_(&quot;E518: Unknown option&quot;);</a>
<a name="ln98">static char e_not_allowed_in_modeline[]</a>
<a name="ln99">  = N_(&quot;E520: Not allowed in a modeline&quot;);</a>
<a name="ln100">static char e_not_allowed_in_modeline_when_modelineexpr_is_off[]</a>
<a name="ln101">  = N_(&quot;E992: Not allowed in a modeline when 'modelineexpr' is off&quot;);</a>
<a name="ln102">static char e_key_code_not_set[]</a>
<a name="ln103">  = N_(&quot;E846: Key code not set&quot;);</a>
<a name="ln104">static char e_number_required_after_equal[]</a>
<a name="ln105">  = N_(&quot;E521: Number required after =&quot;);</a>
<a name="ln106">static char e_preview_window_already_exists[]</a>
<a name="ln107">  = N_(&quot;E590: A preview window already exists&quot;);</a>
<a name="ln108"> </a>
<a name="ln109">static char *p_term = NULL;</a>
<a name="ln110">static char *p_ttytype = NULL;</a>
<a name="ln111"> </a>
<a name="ln112">// Saved values for when 'bin' is set.</a>
<a name="ln113">static int p_et_nobin;</a>
<a name="ln114">static int p_ml_nobin;</a>
<a name="ln115">static long p_tw_nobin;</a>
<a name="ln116">static long p_wm_nobin;</a>
<a name="ln117"> </a>
<a name="ln118">// Saved values for when 'paste' is set.</a>
<a name="ln119">static int p_ai_nopaste;</a>
<a name="ln120">static int p_et_nopaste;</a>
<a name="ln121">static long p_sts_nopaste;</a>
<a name="ln122">static long p_tw_nopaste;</a>
<a name="ln123">static long p_wm_nopaste;</a>
<a name="ln124">static char *p_vsts_nopaste;</a>
<a name="ln125"> </a>
<a name="ln126">// options[] is initialized here.</a>
<a name="ln127">// The order of the options MUST be alphabetic for &quot;:set all&quot; and findoption().</a>
<a name="ln128">// All option names MUST start with a lowercase letter (for findoption()).</a>
<a name="ln129">// Exception: &quot;t_&quot; options are at the end.</a>
<a name="ln130">// The options with a NULL variable are 'hidden': a set command for them is</a>
<a name="ln131">// ignored and they are not printed.</a>
<a name="ln132"> </a>
<a name="ln133">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln134"># include &quot;options.generated.h&quot;</a>
<a name="ln135">#endif</a>
<a name="ln136"> </a>
<a name="ln137">#define OPTION_COUNT ARRAY_SIZE(options)</a>
<a name="ln138"> </a>
<a name="ln139">typedef enum {</a>
<a name="ln140">  OP_NONE = 0,</a>
<a name="ln141">  OP_ADDING,      ///&lt; &quot;opt+=arg&quot;</a>
<a name="ln142">  OP_PREPENDING,  ///&lt; &quot;opt^=arg&quot;</a>
<a name="ln143">  OP_REMOVING,    ///&lt; &quot;opt-=arg&quot;</a>
<a name="ln144">} set_op_T;</a>
<a name="ln145"> </a>
<a name="ln146">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln147"># include &quot;option.c.generated.h&quot;</a>
<a name="ln148">#endif</a>
<a name="ln149"> </a>
<a name="ln150">void set_init_tablocal(void)</a>
<a name="ln151">{</a>
<a name="ln152">  // susy baka: cmdheight calls itself OPT_GLOBAL but is really tablocal!</a>
<a name="ln153">  int ch_idx = findoption(&quot;cmdheight&quot;);</a>
<a name="ln154">  p_ch = (long)options[ch_idx].def_val;</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">/// Initialize the options, first part.</a>
<a name="ln158">///</a>
<a name="ln159">/// Called only once from main(), just after creating the first buffer.</a>
<a name="ln160">/// If &quot;clean_arg&quot; is true, Nvim was started with --clean.</a>
<a name="ln161">///</a>
<a name="ln162">/// NOTE: ELOG() etc calls are not allowed here, as log location depends on</a>
<a name="ln163">/// env var expansion which depends on expression evaluation and other</a>
<a name="ln164">/// editor state initialized here. Do logging in set_init_2 or later.</a>
<a name="ln165">void set_init_1(bool clean_arg)</a>
<a name="ln166">{</a>
<a name="ln167">  int opt_idx;</a>
<a name="ln168"> </a>
<a name="ln169">  langmap_init();</a>
<a name="ln170"> </a>
<a name="ln171">  // Find default value for 'shell' option.</a>
<a name="ln172">  // Don't use it if it is empty.</a>
<a name="ln173">  {</a>
<a name="ln174">    const char *shell = os_getenv(&quot;SHELL&quot;);</a>
<a name="ln175">    if (shell != NULL) {</a>
<a name="ln176">      if (vim_strchr(shell, ' ') != NULL) {</a>
<a name="ln177">        const size_t len = strlen(shell) + 3;  // two quotes and a trailing NUL</a>
<a name="ln178">        char *const cmd = xmalloc(len);</a>
<a name="ln179">        snprintf(cmd, len, &quot;\&quot;%s\&quot;&quot;, shell);</a>
<a name="ln180">        set_string_default(&quot;sh&quot;, cmd, true);</a>
<a name="ln181">      } else {</a>
<a name="ln182">        set_string_default(&quot;sh&quot;, (char *)shell, false);</a>
<a name="ln183">      }</a>
<a name="ln184">    }</a>
<a name="ln185">  }</a>
<a name="ln186"> </a>
<a name="ln187">  // Set the default for 'backupskip' to include environment variables for</a>
<a name="ln188">  // temp files.</a>
<a name="ln189">  {</a>
<a name="ln190">#ifdef UNIX</a>
<a name="ln191">    static char *(names[4]) = { &quot;&quot;, &quot;TMPDIR&quot;, &quot;TEMP&quot;, &quot;TMP&quot; };</a>
<a name="ln192">#else</a>
<a name="ln193">    static char *(names[3]) = { &quot;TMPDIR&quot;, &quot;TEMP&quot;, &quot;TMP&quot; };</a>
<a name="ln194">#endif</a>
<a name="ln195">    garray_T ga;</a>
<a name="ln196">    opt_idx = findoption(&quot;backupskip&quot;);</a>
<a name="ln197"> </a>
<a name="ln198">    ga_init(&amp;ga, 1, 100);</a>
<a name="ln199">    for (size_t n = 0; n &lt; ARRAY_SIZE(names); n++) {</a>
<a name="ln200">      bool mustfree = true;</a>
<a name="ln201">      char *p;</a>
<a name="ln202">#ifdef UNIX</a>
<a name="ln203">      if (*names[n] == NUL) {</a>
<a name="ln204"># ifdef __APPLE__</a>
<a name="ln205">        p = &quot;/private/tmp&quot;;</a>
<a name="ln206"># else</a>
<a name="ln207">        p = &quot;/tmp&quot;;</a>
<a name="ln208"># endif</a>
<a name="ln209">        mustfree = false;</a>
<a name="ln210">      } else  // NOLINT(readability/braces)</a>
<a name="ln211">#endif</a>
<a name="ln212">      {</a>
<a name="ln213">        p = vim_getenv(names[n]);</a>
<a name="ln214">      }</a>
<a name="ln215">      if (p != NULL &amp;&amp; *p != NUL) {</a>
<a name="ln216">        // First time count the NUL, otherwise count the ','.</a>
<a name="ln217">        const size_t len = strlen(p) + 3;</a>
<a name="ln218">        char *item = xmalloc(len);</a>
<a name="ln219">        xstrlcpy(item, p, len);</a>
<a name="ln220">        add_pathsep(item);</a>
<a name="ln221">        xstrlcat(item, &quot;*&quot;, len);</a>
<a name="ln222">        if (find_dup_item(ga.ga_data, item, options[opt_idx].flags)</a>
<a name="ln223">            == NULL) {</a>
<a name="ln224">          ga_grow(&amp;ga, (int)len);</a>
<a name="ln225">          if (!GA_EMPTY(&amp;ga)) {</a>
<a name="ln226">            STRCAT(ga.ga_data, &quot;,&quot;);</a>
<a name="ln227">          }</a>
<a name="ln228">          STRCAT(ga.ga_data, p);</a>
<a name="ln229">          add_pathsep(ga.ga_data);</a>
<a name="ln230">          STRCAT(ga.ga_data, &quot;*&quot;);</a>
<a name="ln231">          ga.ga_len += (int)len;</a>
<a name="ln232">        }</a>
<a name="ln233">        xfree(item);</a>
<a name="ln234">      }</a>
<a name="ln235">      if (mustfree) {</a>
<a name="ln236">        xfree(p);</a>
<a name="ln237">      }</a>
<a name="ln238">    }</a>
<a name="ln239">    if (ga.ga_data != NULL) {</a>
<a name="ln240">      set_string_default(&quot;bsk&quot;, ga.ga_data, true);</a>
<a name="ln241">    }</a>
<a name="ln242">  }</a>
<a name="ln243"> </a>
<a name="ln244">  {</a>
<a name="ln245">    char *cdpath;</a>
<a name="ln246">    char *buf;</a>
<a name="ln247">    int i;</a>
<a name="ln248">    int j;</a>
<a name="ln249"> </a>
<a name="ln250">    // Initialize the 'cdpath' option's default value.</a>
<a name="ln251">    cdpath = vim_getenv(&quot;CDPATH&quot;);</a>
<a name="ln252">    if (cdpath != NULL) {</a>
<a name="ln253">      buf = xmalloc(2 * strlen(cdpath) + 2);</a>
<a name="ln254">      {</a>
<a name="ln255">        buf[0] = ',';               // start with &quot;,&quot;, current dir first</a>
<a name="ln256">        j = 1;</a>
<a name="ln257">        for (i = 0; cdpath[i] != NUL; i++) {</a>
<a name="ln258">          if (vim_ispathlistsep(cdpath[i])) {</a>
<a name="ln259">            buf[j++] = ',';</a>
<a name="ln260">          } else {</a>
<a name="ln261">            if (cdpath[i] == ' ' || cdpath[i] == ',') {</a>
<a name="ln262">              buf[j++] = '\\';</a>
<a name="ln263">            }</a>
<a name="ln264">            buf[j++] = cdpath[i];</a>
<a name="ln265">          }</a>
<a name="ln266">        }</a>
<a name="ln267">        buf[j] = NUL;</a>
<a name="ln268">        opt_idx = findoption(&quot;cdpath&quot;);</a>
<a name="ln269">        if (opt_idx &gt;= 0) {</a>
<a name="ln270">          options[opt_idx].def_val = buf;</a>
<a name="ln271">          options[opt_idx].flags |= P_DEF_ALLOCED;</a>
<a name="ln272">        } else {</a>
<a name="ln273">          xfree(buf);           // cannot happen</a>
<a name="ln274">        }</a>
<a name="ln275">      }</a>
<a name="ln276">      xfree(cdpath);</a>
<a name="ln277">    }</a>
<a name="ln278">  }</a>
<a name="ln279"> </a>
<a name="ln280">#if defined(MSWIN) || defined(MAC)</a>
<a name="ln281">  // Set print encoding on platforms that don't default to latin1</a>
<a name="ln282">  set_string_default(&quot;printencoding&quot;, &quot;hp-roman8&quot;, false);</a>
<a name="ln283">#endif</a>
<a name="ln284"> </a>
<a name="ln285">  // 'printexpr' must be allocated to be able to evaluate it.</a>
<a name="ln286">  set_string_default(&quot;printexpr&quot;,</a>
<a name="ln287">#ifdef UNIX</a>
<a name="ln288">                     &quot;system(['lpr'] &quot;</a>
<a name="ln289">                     &quot;+ (empty(&amp;printdevice)?[]:['-P', &amp;printdevice]) &quot;</a>
<a name="ln290">                     &quot;+ [v:fname_in])&quot;</a>
<a name="ln291">                     &quot;. delete(v:fname_in)&quot;</a>
<a name="ln292">                     &quot;+ v:shell_error&quot;,</a>
<a name="ln293">#elif defined(MSWIN)</a>
<a name="ln294">                     &quot;system(['copy', v:fname_in, &quot;</a>
<a name="ln295">                     &quot;empty(&amp;printdevice)?'LPT1':&amp;printdevice])&quot;</a>
<a name="ln296">                     &quot;. delete(v:fname_in)&quot;,</a>
<a name="ln297">#else</a>
<a name="ln298">                     &quot;&quot;,</a>
<a name="ln299">#endif</a>
<a name="ln300">                     false);</a>
<a name="ln301"> </a>
<a name="ln302">  char *backupdir = stdpaths_user_state_subpath(&quot;backup&quot;, 2, true);</a>
<a name="ln303">  const size_t backupdir_len = strlen(backupdir);</a>
<a name="ln304">  backupdir = xrealloc(backupdir, backupdir_len + 3);</a>
<a name="ln305">  memmove(backupdir + 2, backupdir, backupdir_len + 1);</a>
<a name="ln306">  memmove(backupdir, &quot;.,&quot;, 2);</a>
<a name="ln307">  set_string_default(&quot;backupdir&quot;, backupdir, true);</a>
<a name="ln308">  set_string_default(&quot;viewdir&quot;, stdpaths_user_state_subpath(&quot;view&quot;, 2, true),</a>
<a name="ln309">                     true);</a>
<a name="ln310">  set_string_default(&quot;directory&quot;, stdpaths_user_state_subpath(&quot;swap&quot;, 2, true),</a>
<a name="ln311">                     true);</a>
<a name="ln312">  set_string_default(&quot;undodir&quot;, stdpaths_user_state_subpath(&quot;undo&quot;, 2, true),</a>
<a name="ln313">                     true);</a>
<a name="ln314">  // Set default for &amp;runtimepath. All necessary expansions are performed in</a>
<a name="ln315">  // this function.</a>
<a name="ln316">  char *rtp = runtimepath_default(clean_arg);</a>
<a name="ln317">  if (rtp) {</a>
<a name="ln318">    set_string_default(&quot;runtimepath&quot;, rtp, true);</a>
<a name="ln319">    // Make a copy of 'rtp' for 'packpath'</a>
<a name="ln320">    set_string_default(&quot;packpath&quot;, rtp, false);</a>
<a name="ln321">    rtp = NULL;  // ownership taken</a>
<a name="ln322">  }</a>
<a name="ln323"> </a>
<a name="ln324">  // Set all the options (except the terminal options) to their default</a>
<a name="ln325">  // value.  Also set the global value for local options.</a>
<a name="ln326">  set_options_default(0);</a>
<a name="ln327"> </a>
<a name="ln328">  curbuf-&gt;b_p_initialized = true;</a>
<a name="ln329">  curbuf-&gt;b_p_ar = -1;          // no local 'autoread' value</a>
<a name="ln330">  curbuf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln331">  check_buf_options(curbuf);</a>
<a name="ln332">  check_win_options(curwin);</a>
<a name="ln333">  check_options();</a>
<a name="ln334"> </a>
<a name="ln335">  // Set all options to their default value</a>
<a name="ln336">  set_options_default(OPT_FREE);</a>
<a name="ln337"> </a>
<a name="ln338">  // set 'laststatus'</a>
<a name="ln339">  last_status(false);</a>
<a name="ln340"> </a>
<a name="ln341">  // Must be before option_expand(), because that one needs vim_isIDc()</a>
<a name="ln342">  didset_options();</a>
<a name="ln343"> </a>
<a name="ln344">  // Use the current chartab for the generic chartab. This is not in</a>
<a name="ln345">  // didset_options() because it only depends on 'encoding'.</a>
<a name="ln346">  init_spell_chartab();</a>
<a name="ln347"> </a>
<a name="ln348">  // Expand environment variables and things like &quot;~&quot; for the defaults.</a>
<a name="ln349">  // If option_expand() returns non-NULL the variable is expanded.  This can</a>
<a name="ln350">  // only happen for non-indirect options.</a>
<a name="ln351">  // Also set the default to the expanded value, so &quot;:set&quot; does not list</a>
<a name="ln352">  // them.</a>
<a name="ln353">  // Don't set the P_ALLOCED flag, because we don't want to free the</a>
<a name="ln354">  // default.</a>
<a name="ln355">  for (opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln356">    if (options[opt_idx].flags &amp; P_NO_DEF_EXP) {</a>
<a name="ln357">      continue;</a>
<a name="ln358">    }</a>
<a name="ln359">    char *p;</a>
<a name="ln360">    if ((options[opt_idx].flags &amp; P_GETTEXT)</a>
<a name="ln361">        &amp;&amp; options[opt_idx].var != NULL) {</a>
<a name="ln362">      p = _(*(char **)options[opt_idx].var);</a>
<a name="ln363">    } else {</a>
<a name="ln364">      p = option_expand(opt_idx, NULL);</a>
<a name="ln365">    }</a>
<a name="ln366">    if (p != NULL) {</a>
<a name="ln367">      p = xstrdup(p);</a>
<a name="ln368">      *(char **)options[opt_idx].var = p;</a>
<a name="ln369">      if (options[opt_idx].flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln370">        xfree(options[opt_idx].def_val);</a>
<a name="ln371">      }</a>
<a name="ln372">      options[opt_idx].def_val = p;</a>
<a name="ln373">      options[opt_idx].flags |= P_DEF_ALLOCED;</a>
<a name="ln374">    }</a>
<a name="ln375">  }</a>
<a name="ln376"> </a>
<a name="ln377">  save_file_ff(curbuf);         // Buffer is unchanged</a>
<a name="ln378"> </a>
<a name="ln379">  // Detect use of mlterm.</a>
<a name="ln380">  // Mlterm is a terminal emulator akin to xterm that has some special</a>
<a name="ln381">  // abilities (bidi namely).</a>
<a name="ln382">  // NOTE: mlterm's author is being asked to 'set' a variable</a>
<a name="ln383">  //       instead of an environment variable due to inheritance.</a>
<a name="ln384">  if (os_env_exists(&quot;MLTERM&quot;)) {</a>
<a name="ln385">    set_option_value_give_err(&quot;tbidi&quot;, 1L, NULL, 0);</a>
<a name="ln386">  }</a>
<a name="ln387"> </a>
<a name="ln388">  didset_options2();</a>
<a name="ln389"> </a>
<a name="ln390">  lang_init();</a>
<a name="ln391"> </a>
<a name="ln392">  // enc_locale() will try to find the encoding of the current locale.</a>
<a name="ln393">  // This will be used when 'default' is used as encoding specifier</a>
<a name="ln394">  // in 'fileencodings'</a>
<a name="ln395">  char_u *p = enc_locale();</a>
<a name="ln396">  if (p == NULL) {</a>
<a name="ln397">    // use utf-8 as 'default' if locale encoding can't be detected.</a>
<a name="ln398">    p = (char_u *)xmemdupz(S_LEN(&quot;utf-8&quot;));</a>
<a name="ln399">  }</a>
<a name="ln400">  fenc_default = (char *)p;</a>
<a name="ln401"> </a>
<a name="ln402">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln403">  // GNU gettext 0.10.37 supports this feature: set the codeset used for</a>
<a name="ln404">  // translated messages independently from the current locale.</a>
<a name="ln405">  (void)bind_textdomain_codeset(PROJECT_NAME, p_enc);</a>
<a name="ln406">#endif</a>
<a name="ln407"> </a>
<a name="ln408">  // Set the default for 'helplang'.</a>
<a name="ln409">  set_helplang_default(get_mess_lang());</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">/// Set an option to its default value.</a>
<a name="ln413">/// This does not take care of side effects!</a>
<a name="ln414">///</a>
<a name="ln415">/// @param opt_flags OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln416">static void set_option_default(int opt_idx, int opt_flags)</a>
<a name="ln417">{</a>
<a name="ln418">  char_u *varp;            // pointer to variable for current option</a>
<a name="ln419">  int both = (opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0;</a>
<a name="ln420"> </a>
<a name="ln421">  varp = (char_u *)get_varp_scope(&amp;(options[opt_idx]), both ? OPT_LOCAL : opt_flags);</a>
<a name="ln422">  uint32_t flags = options[opt_idx].flags;</a>
<a name="ln423">  if (varp != NULL) {       // skip hidden option, nothing to do for it</a>
<a name="ln424">    if (flags &amp; P_STRING) {</a>
<a name="ln425">      // Use set_string_option_direct() for local options to handle</a>
<a name="ln426">      // freeing and allocating the value.</a>
<a name="ln427">      if (options[opt_idx].indir != PV_NONE) {</a>
<a name="ln428">        set_string_option_direct(NULL, opt_idx,</a>
<a name="ln429">                                 options[opt_idx].def_val, opt_flags, 0);</a>
<a name="ln430">      } else {</a>
<a name="ln431">        if ((opt_flags &amp; OPT_FREE) &amp;&amp; (flags &amp; P_ALLOCED)) {</a>
<a name="ln432">          free_string_option(*(char **)(varp));</a>
<a name="ln433">        }</a>
<a name="ln434">        *(char **)varp = options[opt_idx].def_val;</a>
<a name="ln435">        options[opt_idx].flags &amp;= ~P_ALLOCED;</a>
<a name="ln436">      }</a>
<a name="ln437">    } else if (flags &amp; P_NUM) {</a>
<a name="ln438">      if (options[opt_idx].indir == PV_SCROLL) {</a>
<a name="ln439">        win_comp_scroll(curwin);</a>
<a name="ln440">      } else {</a>
<a name="ln441">        long def_val = (long)options[opt_idx].def_val;</a>
<a name="ln442">        if ((long *)varp == &amp;curwin-&gt;w_p_so</a>
<a name="ln443">            || (long *)varp == &amp;curwin-&gt;w_p_siso) {</a>
<a name="ln444">          // 'scrolloff' and 'sidescrolloff' local values have a</a>
<a name="ln445">          // different default value than the global default.</a>
<a name="ln446">          *(long *)varp = -1;</a>
<a name="ln447">        } else {</a>
<a name="ln448">          *(long *)varp = def_val;</a>
<a name="ln449">        }</a>
<a name="ln450">        // May also set global value for local option.</a>
<a name="ln451">        if (both) {</a>
<a name="ln452">          *(long *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) =</a>
<a name="ln453">            def_val;</a>
<a name="ln454">        }</a>
<a name="ln455">      }</a>
<a name="ln456">    } else {  // P_BOOL</a>
<a name="ln457">      *(int *)varp = (int)(intptr_t)options[opt_idx].def_val;</a>
<a name="ln458">#ifdef UNIX</a>
<a name="ln459">      // 'modeline' defaults to off for root</a>
<a name="ln460">      if (options[opt_idx].indir == PV_ML &amp;&amp; getuid() == ROOT_UID) {</a>
<a name="ln461">        *(int *)varp = false;</a>
<a name="ln462">      }</a>
<a name="ln463">#endif</a>
<a name="ln464">      // May also set global value for local option.</a>
<a name="ln465">      if (both) {</a>
<a name="ln466">        *(int *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) =</a>
<a name="ln467">          *(int *)varp;</a>
<a name="ln468">      }</a>
<a name="ln469">    }</a>
<a name="ln470"> </a>
<a name="ln471">    // The default value is not insecure.</a>
<a name="ln472">    uint32_t *flagsp = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln473">    *flagsp = *flagsp &amp; ~P_INSECURE;</a>
<a name="ln474">  }</a>
<a name="ln475"> </a>
<a name="ln476">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln477">}</a>
<a name="ln478"> </a>
<a name="ln479">/// Set all options (except terminal options) to their default value.</a>
<a name="ln480">///</a>
<a name="ln481">/// @param opt_flags  OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln482">static void set_options_default(int opt_flags)</a>
<a name="ln483">{</a>
<a name="ln484">  for (int i = 0; options[i].fullname; i++) {</a>
<a name="ln485">    if (!(options[i].flags &amp; P_NODEFAULT)) {</a>
<a name="ln486">      set_option_default(i, opt_flags);</a>
<a name="ln487">    }</a>
<a name="ln488">  }</a>
<a name="ln489"> </a>
<a name="ln490">  // The 'scroll' option must be computed for all windows.</a>
<a name="ln491">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln492">    win_comp_scroll(wp);</a>
<a name="ln493">  }</a>
<a name="ln494"> </a>
<a name="ln495">  parse_cino(curbuf);</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498">/// Set the Vi-default value of a string option.</a>
<a name="ln499">/// Used for 'sh', 'backupskip' and 'term'.</a>
<a name="ln500">///</a>
<a name="ln501">/// @param name The name of the option</a>
<a name="ln502">/// @param val The value of the option</a>
<a name="ln503">/// @param allocated If true, do not copy default as it was already allocated.</a>
<a name="ln504">static void set_string_default(const char *name, char *val, bool allocated)</a>
<a name="ln505">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln506">{</a>
<a name="ln507">  int opt_idx = findoption(name);</a>
<a name="ln508">  if (opt_idx &gt;= 0) {</a>
<a name="ln509">    if (options[opt_idx].flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln510">      xfree(options[opt_idx].def_val);</a>
<a name="ln511">    }</a>
<a name="ln512"> </a>
<a name="ln513">    options[opt_idx].def_val = allocated ? val : xstrdup(val);</a>
<a name="ln514">    options[opt_idx].flags |= P_DEF_ALLOCED;</a>
<a name="ln515">  }</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">/// For an option value that contains comma separated items, find &quot;newval&quot; in</a>
<a name="ln519">/// &quot;origval&quot;.  Return NULL if not found.</a>
<a name="ln520">static char *find_dup_item(char *origval, const char *newval, uint32_t flags)</a>
<a name="ln521">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln522">{</a>
<a name="ln523">  int bs = 0;</a>
<a name="ln524"> </a>
<a name="ln525">  if (origval == NULL) {</a>
<a name="ln526">    return NULL;</a>
<a name="ln527">  }</a>
<a name="ln528"> </a>
<a name="ln529">  const size_t newlen = strlen(newval);</a>
<a name="ln530">  for (char *s = origval; *s != NUL; s++) {</a>
<a name="ln531">    if ((!(flags &amp; P_COMMA) || s == origval || (s[-1] == ',' &amp;&amp; !(bs &amp; 1)))</a>
<a name="ln532">        &amp;&amp; STRNCMP(s, newval, newlen) == 0</a>
<a name="ln533">        &amp;&amp; (!(flags &amp; P_COMMA) || s[newlen] == ',' || s[newlen] == NUL)) {</a>
<a name="ln534">      return s;</a>
<a name="ln535">    }</a>
<a name="ln536">    // Count backslashes.  Only a comma with an even number of backslashes</a>
<a name="ln537">    // or a single backslash preceded by a comma before it is recognized as</a>
<a name="ln538">    // a separator.</a>
<a name="ln539">    if ((s &gt; origval + 1 &amp;&amp; s[-1] == '\\' &amp;&amp; s[-2] != ',')</a>
<a name="ln540">        || (s == origval + 1 &amp;&amp; s[-1] == '\\')) {</a>
<a name="ln541">      bs++;</a>
<a name="ln542">    } else {</a>
<a name="ln543">      bs = 0;</a>
<a name="ln544">    }</a>
<a name="ln545">  }</a>
<a name="ln546">  return NULL;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549">/// Set the Vi-default value of a number option.</a>
<a name="ln550">/// Used for 'lines' and 'columns'.</a>
<a name="ln551">void set_number_default(char *name, long val)</a>
<a name="ln552">{</a>
<a name="ln553">  int opt_idx;</a>
<a name="ln554"> </a>
<a name="ln555">  opt_idx = findoption(name);</a>
<a name="ln556">  if (opt_idx &gt;= 0) {</a>
<a name="ln557">    options[opt_idx].def_val = (char *)(intptr_t)val;</a>
<a name="ln558">  }</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">#if defined(EXITFREE)</a>
<a name="ln562">/// Free all options.</a>
<a name="ln563">void free_all_options(void)</a>
<a name="ln564">{</a>
<a name="ln565">  for (int i = 0; options[i].fullname; i++) {</a>
<a name="ln566">    if (options[i].indir == PV_NONE) {</a>
<a name="ln567">      // global option: free value and default value.</a>
<a name="ln568">      if ((options[i].flags &amp; P_ALLOCED) &amp;&amp; options[i].var != NULL) {</a>
<a name="ln569">        free_string_option(*(char **)options[i].var);</a>
<a name="ln570">      }</a>
<a name="ln571">      if (options[i].flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln572">        free_string_option(options[i].def_val);</a>
<a name="ln573">      }</a>
<a name="ln574">    } else if (options[i].var != VAR_WIN &amp;&amp; (options[i].flags &amp; P_STRING)) {</a>
<a name="ln575">      // buffer-local option: free global value</a>
<a name="ln576">      clear_string_option((char **)options[i].var);</a>
<a name="ln577">    }</a>
<a name="ln578">  }</a>
<a name="ln579">  free_operatorfunc_option();</a>
<a name="ln580">}</a>
<a name="ln581">#endif</a>
<a name="ln582"> </a>
<a name="ln583">/// Initialize the options, part two: After getting Rows and Columns.</a>
<a name="ln584">void set_init_2(bool headless)</a>
<a name="ln585">{</a>
<a name="ln586">  // set in set_init_1 but logging is not allowed there</a>
<a name="ln587">  ILOG(&quot;startup runtimepath/packpath value: %s&quot;, p_rtp);</a>
<a name="ln588"> </a>
<a name="ln589">  int idx;</a>
<a name="ln590"> </a>
<a name="ln591">  // 'scroll' defaults to half the window height. The stored default is zero,</a>
<a name="ln592">  // which results in the actual value computed from the window height.</a>
<a name="ln593">  idx = findoption(&quot;scroll&quot;);</a>
<a name="ln594">  if (idx &gt;= 0 &amp;&amp; !(options[idx].flags &amp; P_WAS_SET)) {</a>
<a name="ln595">    set_option_default(idx, OPT_LOCAL);</a>
<a name="ln596">  }</a>
<a name="ln597">  comp_col();</a>
<a name="ln598"> </a>
<a name="ln599">  // 'window' is only for backwards compatibility with Vi.</a>
<a name="ln600">  // Default is Rows - 1.</a>
<a name="ln601">  if (!option_was_set(&quot;window&quot;)) {</a>
<a name="ln602">    p_window = Rows - 1;</a>
<a name="ln603">  }</a>
<a name="ln604">  set_number_default(&quot;window&quot;, Rows - 1);</a>
<a name="ln605">  (void)parse_printoptions();      // parse 'printoptions' default value</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">/// Initialize the options, part three: After reading the .vimrc</a>
<a name="ln609">void set_init_3(void)</a>
<a name="ln610">{</a>
<a name="ln611">  parse_shape_opt(SHAPE_CURSOR);   // set cursor shapes from 'guicursor'</a>
<a name="ln612"> </a>
<a name="ln613">  // Set 'shellpipe' and 'shellredir', depending on the 'shell' option.</a>
<a name="ln614">  // This is done after other initializations, where 'shell' might have been</a>
<a name="ln615">  // set, but only if they have not been set before.</a>
<a name="ln616">  int idx_srr = findoption(&quot;srr&quot;);</a>
<a name="ln617">  int do_srr = (idx_srr &lt; 0)</a>
<a name="ln618">    ? false</a>
<a name="ln619">    : !(options[idx_srr].flags &amp; P_WAS_SET);</a>
<a name="ln620">  int idx_sp = findoption(&quot;sp&quot;);</a>
<a name="ln621">  int do_sp = (idx_sp &lt; 0)</a>
<a name="ln622">    ? false</a>
<a name="ln623">    : !(options[idx_sp].flags &amp; P_WAS_SET);</a>
<a name="ln624"> </a>
<a name="ln625">  size_t len = 0;</a>
<a name="ln626">  char *p = (char *)invocation_path_tail((char_u *)p_sh, &amp;len);</a>
<a name="ln627">  p = xstrnsave(p, len);</a>
<a name="ln628"> </a>
<a name="ln629">  {</a>
<a name="ln630">    //</a>
<a name="ln631">    // Default for p_sp is &quot;| tee&quot;, for p_srr is &quot;&gt;&quot;.</a>
<a name="ln632">    // For known shells it is changed here to include stderr.</a>
<a name="ln633">    //</a>
<a name="ln634">    if (path_fnamecmp(p, &quot;csh&quot;) == 0</a>
<a name="ln635">        || path_fnamecmp(p, &quot;tcsh&quot;) == 0) {</a>
<a name="ln636">      if (do_sp) {</a>
<a name="ln637">        p_sp = &quot;|&amp; tee&quot;;</a>
<a name="ln638">        options[idx_sp].def_val = p_sp;</a>
<a name="ln639">      }</a>
<a name="ln640">      if (do_srr) {</a>
<a name="ln641">        p_srr = &quot;&gt;&amp;&quot;;</a>
<a name="ln642">        options[idx_srr].def_val = p_srr;</a>
<a name="ln643">      }</a>
<a name="ln644">    } else if (path_fnamecmp(p, &quot;sh&quot;) == 0</a>
<a name="ln645">               || path_fnamecmp(p, &quot;ksh&quot;) == 0</a>
<a name="ln646">               || path_fnamecmp(p, &quot;mksh&quot;) == 0</a>
<a name="ln647">               || path_fnamecmp(p, &quot;pdksh&quot;) == 0</a>
<a name="ln648">               || path_fnamecmp(p, &quot;zsh&quot;) == 0</a>
<a name="ln649">               || path_fnamecmp(p, &quot;zsh-beta&quot;) == 0</a>
<a name="ln650">               || path_fnamecmp(p, &quot;bash&quot;) == 0</a>
<a name="ln651">               || path_fnamecmp(p, &quot;fish&quot;) == 0</a>
<a name="ln652">               || path_fnamecmp(p, &quot;ash&quot;) == 0</a>
<a name="ln653">               || path_fnamecmp(p, &quot;dash&quot;) == 0) {</a>
<a name="ln654">      // Always use POSIX shell style redirection if we reach this</a>
<a name="ln655">      if (do_sp) {</a>
<a name="ln656">        p_sp = &quot;2&gt;&amp;1| tee&quot;;</a>
<a name="ln657">        options[idx_sp].def_val = p_sp;</a>
<a name="ln658">      }</a>
<a name="ln659">      if (do_srr) {</a>
<a name="ln660">        p_srr = &quot;&gt;%s 2&gt;&amp;1&quot;;</a>
<a name="ln661">        options[idx_srr].def_val = p_srr;</a>
<a name="ln662">      }</a>
<a name="ln663">    }</a>
<a name="ln664">    xfree(p);</a>
<a name="ln665">  }</a>
<a name="ln666"> </a>
<a name="ln667">  if (buf_is_empty(curbuf)) {</a>
<a name="ln668">    int idx_ffs = findoption_len(S_LEN(&quot;ffs&quot;));</a>
<a name="ln669"> </a>
<a name="ln670">    // Apply the first entry of 'fileformats' to the initial buffer.</a>
<a name="ln671">    if (idx_ffs &gt;= 0 &amp;&amp; (options[idx_ffs].flags &amp; P_WAS_SET)) {</a>
<a name="ln672">      set_fileformat(default_fileformat(), OPT_LOCAL);</a>
<a name="ln673">    }</a>
<a name="ln674">  }</a>
<a name="ln675"> </a>
<a name="ln676">  set_title_defaults();  // 'title', 'icon'</a>
<a name="ln677">}</a>
<a name="ln678"> </a>
<a name="ln679">/// When 'helplang' is still at its default value, set it to &quot;lang&quot;.</a>
<a name="ln680">/// Only the first two characters of &quot;lang&quot; are used.</a>
<a name="ln681">void set_helplang_default(const char *lang)</a>
<a name="ln682">{</a>
<a name="ln683">  if (lang == NULL) {</a>
<a name="ln684">    return;</a>
<a name="ln685">  }</a>
<a name="ln686"> </a>
<a name="ln687">  const size_t lang_len = strlen(lang);</a>
<a name="ln688">  if (lang_len &lt; 2) {  // safety check</a>
<a name="ln689">    return;</a>
<a name="ln690">  }</a>
<a name="ln691">  int idx = findoption(&quot;hlg&quot;);</a>
<a name="ln692">  if (idx &gt;= 0 &amp;&amp; !(options[idx].flags &amp; P_WAS_SET)) {</a>
<a name="ln693">    if (options[idx].flags &amp; P_ALLOCED) {</a>
<a name="ln694">      free_string_option((char *)p_hlg);</a>
<a name="ln695">    }</a>
<a name="ln696">    p_hlg = (char_u *)xmemdupz(lang, lang_len);</a>
<a name="ln697">    // zh_CN becomes &quot;cn&quot;, zh_TW becomes &quot;tw&quot;.</a>
<a name="ln698">    if (STRNICMP(p_hlg, &quot;zh_&quot;, 3) == 0 &amp;&amp; STRLEN(p_hlg) &gt;= 5) {</a>
<a name="ln699">      p_hlg[0] = (char_u)TOLOWER_ASC(p_hlg[3]);</a>
<a name="ln700">      p_hlg[1] = (char_u)TOLOWER_ASC(p_hlg[4]);</a>
<a name="ln701">    } else if (STRLEN(p_hlg) &gt;= 1 &amp;&amp; *p_hlg == 'C') {</a>
<a name="ln702">      // any C like setting, such as C.UTF-8, becomes &quot;en&quot;</a>
<a name="ln703">      p_hlg[0] = 'e';</a>
<a name="ln704">      p_hlg[1] = 'n';</a>
<a name="ln705">    }</a>
<a name="ln706">    p_hlg[2] = NUL;</a>
<a name="ln707">    options[idx].flags |= P_ALLOCED;</a>
<a name="ln708">  }</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">/// 'title' and 'icon' only default to true if they have not been set or reset</a>
<a name="ln712">/// in .vimrc and we can read the old value.</a>
<a name="ln713">/// When 'title' and 'icon' have been reset in .vimrc, we won't even check if</a>
<a name="ln714">/// they can be reset.  This reduces startup time when using X on a remote</a>
<a name="ln715">/// machine.</a>
<a name="ln716">void set_title_defaults(void)</a>
<a name="ln717">{</a>
<a name="ln718">  int idx1;</a>
<a name="ln719"> </a>
<a name="ln720">  // If GUI is (going to be) used, we can always set the window title and</a>
<a name="ln721">  // icon name.  Saves a bit of time, because the X11 display server does</a>
<a name="ln722">  // not need to be contacted.</a>
<a name="ln723">  idx1 = findoption(&quot;title&quot;);</a>
<a name="ln724">  if (idx1 &gt;= 0 &amp;&amp; !(options[idx1].flags &amp; P_WAS_SET)) {</a>
<a name="ln725">    options[idx1].def_val = 0;</a>
<a name="ln726">    p_title = 0;</a>
<a name="ln727">  }</a>
<a name="ln728">  idx1 = findoption(&quot;icon&quot;);</a>
<a name="ln729">  if (idx1 &gt;= 0 &amp;&amp; !(options[idx1].flags &amp; P_WAS_SET)) {</a>
<a name="ln730">    options[idx1].def_val = 0;</a>
<a name="ln731">    p_icon = 0;</a>
<a name="ln732">  }</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735">void ex_set(exarg_T *eap)</a>
<a name="ln736">{</a>
<a name="ln737">  int flags = 0;</a>
<a name="ln738"> </a>
<a name="ln739">  if (eap-&gt;cmdidx == CMD_setlocal) {</a>
<a name="ln740">    flags = OPT_LOCAL;</a>
<a name="ln741">  } else if (eap-&gt;cmdidx == CMD_setglobal) {</a>
<a name="ln742">    flags = OPT_GLOBAL;</a>
<a name="ln743">  }</a>
<a name="ln744">  if (eap-&gt;forceit) {</a>
<a name="ln745">    flags |= OPT_ONECOLUMN;</a>
<a name="ln746">  }</a>
<a name="ln747">  (void)do_set(eap-&gt;arg, flags);</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">/// Part of do_set() for string options.</a>
<a name="ln751">/// @return  FAIL on failure, do not process further options.</a>
<a name="ln752">static int do_set_string(int opt_idx, int opt_flags, char **argp, int nextchar, set_op_T op_arg,</a>
<a name="ln753">                         uint32_t flags, char *varp_arg, char *errbuf, size_t errbuflen,</a>
<a name="ln754">                         int *value_checked, char **errmsg)</a>
<a name="ln755">{</a>
<a name="ln756">  char *arg = *argp;</a>
<a name="ln757">  set_op_T op = op_arg;</a>
<a name="ln758">  char *varp = varp_arg;</a>
<a name="ln759">  char *save_arg = NULL;</a>
<a name="ln760">  char *s = NULL;</a>
<a name="ln761">  char_u *oldval = NULL;  // previous value if *varp</a>
<a name="ln762">  char *newval;</a>
<a name="ln763">  char_u *origval = NULL;</a>
<a name="ln764">  char_u *origval_l = NULL;</a>
<a name="ln765">  char_u *origval_g = NULL;</a>
<a name="ln766">  char *saved_origval = NULL;</a>
<a name="ln767">  char *saved_origval_l = NULL;</a>
<a name="ln768">  char *saved_origval_g = NULL;</a>
<a name="ln769">  char *saved_newval = NULL;</a>
<a name="ln770">  unsigned newlen;</a>
<a name="ln771">  int comma;</a>
<a name="ln772">  char whichwrap[80];</a>
<a name="ln773"> </a>
<a name="ln774">  // When using &quot;:set opt=val&quot; for a global option</a>
<a name="ln775">  // with a local value the local value will be</a>
<a name="ln776">  // reset, use the global value here.</a>
<a name="ln777">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0</a>
<a name="ln778">      &amp;&amp; ((int)options[opt_idx].indir &amp; PV_BOTH)) {</a>
<a name="ln779">    varp = (char *)options[opt_idx].var;</a>
<a name="ln780">  }</a>
<a name="ln781"> </a>
<a name="ln782">  // The old value is kept until we are sure that the new value is valid.</a>
<a name="ln783">  oldval = *(char_u **)varp;</a>
<a name="ln784"> </a>
<a name="ln785">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln786">    origval_l = *(char_u **)get_varp_scope(&amp;(options[opt_idx]), OPT_LOCAL);</a>
<a name="ln787">    origval_g = *(char_u **)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln788"> </a>
<a name="ln789">    // A global-local string option might have an empty option as value to</a>
<a name="ln790">    // indicate that the global value should be used.</a>
<a name="ln791">    if (((int)options[opt_idx].indir &amp; PV_BOTH) &amp;&amp; origval_l == (char_u *)empty_option) {</a>
<a name="ln792">      origval_l = origval_g;</a>
<a name="ln793">    }</a>
<a name="ln794">  }</a>
<a name="ln795"> </a>
<a name="ln796">  // When setting the local value of a global option, the old value may be</a>
<a name="ln797">  // the global value.</a>
<a name="ln798">  if (((int)options[opt_idx].indir &amp; PV_BOTH) &amp;&amp; (opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln799">    origval = *(char_u **)get_varp(&amp;options[opt_idx]);</a>
<a name="ln800">  } else {</a>
<a name="ln801">    origval = oldval;</a>
<a name="ln802">  }</a>
<a name="ln803"> </a>
<a name="ln804">  if (nextchar == '&amp;') {  // set to default val</a>
<a name="ln805">    newval = options[opt_idx].def_val;</a>
<a name="ln806">    // expand environment variables and ~ since the default value was</a>
<a name="ln807">    // already expanded, only required when an environment variable was set</a>
<a name="ln808">    // later</a>
<a name="ln809">    if (newval == NULL) {</a>
<a name="ln810">      newval = empty_option;</a>
<a name="ln811">    } else if (!(options[opt_idx].flags &amp; P_NO_DEF_EXP)) {</a>
<a name="ln812">      s = option_expand(opt_idx, newval);</a>
<a name="ln813">      if (s == NULL) {</a>
<a name="ln814">        s = newval;</a>
<a name="ln815">      }</a>
<a name="ln816">      newval = xstrdup(s);</a>
<a name="ln817">    } else {</a>
<a name="ln818">      newval = xstrdup(newval);</a>
<a name="ln819">    }</a>
<a name="ln820">  } else if (nextchar == '&lt;') {  // set to global val</a>
<a name="ln821">    newval = xstrdup(*(char **)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL));</a>
<a name="ln822">  } else {</a>
<a name="ln823">    arg++;  // jump to after the '=' or ':'</a>
<a name="ln824"> </a>
<a name="ln825">    // Set 'keywordprg' to &quot;:help&quot; if an empty</a>
<a name="ln826">    // value was passed to :set by the user.</a>
<a name="ln827">    if (varp == (char *)&amp;p_kp &amp;&amp; (*arg == NUL || *arg == ' ')) {</a>
<a name="ln828">      save_arg = arg;</a>
<a name="ln829">      arg = &quot;:help&quot;;</a>
<a name="ln830">    } else if (varp == (char *)&amp;p_bs &amp;&amp; ascii_isdigit(**(char_u **)varp)) {</a>
<a name="ln831">      // Convert 'backspace' number to string, for</a>
<a name="ln832">      // adding, prepending and removing string.</a>
<a name="ln833">      int i = getdigits_int((char **)varp, true, 0);</a>
<a name="ln834">      switch (i) {</a>
<a name="ln835">      case 0:</a>
<a name="ln836">        *(char **)varp = empty_option;</a>
<a name="ln837">        break;</a>
<a name="ln838">      case 1:</a>
<a name="ln839">        *(char_u **)varp = (char_u *)xstrdup(&quot;indent,eol&quot;);</a>
<a name="ln840">        break;</a>
<a name="ln841">      case 2:</a>
<a name="ln842">        *(char_u **)varp = (char_u *)xstrdup(&quot;indent,eol,start&quot;);</a>
<a name="ln843">        break;</a>
<a name="ln844">      case 3:</a>
<a name="ln845">        *(char_u **)varp = (char_u *)xstrdup(&quot;indent,eol,nostop&quot;);</a>
<a name="ln846">        break;</a>
<a name="ln847">      }</a>
<a name="ln848">      xfree(oldval);</a>
<a name="ln849">      if (origval == oldval) {</a>
<a name="ln850">        origval = *(char_u **)varp;</a>
<a name="ln851">      }</a>
<a name="ln852">      if (origval_l == oldval) {</a>
<a name="ln853">        origval_l = *(char_u **)varp;</a>
<a name="ln854">      }</a>
<a name="ln855">      if (origval_g == oldval) {</a>
<a name="ln856">        origval_g = *(char_u **)varp;</a>
<a name="ln857">      }</a>
<a name="ln858">      oldval = *(char_u **)varp;</a>
<a name="ln859">    } else if (varp == (char *)&amp;p_ww &amp;&amp; ascii_isdigit(*arg)) {</a>
<a name="ln860">      // Convert 'whichwrap' number to string, for backwards compatibility</a>
<a name="ln861">      // with Vim 3.0.</a>
<a name="ln862">      *whichwrap = NUL;</a>
<a name="ln863">      int i = getdigits_int(&amp;arg, true, 0);</a>
<a name="ln864">      if (i &amp; 1) {</a>
<a name="ln865">        xstrlcat(whichwrap, &quot;b,&quot;, sizeof(whichwrap));</a>
<a name="ln866">      }</a>
<a name="ln867">      if (i &amp; 2) {</a>
<a name="ln868">        xstrlcat(whichwrap, &quot;s,&quot;, sizeof(whichwrap));</a>
<a name="ln869">      }</a>
<a name="ln870">      if (i &amp; 4) {</a>
<a name="ln871">        xstrlcat(whichwrap, &quot;h,l,&quot;, sizeof(whichwrap));</a>
<a name="ln872">      }</a>
<a name="ln873">      if (i &amp; 8) {</a>
<a name="ln874">        xstrlcat(whichwrap, &quot;&lt;,&gt;,&quot;, sizeof(whichwrap));</a>
<a name="ln875">      }</a>
<a name="ln876">      if (i &amp; 16) {</a>
<a name="ln877">        xstrlcat(whichwrap, &quot;[,],&quot;, sizeof(whichwrap));</a>
<a name="ln878">      }</a>
<a name="ln879">      if (*whichwrap != NUL) {  // remove trailing ,</a>
<a name="ln880">        whichwrap[strlen(whichwrap) - 1] = NUL;</a>
<a name="ln881">      }</a>
<a name="ln882">      save_arg = arg;</a>
<a name="ln883">      arg = whichwrap;</a>
<a name="ln884">    } else if (*arg == '&gt;' &amp;&amp; (varp == (char *)&amp;p_dir || varp == (char *)&amp;p_bdir)) {</a>
<a name="ln885">      // Remove '&gt;' before 'dir' and 'bdir', for backwards compatibility with</a>
<a name="ln886">      // version 3.0</a>
<a name="ln887">      arg++;</a>
<a name="ln888">    }</a>
<a name="ln889"> </a>
<a name="ln890">    // Copy the new string into allocated memory.</a>
<a name="ln891">    // Can't use set_string_option_direct(), because we need to remove the</a>
<a name="ln892">    // backslashes.</a>
<a name="ln893"> </a>
<a name="ln894">    // get a bit too much</a>
<a name="ln895">    newlen = (unsigned)strlen(arg) + 1;</a>
<a name="ln896">    if (op != OP_NONE) {</a>
<a name="ln897">      newlen += (unsigned)STRLEN(origval) + 1;</a>
<a name="ln898">    }</a>
<a name="ln899">    newval = xmalloc(newlen);</a>
<a name="ln900">    s = newval;</a>
<a name="ln901"> </a>
<a name="ln902">    // Copy the string, skip over escaped chars.</a>
<a name="ln903">    // For MS-Windows backslashes before normal file name characters</a>
<a name="ln904">    // are not removed, and keep backslash at start, for &quot;\\machine\path&quot;,</a>
<a name="ln905">    // but do remove it for &quot;\\\\machine\\path&quot;.</a>
<a name="ln906">    // The reverse is found in ExpandOldSetting().</a>
<a name="ln907">    while (*arg != NUL &amp;&amp; !ascii_iswhite(*arg)) {</a>
<a name="ln908">      if (*arg == '\\' &amp;&amp; arg[1] != NUL</a>
<a name="ln909">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln910">          &amp;&amp; !((flags &amp; P_EXPAND)</a>
<a name="ln911">               &amp;&amp; vim_isfilec(arg[1])</a>
<a name="ln912">               &amp;&amp; !ascii_iswhite(arg[1])</a>
<a name="ln913">               &amp;&amp; (arg[1] != '\\'</a>
<a name="ln914">                   || (s == newval &amp;&amp; arg[2] != '\\')))</a>
<a name="ln915">#endif</a>
<a name="ln916">          ) {</a>
<a name="ln917">        arg++;  // remove backslash</a>
<a name="ln918">      }</a>
<a name="ln919">      int i = utfc_ptr2len(arg);</a>
<a name="ln920">      if (i &gt; 1) {</a>
<a name="ln921">        // copy multibyte char</a>
<a name="ln922">        memmove(s, arg, (size_t)i);</a>
<a name="ln923">        arg += i;</a>
<a name="ln924">        s += i;</a>
<a name="ln925">      } else {</a>
<a name="ln926">        *s++ = *arg++;</a>
<a name="ln927">      }</a>
<a name="ln928">    }</a>
<a name="ln929">    *s = NUL;</a>
<a name="ln930"> </a>
<a name="ln931">    // Expand environment variables and ~.</a>
<a name="ln932">    // Don't do it when adding without inserting a comma.</a>
<a name="ln933">    if (op == OP_NONE || (flags &amp; P_COMMA)) {</a>
<a name="ln934">      s = option_expand(opt_idx, newval);</a>
<a name="ln935">      if (s != NULL) {</a>
<a name="ln936">        xfree(newval);</a>
<a name="ln937">        newlen = (unsigned)strlen(s) + 1;</a>
<a name="ln938">        if (op != OP_NONE) {</a>
<a name="ln939">          newlen += (unsigned)STRLEN(origval) + 1;</a>
<a name="ln940">        }</a>
<a name="ln941">        newval = xmalloc(newlen);</a>
<a name="ln942">        STRCPY(newval, s);</a>
<a name="ln943">      }</a>
<a name="ln944">    }</a>
<a name="ln945"> </a>
<a name="ln946">    // locate newval[] in origval[] when removing it</a>
<a name="ln947">    // and when adding to avoid duplicates</a>
<a name="ln948">    int len = 0;</a>
<a name="ln949">    if (op == OP_REMOVING || (flags &amp; P_NODUP)) {</a>
<a name="ln950">      len = (int)STRLEN(newval);</a>
<a name="ln951">      s = find_dup_item((char *)origval, newval, flags);</a>
<a name="ln952"> </a>
<a name="ln953">      // do not add if already there</a>
<a name="ln954">      if ((op == OP_ADDING || op == OP_PREPENDING) &amp;&amp; s != NULL) {</a>
<a name="ln955">        op = OP_NONE;</a>
<a name="ln956">        STRCPY(newval, origval);</a>
<a name="ln957">      }</a>
<a name="ln958"> </a>
<a name="ln959">      // if no duplicate, move pointer to end of original value</a>
<a name="ln960">      if (s == NULL) {</a>
<a name="ln961">        s = (char *)origval + (int)STRLEN(origval);</a>
<a name="ln962">      }</a>
<a name="ln963">    }</a>
<a name="ln964"> </a>
<a name="ln965">    // concatenate the two strings; add a ',' if needed</a>
<a name="ln966">    if (op == OP_ADDING || op == OP_PREPENDING) {</a>
<a name="ln967">      comma = ((flags &amp; P_COMMA) &amp;&amp; *origval != NUL &amp;&amp; *newval != NUL);</a>
<a name="ln968">      if (op == OP_ADDING) {</a>
<a name="ln969">        len = (int)STRLEN(origval);</a>
<a name="ln970">        // Strip a trailing comma, would get 2.</a>
<a name="ln971">        if (comma &amp;&amp; len &gt; 1</a>
<a name="ln972">            &amp;&amp; (flags &amp; P_ONECOMMA) == P_ONECOMMA</a>
<a name="ln973">            &amp;&amp; origval[len - 1] == ','</a>
<a name="ln974">            &amp;&amp; origval[len - 2] != '\\') {</a>
<a name="ln975">          len--;</a>
<a name="ln976">        }</a>
<a name="ln977">        memmove(newval + len + comma, newval, strlen(newval) + 1);</a>
<a name="ln978">        memmove(newval, origval, (size_t)len);</a>
<a name="ln979">      } else {</a>
<a name="ln980">        len = (int)strlen(newval);</a>
<a name="ln981">        STRMOVE(newval + len + comma, origval);</a>
<a name="ln982">      }</a>
<a name="ln983">      if (comma) {</a>
<a name="ln984">        newval[len] = ',';</a>
<a name="ln985">      }</a>
<a name="ln986">    }</a>
<a name="ln987"> </a>
<a name="ln988">    // Remove newval[] from origval[]. (Note: &quot;len&quot; has been set above and</a>
<a name="ln989">    // is used here).</a>
<a name="ln990">    if (op == OP_REMOVING) {</a>
<a name="ln991">      STRCPY(newval, origval);</a>
<a name="ln992">      if (*s) {</a>
<a name="ln993">        // may need to remove a comma</a>
<a name="ln994">        if (flags &amp; P_COMMA) {</a>
<a name="ln995">          if (s == (char *)origval) {</a>
<a name="ln996">            // include comma after string</a>
<a name="ln997">            if (s[len] == ',') {</a>
<a name="ln998">              len++;</a>
<a name="ln999">            }</a>
<a name="ln1000">          } else {</a>
<a name="ln1001">            // include comma before string</a>
<a name="ln1002">            s--;</a>
<a name="ln1003">            len++;</a>
<a name="ln1004">          }</a>
<a name="ln1005">        }</a>
<a name="ln1006">        STRMOVE(newval + (s - (char *)origval), s + len);</a>
<a name="ln1007">      }</a>
<a name="ln1008">    }</a>
<a name="ln1009"> </a>
<a name="ln1010">    if (flags &amp; P_FLAGLIST) {</a>
<a name="ln1011">      // Remove flags that appear twice.</a>
<a name="ln1012">      for (s = newval; *s;) {</a>
<a name="ln1013">        // if options have P_FLAGLIST and P_ONECOMMA such as</a>
<a name="ln1014">        // 'whichwrap'</a>
<a name="ln1015">        if (flags &amp; P_ONECOMMA) {</a>
<a name="ln1016">          if (*s != ',' &amp;&amp; *(s + 1) == ','</a>
<a name="ln1017">              &amp;&amp; vim_strchr(s + 2, *s) != NULL) {</a>
<a name="ln1018">            // Remove the duplicated value and the next comma.</a>
<a name="ln1019">            STRMOVE(s, s + 2);</a>
<a name="ln1020">            continue;</a>
<a name="ln1021">          }</a>
<a name="ln1022">        } else {</a>
<a name="ln1023">          if ((!(flags &amp; P_COMMA) || *s != ',')</a>
<a name="ln1024">              &amp;&amp; vim_strchr(s + 1, *s) != NULL) {</a>
<a name="ln1025">            STRMOVE(s, s + 1);</a>
<a name="ln1026">            continue;</a>
<a name="ln1027">          }</a>
<a name="ln1028">        }</a>
<a name="ln1029">        s++;</a>
<a name="ln1030">      }</a>
<a name="ln1031">    }</a>
<a name="ln1032"> </a>
<a name="ln1033">    if (save_arg != NULL) {</a>
<a name="ln1034">      arg = save_arg;  // arg was temporarily changed, restore it</a>
<a name="ln1035">    }</a>
<a name="ln1036">  }</a>
<a name="ln1037"> </a>
<a name="ln1038">  // Set the new value.</a>
<a name="ln1039">  *(char_u **)(varp) = (char_u *)newval;</a>
<a name="ln1040"> </a>
<a name="ln1041">  // origval may be freed by did_set_string_option(), make a copy.</a>
<a name="ln1042">  saved_origval = (origval != NULL) ? xstrdup((char *)origval) : NULL;</a>
<a name="ln1043">  saved_origval_l = (origval_l != NULL) ? xstrdup((char *)origval_l) : NULL;</a>
<a name="ln1044">  saved_origval_g = (origval_g != NULL) ? xstrdup((char *)origval_g) : NULL;</a>
<a name="ln1045"> </a>
<a name="ln1046">  // newval (and varp) may become invalid if the buffer is closed by</a>
<a name="ln1047">  // autocommands.</a>
<a name="ln1048">  saved_newval = (newval != NULL) ? xstrdup(newval) : NULL;</a>
<a name="ln1049"> </a>
<a name="ln1050">  {</a>
<a name="ln1051">    uint32_t *p = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln1052">    const int secure_saved = secure;</a>
<a name="ln1053"> </a>
<a name="ln1054">    // When an option is set in the sandbox, from a modeline or in secure</a>
<a name="ln1055">    // mode, then deal with side effects in secure mode.  Also when the</a>
<a name="ln1056">    // value was set with the P_INSECURE flag and is not completely</a>
<a name="ln1057">    // replaced.</a>
<a name="ln1058">    if ((opt_flags &amp; OPT_MODELINE)</a>
<a name="ln1059">        || sandbox != 0</a>
<a name="ln1060">        || (op != OP_NONE &amp;&amp; (*p &amp; P_INSECURE))) {</a>
<a name="ln1061">      secure = 1;</a>
<a name="ln1062">    }</a>
<a name="ln1063"> </a>
<a name="ln1064">    // Handle side effects, and set the global value for &quot;:set&quot; on local</a>
<a name="ln1065">    // options. Note: when setting 'syntax' or 'filetype' autocommands may</a>
<a name="ln1066">    // be triggered that can cause havoc.</a>
<a name="ln1067">    *errmsg = did_set_string_option(opt_idx, (char **)varp, (char *)oldval,</a>
<a name="ln1068">                                    errbuf, errbuflen,</a>
<a name="ln1069">                                    opt_flags, value_checked);</a>
<a name="ln1070"> </a>
<a name="ln1071">    secure = secure_saved;</a>
<a name="ln1072">  }</a>
<a name="ln1073"> </a>
<a name="ln1074">  if (*errmsg == NULL) {</a>
<a name="ln1075">    if (!starting) {</a>
<a name="ln1076">      trigger_optionsset_string(opt_idx, opt_flags, saved_origval, saved_origval_l,</a>
<a name="ln1077">                                saved_origval_g, saved_newval);</a>
<a name="ln1078">    }</a>
<a name="ln1079">    if (options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln1080">      ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln1081">                         STRING_OBJ(cstr_as_string(saved_newval)));</a>
<a name="ln1082">    }</a>
<a name="ln1083">  }</a>
<a name="ln1084">  xfree(saved_origval);</a>
<a name="ln1085">  xfree(saved_origval_l);</a>
<a name="ln1086">  xfree(saved_origval_g);</a>
<a name="ln1087">  xfree(saved_newval);</a>
<a name="ln1088"> </a>
<a name="ln1089">  *argp = arg;</a>
<a name="ln1090">  return *errmsg == NULL ? OK : FAIL;</a>
<a name="ln1091">}</a>
<a name="ln1092"> </a>
<a name="ln1093">/// Parse 'arg' for option settings.</a>
<a name="ln1094">///</a>
<a name="ln1095">/// 'arg' may be IObuff, but only when no errors can be present and option</a>
<a name="ln1096">/// does not need to be expanded with option_expand().</a>
<a name="ln1097">/// &quot;opt_flags&quot;:</a>
<a name="ln1098">/// 0 for &quot;:set&quot;</a>
<a name="ln1099">/// OPT_GLOBAL   for &quot;:setglobal&quot;</a>
<a name="ln1100">/// OPT_LOCAL    for &quot;:setlocal&quot; and a modeline</a>
<a name="ln1101">/// OPT_MODELINE for a modeline</a>
<a name="ln1102">/// OPT_WINONLY  to only set window-local options</a>
<a name="ln1103">/// OPT_NOWIN    to skip setting window-local options</a>
<a name="ln1104">///</a>
<a name="ln1105">/// @param arg  option string (may be written to!)</a>
<a name="ln1106">///</a>
<a name="ln1107">/// @return  FAIL if an error is detected, OK otherwise</a>
<a name="ln1108">int do_set(char *arg, int opt_flags)</a>
<a name="ln1109">{</a>
<a name="ln1110">  int opt_idx;</a>
<a name="ln1111">  char *errmsg;</a>
<a name="ln1112">  char errbuf[80];</a>
<a name="ln1113">  char *startarg;</a>
<a name="ln1114">  int prefix;           // 1: nothing, 0: &quot;no&quot;, 2: &quot;inv&quot; in front of name</a>
<a name="ln1115">  char_u nextchar;                  // next non-white char after option name</a>
<a name="ln1116">  int afterchar;                    // character just after option name</a>
<a name="ln1117">  int len;</a>
<a name="ln1118">  int i;</a>
<a name="ln1119">  varnumber_T value;</a>
<a name="ln1120">  int key;</a>
<a name="ln1121">  uint32_t flags;                   // flags for current option</a>
<a name="ln1122">  char *varp = NULL;                // pointer to variable for current option</a>
<a name="ln1123">  int did_show = false;             // already showed one value</a>
<a name="ln1124">  set_op_T op = 0;</a>
<a name="ln1125"> </a>
<a name="ln1126">  if (*arg == NUL) {</a>
<a name="ln1127">    showoptions(0, opt_flags);</a>
<a name="ln1128">    did_show = true;</a>
<a name="ln1129">    goto theend;</a>
<a name="ln1130">  }</a>
<a name="ln1131"> </a>
<a name="ln1132">  while (*arg != NUL) {         // loop to process all options</a>
<a name="ln1133">    errmsg = NULL;</a>
<a name="ln1134">    startarg = arg;             // remember for error message</a>
<a name="ln1135"> </a>
<a name="ln1136">    if (STRNCMP(arg, &quot;all&quot;, 3) == 0 &amp;&amp; !isalpha(arg[3])</a>
<a name="ln1137">        &amp;&amp; !(opt_flags &amp; OPT_MODELINE)) {</a>
<a name="ln1138">      // &quot;:set all&quot;  show all options.</a>
<a name="ln1139">      // &quot;:set all&amp;&quot; set all options to their default value.</a>
<a name="ln1140">      arg += 3;</a>
<a name="ln1141">      if (*arg == '&amp;') {</a>
<a name="ln1142">        arg++;</a>
<a name="ln1143">        // Only for :set command set global value of local options.</a>
<a name="ln1144">        set_options_default(OPT_FREE | opt_flags);</a>
<a name="ln1145">        didset_options();</a>
<a name="ln1146">        didset_options2();</a>
<a name="ln1147">        ui_refresh_options();</a>
<a name="ln1148">        redraw_all_later(UPD_CLEAR);</a>
<a name="ln1149">      } else {</a>
<a name="ln1150">        showoptions(1, opt_flags);</a>
<a name="ln1151">        did_show = true;</a>
<a name="ln1152">      }</a>
<a name="ln1153">    } else {</a>
<a name="ln1154">      prefix = 1;</a>
<a name="ln1155">      if (STRNCMP(arg, &quot;no&quot;, 2) == 0) {</a>
<a name="ln1156">        prefix = 0;</a>
<a name="ln1157">        arg += 2;</a>
<a name="ln1158">      } else if (STRNCMP(arg, &quot;inv&quot;, 3) == 0) {</a>
<a name="ln1159">        prefix = 2;</a>
<a name="ln1160">        arg += 3;</a>
<a name="ln1161">      }</a>
<a name="ln1162"> </a>
<a name="ln1163">      // find end of name</a>
<a name="ln1164">      key = 0;</a>
<a name="ln1165">      if (*arg == '&lt;') {</a>
<a name="ln1166">        opt_idx = -1;</a>
<a name="ln1167">        // look out for &lt;t_&gt;;&gt;</a>
<a name="ln1168">        if (arg[1] == 't' &amp;&amp; arg[2] == '_' &amp;&amp; arg[3] &amp;&amp; arg[4]) {</a>
<a name="ln1169">          len = 5;</a>
<a name="ln1170">        } else {</a>
<a name="ln1171">          len = 1;</a>
<a name="ln1172">          while (arg[len] != NUL &amp;&amp; arg[len] != '&gt;') {</a>
<a name="ln1173">            len++;</a>
<a name="ln1174">          }</a>
<a name="ln1175">        }</a>
<a name="ln1176">        if (arg[len] != '&gt;') {</a>
<a name="ln1177">          errmsg = e_invarg;</a>
<a name="ln1178">          goto skip;</a>
<a name="ln1179">        }</a>
<a name="ln1180">        if (arg[1] == 't' &amp;&amp; arg[2] == '_') {  // could be term code</a>
<a name="ln1181">          opt_idx = findoption_len((const char *)arg + 1, (size_t)(len - 1));</a>
<a name="ln1182">        }</a>
<a name="ln1183">        len++;</a>
<a name="ln1184">        if (opt_idx == -1) {</a>
<a name="ln1185">          key = find_key_option(arg + 1, true);</a>
<a name="ln1186">        }</a>
<a name="ln1187">      } else {</a>
<a name="ln1188">        len = 0;</a>
<a name="ln1189">        // The two characters after &quot;t_&quot; may not be alphanumeric.</a>
<a name="ln1190">        if (arg[0] == 't' &amp;&amp; arg[1] == '_' &amp;&amp; arg[2] &amp;&amp; arg[3]) {</a>
<a name="ln1191">          len = 4;</a>
<a name="ln1192">        } else {</a>
<a name="ln1193">          while (ASCII_ISALNUM(arg[len]) || arg[len] == '_') {</a>
<a name="ln1194">            len++;</a>
<a name="ln1195">          }</a>
<a name="ln1196">        }</a>
<a name="ln1197">        opt_idx = findoption_len((const char *)arg, (size_t)len);</a>
<a name="ln1198">        if (opt_idx == -1) {</a>
<a name="ln1199">          key = find_key_option(arg, false);</a>
<a name="ln1200">        }</a>
<a name="ln1201">      }</a>
<a name="ln1202"> </a>
<a name="ln1203">      // remember character after option name</a>
<a name="ln1204">      afterchar = (uint8_t)arg[len];</a>
<a name="ln1205"> </a>
<a name="ln1206">      // skip white space, allow &quot;:set ai  ?&quot;</a>
<a name="ln1207">      while (ascii_iswhite(arg[len])) {</a>
<a name="ln1208">        len++;</a>
<a name="ln1209">      }</a>
<a name="ln1210"> </a>
<a name="ln1211">      op = OP_NONE;</a>
<a name="ln1212">      if (arg[len] != NUL &amp;&amp; arg[len + 1] == '=') {</a>
<a name="ln1213">        if (arg[len] == '+') {</a>
<a name="ln1214">          op = OP_ADDING;                       // &quot;+=&quot;</a>
<a name="ln1215">          len++;</a>
<a name="ln1216">        } else if (arg[len] == '^') {</a>
<a name="ln1217">          op = OP_PREPENDING;                   // &quot;^=&quot;</a>
<a name="ln1218">          len++;</a>
<a name="ln1219">        } else if (arg[len] == '-') {</a>
<a name="ln1220">          op = OP_REMOVING;                     // &quot;-=&quot;</a>
<a name="ln1221">          len++;</a>
<a name="ln1222">        }</a>
<a name="ln1223">      }</a>
<a name="ln1224">      nextchar = (uint8_t)arg[len];</a>
<a name="ln1225"> </a>
<a name="ln1226">      if (opt_idx == -1 &amp;&amp; key == 0) {          // found a mismatch: skip</a>
<a name="ln1227">        errmsg = e_unknown_option;</a>
<a name="ln1228">        goto skip;</a>
<a name="ln1229">      }</a>
<a name="ln1230"> </a>
<a name="ln1231">      if (opt_idx &gt;= 0) {</a>
<a name="ln1232">        if (options[opt_idx].var == NULL) {         // hidden option: skip</a>
<a name="ln1233">          // Only give an error message when requesting the value of</a>
<a name="ln1234">          // a hidden option, ignore setting it.</a>
<a name="ln1235">          if (vim_strchr(&quot;=:!&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1236">              &amp;&amp; (!(options[opt_idx].flags &amp; P_BOOL)</a>
<a name="ln1237">                  || nextchar == '?')) {</a>
<a name="ln1238">            errmsg = e_unsupportedoption;</a>
<a name="ln1239">          }</a>
<a name="ln1240">          goto skip;</a>
<a name="ln1241">        }</a>
<a name="ln1242"> </a>
<a name="ln1243">        flags = options[opt_idx].flags;</a>
<a name="ln1244">        varp = get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln1245">      } else {</a>
<a name="ln1246">        flags = P_STRING;</a>
<a name="ln1247">      }</a>
<a name="ln1248"> </a>
<a name="ln1249">      // Skip all options that are not window-local (used when showing</a>
<a name="ln1250">      // an already loaded buffer in a window).</a>
<a name="ln1251">      if ((opt_flags &amp; OPT_WINONLY)</a>
<a name="ln1252">          &amp;&amp; (opt_idx &lt; 0 || options[opt_idx].var != VAR_WIN)) {</a>
<a name="ln1253">        goto skip;</a>
<a name="ln1254">      }</a>
<a name="ln1255"> </a>
<a name="ln1256">      // Skip all options that are window-local (used for :vimgrep).</a>
<a name="ln1257">      if ((opt_flags &amp; OPT_NOWIN) &amp;&amp; opt_idx &gt;= 0</a>
<a name="ln1258">          &amp;&amp; options[opt_idx].var == VAR_WIN) {</a>
<a name="ln1259">        goto skip;</a>
<a name="ln1260">      }</a>
<a name="ln1261"> </a>
<a name="ln1262">      // Disallow changing some options from modelines.</a>
<a name="ln1263">      if (opt_flags &amp; OPT_MODELINE) {</a>
<a name="ln1264">        if (flags &amp; (P_SECURE | P_NO_ML)) {</a>
<a name="ln1265">          errmsg = e_not_allowed_in_modeline;</a>
<a name="ln1266">          goto skip;</a>
<a name="ln1267">        }</a>
<a name="ln1268">        if ((flags &amp; P_MLE) &amp;&amp; !p_mle) {</a>
<a name="ln1269">          errmsg = e_not_allowed_in_modeline_when_modelineexpr_is_off;</a>
<a name="ln1270">          goto skip;</a>
<a name="ln1271">        }</a>
<a name="ln1272">        // In diff mode some options are overruled.  This avoids that</a>
<a name="ln1273">        // 'foldmethod' becomes &quot;marker&quot; instead of &quot;diff&quot; and that</a>
<a name="ln1274">        // &quot;wrap&quot; gets set.</a>
<a name="ln1275">        if (curwin-&gt;w_p_diff</a>
<a name="ln1276">            &amp;&amp; opt_idx &gt;= 0              // shut up coverity warning</a>
<a name="ln1277">            &amp;&amp; (options[opt_idx].indir == PV_FDM</a>
<a name="ln1278">                || options[opt_idx].indir == PV_WRAP)) {</a>
<a name="ln1279">          goto skip;</a>
<a name="ln1280">        }</a>
<a name="ln1281">      }</a>
<a name="ln1282"> </a>
<a name="ln1283">      // Disallow changing some options in the sandbox</a>
<a name="ln1284">      if (sandbox != 0 &amp;&amp; (flags &amp; P_SECURE)) {</a>
<a name="ln1285">        errmsg = e_sandbox;</a>
<a name="ln1286">        goto skip;</a>
<a name="ln1287">      }</a>
<a name="ln1288"> </a>
<a name="ln1289">      if (vim_strchr(&quot;?=:!&amp;&lt;&quot;, nextchar) != NULL) {</a>
<a name="ln1290">        arg += len;</a>
<a name="ln1291">        if (nextchar == '&amp;' &amp;&amp; arg[1] == 'v' &amp;&amp; arg[2] == 'i') {</a>
<a name="ln1292">          if (arg[3] == 'm') {  // &quot;opt&amp;vim&quot;: set to Vim default</a>
<a name="ln1293">            arg += 3;</a>
<a name="ln1294">          } else {  // &quot;opt&amp;vi&quot;: set to Vi default</a>
<a name="ln1295">            arg += 2;</a>
<a name="ln1296">          }</a>
<a name="ln1297">        }</a>
<a name="ln1298">        if (vim_strchr(&quot;?!&amp;&lt;&quot;, nextchar) != NULL</a>
<a name="ln1299">            &amp;&amp; arg[1] != NUL &amp;&amp; !ascii_iswhite(arg[1])) {</a>
<a name="ln1300">          errmsg = e_trailing;</a>
<a name="ln1301">          goto skip;</a>
<a name="ln1302">        }</a>
<a name="ln1303">      }</a>
<a name="ln1304"> </a>
<a name="ln1305">      //</a>
<a name="ln1306">      // allow '=' and ':' as MS-DOS command.com allows only one</a>
<a name="ln1307">      // '=' character per &quot;set&quot; command line. grrr. (jw)</a>
<a name="ln1308">      //</a>
<a name="ln1309">      if (nextchar == '?'</a>
<a name="ln1310">          || (prefix == 1</a>
<a name="ln1311">              &amp;&amp; vim_strchr(&quot;=:&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1312">              &amp;&amp; !(flags &amp; P_BOOL))) {</a>
<a name="ln1313">        // print value</a>
<a name="ln1314">        if (did_show) {</a>
<a name="ln1315">          msg_putchar('\n');                // cursor below last one</a>
<a name="ln1316">        } else {</a>
<a name="ln1317">          gotocmdline(true);                // cursor at status line</a>
<a name="ln1318">          did_show = true;                  // remember that we did a line</a>
<a name="ln1319">        }</a>
<a name="ln1320">        if (opt_idx &gt;= 0) {</a>
<a name="ln1321">          showoneopt(&amp;options[opt_idx], opt_flags);</a>
<a name="ln1322">          if (p_verbose &gt; 0) {</a>
<a name="ln1323">            // Mention where the option was last set.</a>
<a name="ln1324">            if (varp == (char *)options[opt_idx].var) {</a>
<a name="ln1325">              option_last_set_msg(options[opt_idx].last_set);</a>
<a name="ln1326">            } else if ((int)options[opt_idx].indir &amp; PV_WIN) {</a>
<a name="ln1327">              option_last_set_msg(curwin-&gt;w_p_script_ctx[</a>
<a name="ln1328">                                                         (int)options[opt_idx].indir &amp; PV_MASK]);</a>
<a name="ln1329">            } else if ((int)options[opt_idx].indir &amp; PV_BUF) {</a>
<a name="ln1330">              option_last_set_msg(curbuf-&gt;b_p_script_ctx[</a>
<a name="ln1331">                                                         (int)options[opt_idx].indir &amp; PV_MASK]);</a>
<a name="ln1332">            }</a>
<a name="ln1333">          }</a>
<a name="ln1334">        } else {</a>
<a name="ln1335">          errmsg = e_key_code_not_set;</a>
<a name="ln1336">          goto skip;</a>
<a name="ln1337">        }</a>
<a name="ln1338">        if (nextchar != '?'</a>
<a name="ln1339">            &amp;&amp; nextchar != NUL &amp;&amp; !ascii_iswhite(afterchar)) {</a>
<a name="ln1340">          errmsg = e_trailing;</a>
<a name="ln1341">        }</a>
<a name="ln1342">      } else {</a>
<a name="ln1343">        int value_checked = false;</a>
<a name="ln1344"> </a>
<a name="ln1345">        if (flags &amp; P_BOOL) {                       // boolean</a>
<a name="ln1346">          if (nextchar == '=' || nextchar == ':') {</a>
<a name="ln1347">            errmsg = e_invarg;</a>
<a name="ln1348">            goto skip;</a>
<a name="ln1349">          }</a>
<a name="ln1350"> </a>
<a name="ln1351">          // &quot;:set opt!&quot;: invert</a>
<a name="ln1352">          // &quot;:set opt&amp;&quot;: reset to default value</a>
<a name="ln1353">          // &quot;:set opt&lt;&quot;: reset to global value</a>
<a name="ln1354">          if (nextchar == '!') {</a>
<a name="ln1355">            value = *(int *)(varp) ^ 1;</a>
<a name="ln1356">          } else if (nextchar == '&amp;') {</a>
<a name="ln1357">            value = (int)(intptr_t)options[opt_idx].def_val;</a>
<a name="ln1358">          } else if (nextchar == '&lt;') {</a>
<a name="ln1359">            // For 'autoread' -1 means to use global value.</a>
<a name="ln1360">            if ((int *)varp == &amp;curbuf-&gt;b_p_ar</a>
<a name="ln1361">                &amp;&amp; opt_flags == OPT_LOCAL) {</a>
<a name="ln1362">              value = -1;</a>
<a name="ln1363">            } else {</a>
<a name="ln1364">              value = *(int *)get_varp_scope(&amp;(options[opt_idx]),</a>
<a name="ln1365">                                             OPT_GLOBAL);</a>
<a name="ln1366">            }</a>
<a name="ln1367">          } else {</a>
<a name="ln1368">            // &quot;:set invopt&quot;: invert</a>
<a name="ln1369">            // &quot;:set opt&quot; or &quot;:set noopt&quot;: set or reset</a>
<a name="ln1370">            if (nextchar != NUL &amp;&amp; !ascii_iswhite(afterchar)) {</a>
<a name="ln1371">              errmsg = e_trailing;</a>
<a name="ln1372">              goto skip;</a>
<a name="ln1373">            }</a>
<a name="ln1374">            if (prefix == 2) {                  // inv</a>
<a name="ln1375">              value = *(int *)(varp) ^ 1;</a>
<a name="ln1376">            } else {</a>
<a name="ln1377">              value = prefix;</a>
<a name="ln1378">            }</a>
<a name="ln1379">          }</a>
<a name="ln1380"> </a>
<a name="ln1381">          errmsg = set_bool_option(opt_idx, (char_u *)varp, (int)value, opt_flags);</a>
<a name="ln1382">        } else {  // Numeric or string.</a>
<a name="ln1383">          if (vim_strchr(&quot;=:&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1384">              || prefix != 1) {</a>
<a name="ln1385">            errmsg = e_invarg;</a>
<a name="ln1386">            goto skip;</a>
<a name="ln1387">          }</a>
<a name="ln1388"> </a>
<a name="ln1389">          if (flags &amp; P_NUM) {                      // numeric</a>
<a name="ln1390">            // Different ways to set a number option:</a>
<a name="ln1391">            // &amp;            set to default value</a>
<a name="ln1392">            // &lt;            set to global value</a>
<a name="ln1393">            // &lt;xx&gt;         accept special key codes for 'wildchar'</a>
<a name="ln1394">            // c            accept any non-digit for 'wildchar'</a>
<a name="ln1395">            // [-]0-9       set number</a>
<a name="ln1396">            // other        error</a>
<a name="ln1397">            arg++;</a>
<a name="ln1398">            if (nextchar == '&amp;') {</a>
<a name="ln1399">              value = (long)(intptr_t)options[opt_idx].def_val;</a>
<a name="ln1400">            } else if (nextchar == '&lt;') {</a>
<a name="ln1401">              // For 'undolevels' NO_LOCAL_UNDOLEVEL means to</a>
<a name="ln1402">              // use the global value.</a>
<a name="ln1403">              if ((long *)varp == &amp;curbuf-&gt;b_p_ul &amp;&amp; opt_flags == OPT_LOCAL) {</a>
<a name="ln1404">                value = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln1405">              } else {</a>
<a name="ln1406">                value = *(long *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln1407">              }</a>
<a name="ln1408">            } else if (((long *)varp == &amp;p_wc</a>
<a name="ln1409">                        || (long *)varp == &amp;p_wcm)</a>
<a name="ln1410">                       &amp;&amp; (*arg == '&lt;'</a>
<a name="ln1411">                           || *arg == '^'</a>
<a name="ln1412">                           || (*arg != NUL &amp;&amp; (!arg[1] || ascii_iswhite(arg[1]))</a>
<a name="ln1413">                               &amp;&amp; !ascii_isdigit(*arg)))) {</a>
<a name="ln1414">              value = string_to_key((char_u *)arg);</a>
<a name="ln1415">              if (value == 0 &amp;&amp; (long *)varp != &amp;p_wcm) {</a>
<a name="ln1416">                errmsg = e_invarg;</a>
<a name="ln1417">                goto skip;</a>
<a name="ln1418">              }</a>
<a name="ln1419">            } else if (*arg == '-' || ascii_isdigit(*arg)) {</a>
<a name="ln1420">              // Allow negative, octal and hex numbers.</a>
<a name="ln1421">              vim_str2nr(arg, NULL, &amp;i, STR2NR_ALL, &amp;value, NULL, 0, true);</a>
<a name="ln1422">              if (i == 0 || (arg[i] != NUL &amp;&amp; !ascii_iswhite(arg[i]))) {</a>
<a name="ln1423">                errmsg = e_number_required_after_equal;</a>
<a name="ln1424">                goto skip;</a>
<a name="ln1425">              }</a>
<a name="ln1426">            } else {</a>
<a name="ln1427">              errmsg = e_number_required_after_equal;</a>
<a name="ln1428">              goto skip;</a>
<a name="ln1429">            }</a>
<a name="ln1430"> </a>
<a name="ln1431">            if (op == OP_ADDING) {</a>
<a name="ln1432">              value = *(long *)varp + value;</a>
<a name="ln1433">            }</a>
<a name="ln1434">            if (op == OP_PREPENDING) {</a>
<a name="ln1435">              value = *(long *)varp * value;</a>
<a name="ln1436">            }</a>
<a name="ln1437">            if (op == OP_REMOVING) {</a>
<a name="ln1438">              value = *(long *)varp - value;</a>
<a name="ln1439">            }</a>
<a name="ln1440">            errmsg = set_num_option(opt_idx, (char_u *)varp, (long)value,</a>
<a name="ln1441">                                    errbuf, sizeof(errbuf),</a>
<a name="ln1442">                                    opt_flags);</a>
<a name="ln1443">          } else if (opt_idx &gt;= 0) {  // String.</a>
<a name="ln1444">            if (do_set_string(opt_idx, opt_flags, &amp;arg, nextchar,</a>
<a name="ln1445">                              op, flags, varp, errbuf, sizeof(errbuf),</a>
<a name="ln1446">                              &amp;value_checked, &amp;errmsg) == FAIL) {</a>
<a name="ln1447">              if (errmsg != NULL) {</a>
<a name="ln1448">                goto skip;</a>
<a name="ln1449">              }</a>
<a name="ln1450">              break;</a>
<a name="ln1451">            }</a>
<a name="ln1452">          } else {</a>
<a name="ln1453">            // key code option(FIXME(tarruda): Show a warning or something</a>
<a name="ln1454">            // similar)</a>
<a name="ln1455">          }</a>
<a name="ln1456">        }</a>
<a name="ln1457"> </a>
<a name="ln1458">        if (opt_idx &gt;= 0) {</a>
<a name="ln1459">          did_set_option(opt_idx, opt_flags, op == OP_NONE, value_checked);</a>
<a name="ln1460">        }</a>
<a name="ln1461">      }</a>
<a name="ln1462"> </a>
<a name="ln1463">skip:</a>
<a name="ln1464">      // Advance to next argument.</a>
<a name="ln1465">      // - skip until a blank found, taking care of backslashes</a>
<a name="ln1466">      // - skip blanks</a>
<a name="ln1467">      // - skip one &quot;=val&quot; argument (for hidden options &quot;:set gfn =xx&quot;)</a>
<a name="ln1468">      for (i = 0; i &lt; 2; i++) {</a>
<a name="ln1469">        while (*arg != NUL &amp;&amp; !ascii_iswhite(*arg)) {</a>
<a name="ln1470">          if (*arg++ == '\\' &amp;&amp; *arg != NUL) {</a>
<a name="ln1471">            arg++;</a>
<a name="ln1472">          }</a>
<a name="ln1473">        }</a>
<a name="ln1474">        arg = skipwhite(arg);</a>
<a name="ln1475">        if (*arg != '=') {</a>
<a name="ln1476">          break;</a>
<a name="ln1477">        }</a>
<a name="ln1478">      }</a>
<a name="ln1479">    }</a>
<a name="ln1480"> </a>
<a name="ln1481">    if (errmsg != NULL) {</a>
<a name="ln1482">      STRLCPY(IObuff, _(errmsg), IOSIZE);</a>
<a name="ln1483">      i = (int)strlen(IObuff) + 2;</a>
<a name="ln1484">      if (i + (arg - startarg) &lt; IOSIZE) {</a>
<a name="ln1485">        // append the argument with the error</a>
<a name="ln1486">        STRCAT(IObuff, &quot;: &quot;);</a>
<a name="ln1487">        assert(arg &gt;= startarg);</a>
<a name="ln1488">        memmove(IObuff + i, startarg, (size_t)(arg - startarg));</a>
<a name="ln1489">        IObuff[i + (arg - startarg)] = NUL;</a>
<a name="ln1490">      }</a>
<a name="ln1491">      // make sure all characters are printable</a>
<a name="ln1492">      trans_characters((char *)IObuff, IOSIZE);</a>
<a name="ln1493"> </a>
<a name="ln1494">      no_wait_return++;         // wait_return() done later</a>
<a name="ln1495">      emsg((char *)IObuff);     // show error highlighted</a>
<a name="ln1496">      no_wait_return--;</a>
<a name="ln1497"> </a>
<a name="ln1498">      return FAIL;</a>
<a name="ln1499">    }</a>
<a name="ln1500"> </a>
<a name="ln1501">    arg = skipwhite(arg);</a>
<a name="ln1502">  }</a>
<a name="ln1503"> </a>
<a name="ln1504">theend:</a>
<a name="ln1505">  if (silent_mode &amp;&amp; did_show) {</a>
<a name="ln1506">    // After displaying option values in silent mode.</a>
<a name="ln1507">    silent_mode = false;</a>
<a name="ln1508">    info_message = true;        // use mch_msg(), not mch_errmsg()</a>
<a name="ln1509">    msg_putchar('\n');</a>
<a name="ln1510">    ui_flush();</a>
<a name="ln1511">    silent_mode = true;</a>
<a name="ln1512">    info_message = false;       // use mch_msg(), not mch_errmsg()</a>
<a name="ln1513">  }</a>
<a name="ln1514"> </a>
<a name="ln1515">  return OK;</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518">/// Call this when an option has been given a new value through a user command.</a>
<a name="ln1519">/// Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.</a>
<a name="ln1520">///</a>
<a name="ln1521">/// @param opt_flags  possibly with OPT_MODELINE</a>
<a name="ln1522">/// @param new_value  value was replaced completely</a>
<a name="ln1523">/// @param value_checked  value was checked to be safe, no need to set P_INSECURE</a>
<a name="ln1524">void did_set_option(int opt_idx, int opt_flags, int new_value, int value_checked)</a>
<a name="ln1525">{</a>
<a name="ln1526">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln1527"> </a>
<a name="ln1528">  // When an option is set in the sandbox, from a modeline or in secure mode</a>
<a name="ln1529">  // set the P_INSECURE flag.  Otherwise, if a new value is stored reset the</a>
<a name="ln1530">  // flag.</a>
<a name="ln1531">  uint32_t *p = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln1532">  if (!value_checked &amp;&amp; (secure</a>
<a name="ln1533">                         || sandbox != 0</a>
<a name="ln1534">                         || (opt_flags &amp; OPT_MODELINE))) {</a>
<a name="ln1535">    *p = *p | P_INSECURE;</a>
<a name="ln1536">  } else if (new_value) {</a>
<a name="ln1537">    *p = *p &amp; ~P_INSECURE;</a>
<a name="ln1538">  }</a>
<a name="ln1539">}</a>
<a name="ln1540"> </a>
<a name="ln1541">/// Convert a key name or string into a key value.</a>
<a name="ln1542">/// Used for 'wildchar' and 'cedit' options.</a>
<a name="ln1543">int string_to_key(char_u *arg)</a>
<a name="ln1544">{</a>
<a name="ln1545">  if (*arg == '&lt;') {</a>
<a name="ln1546">    return find_key_option((char *)arg + 1, true);</a>
<a name="ln1547">  }</a>
<a name="ln1548">  if (*arg == '^') {</a>
<a name="ln1549">    return CTRL_CHR(arg[1]);</a>
<a name="ln1550">  }</a>
<a name="ln1551">  return *arg;</a>
<a name="ln1552">}</a>
<a name="ln1553"> </a>
<a name="ln1554">// When changing 'title', 'titlestring', 'icon' or 'iconstring', call</a>
<a name="ln1555">// maketitle() to create and display it.</a>
<a name="ln1556">// When switching the title or icon off, call ui_set_{icon,title}(NULL) to get</a>
<a name="ln1557">// the old value back.</a>
<a name="ln1558">void did_set_title(void)</a>
<a name="ln1559">{</a>
<a name="ln1560">  if (starting != NO_SCREEN) {</a>
<a name="ln1561">    maketitle();</a>
<a name="ln1562">  }</a>
<a name="ln1563">}</a>
<a name="ln1564"> </a>
<a name="ln1565">/// set_options_bin -  called when 'bin' changes value.</a>
<a name="ln1566">///</a>
<a name="ln1567">/// @param opt_flags  OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln1568">void set_options_bin(int oldval, int newval, int opt_flags)</a>
<a name="ln1569">{</a>
<a name="ln1570">  // The option values that are changed when 'bin' changes are</a>
<a name="ln1571">  // copied when 'bin is set and restored when 'bin' is reset.</a>
<a name="ln1572">  if (newval) {</a>
<a name="ln1573">    if (!oldval) {              // switched on</a>
<a name="ln1574">      if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1575">        curbuf-&gt;b_p_tw_nobin = curbuf-&gt;b_p_tw;</a>
<a name="ln1576">        curbuf-&gt;b_p_wm_nobin = curbuf-&gt;b_p_wm;</a>
<a name="ln1577">        curbuf-&gt;b_p_ml_nobin = curbuf-&gt;b_p_ml;</a>
<a name="ln1578">        curbuf-&gt;b_p_et_nobin = curbuf-&gt;b_p_et;</a>
<a name="ln1579">      }</a>
<a name="ln1580">      if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1581">        p_tw_nobin = p_tw;</a>
<a name="ln1582">        p_wm_nobin = p_wm;</a>
<a name="ln1583">        p_ml_nobin = p_ml;</a>
<a name="ln1584">        p_et_nobin = p_et;</a>
<a name="ln1585">      }</a>
<a name="ln1586">    }</a>
<a name="ln1587"> </a>
<a name="ln1588">    if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1589">      curbuf-&gt;b_p_tw = 0;       // no automatic line wrap</a>
<a name="ln1590">      curbuf-&gt;b_p_wm = 0;       // no automatic line wrap</a>
<a name="ln1591">      curbuf-&gt;b_p_ml = 0;       // no modelines</a>
<a name="ln1592">      curbuf-&gt;b_p_et = 0;       // no expandtab</a>
<a name="ln1593">    }</a>
<a name="ln1594">    if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1595">      p_tw = 0;</a>
<a name="ln1596">      p_wm = 0;</a>
<a name="ln1597">      p_ml = false;</a>
<a name="ln1598">      p_et = false;</a>
<a name="ln1599">      p_bin = true;             // needed when called for the &quot;-b&quot; argument</a>
<a name="ln1600">    }</a>
<a name="ln1601">  } else if (oldval) {        // switched off</a>
<a name="ln1602">    if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1603">      curbuf-&gt;b_p_tw = curbuf-&gt;b_p_tw_nobin;</a>
<a name="ln1604">      curbuf-&gt;b_p_wm = curbuf-&gt;b_p_wm_nobin;</a>
<a name="ln1605">      curbuf-&gt;b_p_ml = curbuf-&gt;b_p_ml_nobin;</a>
<a name="ln1606">      curbuf-&gt;b_p_et = curbuf-&gt;b_p_et_nobin;</a>
<a name="ln1607">    }</a>
<a name="ln1608">    if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1609">      p_tw = p_tw_nobin;</a>
<a name="ln1610">      p_wm = p_wm_nobin;</a>
<a name="ln1611">      p_ml = p_ml_nobin;</a>
<a name="ln1612">      p_et = p_et_nobin;</a>
<a name="ln1613">    }</a>
<a name="ln1614">  }</a>
<a name="ln1615">}</a>
<a name="ln1616"> </a>
<a name="ln1617">/// Find the parameter represented by the given character (eg ', :, &quot;, or /),</a>
<a name="ln1618">/// and return its associated value in the 'shada' string.</a>
<a name="ln1619">/// Only works for number parameters, not for 'r' or 'n'.</a>
<a name="ln1620">/// If the parameter is not specified in the string or there is no following</a>
<a name="ln1621">/// number, return -1.</a>
<a name="ln1622">int get_shada_parameter(int type)</a>
<a name="ln1623">{</a>
<a name="ln1624">  char_u *p;</a>
<a name="ln1625"> </a>
<a name="ln1626">  p = find_shada_parameter(type);</a>
<a name="ln1627">  if (p != NULL &amp;&amp; ascii_isdigit(*p)) {</a>
<a name="ln1628">    return atoi((char *)p);</a>
<a name="ln1629">  }</a>
<a name="ln1630">  return -1;</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">/// Find the parameter represented by the given character (eg ''', ':', '&quot;', or</a>
<a name="ln1634">/// '/') in the 'shada' option and return a pointer to the string after it.</a>
<a name="ln1635">/// Return NULL if the parameter is not specified in the string.</a>
<a name="ln1636">char_u *find_shada_parameter(int type)</a>
<a name="ln1637">{</a>
<a name="ln1638">  for (char *p = p_shada; *p; p++) {</a>
<a name="ln1639">    if (*p == type) {</a>
<a name="ln1640">      return (char_u *)p + 1;</a>
<a name="ln1641">    }</a>
<a name="ln1642">    if (*p == 'n') {                // 'n' is always the last one</a>
<a name="ln1643">      break;</a>
<a name="ln1644">    }</a>
<a name="ln1645">    p = vim_strchr(p, ',');         // skip until next ','</a>
<a name="ln1646">    if (p == NULL) {                // hit the end without finding parameter</a>
<a name="ln1647">      break;</a>
<a name="ln1648">    }</a>
<a name="ln1649">  }</a>
<a name="ln1650">  return NULL;</a>
<a name="ln1651">}</a>
<a name="ln1652"> </a>
<a name="ln1653">/// Expand environment variables for some string options.</a>
<a name="ln1654">/// These string options cannot be indirect!</a>
<a name="ln1655">/// If &quot;val&quot; is NULL expand the current value of the option.</a>
<a name="ln1656">/// Return pointer to NameBuff, or NULL when not expanded.</a>
<a name="ln1657">static char *option_expand(int opt_idx, char *val)</a>
<a name="ln1658">{</a>
<a name="ln1659">  // if option doesn't need expansion nothing to do</a>
<a name="ln1660">  if (!(options[opt_idx].flags &amp; P_EXPAND) || options[opt_idx].var == NULL) {</a>
<a name="ln1661">    return NULL;</a>
<a name="ln1662">  }</a>
<a name="ln1663"> </a>
<a name="ln1664">  if (val == NULL) {</a>
<a name="ln1665">    val = *(char **)options[opt_idx].var;</a>
<a name="ln1666">  }</a>
<a name="ln1667"> </a>
<a name="ln1668">  // If val is longer than MAXPATHL no meaningful expansion can be done,</a>
<a name="ln1669">  // expand_env() would truncate the string.</a>
<a name="ln1670">  if (val == NULL || strlen(val) &gt; MAXPATHL) {</a>
<a name="ln1671">    return NULL;</a>
<a name="ln1672">  }</a>
<a name="ln1673"> </a>
<a name="ln1674">  // Expanding this with NameBuff, expand_env() must not be passed IObuff.</a>
<a name="ln1675">  // Escape spaces when expanding 'tags', they are used to separate file</a>
<a name="ln1676">  // names.</a>
<a name="ln1677">  // For 'spellsuggest' expand after &quot;file:&quot;.</a>
<a name="ln1678">  expand_env_esc((char_u *)val, (char_u *)NameBuff, MAXPATHL,</a>
<a name="ln1679">                 (char_u **)options[opt_idx].var == &amp;p_tags, false,</a>
<a name="ln1680">                 (char_u **)options[opt_idx].var == (char_u **)&amp;p_sps ? (char_u *)&quot;file:&quot; :</a>
<a name="ln1681">                 NULL);</a>
<a name="ln1682">  if (strcmp(NameBuff, val) == 0) {   // they are the same</a>
<a name="ln1683">    return NULL;</a>
<a name="ln1684">  }</a>
<a name="ln1685"> </a>
<a name="ln1686">  return NameBuff;</a>
<a name="ln1687">}</a>
<a name="ln1688"> </a>
<a name="ln1689">/// After setting various option values: recompute variables that depend on</a>
<a name="ln1690">/// option values.</a>
<a name="ln1691">static void didset_options(void)</a>
<a name="ln1692">{</a>
<a name="ln1693">  // initialize the table for 'iskeyword' et.al.</a>
<a name="ln1694">  (void)init_chartab();</a>
<a name="ln1695"> </a>
<a name="ln1696">  didset_string_options();</a>
<a name="ln1697"> </a>
<a name="ln1698">  (void)spell_check_msm();</a>
<a name="ln1699">  (void)spell_check_sps();</a>
<a name="ln1700">  (void)compile_cap_prog(curwin-&gt;w_s);</a>
<a name="ln1701">  (void)did_set_spell_option(true);</a>
<a name="ln1702">  // set cedit_key</a>
<a name="ln1703">  (void)check_cedit();</a>
<a name="ln1704">  // initialize the table for 'breakat'.</a>
<a name="ln1705">  fill_breakat_flags();</a>
<a name="ln1706">  didset_window_options(curwin, true);</a>
<a name="ln1707">}</a>
<a name="ln1708"> </a>
<a name="ln1709">// More side effects of setting options.</a>
<a name="ln1710">static void didset_options2(void)</a>
<a name="ln1711">{</a>
<a name="ln1712">  // Initialize the highlight_attr[] table.</a>
<a name="ln1713">  highlight_changed();</a>
<a name="ln1714"> </a>
<a name="ln1715">  // Parse default for 'fillchars'.</a>
<a name="ln1716">  (void)set_chars_option(curwin, &amp;curwin-&gt;w_p_fcs, true);</a>
<a name="ln1717"> </a>
<a name="ln1718">  // Parse default for 'listchars'.</a>
<a name="ln1719">  (void)set_chars_option(curwin, &amp;curwin-&gt;w_p_lcs, true);</a>
<a name="ln1720"> </a>
<a name="ln1721">  // Parse default for 'wildmode'.</a>
<a name="ln1722">  check_opt_wim();</a>
<a name="ln1723">  xfree(curbuf-&gt;b_p_vsts_array);</a>
<a name="ln1724">  (void)tabstop_set(curbuf-&gt;b_p_vsts, &amp;curbuf-&gt;b_p_vsts_array);</a>
<a name="ln1725">  xfree(curbuf-&gt;b_p_vts_array);</a>
<a name="ln1726">  (void)tabstop_set(curbuf-&gt;b_p_vts,  &amp;curbuf-&gt;b_p_vts_array);</a>
<a name="ln1727">}</a>
<a name="ln1728"> </a>
<a name="ln1729">/// Check for string options that are NULL (normally only termcap options).</a>
<a name="ln1730">void check_options(void)</a>
<a name="ln1731">{</a>
<a name="ln1732">  int opt_idx;</a>
<a name="ln1733"> </a>
<a name="ln1734">  for (opt_idx = 0; options[opt_idx].fullname != NULL; opt_idx++) {</a>
<a name="ln1735">    if ((options[opt_idx].flags &amp; P_STRING) &amp;&amp; options[opt_idx].var != NULL) {</a>
<a name="ln1736">      check_string_option((char **)get_varp(&amp;(options[opt_idx])));</a>
<a name="ln1737">    }</a>
<a name="ln1738">  }</a>
<a name="ln1739">}</a>
<a name="ln1740"> </a>
<a name="ln1741">/// Return true when option &quot;opt&quot; was set from a modeline or in secure mode.</a>
<a name="ln1742">/// Return false when it wasn't.</a>
<a name="ln1743">/// Return -1 for an unknown option.</a>
<a name="ln1744">int was_set_insecurely(win_T *const wp, char *opt, int opt_flags)</a>
<a name="ln1745">{</a>
<a name="ln1746">  int idx = findoption(opt);</a>
<a name="ln1747"> </a>
<a name="ln1748">  if (idx &gt;= 0) {</a>
<a name="ln1749">    uint32_t *flagp = insecure_flag(wp, idx, opt_flags);</a>
<a name="ln1750">    return (*flagp &amp; P_INSECURE) != 0;</a>
<a name="ln1751">  }</a>
<a name="ln1752">  internal_error(&quot;was_set_insecurely()&quot;);</a>
<a name="ln1753">  return -1;</a>
<a name="ln1754">}</a>
<a name="ln1755"> </a>
<a name="ln1756">/// Get a pointer to the flags used for the P_INSECURE flag of option</a>
<a name="ln1757">/// &quot;opt_idx&quot;.  For some local options a local flags field is used.</a>
<a name="ln1758">/// NOTE: Caller must make sure that &quot;wp&quot; is set to the window from which</a>
<a name="ln1759">/// the option is used.</a>
<a name="ln1760">static uint32_t *insecure_flag(win_T *const wp, int opt_idx, int opt_flags)</a>
<a name="ln1761">{</a>
<a name="ln1762">  if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln1763">    assert(wp != NULL);</a>
<a name="ln1764">    switch ((int)options[opt_idx].indir) {</a>
<a name="ln1765">    case PV_STL:</a>
<a name="ln1766">      return &amp;wp-&gt;w_p_stl_flags;</a>
<a name="ln1767">    case PV_WBR:</a>
<a name="ln1768">      return &amp;wp-&gt;w_p_wbr_flags;</a>
<a name="ln1769">    case PV_FDE:</a>
<a name="ln1770">      return &amp;wp-&gt;w_p_fde_flags;</a>
<a name="ln1771">    case PV_FDT:</a>
<a name="ln1772">      return &amp;wp-&gt;w_p_fdt_flags;</a>
<a name="ln1773">    case PV_INDE:</a>
<a name="ln1774">      return &amp;wp-&gt;w_buffer-&gt;b_p_inde_flags;</a>
<a name="ln1775">    case PV_FEX:</a>
<a name="ln1776">      return &amp;wp-&gt;w_buffer-&gt;b_p_fex_flags;</a>
<a name="ln1777">    case PV_INEX:</a>
<a name="ln1778">      return &amp;wp-&gt;w_buffer-&gt;b_p_inex_flags;</a>
<a name="ln1779">    }</a>
<a name="ln1780">  }</a>
<a name="ln1781"> </a>
<a name="ln1782">  // Nothing special, return global flags field.</a>
<a name="ln1783">  return &amp;options[opt_idx].flags;</a>
<a name="ln1784">}</a>
<a name="ln1785"> </a>
<a name="ln1786">/// Redraw the window title and/or tab page text later.</a>
<a name="ln1787">void redraw_titles(void)</a>
<a name="ln1788">{</a>
<a name="ln1789">  need_maketitle = true;</a>
<a name="ln1790">  redraw_tabline = true;</a>
<a name="ln1791">}</a>
<a name="ln1792"> </a>
<a name="ln1793">/// Return true if &quot;val&quot; is a valid name: only consists of alphanumeric ASCII</a>
<a name="ln1794">/// characters or characters in &quot;allowed&quot;.</a>
<a name="ln1795">bool valid_name(const char *val, const char *allowed)</a>
<a name="ln1796">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1797">{</a>
<a name="ln1798">  for (const char_u *s = (char_u *)val; *s != NUL; s++) {</a>
<a name="ln1799">    if (!ASCII_ISALNUM(*s)</a>
<a name="ln1800">        &amp;&amp; vim_strchr(allowed, *s) == NULL) {</a>
<a name="ln1801">      return false;</a>
<a name="ln1802">    }</a>
<a name="ln1803">  }</a>
<a name="ln1804">  return true;</a>
<a name="ln1805">}</a>
<a name="ln1806"> </a>
<a name="ln1807">void check_blending(win_T *wp)</a>
<a name="ln1808">{</a>
<a name="ln1809">  wp-&gt;w_grid_alloc.blending =</a>
<a name="ln1810">    wp-&gt;w_p_winbl &gt; 0 || (wp-&gt;w_floating &amp;&amp; wp-&gt;w_float_config.shadow);</a>
<a name="ln1811">}</a>
<a name="ln1812"> </a>
<a name="ln1813">/// Handle setting `winhighlight' in window &quot;wp&quot;</a>
<a name="ln1814">bool parse_winhl_opt(win_T *wp)</a>
<a name="ln1815">{</a>
<a name="ln1816">  const char *p = (const char *)wp-&gt;w_p_winhl;</a>
<a name="ln1817"> </a>
<a name="ln1818">  if (!*p) {</a>
<a name="ln1819">    if (wp-&gt;w_ns_hl_winhl &amp;&amp; wp-&gt;w_ns_hl == wp-&gt;w_ns_hl_winhl) {</a>
<a name="ln1820">      wp-&gt;w_ns_hl = 0;</a>
<a name="ln1821">      wp-&gt;w_hl_needs_update = true;</a>
<a name="ln1822">    }</a>
<a name="ln1823"> </a>
<a name="ln1824">    return true;</a>
<a name="ln1825">  }</a>
<a name="ln1826"> </a>
<a name="ln1827">  if (wp-&gt;w_ns_hl_winhl == 0) {</a>
<a name="ln1828">    wp-&gt;w_ns_hl_winhl = (int)nvim_create_namespace(NULL_STRING);</a>
<a name="ln1829">  } else {</a>
<a name="ln1830">    // namespace already exist. invalidate existing items</a>
<a name="ln1831">    DecorProvider *dp = get_decor_provider(wp-&gt;w_ns_hl_winhl, true);</a>
<a name="ln1832">    dp-&gt;hl_valid++;</a>
<a name="ln1833">  }</a>
<a name="ln1834">  wp-&gt;w_ns_hl = wp-&gt;w_ns_hl_winhl;</a>
<a name="ln1835">  int ns_hl = wp-&gt;w_ns_hl;</a>
<a name="ln1836"> </a>
<a name="ln1837">  while (*p) {</a>
<a name="ln1838">    char *colon = strchr(p, ':');</a>
<a name="ln1839">    if (!colon) {</a>
<a name="ln1840">      return false;</a>
<a name="ln1841">    }</a>
<a name="ln1842">    size_t nlen = (size_t)(colon - p);</a>
<a name="ln1843">    char *hi = colon + 1;</a>
<a name="ln1844">    char *commap = xstrchrnul(hi, ',');</a>
<a name="ln1845">    size_t len = (size_t)(commap - hi);</a>
<a name="ln1846">    int hl_id = len ? syn_check_group(hi, len) : -1;</a>
<a name="ln1847">    int hl_id_link = nlen ? syn_check_group(p, nlen) : 0;</a>
<a name="ln1848"> </a>
<a name="ln1849">    HlAttrs attrs = HLATTRS_INIT;</a>
<a name="ln1850">    attrs.rgb_ae_attr |= HL_GLOBAL;</a>
<a name="ln1851">    ns_hl_def(ns_hl, hl_id_link, attrs, hl_id, NULL);</a>
<a name="ln1852"> </a>
<a name="ln1853">    p = *commap ? commap + 1 : &quot;&quot;;</a>
<a name="ln1854">  }</a>
<a name="ln1855"> </a>
<a name="ln1856">  wp-&gt;w_hl_needs_update = true;</a>
<a name="ln1857">  return true;</a>
<a name="ln1858">}</a>
<a name="ln1859"> </a>
<a name="ln1860">/// Set the script_ctx for an option, taking care of setting the buffer- or</a>
<a name="ln1861">/// window-local value.</a>
<a name="ln1862">void set_option_sctx_idx(int opt_idx, int opt_flags, sctx_T script_ctx)</a>
<a name="ln1863">{</a>
<a name="ln1864">  int both = (opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0;</a>
<a name="ln1865">  int indir = (int)options[opt_idx].indir;</a>
<a name="ln1866">  nlua_set_sctx(&amp;script_ctx);</a>
<a name="ln1867">  LastSet last_set = {</a>
<a name="ln1868">    .script_ctx = script_ctx,</a>
<a name="ln1869">    .channel_id = current_channel_id,</a>
<a name="ln1870">  };</a>
<a name="ln1871"> </a>
<a name="ln1872">  // Modeline already has the line number set.</a>
<a name="ln1873">  if (!(opt_flags &amp; OPT_MODELINE)) {</a>
<a name="ln1874">    last_set.script_ctx.sc_lnum += SOURCING_LNUM;</a>
<a name="ln1875">  }</a>
<a name="ln1876"> </a>
<a name="ln1877">  // Remember where the option was set.  For local options need to do that</a>
<a name="ln1878">  // in the buffer or window structure.</a>
<a name="ln1879">  if (both || (opt_flags &amp; OPT_GLOBAL) || (indir &amp; (PV_BUF|PV_WIN)) == 0) {</a>
<a name="ln1880">    options[opt_idx].last_set = last_set;</a>
<a name="ln1881">  }</a>
<a name="ln1882">  if (both || (opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1883">    if (indir &amp; PV_BUF) {</a>
<a name="ln1884">      curbuf-&gt;b_p_script_ctx[indir &amp; PV_MASK] = last_set;</a>
<a name="ln1885">    } else if (indir &amp; PV_WIN) {</a>
<a name="ln1886">      curwin-&gt;w_p_script_ctx[indir &amp; PV_MASK] = last_set;</a>
<a name="ln1887">    }</a>
<a name="ln1888">  }</a>
<a name="ln1889">}</a>
<a name="ln1890"> </a>
<a name="ln1891">/// Set the value of a boolean option, taking care of side effects</a>
<a name="ln1892">///</a>
<a name="ln1893">/// @param[in]  opt_idx  Option index in options[] table.</a>
<a name="ln1894">/// @param[out]  varp  Pointer to the option variable.</a>
<a name="ln1895">/// @param[in]  value  New value.</a>
<a name="ln1896">/// @param[in]  opt_flags  OPT_LOCAL and/or OPT_GLOBAL.</a>
<a name="ln1897">///</a>
<a name="ln1898">/// @return NULL on success, error message on error.</a>
<a name="ln1899">static char *set_bool_option(const int opt_idx, char_u *const varp, const int value,</a>
<a name="ln1900">                             const int opt_flags)</a>
<a name="ln1901">{</a>
<a name="ln1902">  int old_value = *(int *)varp;</a>
<a name="ln1903">  int old_global_value = 0;</a>
<a name="ln1904">  char *errmsg = NULL;</a>
<a name="ln1905"> </a>
<a name="ln1906">  // Disallow changing some options from secure mode</a>
<a name="ln1907">  if ((secure || sandbox != 0)</a>
<a name="ln1908">      &amp;&amp; (options[opt_idx].flags &amp; P_SECURE)) {</a>
<a name="ln1909">    return (char *)e_secure;</a>
<a name="ln1910">  }</a>
<a name="ln1911"> </a>
<a name="ln1912">  // Save the global value before changing anything. This is needed as for</a>
<a name="ln1913">  // a global-only option setting the &quot;local value&quot; in fact sets the global</a>
<a name="ln1914">  // value (since there is only one value).</a>
<a name="ln1915">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln1916">    old_global_value = *(int *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln1917">  }</a>
<a name="ln1918"> </a>
<a name="ln1919">  *(int *)varp = value;             // set the new value</a>
<a name="ln1920">  // Remember where the option was set.</a>
<a name="ln1921">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln1922"> </a>
<a name="ln1923">  // May set global value for local option.</a>
<a name="ln1924">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln1925">    *(int *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) = value;</a>
<a name="ln1926">  }</a>
<a name="ln1927"> </a>
<a name="ln1928">  // Ensure that options set to p_force_on cannot be disabled.</a>
<a name="ln1929">  if ((int *)varp == &amp;p_force_on &amp;&amp; p_force_on == false) {</a>
<a name="ln1930">    p_force_on = true;</a>
<a name="ln1931">    return e_unsupportedoption;</a>
<a name="ln1932">    // Ensure that options set to p_force_off cannot be enabled.</a>
<a name="ln1933">  } else if ((int *)varp == &amp;p_force_off &amp;&amp; p_force_off == true) {</a>
<a name="ln1934">    p_force_off = false;</a>
<a name="ln1935">    return (char *)e_unsupportedoption;</a>
<a name="ln1936">  } else if ((int *)varp == &amp;p_lrm) {</a>
<a name="ln1937">    // 'langremap' -&gt; !'langnoremap'</a>
<a name="ln1938">    p_lnr = !p_lrm;</a>
<a name="ln1939">  } else if ((int *)varp == &amp;p_lnr) {</a>
<a name="ln1940">    // 'langnoremap' -&gt; !'langremap'</a>
<a name="ln1941">    p_lrm = !p_lnr;</a>
<a name="ln1942">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_udf || (int *)varp == &amp;p_udf) {</a>
<a name="ln1943">    // 'undofile'</a>
<a name="ln1944">    // Only take action when the option was set. When reset we do not</a>
<a name="ln1945">    // delete the undo file, the option may be set again without making</a>
<a name="ln1946">    // any changes in between.</a>
<a name="ln1947">    if (curbuf-&gt;b_p_udf || p_udf) {</a>
<a name="ln1948">      char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln1949"> </a>
<a name="ln1950">      FOR_ALL_BUFFERS(bp) {</a>
<a name="ln1951">        // When 'undofile' is set globally: for every buffer, otherwise</a>
<a name="ln1952">        // only for the current buffer: Try to read in the undofile,</a>
<a name="ln1953">        // if one exists, the buffer wasn't changed and the buffer was</a>
<a name="ln1954">        // loaded</a>
<a name="ln1955">        if ((curbuf == bp</a>
<a name="ln1956">             || (opt_flags &amp; OPT_GLOBAL) || opt_flags == 0)</a>
<a name="ln1957">            &amp;&amp; !bufIsChanged(bp) &amp;&amp; bp-&gt;b_ml.ml_mfp != NULL) {</a>
<a name="ln1958">          u_compute_hash(bp, hash);</a>
<a name="ln1959">          u_read_undo(NULL, hash, (char_u *)bp-&gt;b_fname);</a>
<a name="ln1960">        }</a>
<a name="ln1961">      }</a>
<a name="ln1962">    }</a>
<a name="ln1963">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_ro) {</a>
<a name="ln1964">    // when 'readonly' is reset globally, also reset readonlymode</a>
<a name="ln1965">    if (!curbuf-&gt;b_p_ro &amp;&amp; (opt_flags &amp; OPT_LOCAL) == 0) {</a>
<a name="ln1966">      readonlymode = false;</a>
<a name="ln1967">    }</a>
<a name="ln1968"> </a>
<a name="ln1969">    // when 'readonly' is set may give W10 again</a>
<a name="ln1970">    if (curbuf-&gt;b_p_ro) {</a>
<a name="ln1971">      curbuf-&gt;b_did_warn = false;</a>
<a name="ln1972">    }</a>
<a name="ln1973"> </a>
<a name="ln1974">    redraw_titles();</a>
<a name="ln1975">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_ma) {</a>
<a name="ln1976">    // when 'modifiable' is changed, redraw the window title</a>
<a name="ln1977">    redraw_titles();</a>
<a name="ln1978">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_eol) {</a>
<a name="ln1979">    // when 'endofline' is changed, redraw the window title</a>
<a name="ln1980">    redraw_titles();</a>
<a name="ln1981">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_fixeol) {</a>
<a name="ln1982">    // when 'fixeol' is changed, redraw the window title</a>
<a name="ln1983">    redraw_titles();</a>
<a name="ln1984">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_bomb) {</a>
<a name="ln1985">    // when 'bomb' is changed, redraw the window title and tab page text</a>
<a name="ln1986">    redraw_titles();</a>
<a name="ln1987">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_bin) {</a>
<a name="ln1988">    // when 'bin' is set also set some other options</a>
<a name="ln1989">    set_options_bin(old_value, curbuf-&gt;b_p_bin, opt_flags);</a>
<a name="ln1990">    redraw_titles();</a>
<a name="ln1991">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_bl &amp;&amp; old_value != curbuf-&gt;b_p_bl) {</a>
<a name="ln1992">    // when 'buflisted' changes, trigger autocommands</a>
<a name="ln1993">    apply_autocmds(curbuf-&gt;b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,</a>
<a name="ln1994">                   NULL, NULL, true, curbuf);</a>
<a name="ln1995">  } else if ((int *)varp == &amp;curbuf-&gt;b_p_swf) {</a>
<a name="ln1996">    // when 'swf' is set, create swapfile, when reset remove swapfile</a>
<a name="ln1997">    if (curbuf-&gt;b_p_swf &amp;&amp; p_uc) {</a>
<a name="ln1998">      ml_open_file(curbuf);                     // create the swap file</a>
<a name="ln1999">    } else {</a>
<a name="ln2000">      // no need to reset curbuf-&gt;b_may_swap, ml_open_file() will check</a>
<a name="ln2001">      // buf-&gt;b_p_swf</a>
<a name="ln2002">      mf_close_file(curbuf, true);              // remove the swap file</a>
<a name="ln2003">    }</a>
<a name="ln2004">  } else if ((int *)varp == &amp;p_paste) {</a>
<a name="ln2005">    // when 'paste' is set or reset also change other options</a>
<a name="ln2006">    paste_option_changed();</a>
<a name="ln2007">  } else if ((int *)varp == &amp;p_ic &amp;&amp; p_hls) {</a>
<a name="ln2008">    // when 'ignorecase' is set or reset and 'hlsearch' is set, redraw</a>
<a name="ln2009">    redraw_all_later(UPD_SOME_VALID);</a>
<a name="ln2010">  } else if ((int *)varp == &amp;p_hls) {</a>
<a name="ln2011">    // when 'hlsearch' is set or reset: reset no_hlsearch</a>
<a name="ln2012">    set_no_hlsearch(false);</a>
<a name="ln2013">  } else if ((int *)varp == &amp;curwin-&gt;w_p_scb) {</a>
<a name="ln2014">    // when 'scrollbind' is set: snapshot the current position to avoid a jump</a>
<a name="ln2015">    // at the end of normal_cmd()</a>
<a name="ln2016">    if (curwin-&gt;w_p_scb) {</a>
<a name="ln2017">      do_check_scrollbind(false);</a>
<a name="ln2018">      curwin-&gt;w_scbind_pos = curwin-&gt;w_topline;</a>
<a name="ln2019">    }</a>
<a name="ln2020">  } else if ((int *)varp == &amp;curwin-&gt;w_p_pvw) {</a>
<a name="ln2021">    // There can be only one window with 'previewwindow' set.</a>
<a name="ln2022">    if (curwin-&gt;w_p_pvw) {</a>
<a name="ln2023">      FOR_ALL_WINDOWS_IN_TAB(win, curtab) {</a>
<a name="ln2024">        if (win-&gt;w_p_pvw &amp;&amp; win != curwin) {</a>
<a name="ln2025">          curwin-&gt;w_p_pvw = false;</a>
<a name="ln2026">          return e_preview_window_already_exists;</a>
<a name="ln2027">        }</a>
<a name="ln2028">      }</a>
<a name="ln2029">    }</a>
<a name="ln2030">  } else if (varp == (char_u *)&amp;(curbuf-&gt;b_p_lisp)) {</a>
<a name="ln2031">    // When 'lisp' option changes include/exclude '-' in</a>
<a name="ln2032">    // keyword characters.</a>
<a name="ln2033">    (void)buf_init_chartab(curbuf, false);          // ignore errors</a>
<a name="ln2034">  } else if ((int *)varp == &amp;p_title) {</a>
<a name="ln2035">    // when 'title' changed, may need to change the title; same for 'icon'</a>
<a name="ln2036">    did_set_title();</a>
<a name="ln2037">  } else if ((int *)varp == &amp;p_icon) {</a>
<a name="ln2038">    did_set_title();</a>
<a name="ln2039">  } else if ((int *)varp == &amp;curbuf-&gt;b_changed) {</a>
<a name="ln2040">    if (!value) {</a>
<a name="ln2041">      save_file_ff(curbuf);             // Buffer is unchanged</a>
<a name="ln2042">    }</a>
<a name="ln2043">    redraw_titles();</a>
<a name="ln2044">    modified_was_set = value;</a>
<a name="ln2045"> </a>
<a name="ln2046">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2047">  } else if ((int *)varp == &amp;p_ssl) {</a>
<a name="ln2048">    if (p_ssl) {</a>
<a name="ln2049">      psepc = '/';</a>
<a name="ln2050">      psepcN = '\\';</a>
<a name="ln2051">      pseps[0] = '/';</a>
<a name="ln2052">    } else {</a>
<a name="ln2053">      psepc = '\\';</a>
<a name="ln2054">      psepcN = '/';</a>
<a name="ln2055">      pseps[0] = '\\';</a>
<a name="ln2056">    }</a>
<a name="ln2057"> </a>
<a name="ln2058">    // need to adjust the file name arguments and buffer names.</a>
<a name="ln2059">    buflist_slash_adjust();</a>
<a name="ln2060">    alist_slash_adjust();</a>
<a name="ln2061">    scriptnames_slash_adjust();</a>
<a name="ln2062">#endif</a>
<a name="ln2063">  } else if ((int *)varp == &amp;curwin-&gt;w_p_wrap) {</a>
<a name="ln2064">    // If 'wrap' is set, set w_leftcol to zero.</a>
<a name="ln2065">    if (curwin-&gt;w_p_wrap) {</a>
<a name="ln2066">      curwin-&gt;w_leftcol = 0;</a>
<a name="ln2067">    }</a>
<a name="ln2068">  } else if ((int *)varp == &amp;p_ea) {</a>
<a name="ln2069">    if (p_ea &amp;&amp; !old_value) {</a>
<a name="ln2070">      win_equal(curwin, false, 0);</a>
<a name="ln2071">    }</a>
<a name="ln2072">  } else if ((int *)varp == &amp;p_acd) {</a>
<a name="ln2073">    // Change directories when the 'acd' option is set now.</a>
<a name="ln2074">    do_autochdir();</a>
<a name="ln2075">  } else if ((int *)varp == &amp;curwin-&gt;w_p_diff) {  // 'diff'</a>
<a name="ln2076">    // May add or remove the buffer from the list of diff buffers.</a>
<a name="ln2077">    diff_buf_adjust(curwin);</a>
<a name="ln2078">    if (foldmethodIsDiff(curwin)) {</a>
<a name="ln2079">      foldUpdateAll(curwin);</a>
<a name="ln2080">    }</a>
<a name="ln2081">  } else if ((int *)varp == &amp;curwin-&gt;w_p_spell) {  // 'spell'</a>
<a name="ln2082">    if (curwin-&gt;w_p_spell) {</a>
<a name="ln2083">      errmsg = did_set_spelllang(curwin);</a>
<a name="ln2084">    }</a>
<a name="ln2085">  }</a>
<a name="ln2086"> </a>
<a name="ln2087">  if ((int *)varp == &amp;curwin-&gt;w_p_arab) {</a>
<a name="ln2088">    if (curwin-&gt;w_p_arab) {</a>
<a name="ln2089">      // 'arabic' is set, handle various sub-settings.</a>
<a name="ln2090">      if (!p_tbidi) {</a>
<a name="ln2091">        // set rightleft mode</a>
<a name="ln2092">        if (!curwin-&gt;w_p_rl) {</a>
<a name="ln2093">          curwin-&gt;w_p_rl = true;</a>
<a name="ln2094">          changed_window_setting();</a>
<a name="ln2095">        }</a>
<a name="ln2096"> </a>
<a name="ln2097">        // Enable Arabic shaping (major part of what Arabic requires)</a>
<a name="ln2098">        if (!p_arshape) {</a>
<a name="ln2099">          p_arshape = true;</a>
<a name="ln2100">          redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln2101">        }</a>
<a name="ln2102">      }</a>
<a name="ln2103"> </a>
<a name="ln2104">      // Arabic requires a utf-8 encoding, inform the user if it's not</a>
<a name="ln2105">      // set.</a>
<a name="ln2106">      if (strcmp(p_enc, &quot;utf-8&quot;) != 0) {</a>
<a name="ln2107">        static char *w_arabic = N_(&quot;W17: Arabic requires UTF-8, do ':set encoding=utf-8'&quot;);</a>
<a name="ln2108"> </a>
<a name="ln2109">        msg_source(HL_ATTR(HLF_W));</a>
<a name="ln2110">        msg_attr(_(w_arabic), HL_ATTR(HLF_W));</a>
<a name="ln2111">        set_vim_var_string(VV_WARNINGMSG, _(w_arabic), -1);</a>
<a name="ln2112">      }</a>
<a name="ln2113"> </a>
<a name="ln2114">      // set 'delcombine'</a>
<a name="ln2115">      p_deco = true;</a>
<a name="ln2116"> </a>
<a name="ln2117">      // Force-set the necessary keymap for arabic.</a>
<a name="ln2118">      errmsg = set_option_value(&quot;keymap&quot;, 0L, &quot;arabic&quot;, OPT_LOCAL);</a>
<a name="ln2119">    } else {</a>
<a name="ln2120">      // 'arabic' is reset, handle various sub-settings.</a>
<a name="ln2121">      if (!p_tbidi) {</a>
<a name="ln2122">        // reset rightleft mode</a>
<a name="ln2123">        if (curwin-&gt;w_p_rl) {</a>
<a name="ln2124">          curwin-&gt;w_p_rl = false;</a>
<a name="ln2125">          changed_window_setting();</a>
<a name="ln2126">        }</a>
<a name="ln2127"> </a>
<a name="ln2128">        // 'arabicshape' isn't reset, it is a global option and</a>
<a name="ln2129">        // another window may still need it &quot;on&quot;.</a>
<a name="ln2130">      }</a>
<a name="ln2131"> </a>
<a name="ln2132">      // 'delcombine' isn't reset, it is a global option and another</a>
<a name="ln2133">      // window may still want it &quot;on&quot;.</a>
<a name="ln2134"> </a>
<a name="ln2135">      // Revert to the default keymap</a>
<a name="ln2136">      curbuf-&gt;b_p_iminsert = B_IMODE_NONE;</a>
<a name="ln2137">      curbuf-&gt;b_p_imsearch = B_IMODE_USE_INSERT;</a>
<a name="ln2138">    }</a>
<a name="ln2139">  }</a>
<a name="ln2140"> </a>
<a name="ln2141">  // End of handling side effects for bool options.</a>
<a name="ln2142"> </a>
<a name="ln2143">  // after handling side effects, call autocommand</a>
<a name="ln2144"> </a>
<a name="ln2145">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln2146"> </a>
<a name="ln2147">  // Don't do this while starting up or recursively.</a>
<a name="ln2148">  if (!starting &amp;&amp; *get_vim_var_str(VV_OPTION_TYPE) == NUL) {</a>
<a name="ln2149">    char buf_old[2];</a>
<a name="ln2150">    char buf_old_global[2];</a>
<a name="ln2151">    char buf_new[2];</a>
<a name="ln2152">    char buf_type[7];</a>
<a name="ln2153">    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), &quot;%d&quot;, old_value ? true : false);</a>
<a name="ln2154">    vim_snprintf(buf_old_global, ARRAY_SIZE(buf_old_global), &quot;%d&quot;, old_global_value ? true : false);</a>
<a name="ln2155">    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), &quot;%d&quot;, value ? true : false);</a>
<a name="ln2156">    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), &quot;%s&quot;,</a>
<a name="ln2157">                 (opt_flags &amp; OPT_LOCAL) ? &quot;local&quot; : &quot;global&quot;);</a>
<a name="ln2158">    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);</a>
<a name="ln2159">    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);</a>
<a name="ln2160">    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);</a>
<a name="ln2161">    if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln2162">      set_vim_var_string(VV_OPTION_COMMAND, &quot;setlocal&quot;, -1);</a>
<a name="ln2163">      set_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);</a>
<a name="ln2164">    }</a>
<a name="ln2165">    if (opt_flags &amp; OPT_GLOBAL) {</a>
<a name="ln2166">      set_vim_var_string(VV_OPTION_COMMAND, &quot;setglobal&quot;, -1);</a>
<a name="ln2167">      set_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old, -1);</a>
<a name="ln2168">    }</a>
<a name="ln2169">    if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln2170">      set_vim_var_string(VV_OPTION_COMMAND, &quot;set&quot;, -1);</a>
<a name="ln2171">      set_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);</a>
<a name="ln2172">      set_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old_global, -1);</a>
<a name="ln2173">    }</a>
<a name="ln2174">    if (opt_flags &amp; OPT_MODELINE) {</a>
<a name="ln2175">      set_vim_var_string(VV_OPTION_COMMAND, &quot;modeline&quot;, -1);</a>
<a name="ln2176">      set_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);</a>
<a name="ln2177">    }</a>
<a name="ln2178">    apply_autocmds(EVENT_OPTIONSET, options[opt_idx].fullname, NULL, false, NULL);</a>
<a name="ln2179">    reset_v_option_vars();</a>
<a name="ln2180">  }</a>
<a name="ln2181"> </a>
<a name="ln2182">  if (options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln2183">    ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln2184">                       BOOLEAN_OBJ(*varp));</a>
<a name="ln2185">  }</a>
<a name="ln2186"> </a>
<a name="ln2187">  comp_col();                       // in case 'ruler' or 'showcmd' changed</a>
<a name="ln2188">  if (curwin-&gt;w_curswant != MAXCOL</a>
<a name="ln2189">      &amp;&amp; (options[opt_idx].flags &amp; (P_CURSWANT | P_RALL)) != 0) {</a>
<a name="ln2190">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln2191">  }</a>
<a name="ln2192">  check_redraw(options[opt_idx].flags);</a>
<a name="ln2193"> </a>
<a name="ln2194">  return errmsg;</a>
<a name="ln2195">}</a>
<a name="ln2196"> </a>
<a name="ln2197">/// Set the value of a number option, taking care of side effects</a>
<a name="ln2198">///</a>
<a name="ln2199">/// @param[in]  opt_idx  Option index in options[] table.</a>
<a name="ln2200">/// @param[out]  varp  Pointer to the option variable.</a>
<a name="ln2201">/// @param[in]  value  New value.</a>
<a name="ln2202">/// @param  errbuf  Buffer for error messages.</a>
<a name="ln2203">/// @param[in]  errbuflen  Length of `errbuf`.</a>
<a name="ln2204">/// @param[in]  opt_flags  OPT_LOCAL, OPT_GLOBAL or OPT_MODELINE.</a>
<a name="ln2205">///</a>
<a name="ln2206">/// @return NULL on success, error message on error.</a>
<a name="ln2207">static char *set_num_option(int opt_idx, char_u *varp, long value, char *errbuf, size_t errbuflen,</a>
<a name="ln2208">                            int opt_flags)</a>
<a name="ln2209">{</a>
<a name="ln2210">  char *errmsg = NULL;</a>
<a name="ln2211">  long old_value = *(long *)varp;</a>
<a name="ln2212">  long old_global_value = 0;  // only used when setting a local and global option</a>
<a name="ln2213">  long old_Rows = Rows;       // remember old Rows</a>
<a name="ln2214">  long *pp = (long *)varp;</a>
<a name="ln2215"> </a>
<a name="ln2216">  // Disallow changing some options from secure mode.</a>
<a name="ln2217">  if ((secure || sandbox != 0)</a>
<a name="ln2218">      &amp;&amp; (options[opt_idx].flags &amp; P_SECURE)) {</a>
<a name="ln2219">    return e_secure;</a>
<a name="ln2220">  }</a>
<a name="ln2221"> </a>
<a name="ln2222">  // Save the global value before changing anything. This is needed as for</a>
<a name="ln2223">  // a global-only option setting the &quot;local value&quot; in fact sets the global</a>
<a name="ln2224">  // value (since there is only one value).</a>
<a name="ln2225">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln2226">    old_global_value = *(long *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln2227">  }</a>
<a name="ln2228"> </a>
<a name="ln2229">  // Many number options assume their value is in the signed int range.</a>
<a name="ln2230">  if (value &lt; INT_MIN || value &gt; INT_MAX) {</a>
<a name="ln2231">    return e_invarg;</a>
<a name="ln2232">  }</a>
<a name="ln2233"> </a>
<a name="ln2234">  // Options that need some validation.</a>
<a name="ln2235">  if (pp == &amp;p_wh) {</a>
<a name="ln2236">    if (value &lt; 1) {</a>
<a name="ln2237">      errmsg = e_positive;</a>
<a name="ln2238">    } else if (p_wmh &gt; value) {</a>
<a name="ln2239">      errmsg = e_winheight;</a>
<a name="ln2240">    }</a>
<a name="ln2241">  } else if (pp == &amp;p_hh) {</a>
<a name="ln2242">    if (value &lt; 0) {</a>
<a name="ln2243">      errmsg = e_positive;</a>
<a name="ln2244">    }</a>
<a name="ln2245">  } else if (pp == &amp;p_wmh) {</a>
<a name="ln2246">    if (value &lt; 0) {</a>
<a name="ln2247">      errmsg = e_positive;</a>
<a name="ln2248">    } else if (value &gt; p_wh) {</a>
<a name="ln2249">      errmsg = e_winheight;</a>
<a name="ln2250">    }</a>
<a name="ln2251">  } else if (pp == &amp;p_wiw) {</a>
<a name="ln2252">    if (value &lt; 1) {</a>
<a name="ln2253">      errmsg = e_positive;</a>
<a name="ln2254">    } else if (p_wmw &gt; value) {</a>
<a name="ln2255">      errmsg = e_winwidth;</a>
<a name="ln2256">    }</a>
<a name="ln2257">  } else if (pp == &amp;p_wmw) {</a>
<a name="ln2258">    if (value &lt; 0) {</a>
<a name="ln2259">      errmsg = e_positive;</a>
<a name="ln2260">    } else if (value &gt; p_wiw) {</a>
<a name="ln2261">      errmsg = e_winwidth;</a>
<a name="ln2262">    }</a>
<a name="ln2263">  } else if (pp == &amp;p_mco) {</a>
<a name="ln2264">    value = MAX_MCO;</a>
<a name="ln2265">  } else if (pp == &amp;p_titlelen) {</a>
<a name="ln2266">    if (value &lt; 0) {</a>
<a name="ln2267">      errmsg = e_positive;</a>
<a name="ln2268">    }</a>
<a name="ln2269">  } else if (pp == &amp;p_uc) {</a>
<a name="ln2270">    if (value &lt; 0) {</a>
<a name="ln2271">      errmsg = e_positive;</a>
<a name="ln2272">    }</a>
<a name="ln2273">  } else if (pp == &amp;p_ch) {</a>
<a name="ln2274">    int minval = 0;</a>
<a name="ln2275">    if (value &lt; minval) {</a>
<a name="ln2276">      errmsg = e_positive;</a>
<a name="ln2277">    }</a>
<a name="ln2278">  } else if (pp == &amp;p_tm) {</a>
<a name="ln2279">    if (value &lt; 0) {</a>
<a name="ln2280">      errmsg = e_positive;</a>
<a name="ln2281">    }</a>
<a name="ln2282">  } else if (pp == &amp;p_hi) {</a>
<a name="ln2283">    if (value &lt; 0) {</a>
<a name="ln2284">      errmsg = e_positive;</a>
<a name="ln2285">    } else if (value &gt; 10000) {</a>
<a name="ln2286">      errmsg = e_invarg;</a>
<a name="ln2287">    }</a>
<a name="ln2288">  } else if (pp == &amp;p_pyx) {</a>
<a name="ln2289">    if (value == 0) {</a>
<a name="ln2290">      value = 3;</a>
<a name="ln2291">    } else if (value != 3) {</a>
<a name="ln2292">      errmsg = e_invarg;</a>
<a name="ln2293">    }</a>
<a name="ln2294">  } else if (pp == &amp;p_re) {</a>
<a name="ln2295">    if (value &lt; 0 || value &gt; 2) {</a>
<a name="ln2296">      errmsg = e_invarg;</a>
<a name="ln2297">    }</a>
<a name="ln2298">  } else if (pp == &amp;p_report) {</a>
<a name="ln2299">    if (value &lt; 0) {</a>
<a name="ln2300">      errmsg = e_positive;</a>
<a name="ln2301">    }</a>
<a name="ln2302">  } else if (pp == &amp;p_so) {</a>
<a name="ln2303">    if (value &lt; 0 &amp;&amp; full_screen) {</a>
<a name="ln2304">      errmsg = e_positive;</a>
<a name="ln2305">    }</a>
<a name="ln2306">  } else if (pp == &amp;p_siso) {</a>
<a name="ln2307">    if (value &lt; 0 &amp;&amp; full_screen) {</a>
<a name="ln2308">      errmsg = e_positive;</a>
<a name="ln2309">    }</a>
<a name="ln2310">  } else if (pp == &amp;p_cwh) {</a>
<a name="ln2311">    if (value &lt; 1) {</a>
<a name="ln2312">      errmsg = e_positive;</a>
<a name="ln2313">    }</a>
<a name="ln2314">  } else if (pp == &amp;p_ut) {</a>
<a name="ln2315">    if (value &lt; 0) {</a>
<a name="ln2316">      errmsg = e_positive;</a>
<a name="ln2317">    }</a>
<a name="ln2318">  } else if (pp == &amp;p_ss) {</a>
<a name="ln2319">    if (value &lt; 0) {</a>
<a name="ln2320">      errmsg = e_positive;</a>
<a name="ln2321">    }</a>
<a name="ln2322">  } else if (pp == &amp;curwin-&gt;w_p_fdl || pp == &amp;curwin-&gt;w_allbuf_opt.wo_fdl) {</a>
<a name="ln2323">    if (value &lt; 0) {</a>
<a name="ln2324">      errmsg = e_positive;</a>
<a name="ln2325">    }</a>
<a name="ln2326">  } else if (pp == &amp;curwin-&gt;w_p_cole || pp == &amp;curwin-&gt;w_allbuf_opt.wo_cole) {</a>
<a name="ln2327">    if (value &lt; 0) {</a>
<a name="ln2328">      errmsg = e_positive;</a>
<a name="ln2329">    } else if (value &gt; 3) {</a>
<a name="ln2330">      errmsg = e_invarg;</a>
<a name="ln2331">    }</a>
<a name="ln2332">  } else if (pp == &amp;curwin-&gt;w_p_nuw || pp == &amp;curwin-&gt;w_allbuf_opt.wo_nuw) {</a>
<a name="ln2333">    if (value &lt; 1) {</a>
<a name="ln2334">      errmsg = e_positive;</a>
<a name="ln2335">    } else if (value &gt; 20) {</a>
<a name="ln2336">      errmsg = e_invarg;</a>
<a name="ln2337">    }</a>
<a name="ln2338">  } else if (pp == &amp;curbuf-&gt;b_p_iminsert || pp == &amp;p_iminsert) {</a>
<a name="ln2339">    if (value &lt; 0 || value &gt; B_IMODE_LAST) {</a>
<a name="ln2340">      errmsg = e_invarg;</a>
<a name="ln2341">    }</a>
<a name="ln2342">  } else if (pp == &amp;curbuf-&gt;b_p_imsearch || pp == &amp;p_imsearch) {</a>
<a name="ln2343">    if (value &lt; -1 || value &gt; B_IMODE_LAST) {</a>
<a name="ln2344">      errmsg = e_invarg;</a>
<a name="ln2345">    }</a>
<a name="ln2346">  } else if (pp == &amp;curbuf-&gt;b_p_channel || pp == &amp;p_channel) {</a>
<a name="ln2347">    errmsg = e_invarg;</a>
<a name="ln2348">  } else if (pp == &amp;curbuf-&gt;b_p_scbk || pp == &amp;p_scbk) {</a>
<a name="ln2349">    if (value &lt; -1 || value &gt; SB_MAX) {</a>
<a name="ln2350">      errmsg = e_invarg;</a>
<a name="ln2351">    }</a>
<a name="ln2352">  } else if (pp == &amp;curbuf-&gt;b_p_sw || pp == &amp;p_sw) {</a>
<a name="ln2353">    if (value &lt; 0) {</a>
<a name="ln2354">      errmsg = e_positive;</a>
<a name="ln2355">    }</a>
<a name="ln2356">  } else if (pp == &amp;curbuf-&gt;b_p_ts || pp == &amp;p_ts) {</a>
<a name="ln2357">    if (value &lt; 1) {</a>
<a name="ln2358">      errmsg = e_positive;</a>
<a name="ln2359">    } else if (value &gt; TABSTOP_MAX) {</a>
<a name="ln2360">      errmsg = e_invarg;</a>
<a name="ln2361">    }</a>
<a name="ln2362">  } else if (pp == &amp;curbuf-&gt;b_p_tw || pp == &amp;p_tw) {</a>
<a name="ln2363">    if (value &lt; 0) {</a>
<a name="ln2364">      errmsg = e_positive;</a>
<a name="ln2365">    }</a>
<a name="ln2366">  } else if (pp == &amp;p_wd) {</a>
<a name="ln2367">    if (value &lt; 0) {</a>
<a name="ln2368">      errmsg = e_positive;</a>
<a name="ln2369">    }</a>
<a name="ln2370">  }</a>
<a name="ln2371"> </a>
<a name="ln2372">  // Don't change the value and return early if validation failed.</a>
<a name="ln2373">  if (errmsg != NULL) {</a>
<a name="ln2374">    return errmsg;</a>
<a name="ln2375">  }</a>
<a name="ln2376"> </a>
<a name="ln2377">  *pp = value;</a>
<a name="ln2378">  // Remember where the option was set.</a>
<a name="ln2379">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln2380"> </a>
<a name="ln2381">  // For these options we want to fix some invalid values.</a>
<a name="ln2382">  if (pp == &amp;p_window) {</a>
<a name="ln2383">    if (p_window &lt; 1) {</a>
<a name="ln2384">      p_window = Rows - 1;</a>
<a name="ln2385">    } else if (p_window &gt;= Rows) {</a>
<a name="ln2386">      p_window = Rows - 1;</a>
<a name="ln2387">    }</a>
<a name="ln2388">  } else if (pp == &amp;p_ch) {</a>
<a name="ln2389">    if (ui_has(kUIMessages)) {</a>
<a name="ln2390">      p_ch = 0;</a>
<a name="ln2391">    }</a>
<a name="ln2392">    if (p_ch &gt; Rows - min_rows() + 1) {</a>
<a name="ln2393">      p_ch = Rows - min_rows() + 1;</a>
<a name="ln2394">    }</a>
<a name="ln2395">  }</a>
<a name="ln2396"> </a>
<a name="ln2397">  // Number options that need some action when changed</a>
<a name="ln2398">  if (pp == &amp;p_wh) {</a>
<a name="ln2399">    // 'winheight'</a>
<a name="ln2400">    if (!ONE_WINDOW &amp;&amp; curwin-&gt;w_height &lt; p_wh) {</a>
<a name="ln2401">      win_setheight((int)p_wh);</a>
<a name="ln2402">    }</a>
<a name="ln2403">  } else if (pp == &amp;p_hh) {</a>
<a name="ln2404">    // 'helpheight'</a>
<a name="ln2405">    if (!ONE_WINDOW &amp;&amp; curbuf-&gt;b_help &amp;&amp; curwin-&gt;w_height &lt; p_hh) {</a>
<a name="ln2406">      win_setheight((int)p_hh);</a>
<a name="ln2407">    }</a>
<a name="ln2408">  } else if (pp == &amp;p_wmh) {</a>
<a name="ln2409">    // 'winminheight'</a>
<a name="ln2410">    win_setminheight();</a>
<a name="ln2411">  } else if (pp == &amp;p_wiw) {</a>
<a name="ln2412">    // 'winwidth'</a>
<a name="ln2413">    if (!ONE_WINDOW &amp;&amp; curwin-&gt;w_width &lt; p_wiw) {</a>
<a name="ln2414">      win_setwidth((int)p_wiw);</a>
<a name="ln2415">    }</a>
<a name="ln2416">  } else if (pp == &amp;p_wmw) {</a>
<a name="ln2417">    // 'winminwidth'</a>
<a name="ln2418">    win_setminwidth();</a>
<a name="ln2419">  } else if (pp == &amp;p_ls) {</a>
<a name="ln2420">    // When switching to global statusline, decrease topframe height</a>
<a name="ln2421">    // Also clear the cmdline to remove the ruler if there is one</a>
<a name="ln2422">    if (value == 3 &amp;&amp; old_value != 3) {</a>
<a name="ln2423">      frame_new_height(topframe, topframe-&gt;fr_height - STATUS_HEIGHT, false, false);</a>
<a name="ln2424">      (void)win_comp_pos();</a>
<a name="ln2425">      clear_cmdline = true;</a>
<a name="ln2426">    }</a>
<a name="ln2427">    // When switching from global statusline, increase height of topframe by STATUS_HEIGHT</a>
<a name="ln2428">    // in order to to re-add the space that was previously taken by the global statusline</a>
<a name="ln2429">    if (old_value == 3 &amp;&amp; value != 3) {</a>
<a name="ln2430">      frame_new_height(topframe, topframe-&gt;fr_height + STATUS_HEIGHT, false, false);</a>
<a name="ln2431">      (void)win_comp_pos();</a>
<a name="ln2432">    }</a>
<a name="ln2433"> </a>
<a name="ln2434">    last_status(false);  // (re)set last window status line.</a>
<a name="ln2435">  } else if (pp == &amp;p_stal) {</a>
<a name="ln2436">    // (re)set tab page line</a>
<a name="ln2437">    win_new_screen_rows();   // recompute window positions and heights</a>
<a name="ln2438">  } else if (pp == &amp;curwin-&gt;w_p_fdl) {</a>
<a name="ln2439">    newFoldLevel();</a>
<a name="ln2440">  } else if (pp == &amp;curwin-&gt;w_p_fml) {</a>
<a name="ln2441">    foldUpdateAll(curwin);</a>
<a name="ln2442">  } else if (pp == &amp;curwin-&gt;w_p_fdn) {</a>
<a name="ln2443">    if (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin)) {</a>
<a name="ln2444">      foldUpdateAll(curwin);</a>
<a name="ln2445">    }</a>
<a name="ln2446">  } else if (pp == &amp;curbuf-&gt;b_p_sw || pp == &amp;curbuf-&gt;b_p_ts) {</a>
<a name="ln2447">    // 'shiftwidth' or 'tabstop'</a>
<a name="ln2448">    if (foldmethodIsIndent(curwin)) {</a>
<a name="ln2449">      foldUpdateAll(curwin);</a>
<a name="ln2450">    }</a>
<a name="ln2451">    // When 'shiftwidth' changes, or it's zero and 'tabstop' changes:</a>
<a name="ln2452">    // parse 'cinoptions'.</a>
<a name="ln2453">    if (pp == &amp;curbuf-&gt;b_p_sw || curbuf-&gt;b_p_sw == 0) {</a>
<a name="ln2454">      parse_cino(curbuf);</a>
<a name="ln2455">    }</a>
<a name="ln2456">  } else if (pp == &amp;curbuf-&gt;b_p_iminsert) {</a>
<a name="ln2457">    showmode();</a>
<a name="ln2458">    // Show/unshow value of 'keymap' in status lines.</a>
<a name="ln2459">    status_redraw_curbuf();</a>
<a name="ln2460">  } else if (pp == &amp;p_titlelen) {</a>
<a name="ln2461">    // if 'titlelen' has changed, redraw the title</a>
<a name="ln2462">    if (starting != NO_SCREEN &amp;&amp; old_value != p_titlelen) {</a>
<a name="ln2463">      need_maketitle = true;</a>
<a name="ln2464">    }</a>
<a name="ln2465">  } else if (pp == &amp;p_ch) {</a>
<a name="ln2466">    // if p_ch changed value, change the command line height</a>
<a name="ln2467">    // Only compute the new window layout when startup has been</a>
<a name="ln2468">    // completed. Otherwise the frame sizes may be wrong.</a>
<a name="ln2469">    if ((p_ch != old_value</a>
<a name="ln2470">         || tabline_height() + global_stl_height() + topframe-&gt;fr_height != Rows - p_ch)</a>
<a name="ln2471">        &amp;&amp; full_screen) {</a>
<a name="ln2472">      command_height();</a>
<a name="ln2473">    }</a>
<a name="ln2474">  } else if (pp == &amp;p_uc) {</a>
<a name="ln2475">    // when 'updatecount' changes from zero to non-zero, open swap files</a>
<a name="ln2476">    if (p_uc &amp;&amp; !old_value) {</a>
<a name="ln2477">      ml_open_files();</a>
<a name="ln2478">    }</a>
<a name="ln2479">  } else if (pp == &amp;p_pb) {</a>
<a name="ln2480">    p_pb = MAX(MIN(p_pb, 100), 0);</a>
<a name="ln2481">    hl_invalidate_blends();</a>
<a name="ln2482">    pum_grid.blending = (p_pb &gt; 0);</a>
<a name="ln2483">    if (pum_drawn()) {</a>
<a name="ln2484">      pum_redraw();</a>
<a name="ln2485">    }</a>
<a name="ln2486">  } else if (pp == &amp;p_ul || pp == &amp;curbuf-&gt;b_p_ul) {</a>
<a name="ln2487">    // sync undo before 'undolevels' changes</a>
<a name="ln2488">    // use the old value, otherwise u_sync() may not work properly</a>
<a name="ln2489">    *pp = old_value;</a>
<a name="ln2490">    u_sync(true);</a>
<a name="ln2491">    *pp = value;</a>
<a name="ln2492">  } else if (pp == &amp;curbuf-&gt;b_p_tw) {</a>
<a name="ln2493">    FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln2494">      check_colorcolumn(wp);</a>
<a name="ln2495">    }</a>
<a name="ln2496">  } else if (pp == &amp;curbuf-&gt;b_p_scbk || pp == &amp;p_scbk) {</a>
<a name="ln2497">    if (curbuf-&gt;terminal &amp;&amp; value &lt; old_value) {</a>
<a name="ln2498">      // Force the scrollback to take immediate effect only when decreasing it.</a>
<a name="ln2499">      on_scrollback_option_changed(curbuf-&gt;terminal);</a>
<a name="ln2500">    }</a>
<a name="ln2501">  } else if (pp == &amp;curwin-&gt;w_p_nuw) {</a>
<a name="ln2502">    curwin-&gt;w_nrwidth_line_count = 0;</a>
<a name="ln2503">  } else if (pp == &amp;curwin-&gt;w_p_winbl &amp;&amp; value != old_value) {</a>
<a name="ln2504">    // 'winblend'</a>
<a name="ln2505">    curwin-&gt;w_p_winbl = MAX(MIN(curwin-&gt;w_p_winbl, 100), 0);</a>
<a name="ln2506">    curwin-&gt;w_hl_needs_update = true;</a>
<a name="ln2507">    check_blending(curwin);</a>
<a name="ln2508">  }</a>
<a name="ln2509"> </a>
<a name="ln2510">  // Check the (new) bounds for Rows and Columns here.</a>
<a name="ln2511">  if (p_lines &lt; min_rows() &amp;&amp; full_screen) {</a>
<a name="ln2512">    if (errbuf != NULL) {</a>
<a name="ln2513">      vim_snprintf(errbuf, errbuflen,</a>
<a name="ln2514">                   _(&quot;E593: Need at least %d lines&quot;), min_rows());</a>
<a name="ln2515">      errmsg = errbuf;</a>
<a name="ln2516">    }</a>
<a name="ln2517">    p_lines = min_rows();</a>
<a name="ln2518">  }</a>
<a name="ln2519">  if (p_columns &lt; MIN_COLUMNS &amp;&amp; full_screen) {</a>
<a name="ln2520">    if (errbuf != NULL) {</a>
<a name="ln2521">      vim_snprintf(errbuf, errbuflen,</a>
<a name="ln2522">                   _(&quot;E594: Need at least %d columns&quot;), MIN_COLUMNS);</a>
<a name="ln2523">      errmsg = errbuf;</a>
<a name="ln2524">    }</a>
<a name="ln2525">    p_columns = MIN_COLUMNS;</a>
<a name="ln2526">  }</a>
<a name="ln2527"> </a>
<a name="ln2528">  // True max size is defined by check_screensize()</a>
<a name="ln2529">  p_lines = MIN(p_lines, INT_MAX);</a>
<a name="ln2530">  p_columns = MIN(p_columns, INT_MAX);</a>
<a name="ln2531"> </a>
<a name="ln2532">  // If the screen (shell) height has been changed, assume it is the</a>
<a name="ln2533">  // physical screenheight.</a>
<a name="ln2534">  if (p_lines != Rows || p_columns != Columns) {</a>
<a name="ln2535">    // Changing the screen size is not allowed while updating the screen.</a>
<a name="ln2536">    if (updating_screen) {</a>
<a name="ln2537">      *pp = old_value;</a>
<a name="ln2538">    } else if (full_screen) {</a>
<a name="ln2539">      screen_resize((int)p_columns, (int)p_lines);</a>
<a name="ln2540">    } else {</a>
<a name="ln2541">      // TODO(bfredl): is this branch ever needed?</a>
<a name="ln2542">      // Postpone the resizing; check the size and cmdline position for</a>
<a name="ln2543">      // messages.</a>
<a name="ln2544">      Rows = (int)p_lines;</a>
<a name="ln2545">      Columns = (int)p_columns;</a>
<a name="ln2546">      check_screensize();</a>
<a name="ln2547">      int new_row = (int)(Rows - MAX(p_ch, 1));</a>
<a name="ln2548">      if (cmdline_row &gt; new_row &amp;&amp; Rows &gt; p_ch) {</a>
<a name="ln2549">        assert(p_ch &gt;= 0 &amp;&amp; new_row &lt;= INT_MAX);</a>
<a name="ln2550">        cmdline_row = new_row;</a>
<a name="ln2551">      }</a>
<a name="ln2552">    }</a>
<a name="ln2553">    if (p_window &gt;= Rows || !option_was_set(&quot;window&quot;)) {</a>
<a name="ln2554">      p_window = Rows - 1;</a>
<a name="ln2555">    }</a>
<a name="ln2556">  }</a>
<a name="ln2557"> </a>
<a name="ln2558">  if ((curwin-&gt;w_p_scr &lt;= 0</a>
<a name="ln2559">       || (curwin-&gt;w_p_scr &gt; curwin-&gt;w_height</a>
<a name="ln2560">           &amp;&amp; curwin-&gt;w_height &gt; 0))</a>
<a name="ln2561">      &amp;&amp; full_screen) {</a>
<a name="ln2562">    if (pp == &amp;(curwin-&gt;w_p_scr)) {</a>
<a name="ln2563">      if (curwin-&gt;w_p_scr != 0) {</a>
<a name="ln2564">        errmsg = e_scroll;</a>
<a name="ln2565">      }</a>
<a name="ln2566">      win_comp_scroll(curwin);</a>
<a name="ln2567">    } else if (curwin-&gt;w_p_scr &lt;= 0) {</a>
<a name="ln2568">      // If 'scroll' became invalid because of a side effect silently adjust it.</a>
<a name="ln2569">      curwin-&gt;w_p_scr = 1;</a>
<a name="ln2570">    } else {  // curwin-&gt;w_p_scr &gt; curwin-&gt;w_height</a>
<a name="ln2571">      curwin-&gt;w_p_scr = curwin-&gt;w_height;</a>
<a name="ln2572">    }</a>
<a name="ln2573">  }</a>
<a name="ln2574">  if ((p_sj &lt; -100 || p_sj &gt;= Rows) &amp;&amp; full_screen) {</a>
<a name="ln2575">    if (Rows != old_Rows) {     // Rows changed, just adjust p_sj</a>
<a name="ln2576">      p_sj = Rows / 2;</a>
<a name="ln2577">    } else {</a>
<a name="ln2578">      errmsg = e_scroll;</a>
<a name="ln2579">      p_sj = 1;</a>
<a name="ln2580">    }</a>
<a name="ln2581">  }</a>
<a name="ln2582"> </a>
<a name="ln2583">  // May set global value for local option.</a>
<a name="ln2584">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln2585">    *(long *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) = *pp;</a>
<a name="ln2586">  }</a>
<a name="ln2587"> </a>
<a name="ln2588">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln2589"> </a>
<a name="ln2590">  // Don't do this while starting up, failure or recursively.</a>
<a name="ln2591">  if (!starting &amp;&amp; errmsg == NULL &amp;&amp; *get_vim_var_str(VV_OPTION_TYPE) == NUL) {</a>
<a name="ln2592">    char buf_old[NUMBUFLEN];</a>
<a name="ln2593">    char buf_old_global[NUMBUFLEN];</a>
<a name="ln2594">    char buf_new[NUMBUFLEN];</a>
<a name="ln2595">    char buf_type[7];</a>
<a name="ln2596"> </a>
<a name="ln2597">    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), &quot;%ld&quot;, old_value);</a>
<a name="ln2598">    vim_snprintf(buf_old_global, ARRAY_SIZE(buf_old_global), &quot;%ld&quot;, old_global_value);</a>
<a name="ln2599">    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), &quot;%ld&quot;, value);</a>
<a name="ln2600">    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), &quot;%s&quot;,</a>
<a name="ln2601">                 (opt_flags &amp; OPT_LOCAL) ? &quot;local&quot; : &quot;global&quot;);</a>
<a name="ln2602">    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);</a>
<a name="ln2603">    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);</a>
<a name="ln2604">    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);</a>
<a name="ln2605">    if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln2606">      set_vim_var_string(VV_OPTION_COMMAND, &quot;setlocal&quot;, -1);</a>
<a name="ln2607">      set_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);</a>
<a name="ln2608">    }</a>
<a name="ln2609">    if (opt_flags &amp; OPT_GLOBAL) {</a>
<a name="ln2610">      set_vim_var_string(VV_OPTION_COMMAND, &quot;setglobal&quot;, -1);</a>
<a name="ln2611">      set_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old, -1);</a>
<a name="ln2612">    }</a>
<a name="ln2613">    if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln2614">      set_vim_var_string(VV_OPTION_COMMAND, &quot;set&quot;, -1);</a>
<a name="ln2615">      set_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);</a>
<a name="ln2616">      set_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old_global, -1);</a>
<a name="ln2617">    }</a>
<a name="ln2618">    if (opt_flags &amp; OPT_MODELINE) {</a>
<a name="ln2619">      set_vim_var_string(VV_OPTION_COMMAND, &quot;modeline&quot;, -1);</a>
<a name="ln2620">      set_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);</a>
<a name="ln2621">    }</a>
<a name="ln2622">    apply_autocmds(EVENT_OPTIONSET, options[opt_idx].fullname, NULL, false, NULL);</a>
<a name="ln2623">    reset_v_option_vars();</a>
<a name="ln2624">  }</a>
<a name="ln2625"> </a>
<a name="ln2626">  if (errmsg == NULL &amp;&amp; options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln2627">    ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln2628">                       INTEGER_OBJ(*pp));</a>
<a name="ln2629">  }</a>
<a name="ln2630"> </a>
<a name="ln2631">  comp_col();                       // in case 'columns' or 'ls' changed</a>
<a name="ln2632">  if (curwin-&gt;w_curswant != MAXCOL</a>
<a name="ln2633">      &amp;&amp; (options[opt_idx].flags &amp; (P_CURSWANT | P_RALL)) != 0) {</a>
<a name="ln2634">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln2635">  }</a>
<a name="ln2636">  check_redraw(options[opt_idx].flags);</a>
<a name="ln2637"> </a>
<a name="ln2638">  return errmsg;</a>
<a name="ln2639">}</a>
<a name="ln2640"> </a>
<a name="ln2641">/// Called after an option changed: check if something needs to be redrawn.</a>
<a name="ln2642">void check_redraw(uint32_t flags)</a>
<a name="ln2643">{</a>
<a name="ln2644">  // Careful: P_RALL is a combination of other P_ flags</a>
<a name="ln2645">  bool all = (flags &amp; P_RALL) == P_RALL;</a>
<a name="ln2646"> </a>
<a name="ln2647">  if ((flags &amp; P_RSTAT) || all) {  // mark all status lines and window bars dirty</a>
<a name="ln2648">    status_redraw_all();</a>
<a name="ln2649">  }</a>
<a name="ln2650"> </a>
<a name="ln2651">  if ((flags &amp; P_RTABL) || all) {  // mark tablines dirty</a>
<a name="ln2652">    redraw_tabline = true;</a>
<a name="ln2653">  }</a>
<a name="ln2654"> </a>
<a name="ln2655">  if ((flags &amp; P_RBUF) || (flags &amp; P_RWIN) || all) {</a>
<a name="ln2656">    changed_window_setting();</a>
<a name="ln2657">  }</a>
<a name="ln2658">  if (flags &amp; P_RBUF) {</a>
<a name="ln2659">    redraw_curbuf_later(UPD_NOT_VALID);</a>
<a name="ln2660">  }</a>
<a name="ln2661">  if (flags &amp; P_RWINONLY) {</a>
<a name="ln2662">    redraw_later(curwin, UPD_NOT_VALID);</a>
<a name="ln2663">  }</a>
<a name="ln2664">  if (all) {</a>
<a name="ln2665">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln2666">  }</a>
<a name="ln2667">}</a>
<a name="ln2668"> </a>
<a name="ln2669">/// Find index for named option</a>
<a name="ln2670">///</a>
<a name="ln2671">/// @param[in]  arg  Option to find index for.</a>
<a name="ln2672">/// @param[in]  len  Length of the option.</a>
<a name="ln2673">///</a>
<a name="ln2674">/// @return Index of the option or -1 if option was not found.</a>
<a name="ln2675">int findoption_len(const char *const arg, const size_t len)</a>
<a name="ln2676">{</a>
<a name="ln2677">  const char *s;</a>
<a name="ln2678">  const char *p;</a>
<a name="ln2679">  static int quick_tab[27] = { 0, 0 };  // quick access table</a>
<a name="ln2680"> </a>
<a name="ln2681">  // For first call: Initialize the quick-access table.</a>
<a name="ln2682">  // It contains the index for the first option that starts with a certain</a>
<a name="ln2683">  // letter.  There are 26 letters, plus the first &quot;t_&quot; option.</a>
<a name="ln2684">  if (quick_tab[1] == 0) {</a>
<a name="ln2685">    p = options[0].fullname;</a>
<a name="ln2686">    for (uint16_t i = 1; (s = options[i].fullname) != NULL; i++) {</a>
<a name="ln2687">      if (s[0] != p[0]) {</a>
<a name="ln2688">        if (s[0] == 't' &amp;&amp; s[1] == '_') {</a>
<a name="ln2689">          quick_tab[26] = i;</a>
<a name="ln2690">        } else {</a>
<a name="ln2691">          quick_tab[CHAR_ORD_LOW(s[0])] = i;</a>
<a name="ln2692">        }</a>
<a name="ln2693">      }</a>
<a name="ln2694">      p = s;</a>
<a name="ln2695">    }</a>
<a name="ln2696">  }</a>
<a name="ln2697"> </a>
<a name="ln2698">  // Check for name starting with an illegal character.</a>
<a name="ln2699">  if (len == 0 || arg[0] &lt; 'a' || arg[0] &gt; 'z') {</a>
<a name="ln2700">    return -1;</a>
<a name="ln2701">  }</a>
<a name="ln2702"> </a>
<a name="ln2703">  int opt_idx;</a>
<a name="ln2704">  const bool is_term_opt = (len &gt; 2 &amp;&amp; arg[0] == 't' &amp;&amp; arg[1] == '_');</a>
<a name="ln2705">  if (is_term_opt) {</a>
<a name="ln2706">    opt_idx = quick_tab[26];</a>
<a name="ln2707">  } else {</a>
<a name="ln2708">    opt_idx = quick_tab[CHAR_ORD_LOW(arg[0])];</a>
<a name="ln2709">  }</a>
<a name="ln2710">  // Match full name</a>
<a name="ln2711">  for (; (s = options[opt_idx].fullname) != NULL; opt_idx++) {</a>
<a name="ln2712">    if (strncmp(arg, s, len) == 0 &amp;&amp; s[len] == NUL) {</a>
<a name="ln2713">      break;</a>
<a name="ln2714">    }</a>
<a name="ln2715">  }</a>
<a name="ln2716">  if (s == NULL &amp;&amp; !is_term_opt) {</a>
<a name="ln2717">    opt_idx = quick_tab[CHAR_ORD_LOW(arg[0])];</a>
<a name="ln2718">    // Match short name</a>
<a name="ln2719">    for (; options[opt_idx].fullname != NULL; opt_idx++) {</a>
<a name="ln2720">      s = options[opt_idx].shortname;</a>
<a name="ln2721">      if (s != NULL &amp;&amp; strncmp(arg, s, len) == 0 &amp;&amp; s[len] == NUL) {</a>
<a name="ln2722">        break;</a>
<a name="ln2723">      }</a>
<a name="ln2724">      s = NULL;</a>
<a name="ln2725">    }</a>
<a name="ln2726">  }</a>
<a name="ln2727">  if (s == NULL) {</a>
<a name="ln2728">    opt_idx = -1;</a>
<a name="ln2729">  } else {</a>
<a name="ln2730">    // Nvim: handle option aliases.</a>
<a name="ln2731">    if (STRNCMP(options[opt_idx].fullname, &quot;viminfo&quot;, 7) == 0) {</a>
<a name="ln2732">      if (strlen(options[opt_idx].fullname) == 7) {</a>
<a name="ln2733">        return findoption_len(&quot;shada&quot;, 5);</a>
<a name="ln2734">      }</a>
<a name="ln2735">      assert(strcmp(options[opt_idx].fullname, &quot;viminfofile&quot;) == 0);</a>
<a name="ln2736">      return findoption_len(&quot;shadafile&quot;, 9);</a>
<a name="ln2737">    }</a>
<a name="ln2738">  }</a>
<a name="ln2739">  return opt_idx;</a>
<a name="ln2740">}</a>
<a name="ln2741"> </a>
<a name="ln2742">bool is_tty_option(const char *name)</a>
<a name="ln2743">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2744">{</a>
<a name="ln2745">  return (name[0] == 't' &amp;&amp; name[1] == '_')</a>
<a name="ln2746">         || strequal(name, &quot;term&quot;)</a>
<a name="ln2747">         || strequal(name, &quot;ttytype&quot;);</a>
<a name="ln2748">}</a>
<a name="ln2749"> </a>
<a name="ln2750">#define TCO_BUFFER_SIZE 8</a>
<a name="ln2751">/// @param name TUI-related option</a>
<a name="ln2752">/// @param[out,allocated] value option string value</a>
<a name="ln2753">bool get_tty_option(const char *name, char **value)</a>
<a name="ln2754">{</a>
<a name="ln2755">  if (strequal(name, &quot;t_Co&quot;)) {</a>
<a name="ln2756">    if (value) {</a>
<a name="ln2757">      if (t_colors &lt;= 1) {</a>
<a name="ln2758">        *value = xstrdup(&quot;&quot;);</a>
<a name="ln2759">      } else {</a>
<a name="ln2760">        *value = xmalloc(TCO_BUFFER_SIZE);</a>
<a name="ln2761">        snprintf(*value, TCO_BUFFER_SIZE, &quot;%d&quot;, t_colors);</a>
<a name="ln2762">      }</a>
<a name="ln2763">    }</a>
<a name="ln2764">    return true;</a>
<a name="ln2765">  }</a>
<a name="ln2766"> </a>
<a name="ln2767">  if (strequal(name, &quot;term&quot;)) {</a>
<a name="ln2768">    if (value) {</a>
<a name="ln2769">      *value = p_term ? xstrdup(p_term) : xstrdup(&quot;nvim&quot;);</a>
<a name="ln2770">    }</a>
<a name="ln2771">    return true;</a>
<a name="ln2772">  }</a>
<a name="ln2773"> </a>
<a name="ln2774">  if (strequal(name, &quot;ttytype&quot;)) {</a>
<a name="ln2775">    if (value) {</a>
<a name="ln2776">      *value = p_ttytype ? xstrdup(p_ttytype) : xstrdup(&quot;nvim&quot;);</a>
<a name="ln2777">    }</a>
<a name="ln2778">    return true;</a>
<a name="ln2779">  }</a>
<a name="ln2780"> </a>
<a name="ln2781">  if (is_tty_option(name)) {</a>
<a name="ln2782">    if (value) {</a>
<a name="ln2783">      // XXX: All other t_* options were removed in 3baba1e7.</a>
<a name="ln2784">      *value = xstrdup(&quot;&quot;);</a>
<a name="ln2785">    }</a>
<a name="ln2786">    return true;</a>
<a name="ln2787">  }</a>
<a name="ln2788"> </a>
<a name="ln2789">  return false;</a>
<a name="ln2790">}</a>
<a name="ln2791"> </a>
<a name="ln2792">bool set_tty_option(const char *name, char *value)</a>
<a name="ln2793">{</a>
<a name="ln2794">  if (strequal(name, &quot;term&quot;)) {</a>
<a name="ln2795">    if (p_term) {</a>
<a name="ln2796">      xfree(p_term);</a>
<a name="ln2797">    }</a>
<a name="ln2798">    p_term = value;</a>
<a name="ln2799">    return true;</a>
<a name="ln2800">  }</a>
<a name="ln2801"> </a>
<a name="ln2802">  if (strequal(name, &quot;ttytype&quot;)) {</a>
<a name="ln2803">    if (p_ttytype) {</a>
<a name="ln2804">      xfree(p_ttytype);</a>
<a name="ln2805">    }</a>
<a name="ln2806">    p_ttytype = value;</a>
<a name="ln2807">    return true;</a>
<a name="ln2808">  }</a>
<a name="ln2809"> </a>
<a name="ln2810">  return false;</a>
<a name="ln2811">}</a>
<a name="ln2812"> </a>
<a name="ln2813">void set_tty_background(const char *value)</a>
<a name="ln2814">{</a>
<a name="ln2815">  if (option_was_set(&quot;bg&quot;) || strequal(p_bg, value)) {</a>
<a name="ln2816">    // background is already set... ignore</a>
<a name="ln2817">    return;</a>
<a name="ln2818">  }</a>
<a name="ln2819">  if (starting) {</a>
<a name="ln2820">    // Wait until after startup, so OptionSet is triggered.</a>
<a name="ln2821">    do_cmdline_cmd((value[0] == 'l')</a>
<a name="ln2822">                   ? &quot;autocmd VimEnter * ++once ++nested set bg=light&quot;</a>
<a name="ln2823">                   : &quot;autocmd VimEnter * ++once ++nested set bg=dark&quot;);</a>
<a name="ln2824">  } else {</a>
<a name="ln2825">    set_option_value_give_err(&quot;bg&quot;, 0L, value, 0);</a>
<a name="ln2826">    reset_option_was_set(&quot;bg&quot;);</a>
<a name="ln2827">  }</a>
<a name="ln2828">}</a>
<a name="ln2829"> </a>
<a name="ln2830">/// Find index for an option</a>
<a name="ln2831">///</a>
<a name="ln2832">/// @param[in]  arg  Option name.</a>
<a name="ln2833">///</a>
<a name="ln2834">/// @return Option index or -1 if option was not found.</a>
<a name="ln2835">int findoption(const char *const arg)</a>
<a name="ln2836">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2837">{</a>
<a name="ln2838">  return findoption_len(arg, strlen(arg));</a>
<a name="ln2839">}</a>
<a name="ln2840"> </a>
<a name="ln2841">/// Gets the value for an option.</a>
<a name="ln2842">///</a>
<a name="ln2843">/// @param stringval  NULL when only checking existence</a>
<a name="ln2844">///</a>
<a name="ln2845">/// @returns:</a>
<a name="ln2846">///           Number option: gov_number, *numval gets value.</a>
<a name="ln2847">///           Tottle option: gov_bool,   *numval gets value.</a>
<a name="ln2848">///           String option: gov_string, *stringval gets allocated string.</a>
<a name="ln2849">///           Hidden Number option: gov_hidden_number.</a>
<a name="ln2850">///           Hidden Toggle option: gov_hidden_bool.</a>
<a name="ln2851">///           Hidden String option: gov_hidden_string.</a>
<a name="ln2852">///           Unknown option: gov_unknown.</a>
<a name="ln2853">getoption_T get_option_value(const char *name, long *numval, char **stringval, int opt_flags)</a>
<a name="ln2854">{</a>
<a name="ln2855">  if (get_tty_option(name, stringval)) {</a>
<a name="ln2856">    return gov_string;</a>
<a name="ln2857">  }</a>
<a name="ln2858"> </a>
<a name="ln2859">  int opt_idx = findoption(name);</a>
<a name="ln2860">  if (opt_idx &lt; 0) {  // option not in the table</a>
<a name="ln2861">    return gov_unknown;</a>
<a name="ln2862">  }</a>
<a name="ln2863"> </a>
<a name="ln2864">  char_u *varp = (char_u *)get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln2865"> </a>
<a name="ln2866">  if (options[opt_idx].flags &amp; P_STRING) {</a>
<a name="ln2867">    if (varp == NULL) {  // hidden option</a>
<a name="ln2868">      return gov_hidden_string;</a>
<a name="ln2869">    }</a>
<a name="ln2870">    if (stringval != NULL) {</a>
<a name="ln2871">      if ((char **)varp == &amp;p_pt) {  // 'pastetoggle'</a>
<a name="ln2872">        *stringval = str2special_save(*(char **)(varp), false, false);</a>
<a name="ln2873">      } else {</a>
<a name="ln2874">        *stringval = xstrdup(*(char **)(varp));</a>
<a name="ln2875">      }</a>
<a name="ln2876">    }</a>
<a name="ln2877">    return gov_string;</a>
<a name="ln2878">  }</a>
<a name="ln2879"> </a>
<a name="ln2880">  if (varp == NULL) {  // hidden option</a>
<a name="ln2881">    return (options[opt_idx].flags &amp; P_NUM) ? gov_hidden_number : gov_hidden_bool;</a>
<a name="ln2882">  }</a>
<a name="ln2883">  if (options[opt_idx].flags &amp; P_NUM) {</a>
<a name="ln2884">    *numval = *(long *)varp;</a>
<a name="ln2885">  } else {</a>
<a name="ln2886">    // Special case: 'modified' is b_changed, but we also want to consider</a>
<a name="ln2887">    // it set when 'ff' or 'fenc' changed.</a>
<a name="ln2888">    if ((int *)varp == &amp;curbuf-&gt;b_changed) {</a>
<a name="ln2889">      *numval = curbufIsChanged();</a>
<a name="ln2890">    } else {</a>
<a name="ln2891">      *numval = (long)(*(int *)varp);</a>
<a name="ln2892">    }</a>
<a name="ln2893">  }</a>
<a name="ln2894">  return (options[opt_idx].flags &amp; P_NUM) ? gov_number : gov_bool;</a>
<a name="ln2895">}</a>
<a name="ln2896"> </a>
<a name="ln2897">// Returns the option attributes and its value. Unlike the above function it</a>
<a name="ln2898">// will return either global value or local value of the option depending on</a>
<a name="ln2899">// what was requested, but it will never return global value if it was</a>
<a name="ln2900">// requested to return local one and vice versa. Neither it will return</a>
<a name="ln2901">// buffer-local value if it was requested to return window-local one.</a>
<a name="ln2902">//</a>
<a name="ln2903">// Pretends that option is absent if it is not present in the requested scope</a>
<a name="ln2904">// (i.e. has no global, window-local or buffer-local value depending on</a>
<a name="ln2905">// opt_type).</a>
<a name="ln2906">//</a>
<a name="ln2907">// Returned flags:</a>
<a name="ln2908">//       0 hidden or unknown option, also option that does not have requested</a>
<a name="ln2909">//         type (see SREQ_* in option_defs.h)</a>
<a name="ln2910">//  see SOPT_* in option_defs.h for other flags</a>
<a name="ln2911">//</a>
<a name="ln2912">// Possible opt_type values: see SREQ_* in option_defs.h</a>
<a name="ln2913">int get_option_value_strict(char *name, int64_t *numval, char **stringval, int opt_type, void *from)</a>
<a name="ln2914">{</a>
<a name="ln2915">  if (get_tty_option(name, stringval)) {</a>
<a name="ln2916">    return SOPT_STRING | SOPT_GLOBAL;</a>
<a name="ln2917">  }</a>
<a name="ln2918"> </a>
<a name="ln2919">  char_u *varp = NULL;</a>
<a name="ln2920">  int rv = 0;</a>
<a name="ln2921">  int opt_idx = findoption(name);</a>
<a name="ln2922">  if (opt_idx &lt; 0) {</a>
<a name="ln2923">    return 0;</a>
<a name="ln2924">  }</a>
<a name="ln2925"> </a>
<a name="ln2926">  vimoption_T *p = &amp;options[opt_idx];</a>
<a name="ln2927"> </a>
<a name="ln2928">  // Hidden option</a>
<a name="ln2929">  if (p-&gt;var == NULL) {</a>
<a name="ln2930">    return 0;</a>
<a name="ln2931">  }</a>
<a name="ln2932"> </a>
<a name="ln2933">  if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln2934">    rv |= SOPT_BOOL;</a>
<a name="ln2935">  } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln2936">    rv |= SOPT_NUM;</a>
<a name="ln2937">  } else if (p-&gt;flags &amp; P_STRING) {</a>
<a name="ln2938">    rv |= SOPT_STRING;</a>
<a name="ln2939">  }</a>
<a name="ln2940"> </a>
<a name="ln2941">  if (p-&gt;indir == PV_NONE) {</a>
<a name="ln2942">    if (opt_type == SREQ_GLOBAL) {</a>
<a name="ln2943">      rv |= SOPT_GLOBAL;</a>
<a name="ln2944">    } else {</a>
<a name="ln2945">      return 0;  // Did not request global-only option</a>
<a name="ln2946">    }</a>
<a name="ln2947">  } else {</a>
<a name="ln2948">    if (p-&gt;indir &amp; PV_BOTH) {</a>
<a name="ln2949">      rv |= SOPT_GLOBAL;</a>
<a name="ln2950">    }</a>
<a name="ln2951"> </a>
<a name="ln2952">    if (p-&gt;indir &amp; PV_WIN) {</a>
<a name="ln2953">      if (opt_type == SREQ_BUF) {</a>
<a name="ln2954">        return 0;  // Requested buffer-local, not window-local option</a>
<a name="ln2955">      } else {</a>
<a name="ln2956">        rv |= SOPT_WIN;</a>
<a name="ln2957">      }</a>
<a name="ln2958">    } else if (p-&gt;indir &amp; PV_BUF) {</a>
<a name="ln2959">      if (opt_type == SREQ_WIN) {</a>
<a name="ln2960">        return 0;  // Requested window-local, not buffer-local option</a>
<a name="ln2961">      } else {</a>
<a name="ln2962">        rv |= SOPT_BUF;</a>
<a name="ln2963">      }</a>
<a name="ln2964">    }</a>
<a name="ln2965">  }</a>
<a name="ln2966"> </a>
<a name="ln2967">  if (stringval == NULL) {</a>
<a name="ln2968">    return rv;</a>
<a name="ln2969">  }</a>
<a name="ln2970"> </a>
<a name="ln2971">  if (opt_type == SREQ_GLOBAL) {</a>
<a name="ln2972">    if (p-&gt;var == VAR_WIN) {</a>
<a name="ln2973">      return 0;</a>
<a name="ln2974">    } else {</a>
<a name="ln2975">      varp = p-&gt;var;</a>
<a name="ln2976">    }</a>
<a name="ln2977">  } else {</a>
<a name="ln2978">    if (opt_type == SREQ_BUF) {</a>
<a name="ln2979">      // Special case: 'modified' is b_changed, but we also want to</a>
<a name="ln2980">      // consider it set when 'ff' or 'fenc' changed.</a>
<a name="ln2981">      if (p-&gt;indir == PV_MOD) {</a>
<a name="ln2982">        *numval = bufIsChanged((buf_T *)from);</a>
<a name="ln2983">        varp = NULL;</a>
<a name="ln2984">      } else {</a>
<a name="ln2985">        buf_T *save_curbuf = curbuf;</a>
<a name="ln2986"> </a>
<a name="ln2987">        // only getting a pointer, no need to use aucmd_prepbuf()</a>
<a name="ln2988">        curbuf = (buf_T *)from;</a>
<a name="ln2989">        curwin-&gt;w_buffer = curbuf;</a>
<a name="ln2990">        varp = (char_u *)get_varp_scope(p, OPT_LOCAL);</a>
<a name="ln2991">        curbuf = save_curbuf;</a>
<a name="ln2992">        curwin-&gt;w_buffer = curbuf;</a>
<a name="ln2993">      }</a>
<a name="ln2994">    } else if (opt_type == SREQ_WIN) {</a>
<a name="ln2995">      win_T *save_curwin = curwin;</a>
<a name="ln2996">      curwin = (win_T *)from;</a>
<a name="ln2997">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln2998">      varp = (char_u *)get_varp_scope(p, OPT_LOCAL);</a>
<a name="ln2999">      curwin = save_curwin;</a>
<a name="ln3000">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln3001">    }</a>
<a name="ln3002"> </a>
<a name="ln3003">    if (varp == p-&gt;var) {</a>
<a name="ln3004">      return (rv | SOPT_UNSET);</a>
<a name="ln3005">    }</a>
<a name="ln3006">  }</a>
<a name="ln3007"> </a>
<a name="ln3008">  if (varp != NULL) {</a>
<a name="ln3009">    if (p-&gt;flags &amp; P_STRING) {</a>
<a name="ln3010">      *stringval = xstrdup(*(char **)(varp));</a>
<a name="ln3011">    } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln3012">      *numval = *(long *)varp;</a>
<a name="ln3013">    } else {</a>
<a name="ln3014">      *numval = *(int *)varp;</a>
<a name="ln3015">    }</a>
<a name="ln3016">  }</a>
<a name="ln3017"> </a>
<a name="ln3018">  return rv;</a>
<a name="ln3019">}</a>
<a name="ln3020"> </a>
<a name="ln3021">// Return information for option at 'opt_idx'</a>
<a name="ln3022">vimoption_T *get_option(int opt_idx)</a>
<a name="ln3023">{</a>
<a name="ln3024">  return &amp;options[opt_idx];</a>
<a name="ln3025">}</a>
<a name="ln3026"> </a>
<a name="ln3027">/// Set the value of an option</a>
<a name="ln3028">///</a>
<a name="ln3029">/// @param[in]  name  Option name.</a>
<a name="ln3030">/// @param[in]  number  New value for the number or boolean option.</a>
<a name="ln3031">/// @param[in]  string  New value for string option.</a>
<a name="ln3032">/// @param[in]  opt_flags  Flags: OPT_LOCAL, OPT_GLOBAL, or 0 (both).</a>
<a name="ln3033">///                        If OPT_CLEAR is set, the value of the option</a>
<a name="ln3034">///                        is cleared  (the exact semantics of this depend</a>
<a name="ln3035">///                        on the option).</a>
<a name="ln3036">///</a>
<a name="ln3037">/// @return NULL on success, an untranslated error message on error.</a>
<a name="ln3038">char *set_option_value(const char *const name, const long number, const char *const string,</a>
<a name="ln3039">                       const int opt_flags)</a>
<a name="ln3040">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3041">{</a>
<a name="ln3042">  if (is_tty_option(name)) {</a>
<a name="ln3043">    return NULL;  // Fail silently; many old vimrcs set t_xx options.</a>
<a name="ln3044">  }</a>
<a name="ln3045"> </a>
<a name="ln3046">  int opt_idx;</a>
<a name="ln3047">  char_u *varp;</a>
<a name="ln3048"> </a>
<a name="ln3049">  opt_idx = findoption(name);</a>
<a name="ln3050">  if (opt_idx &lt; 0) {</a>
<a name="ln3051">    semsg(_(&quot;E355: Unknown option: %s&quot;), name);</a>
<a name="ln3052">  } else {</a>
<a name="ln3053">    uint32_t flags = options[opt_idx].flags;</a>
<a name="ln3054">    // Disallow changing some options in the sandbox</a>
<a name="ln3055">    if (sandbox &gt; 0 &amp;&amp; (flags &amp; P_SECURE)) {</a>
<a name="ln3056">      emsg(_(e_sandbox));</a>
<a name="ln3057">      return NULL;</a>
<a name="ln3058">    }</a>
<a name="ln3059">    if (flags &amp; P_STRING) {</a>
<a name="ln3060">      const char *s = string;</a>
<a name="ln3061">      if (s == NULL || opt_flags &amp; OPT_CLEAR) {</a>
<a name="ln3062">        s = &quot;&quot;;</a>
<a name="ln3063">      }</a>
<a name="ln3064">      return set_string_option(opt_idx, s, opt_flags);</a>
<a name="ln3065">    }</a>
<a name="ln3066"> </a>
<a name="ln3067">    varp = (char_u *)get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln3068">    if (varp != NULL) {       // hidden option is not changed</a>
<a name="ln3069">      if (number == 0 &amp;&amp; string != NULL) {</a>
<a name="ln3070">        int idx;</a>
<a name="ln3071"> </a>
<a name="ln3072">        // Either we are given a string or we are setting option</a>
<a name="ln3073">        // to zero.</a>
<a name="ln3074">        for (idx = 0; string[idx] == '0'; idx++) {}</a>
<a name="ln3075">        if (string[idx] != NUL || idx == 0) {</a>
<a name="ln3076">          // There's another character after zeros or the string</a>
<a name="ln3077">          // is empty.  In both cases, we are trying to set a</a>
<a name="ln3078">          // num option using a string.</a>
<a name="ln3079">          semsg(_(&quot;E521: Number required: &amp;%s = '%s'&quot;),</a>
<a name="ln3080">                name, string);</a>
<a name="ln3081">          return NULL;  // do nothing as we hit an error</a>
<a name="ln3082">        }</a>
<a name="ln3083">      }</a>
<a name="ln3084">      long numval = number;</a>
<a name="ln3085">      if (opt_flags &amp; OPT_CLEAR) {</a>
<a name="ln3086">        if ((int *)varp == &amp;curbuf-&gt;b_p_ar) {</a>
<a name="ln3087">          numval = -1;</a>
<a name="ln3088">        } else if ((long *)varp == &amp;curbuf-&gt;b_p_ul) {</a>
<a name="ln3089">          numval = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln3090">        } else if ((long *)varp == &amp;curwin-&gt;w_p_so || (long *)varp == &amp;curwin-&gt;w_p_siso) {</a>
<a name="ln3091">          numval = -1;</a>
<a name="ln3092">        } else {</a>
<a name="ln3093">          char *s = NULL;</a>
<a name="ln3094">          (void)get_option_value(name, &amp;numval, &amp;s, OPT_GLOBAL);</a>
<a name="ln3095">        }</a>
<a name="ln3096">      }</a>
<a name="ln3097">      if (flags &amp; P_NUM) {</a>
<a name="ln3098">        return set_num_option(opt_idx, varp, numval, NULL, 0, opt_flags);</a>
<a name="ln3099">      } else {</a>
<a name="ln3100">        return set_bool_option(opt_idx, varp, (int)numval, opt_flags);</a>
<a name="ln3101">      }</a>
<a name="ln3102">    }</a>
<a name="ln3103">  }</a>
<a name="ln3104">  return NULL;</a>
<a name="ln3105">}</a>
<a name="ln3106"> </a>
<a name="ln3107">/// Call set_option_value() and when an error is returned report it.</a>
<a name="ln3108">///</a>
<a name="ln3109">/// @param opt_flags  OPT_LOCAL or 0 (both)</a>
<a name="ln3110">void set_option_value_give_err(const char *name, long number, const char *string, int opt_flags)</a>
<a name="ln3111">{</a>
<a name="ln3112">  char *errmsg = set_option_value(name, number, string, opt_flags);</a>
<a name="ln3113"> </a>
<a name="ln3114">  if (errmsg != NULL) {</a>
<a name="ln3115">    emsg(_(errmsg));</a>
<a name="ln3116">  }</a>
<a name="ln3117">}</a>
<a name="ln3118"> </a>
<a name="ln3119">bool is_option_allocated(const char *name)</a>
<a name="ln3120">{</a>
<a name="ln3121">  int idx = findoption(name);</a>
<a name="ln3122">  return idx &gt;= 0 &amp;&amp; (options[idx].flags &amp; P_ALLOCED);</a>
<a name="ln3123">}</a>
<a name="ln3124"> </a>
<a name="ln3125">/// Return true if &quot;name&quot; is a string option.</a>
<a name="ln3126">/// Returns false if option &quot;name&quot; does not exist.</a>
<a name="ln3127">bool is_string_option(const char *name)</a>
<a name="ln3128">{</a>
<a name="ln3129">  int idx = findoption(name);</a>
<a name="ln3130">  return idx &gt;= 0 &amp;&amp; (options[idx].flags &amp; P_STRING);</a>
<a name="ln3131">}</a>
<a name="ln3132"> </a>
<a name="ln3133">// Translate a string like &quot;t_xx&quot;, &quot;&lt;t_xx&gt;&quot; or &quot;&lt;S-Tab&gt;&quot; to a key number.</a>
<a name="ln3134">// When &quot;has_lt&quot; is true there is a '&lt;' before &quot;*arg_arg&quot;.</a>
<a name="ln3135">// Returns 0 when the key is not recognized.</a>
<a name="ln3136">int find_key_option_len(const char_u *arg_arg, size_t len, bool has_lt)</a>
<a name="ln3137">{</a>
<a name="ln3138">  int key = 0;</a>
<a name="ln3139">  int modifiers;</a>
<a name="ln3140">  const char_u *arg = arg_arg;</a>
<a name="ln3141"> </a>
<a name="ln3142">  // Don't use get_special_key_code() for t_xx, we don't want it to call</a>
<a name="ln3143">  // add_termcap_entry().</a>
<a name="ln3144">  if (len &gt;= 4 &amp;&amp; arg[0] == 't' &amp;&amp; arg[1] == '_') {</a>
<a name="ln3145">    key = TERMCAP2KEY(arg[2], arg[3]);</a>
<a name="ln3146">  } else if (has_lt) {</a>
<a name="ln3147">    arg--;  // put arg at the '&lt;'</a>
<a name="ln3148">    modifiers = 0;</a>
<a name="ln3149">    key = find_special_key(&amp;arg, len + 1, &amp;modifiers,</a>
<a name="ln3150">                           FSK_KEYCODE | FSK_KEEP_X_KEY | FSK_SIMPLIFY, NULL);</a>
<a name="ln3151">    if (modifiers) {  // can't handle modifiers here</a>
<a name="ln3152">      key = 0;</a>
<a name="ln3153">    }</a>
<a name="ln3154">  }</a>
<a name="ln3155">  return key;</a>
<a name="ln3156">}</a>
<a name="ln3157"> </a>
<a name="ln3158">static int find_key_option(const char *arg, bool has_lt)</a>
<a name="ln3159">{</a>
<a name="ln3160">  return find_key_option_len((char_u *)arg, strlen(arg), has_lt);</a>
<a name="ln3161">}</a>
<a name="ln3162"> </a>
<a name="ln3163">/// if 'all' == 0: show changed options</a>
<a name="ln3164">/// if 'all' == 1: show all normal options</a>
<a name="ln3165">///</a>
<a name="ln3166">/// @param opt_flags  OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln3167">static void showoptions(int all, int opt_flags)</a>
<a name="ln3168">{</a>
<a name="ln3169">  vimoption_T *p;</a>
<a name="ln3170">  int col;</a>
<a name="ln3171">  char_u *varp;</a>
<a name="ln3172">  int item_count;</a>
<a name="ln3173">  int run;</a>
<a name="ln3174">  int row, rows;</a>
<a name="ln3175">  int cols;</a>
<a name="ln3176">  int i;</a>
<a name="ln3177">  int len;</a>
<a name="ln3178"> </a>
<a name="ln3179">#define INC 20</a>
<a name="ln3180">#define GAP 3</a>
<a name="ln3181"> </a>
<a name="ln3182">  vimoption_T **items = xmalloc(sizeof(vimoption_T *) * OPTION_COUNT);</a>
<a name="ln3183"> </a>
<a name="ln3184">  // Highlight title</a>
<a name="ln3185">  if (opt_flags &amp; OPT_GLOBAL) {</a>
<a name="ln3186">    msg_puts_title(_(&quot;\n--- Global option values ---&quot;));</a>
<a name="ln3187">  } else if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln3188">    msg_puts_title(_(&quot;\n--- Local option values ---&quot;));</a>
<a name="ln3189">  } else {</a>
<a name="ln3190">    msg_puts_title(_(&quot;\n--- Options ---&quot;));</a>
<a name="ln3191">  }</a>
<a name="ln3192"> </a>
<a name="ln3193">  // Do the loop two times:</a>
<a name="ln3194">  // 1. display the short items</a>
<a name="ln3195">  // 2. display the long items (only strings and numbers)</a>
<a name="ln3196">  // When &quot;opt_flags&quot; has OPT_ONECOLUMN do everything in run 2.</a>
<a name="ln3197">  for (run = 1; run &lt;= 2 &amp;&amp; !got_int; run++) {</a>
<a name="ln3198">    // collect the items in items[]</a>
<a name="ln3199">    item_count = 0;</a>
<a name="ln3200">    for (p = &amp;options[0]; p-&gt;fullname != NULL; p++) {</a>
<a name="ln3201">      // apply :filter /pat/</a>
<a name="ln3202">      if (message_filtered(p-&gt;fullname)) {</a>
<a name="ln3203">        continue;</a>
<a name="ln3204">      }</a>
<a name="ln3205"> </a>
<a name="ln3206">      varp = NULL;</a>
<a name="ln3207">      if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) != 0) {</a>
<a name="ln3208">        if (p-&gt;indir != PV_NONE) {</a>
<a name="ln3209">          varp = (char_u *)get_varp_scope(p, opt_flags);</a>
<a name="ln3210">        }</a>
<a name="ln3211">      } else {</a>
<a name="ln3212">        varp = get_varp(p);</a>
<a name="ln3213">      }</a>
<a name="ln3214">      if (varp != NULL</a>
<a name="ln3215">          &amp;&amp; (all == 1 || (all == 0 &amp;&amp; !optval_default(p, varp)))) {</a>
<a name="ln3216">        if (opt_flags &amp; OPT_ONECOLUMN) {</a>
<a name="ln3217">          len = Columns;</a>
<a name="ln3218">        } else if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln3219">          len = 1;                      // a toggle option fits always</a>
<a name="ln3220">        } else {</a>
<a name="ln3221">          option_value2string(p, opt_flags);</a>
<a name="ln3222">          len = (int)strlen(p-&gt;fullname) + vim_strsize((char *)NameBuff) + 1;</a>
<a name="ln3223">        }</a>
<a name="ln3224">        if ((len &lt;= INC - GAP &amp;&amp; run == 1)</a>
<a name="ln3225">            || (len &gt; INC - GAP &amp;&amp; run == 2)) {</a>
<a name="ln3226">          items[item_count++] = p;</a>
<a name="ln3227">        }</a>
<a name="ln3228">      }</a>
<a name="ln3229">    }</a>
<a name="ln3230"> </a>
<a name="ln3231">    // display the items</a>
<a name="ln3232">    if (run == 1) {</a>
<a name="ln3233">      assert(Columns &lt;= INT_MAX - GAP</a>
<a name="ln3234">             &amp;&amp; Columns + GAP &gt;= INT_MIN + 3</a>
<a name="ln3235">             &amp;&amp; (Columns + GAP - 3) / INC &gt;= INT_MIN</a>
<a name="ln3236">             &amp;&amp; (Columns + GAP - 3) / INC &lt;= INT_MAX);</a>
<a name="ln3237">      cols = (Columns + GAP - 3) / INC;</a>
<a name="ln3238">      if (cols == 0) {</a>
<a name="ln3239">        cols = 1;</a>
<a name="ln3240">      }</a>
<a name="ln3241">      rows = (item_count + cols - 1) / cols;</a>
<a name="ln3242">    } else {    // run == 2</a>
<a name="ln3243">      rows = item_count;</a>
<a name="ln3244">    }</a>
<a name="ln3245">    for (row = 0; row &lt; rows &amp;&amp; !got_int; row++) {</a>
<a name="ln3246">      msg_putchar('\n');                        // go to next line</a>
<a name="ln3247">      if (got_int) {                            // 'q' typed in more</a>
<a name="ln3248">        break;</a>
<a name="ln3249">      }</a>
<a name="ln3250">      col = 0;</a>
<a name="ln3251">      for (i = row; i &lt; item_count; i += rows) {</a>
<a name="ln3252">        msg_col = col;                          // make columns</a>
<a name="ln3253">        showoneopt(items[i], opt_flags);</a>
<a name="ln3254">        col += INC;</a>
<a name="ln3255">      }</a>
<a name="ln3256">      os_breakcheck();</a>
<a name="ln3257">    }</a>
<a name="ln3258">  }</a>
<a name="ln3259">  xfree(items);</a>
<a name="ln3260">}</a>
<a name="ln3261"> </a>
<a name="ln3262">/// Return true if option &quot;p&quot; has its default value.</a>
<a name="ln3263">static int optval_default(vimoption_T *p, const char_u *varp)</a>
<a name="ln3264">{</a>
<a name="ln3265">  if (varp == NULL) {</a>
<a name="ln3266">    return true;            // hidden option is always at default</a>
<a name="ln3267">  }</a>
<a name="ln3268">  if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln3269">    return *(long *)varp == (long)(intptr_t)p-&gt;def_val;</a>
<a name="ln3270">  }</a>
<a name="ln3271">  if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln3272">    return *(int *)varp == (int)(intptr_t)p-&gt;def_val;</a>
<a name="ln3273">  }</a>
<a name="ln3274">  // P_STRING</a>
<a name="ln3275">  return strcmp(*(char **)varp, p-&gt;def_val) == 0;</a>
<a name="ln3276">}</a>
<a name="ln3277"> </a>
<a name="ln3278">/// Send update to UIs with values of UI relevant options</a>
<a name="ln3279">void ui_refresh_options(void)</a>
<a name="ln3280">{</a>
<a name="ln3281">  for (int opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln3282">    uint32_t flags = options[opt_idx].flags;</a>
<a name="ln3283">    if (!(flags &amp; P_UI_OPTION)) {</a>
<a name="ln3284">      continue;</a>
<a name="ln3285">    }</a>
<a name="ln3286">    String name = cstr_as_string(options[opt_idx].fullname);</a>
<a name="ln3287">    void *varp = options[opt_idx].var;</a>
<a name="ln3288">    Object value = OBJECT_INIT;</a>
<a name="ln3289">    if (flags &amp; P_BOOL) {</a>
<a name="ln3290">      value = BOOLEAN_OBJ(*(int *)varp);</a>
<a name="ln3291">    } else if (flags &amp; P_NUM) {</a>
<a name="ln3292">      value = INTEGER_OBJ(*(long *)varp);</a>
<a name="ln3293">    } else if (flags &amp; P_STRING) {</a>
<a name="ln3294">      // cstr_as_string handles NULL string</a>
<a name="ln3295">      value = STRING_OBJ(cstr_as_string(*(char **)varp));</a>
<a name="ln3296">    }</a>
<a name="ln3297">    ui_call_option_set(name, value);</a>
<a name="ln3298">  }</a>
<a name="ln3299">  if (p_mouse != NULL) {</a>
<a name="ln3300">    setmouse();</a>
<a name="ln3301">  }</a>
<a name="ln3302">}</a>
<a name="ln3303"> </a>
<a name="ln3304">/// showoneopt: show the value of one option</a>
<a name="ln3305">/// must not be called with a hidden option!</a>
<a name="ln3306">///</a>
<a name="ln3307">/// @param opt_flags  OPT_LOCAL or OPT_GLOBAL</a>
<a name="ln3308">static void showoneopt(vimoption_T *p, int opt_flags)</a>
<a name="ln3309">{</a>
<a name="ln3310">  int save_silent = silent_mode;</a>
<a name="ln3311"> </a>
<a name="ln3312">  silent_mode = false;</a>
<a name="ln3313">  info_message = true;          // use mch_msg(), not mch_errmsg()</a>
<a name="ln3314"> </a>
<a name="ln3315">  char_u *varp = (char_u *)get_varp_scope(p, opt_flags);</a>
<a name="ln3316"> </a>
<a name="ln3317">  // for 'modified' we also need to check if 'ff' or 'fenc' changed.</a>
<a name="ln3318">  if ((p-&gt;flags &amp; P_BOOL) &amp;&amp; ((int *)varp == &amp;curbuf-&gt;b_changed</a>
<a name="ln3319">                              ? !curbufIsChanged() : !*(int *)varp)) {</a>
<a name="ln3320">    msg_puts(&quot;no&quot;);</a>
<a name="ln3321">  } else if ((p-&gt;flags &amp; P_BOOL) &amp;&amp; *(int *)varp &lt; 0) {</a>
<a name="ln3322">    msg_puts(&quot;--&quot;);</a>
<a name="ln3323">  } else {</a>
<a name="ln3324">    msg_puts(&quot;  &quot;);</a>
<a name="ln3325">  }</a>
<a name="ln3326">  msg_puts(p-&gt;fullname);</a>
<a name="ln3327">  if (!(p-&gt;flags &amp; P_BOOL)) {</a>
<a name="ln3328">    msg_putchar('=');</a>
<a name="ln3329">    // put value string in NameBuff</a>
<a name="ln3330">    option_value2string(p, opt_flags);</a>
<a name="ln3331">    msg_outtrans((char *)NameBuff);</a>
<a name="ln3332">  }</a>
<a name="ln3333"> </a>
<a name="ln3334">  silent_mode = save_silent;</a>
<a name="ln3335">  info_message = false;</a>
<a name="ln3336">}</a>
<a name="ln3337"> </a>
<a name="ln3338">/// Write modified options as &quot;:set&quot; commands to a file.</a>
<a name="ln3339">///</a>
<a name="ln3340">/// There are three values for &quot;opt_flags&quot;:</a>
<a name="ln3341">/// OPT_GLOBAL:         Write global option values and fresh values of</a>
<a name="ln3342">///             buffer-local options (used for start of a session</a>
<a name="ln3343">///             file).</a>
<a name="ln3344">/// OPT_GLOBAL + OPT_LOCAL: Idem, add fresh values of window-local options for</a>
<a name="ln3345">///             curwin (used for a vimrc file).</a>
<a name="ln3346">/// OPT_LOCAL:          Write buffer-local option values for curbuf, fresh</a>
<a name="ln3347">///             and local values for window-local options of</a>
<a name="ln3348">///             curwin.  Local values are also written when at the</a>
<a name="ln3349">///             default value, because a modeline or autocommand</a>
<a name="ln3350">///             may have set them when doing &quot;:edit file&quot; and the</a>
<a name="ln3351">///             user has set them back at the default or fresh</a>
<a name="ln3352">///             value.</a>
<a name="ln3353">///             When &quot;local_only&quot; is true, don't write fresh</a>
<a name="ln3354">///             values, only local values (for &quot;:mkview&quot;).</a>
<a name="ln3355">/// (fresh value = value used for a new buffer or window for a local option).</a>
<a name="ln3356">///</a>
<a name="ln3357">/// Return FAIL on error, OK otherwise.</a>
<a name="ln3358">int makeset(FILE *fd, int opt_flags, int local_only)</a>
<a name="ln3359">{</a>
<a name="ln3360">  vimoption_T *p;</a>
<a name="ln3361">  char *varp;                      // currently used value</a>
<a name="ln3362">  char_u *varp_fresh;              // local value</a>
<a name="ln3363">  char_u *varp_local = NULL;       // fresh value</a>
<a name="ln3364">  char *cmd;</a>
<a name="ln3365">  int round;</a>
<a name="ln3366">  int pri;</a>
<a name="ln3367"> </a>
<a name="ln3368">  // Some options are never written:</a>
<a name="ln3369">  // - Options that don't have a default (terminal name, columns, lines).</a>
<a name="ln3370">  // - Terminal options.</a>
<a name="ln3371">  // - Hidden options.</a>
<a name="ln3372">  //</a>
<a name="ln3373">  // Do the loop over &quot;options[]&quot; twice: once for options with the</a>
<a name="ln3374">  // P_PRI_MKRC flag and once without.</a>
<a name="ln3375">  for (pri = 1; pri &gt;= 0; pri--) {</a>
<a name="ln3376">    for (p = &amp;options[0]; p-&gt;fullname; p++) {</a>
<a name="ln3377">      if (!(p-&gt;flags &amp; P_NO_MKRC)</a>
<a name="ln3378">          &amp;&amp; ((pri == 1) == ((p-&gt;flags &amp; P_PRI_MKRC) != 0))) {</a>
<a name="ln3379">        // skip global option when only doing locals</a>
<a name="ln3380">        if (p-&gt;indir == PV_NONE &amp;&amp; !(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln3381">          continue;</a>
<a name="ln3382">        }</a>
<a name="ln3383"> </a>
<a name="ln3384">        // Do not store options like 'bufhidden' and 'syntax' in a vimrc</a>
<a name="ln3385">        // file, they are always buffer-specific.</a>
<a name="ln3386">        if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; (p-&gt;flags &amp; P_NOGLOB)) {</a>
<a name="ln3387">          continue;</a>
<a name="ln3388">        }</a>
<a name="ln3389"> </a>
<a name="ln3390">        varp = get_varp_scope(p, opt_flags);</a>
<a name="ln3391">        // Hidden options are never written.</a>
<a name="ln3392">        if (!varp) {</a>
<a name="ln3393">          continue;</a>
<a name="ln3394">        }</a>
<a name="ln3395">        // Global values are only written when not at the default value.</a>
<a name="ln3396">        if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; optval_default(p, (char_u *)varp)) {</a>
<a name="ln3397">          continue;</a>
<a name="ln3398">        }</a>
<a name="ln3399"> </a>
<a name="ln3400">        if ((opt_flags &amp; OPT_SKIPRTP)</a>
<a name="ln3401">            &amp;&amp; (p-&gt;var == (char_u *)&amp;p_rtp || p-&gt;var == (char_u *)&amp;p_pp)) {</a>
<a name="ln3402">          continue;</a>
<a name="ln3403">        }</a>
<a name="ln3404"> </a>
<a name="ln3405">        round = 2;</a>
<a name="ln3406">        if (p-&gt;indir != PV_NONE) {</a>
<a name="ln3407">          if (p-&gt;var == VAR_WIN) {</a>
<a name="ln3408">            // skip window-local option when only doing globals</a>
<a name="ln3409">            if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln3410">              continue;</a>
<a name="ln3411">            }</a>
<a name="ln3412">            // When fresh value of window-local option is not at the</a>
<a name="ln3413">            // default, need to write it too.</a>
<a name="ln3414">            if (!(opt_flags &amp; OPT_GLOBAL) &amp;&amp; !local_only) {</a>
<a name="ln3415">              varp_fresh = (char_u *)get_varp_scope(p, OPT_GLOBAL);</a>
<a name="ln3416">              if (!optval_default(p, varp_fresh)) {</a>
<a name="ln3417">                round = 1;</a>
<a name="ln3418">                varp_local = (char_u *)varp;</a>
<a name="ln3419">                varp = (char *)varp_fresh;</a>
<a name="ln3420">              }</a>
<a name="ln3421">            }</a>
<a name="ln3422">          }</a>
<a name="ln3423">        }</a>
<a name="ln3424"> </a>
<a name="ln3425">        // Round 1: fresh value for window-local options.</a>
<a name="ln3426">        // Round 2: other values</a>
<a name="ln3427">        for (; round &lt;= 2; varp = (char *)varp_local, round++) {</a>
<a name="ln3428">          if (round == 1 || (opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln3429">            cmd = &quot;set&quot;;</a>
<a name="ln3430">          } else {</a>
<a name="ln3431">            cmd = &quot;setlocal&quot;;</a>
<a name="ln3432">          }</a>
<a name="ln3433"> </a>
<a name="ln3434">          if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln3435">            if (put_setbool(fd, cmd, p-&gt;fullname, *(int *)varp) == FAIL) {</a>
<a name="ln3436">              return FAIL;</a>
<a name="ln3437">            }</a>
<a name="ln3438">          } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln3439">            if (put_setnum(fd, cmd, p-&gt;fullname, (long *)varp) == FAIL) {</a>
<a name="ln3440">              return FAIL;</a>
<a name="ln3441">            }</a>
<a name="ln3442">          } else {    // P_STRING</a>
<a name="ln3443">            int do_endif = false;</a>
<a name="ln3444"> </a>
<a name="ln3445">            // Don't set 'syntax' and 'filetype' again if the value is</a>
<a name="ln3446">            // already right, avoids reloading the syntax file.</a>
<a name="ln3447">            if (p-&gt;indir == PV_SYN || p-&gt;indir == PV_FT) {</a>
<a name="ln3448">              if (fprintf(fd, &quot;if &amp;%s != '%s'&quot;, p-&gt;fullname,</a>
<a name="ln3449">                          *(char_u **)(varp)) &lt; 0</a>
<a name="ln3450">                  || put_eol(fd) &lt; 0) {</a>
<a name="ln3451">                return FAIL;</a>
<a name="ln3452">              }</a>
<a name="ln3453">              do_endif = true;</a>
<a name="ln3454">            }</a>
<a name="ln3455">            if (put_setstring(fd, cmd, p-&gt;fullname, (char **)varp, p-&gt;flags) == FAIL) {</a>
<a name="ln3456">              return FAIL;</a>
<a name="ln3457">            }</a>
<a name="ln3458">            if (do_endif) {</a>
<a name="ln3459">              if (put_line(fd, &quot;endif&quot;) == FAIL) {</a>
<a name="ln3460">                return FAIL;</a>
<a name="ln3461">              }</a>
<a name="ln3462">            }</a>
<a name="ln3463">          }</a>
<a name="ln3464">        }</a>
<a name="ln3465">      }</a>
<a name="ln3466">    }</a>
<a name="ln3467">  }</a>
<a name="ln3468">  return OK;</a>
<a name="ln3469">}</a>
<a name="ln3470"> </a>
<a name="ln3471">/// Generate set commands for the local fold options only.  Used when</a>
<a name="ln3472">/// 'sessionoptions' or 'viewoptions' contains &quot;folds&quot; but not &quot;options&quot;.</a>
<a name="ln3473">int makefoldset(FILE *fd)</a>
<a name="ln3474">{</a>
<a name="ln3475">  if (put_setstring(fd, &quot;setlocal&quot;, &quot;fdm&quot;, &amp;curwin-&gt;w_p_fdm, 0) == FAIL</a>
<a name="ln3476">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fde&quot;, &amp;curwin-&gt;w_p_fde, 0) == FAIL</a>
<a name="ln3477">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fmr&quot;, &amp;curwin-&gt;w_p_fmr, 0) == FAIL</a>
<a name="ln3478">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fdi&quot;, &amp;curwin-&gt;w_p_fdi, 0) == FAIL</a>
<a name="ln3479">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fdl&quot;, &amp;curwin-&gt;w_p_fdl) == FAIL</a>
<a name="ln3480">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fml&quot;, &amp;curwin-&gt;w_p_fml) == FAIL</a>
<a name="ln3481">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fdn&quot;, &amp;curwin-&gt;w_p_fdn) == FAIL</a>
<a name="ln3482">      || put_setbool(fd, &quot;setlocal&quot;, &quot;fen&quot;, curwin-&gt;w_p_fen) == FAIL) {</a>
<a name="ln3483">    return FAIL;</a>
<a name="ln3484">  }</a>
<a name="ln3485"> </a>
<a name="ln3486">  return OK;</a>
<a name="ln3487">}</a>
<a name="ln3488"> </a>
<a name="ln3489">static int put_setstring(FILE *fd, char *cmd, char *name, char **valuep, uint64_t flags)</a>
<a name="ln3490">{</a>
<a name="ln3491">  char_u *s;</a>
<a name="ln3492">  char_u *buf = NULL;</a>
<a name="ln3493">  char_u *part = NULL;</a>
<a name="ln3494">  char *p;</a>
<a name="ln3495"> </a>
<a name="ln3496">  if (fprintf(fd, &quot;%s %s=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln3497">    return FAIL;</a>
<a name="ln3498">  }</a>
<a name="ln3499">  if (*valuep != NULL) {</a>
<a name="ln3500">    // Output 'pastetoggle' as key names.  For other</a>
<a name="ln3501">    // options some characters have to be escaped with</a>
<a name="ln3502">    // CTRL-V or backslash</a>
<a name="ln3503">    if (valuep == &amp;p_pt) {</a>
<a name="ln3504">      s = (char_u *)(*valuep);</a>
<a name="ln3505">      while (*s != NUL) {</a>
<a name="ln3506">        if (put_escstr(fd, (char_u *)str2special((const char **)&amp;s, false, false), 2) == FAIL) {</a>
<a name="ln3507">          return FAIL;</a>
<a name="ln3508">        }</a>
<a name="ln3509">      }</a>
<a name="ln3510">    } else if ((flags &amp; P_EXPAND) != 0) {</a>
<a name="ln3511">      size_t size = (size_t)strlen(*valuep) + 1;</a>
<a name="ln3512"> </a>
<a name="ln3513">      // replace home directory in the whole option value into &quot;buf&quot;</a>
<a name="ln3514">      buf = xmalloc(size);</a>
<a name="ln3515">      home_replace(NULL, *valuep, (char *)buf, size, false);</a>
<a name="ln3516"> </a>
<a name="ln3517">      // If the option value is longer than MAXPATHL, we need to append</a>
<a name="ln3518">      // each comma separated part of the option separately, so that it</a>
<a name="ln3519">      // can be expanded when read back.</a>
<a name="ln3520">      if (size &gt;= MAXPATHL &amp;&amp; (flags &amp; P_COMMA) != 0</a>
<a name="ln3521">          &amp;&amp; vim_strchr(*valuep, ',') != NULL) {</a>
<a name="ln3522">        part = xmalloc(size);</a>
<a name="ln3523"> </a>
<a name="ln3524">        // write line break to clear the option, e.g. ':set rtp='</a>
<a name="ln3525">        if (put_eol(fd) == FAIL) {</a>
<a name="ln3526">          goto fail;</a>
<a name="ln3527">        }</a>
<a name="ln3528">        p = (char *)buf;</a>
<a name="ln3529">        while (*p != NUL) {</a>
<a name="ln3530">          // for each comma separated option part, append value to</a>
<a name="ln3531">          // the option, :set rtp+=value</a>
<a name="ln3532">          if (fprintf(fd, &quot;%s %s+=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln3533">            goto fail;</a>
<a name="ln3534">          }</a>
<a name="ln3535">          (void)copy_option_part(&amp;p, (char *)part, size, &quot;,&quot;);</a>
<a name="ln3536">          if (put_escstr(fd, part, 2) == FAIL || put_eol(fd) == FAIL) {</a>
<a name="ln3537">            goto fail;</a>
<a name="ln3538">          }</a>
<a name="ln3539">        }</a>
<a name="ln3540">        xfree(buf);</a>
<a name="ln3541">        xfree(part);</a>
<a name="ln3542">        return OK;</a>
<a name="ln3543">      }</a>
<a name="ln3544">      if (put_escstr(fd, buf, 2) == FAIL) {</a>
<a name="ln3545">        xfree(buf);</a>
<a name="ln3546">        return FAIL;</a>
<a name="ln3547">      }</a>
<a name="ln3548">      xfree(buf);</a>
<a name="ln3549">    } else if (put_escstr(fd, (char_u *)(*valuep), 2) == FAIL) {</a>
<a name="ln3550">      return FAIL;</a>
<a name="ln3551">    }</a>
<a name="ln3552">  }</a>
<a name="ln3553">  if (put_eol(fd) &lt; 0) {</a>
<a name="ln3554">    return FAIL;</a>
<a name="ln3555">  }</a>
<a name="ln3556">  return OK;</a>
<a name="ln3557">fail:</a>
<a name="ln3558">  xfree(buf);</a>
<a name="ln3559">  xfree(part);</a>
<a name="ln3560">  return FAIL;</a>
<a name="ln3561">}</a>
<a name="ln3562"> </a>
<a name="ln3563">static int put_setnum(FILE *fd, char *cmd, char *name, long *valuep)</a>
<a name="ln3564">{</a>
<a name="ln3565">  long wc;</a>
<a name="ln3566"> </a>
<a name="ln3567">  if (fprintf(fd, &quot;%s %s=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln3568">    return FAIL;</a>
<a name="ln3569">  }</a>
<a name="ln3570">  if (wc_use_keyname((char_u *)valuep, &amp;wc)) {</a>
<a name="ln3571">    // print 'wildchar' and 'wildcharm' as a key name</a>
<a name="ln3572">    if (fputs((char *)get_special_key_name((int)wc, 0), fd) &lt; 0) {</a>
<a name="ln3573">      return FAIL;</a>
<a name="ln3574">    }</a>
<a name="ln3575">  } else if (fprintf(fd, &quot;%&quot; PRId64, (int64_t)(*valuep)) &lt; 0) {</a>
<a name="ln3576">    return FAIL;</a>
<a name="ln3577">  }</a>
<a name="ln3578">  if (put_eol(fd) &lt; 0) {</a>
<a name="ln3579">    return FAIL;</a>
<a name="ln3580">  }</a>
<a name="ln3581">  return OK;</a>
<a name="ln3582">}</a>
<a name="ln3583"> </a>
<a name="ln3584">static int put_setbool(FILE *fd, char *cmd, char *name, int value)</a>
<a name="ln3585">{</a>
<a name="ln3586">  if (value &lt; 0) {      // global/local option using global value</a>
<a name="ln3587">    return OK;</a>
<a name="ln3588">  }</a>
<a name="ln3589">  if (fprintf(fd, &quot;%s %s%s&quot;, cmd, value ? &quot;&quot; : &quot;no&quot;, name) &lt; 0</a>
<a name="ln3590">      || put_eol(fd) &lt; 0) {</a>
<a name="ln3591">    return FAIL;</a>
<a name="ln3592">  }</a>
<a name="ln3593">  return OK;</a>
<a name="ln3594">}</a>
<a name="ln3595"> </a>
<a name="ln3596">// Unset local option value, similar to &quot;:set opt&lt;&quot;.</a>
<a name="ln3597">void unset_global_local_option(char *name, void *from)</a>
<a name="ln3598">{</a>
<a name="ln3599">  vimoption_T *p;</a>
<a name="ln3600">  buf_T *buf = (buf_T *)from;</a>
<a name="ln3601"> </a>
<a name="ln3602">  int opt_idx = findoption(name);</a>
<a name="ln3603">  if (opt_idx &lt; 0) {</a>
<a name="ln3604">    semsg(_(&quot;E355: Unknown option: %s&quot;), name);</a>
<a name="ln3605">    return;</a>
<a name="ln3606">  }</a>
<a name="ln3607">  p = &amp;(options[opt_idx]);</a>
<a name="ln3608"> </a>
<a name="ln3609">  switch ((int)p-&gt;indir) {</a>
<a name="ln3610">  // global option with local value: use local value if it's been set</a>
<a name="ln3611">  case PV_EP:</a>
<a name="ln3612">    clear_string_option(&amp;buf-&gt;b_p_ep);</a>
<a name="ln3613">    break;</a>
<a name="ln3614">  case PV_KP:</a>
<a name="ln3615">    clear_string_option(&amp;buf-&gt;b_p_kp);</a>
<a name="ln3616">    break;</a>
<a name="ln3617">  case PV_PATH:</a>
<a name="ln3618">    clear_string_option(&amp;buf-&gt;b_p_path);</a>
<a name="ln3619">    break;</a>
<a name="ln3620">  case PV_AR:</a>
<a name="ln3621">    buf-&gt;b_p_ar = -1;</a>
<a name="ln3622">    break;</a>
<a name="ln3623">  case PV_BKC:</a>
<a name="ln3624">    clear_string_option(&amp;buf-&gt;b_p_bkc);</a>
<a name="ln3625">    buf-&gt;b_bkc_flags = 0;</a>
<a name="ln3626">    break;</a>
<a name="ln3627">  case PV_TAGS:</a>
<a name="ln3628">    clear_string_option(&amp;buf-&gt;b_p_tags);</a>
<a name="ln3629">    break;</a>
<a name="ln3630">  case PV_TC:</a>
<a name="ln3631">    clear_string_option(&amp;buf-&gt;b_p_tc);</a>
<a name="ln3632">    buf-&gt;b_tc_flags = 0;</a>
<a name="ln3633">    break;</a>
<a name="ln3634">  case PV_SISO:</a>
<a name="ln3635">    curwin-&gt;w_p_siso = -1;</a>
<a name="ln3636">    break;</a>
<a name="ln3637">  case PV_SO:</a>
<a name="ln3638">    curwin-&gt;w_p_so = -1;</a>
<a name="ln3639">    break;</a>
<a name="ln3640">  case PV_DEF:</a>
<a name="ln3641">    clear_string_option(&amp;buf-&gt;b_p_def);</a>
<a name="ln3642">    break;</a>
<a name="ln3643">  case PV_INC:</a>
<a name="ln3644">    clear_string_option(&amp;buf-&gt;b_p_inc);</a>
<a name="ln3645">    break;</a>
<a name="ln3646">  case PV_DICT:</a>
<a name="ln3647">    clear_string_option(&amp;buf-&gt;b_p_dict);</a>
<a name="ln3648">    break;</a>
<a name="ln3649">  case PV_TSR:</a>
<a name="ln3650">    clear_string_option(&amp;buf-&gt;b_p_tsr);</a>
<a name="ln3651">    break;</a>
<a name="ln3652">  case PV_TSRFU:</a>
<a name="ln3653">    clear_string_option(&amp;buf-&gt;b_p_tsrfu);</a>
<a name="ln3654">    break;</a>
<a name="ln3655">  case PV_FP:</a>
<a name="ln3656">    clear_string_option(&amp;buf-&gt;b_p_fp);</a>
<a name="ln3657">    break;</a>
<a name="ln3658">  case PV_EFM:</a>
<a name="ln3659">    clear_string_option(&amp;buf-&gt;b_p_efm);</a>
<a name="ln3660">    break;</a>
<a name="ln3661">  case PV_GP:</a>
<a name="ln3662">    clear_string_option(&amp;buf-&gt;b_p_gp);</a>
<a name="ln3663">    break;</a>
<a name="ln3664">  case PV_MP:</a>
<a name="ln3665">    clear_string_option(&amp;buf-&gt;b_p_mp);</a>
<a name="ln3666">    break;</a>
<a name="ln3667">  case PV_SBR:</a>
<a name="ln3668">    clear_string_option(&amp;((win_T *)from)-&gt;w_p_sbr);</a>
<a name="ln3669">    break;</a>
<a name="ln3670">  case PV_STL:</a>
<a name="ln3671">    clear_string_option(&amp;((win_T *)from)-&gt;w_p_stl);</a>
<a name="ln3672">    break;</a>
<a name="ln3673">  case PV_WBR:</a>
<a name="ln3674">    clear_string_option(&amp;((win_T *)from)-&gt;w_p_wbr);</a>
<a name="ln3675">    break;</a>
<a name="ln3676">  case PV_UL:</a>
<a name="ln3677">    buf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln3678">    break;</a>
<a name="ln3679">  case PV_LW:</a>
<a name="ln3680">    clear_string_option(&amp;buf-&gt;b_p_lw);</a>
<a name="ln3681">    break;</a>
<a name="ln3682">  case PV_MENC:</a>
<a name="ln3683">    clear_string_option(&amp;buf-&gt;b_p_menc);</a>
<a name="ln3684">    break;</a>
<a name="ln3685">  case PV_LCS:</a>
<a name="ln3686">    clear_string_option(&amp;((win_T *)from)-&gt;w_p_lcs);</a>
<a name="ln3687">    set_chars_option((win_T *)from, &amp;((win_T *)from)-&gt;w_p_lcs, true);</a>
<a name="ln3688">    redraw_later((win_T *)from, UPD_NOT_VALID);</a>
<a name="ln3689">    break;</a>
<a name="ln3690">  case PV_FCS:</a>
<a name="ln3691">    clear_string_option(&amp;((win_T *)from)-&gt;w_p_fcs);</a>
<a name="ln3692">    set_chars_option((win_T *)from, &amp;((win_T *)from)-&gt;w_p_fcs, true);</a>
<a name="ln3693">    redraw_later((win_T *)from, UPD_NOT_VALID);</a>
<a name="ln3694">    break;</a>
<a name="ln3695">  case PV_VE:</a>
<a name="ln3696">    clear_string_option(&amp;((win_T *)from)-&gt;w_p_ve);</a>
<a name="ln3697">    ((win_T *)from)-&gt;w_ve_flags = 0;</a>
<a name="ln3698">    break;</a>
<a name="ln3699">  }</a>
<a name="ln3700">}</a>
<a name="ln3701"> </a>
<a name="ln3702">/// Get pointer to option variable, depending on local or global scope.</a>
<a name="ln3703">char *get_varp_scope(vimoption_T *p, int opt_flags)</a>
<a name="ln3704">{</a>
<a name="ln3705">  if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; p-&gt;indir != PV_NONE) {</a>
<a name="ln3706">    if (p-&gt;var == VAR_WIN) {</a>
<a name="ln3707">      return GLOBAL_WO(get_varp(p));</a>
<a name="ln3708">    }</a>
<a name="ln3709">    return (char *)p-&gt;var;</a>
<a name="ln3710">  }</a>
<a name="ln3711">  if ((opt_flags &amp; OPT_LOCAL) &amp;&amp; ((int)p-&gt;indir &amp; PV_BOTH)) {</a>
<a name="ln3712">    switch ((int)p-&gt;indir) {</a>
<a name="ln3713">    case PV_FP:</a>
<a name="ln3714">      return (char *)&amp;(curbuf-&gt;b_p_fp);</a>
<a name="ln3715">    case PV_EFM:</a>
<a name="ln3716">      return (char *)&amp;(curbuf-&gt;b_p_efm);</a>
<a name="ln3717">    case PV_GP:</a>
<a name="ln3718">      return (char *)&amp;(curbuf-&gt;b_p_gp);</a>
<a name="ln3719">    case PV_MP:</a>
<a name="ln3720">      return (char *)&amp;(curbuf-&gt;b_p_mp);</a>
<a name="ln3721">    case PV_EP:</a>
<a name="ln3722">      return (char *)&amp;(curbuf-&gt;b_p_ep);</a>
<a name="ln3723">    case PV_KP:</a>
<a name="ln3724">      return (char *)&amp;(curbuf-&gt;b_p_kp);</a>
<a name="ln3725">    case PV_PATH:</a>
<a name="ln3726">      return (char *)&amp;(curbuf-&gt;b_p_path);</a>
<a name="ln3727">    case PV_AR:</a>
<a name="ln3728">      return (char *)&amp;(curbuf-&gt;b_p_ar);</a>
<a name="ln3729">    case PV_TAGS:</a>
<a name="ln3730">      return (char *)&amp;(curbuf-&gt;b_p_tags);</a>
<a name="ln3731">    case PV_TC:</a>
<a name="ln3732">      return (char *)&amp;(curbuf-&gt;b_p_tc);</a>
<a name="ln3733">    case PV_SISO:</a>
<a name="ln3734">      return (char *)&amp;(curwin-&gt;w_p_siso);</a>
<a name="ln3735">    case PV_SO:</a>
<a name="ln3736">      return (char *)&amp;(curwin-&gt;w_p_so);</a>
<a name="ln3737">    case PV_DEF:</a>
<a name="ln3738">      return (char *)&amp;(curbuf-&gt;b_p_def);</a>
<a name="ln3739">    case PV_INC:</a>
<a name="ln3740">      return (char *)&amp;(curbuf-&gt;b_p_inc);</a>
<a name="ln3741">    case PV_DICT:</a>
<a name="ln3742">      return (char *)&amp;(curbuf-&gt;b_p_dict);</a>
<a name="ln3743">    case PV_TSR:</a>
<a name="ln3744">      return (char *)&amp;(curbuf-&gt;b_p_tsr);</a>
<a name="ln3745">    case PV_TSRFU:</a>
<a name="ln3746">      return (char *)&amp;(curbuf-&gt;b_p_tsrfu);</a>
<a name="ln3747">    case PV_TFU:</a>
<a name="ln3748">      return (char *)&amp;(curbuf-&gt;b_p_tfu);</a>
<a name="ln3749">    case PV_SBR:</a>
<a name="ln3750">      return (char *)&amp;(curwin-&gt;w_p_sbr);</a>
<a name="ln3751">    case PV_STL:</a>
<a name="ln3752">      return (char *)&amp;(curwin-&gt;w_p_stl);</a>
<a name="ln3753">    case PV_WBR:</a>
<a name="ln3754">      return (char *)&amp;(curwin-&gt;w_p_wbr);</a>
<a name="ln3755">    case PV_UL:</a>
<a name="ln3756">      return (char *)&amp;(curbuf-&gt;b_p_ul);</a>
<a name="ln3757">    case PV_LW:</a>
<a name="ln3758">      return (char *)&amp;(curbuf-&gt;b_p_lw);</a>
<a name="ln3759">    case PV_BKC:</a>
<a name="ln3760">      return (char *)&amp;(curbuf-&gt;b_p_bkc);</a>
<a name="ln3761">    case PV_MENC:</a>
<a name="ln3762">      return (char *)&amp;(curbuf-&gt;b_p_menc);</a>
<a name="ln3763">    case PV_FCS:</a>
<a name="ln3764">      return (char *)&amp;(curwin-&gt;w_p_fcs);</a>
<a name="ln3765">    case PV_LCS:</a>
<a name="ln3766">      return (char *)&amp;(curwin-&gt;w_p_lcs);</a>
<a name="ln3767">    case PV_VE:</a>
<a name="ln3768">      return (char *)&amp;(curwin-&gt;w_p_ve);</a>
<a name="ln3769">    }</a>
<a name="ln3770">    return NULL;     // &quot;cannot happen&quot;</a>
<a name="ln3771">  }</a>
<a name="ln3772">  return (char *)get_varp(p);</a>
<a name="ln3773">}</a>
<a name="ln3774"> </a>
<a name="ln3775">/// Get pointer to option variable.</a>
<a name="ln3776">static char_u *get_varp(vimoption_T *p)</a>
<a name="ln3777">{</a>
<a name="ln3778">  // hidden option, always return NULL</a>
<a name="ln3779">  if (p-&gt;var == NULL) {</a>
<a name="ln3780">    return NULL;</a>
<a name="ln3781">  }</a>
<a name="ln3782"> </a>
<a name="ln3783">  switch ((int)p-&gt;indir) {</a>
<a name="ln3784">  case PV_NONE:</a>
<a name="ln3785">    return p-&gt;var;</a>
<a name="ln3786"> </a>
<a name="ln3787">  // global option with local value: use local value if it's been set</a>
<a name="ln3788">  case PV_EP:</a>
<a name="ln3789">    return *curbuf-&gt;b_p_ep != NUL</a>
<a name="ln3790">           ? (char_u *)&amp;curbuf-&gt;b_p_ep : p-&gt;var;</a>
<a name="ln3791">  case PV_KP:</a>
<a name="ln3792">    return *curbuf-&gt;b_p_kp != NUL</a>
<a name="ln3793">           ? (char_u *)&amp;curbuf-&gt;b_p_kp : p-&gt;var;</a>
<a name="ln3794">  case PV_PATH:</a>
<a name="ln3795">    return *curbuf-&gt;b_p_path != NUL</a>
<a name="ln3796">           ? (char_u *)&amp;(curbuf-&gt;b_p_path) : p-&gt;var;</a>
<a name="ln3797">  case PV_AR:</a>
<a name="ln3798">    return curbuf-&gt;b_p_ar &gt;= 0</a>
<a name="ln3799">           ? (char_u *)&amp;(curbuf-&gt;b_p_ar) : p-&gt;var;</a>
<a name="ln3800">  case PV_TAGS:</a>
<a name="ln3801">    return *curbuf-&gt;b_p_tags != NUL</a>
<a name="ln3802">           ? (char_u *)&amp;(curbuf-&gt;b_p_tags) : p-&gt;var;</a>
<a name="ln3803">  case PV_TC:</a>
<a name="ln3804">    return *curbuf-&gt;b_p_tc != NUL</a>
<a name="ln3805">           ? (char_u *)&amp;(curbuf-&gt;b_p_tc) : p-&gt;var;</a>
<a name="ln3806">  case PV_SISO:</a>
<a name="ln3807">    return curwin-&gt;w_p_siso &gt;= 0</a>
<a name="ln3808">           ? (char_u *)&amp;(curwin-&gt;w_p_siso) : p-&gt;var;</a>
<a name="ln3809">  case PV_SO:</a>
<a name="ln3810">    return curwin-&gt;w_p_so &gt;= 0</a>
<a name="ln3811">           ? (char_u *)&amp;(curwin-&gt;w_p_so) : p-&gt;var;</a>
<a name="ln3812">  case PV_BKC:</a>
<a name="ln3813">    return *curbuf-&gt;b_p_bkc != NUL</a>
<a name="ln3814">           ? (char_u *)&amp;(curbuf-&gt;b_p_bkc) : p-&gt;var;</a>
<a name="ln3815">  case PV_DEF:</a>
<a name="ln3816">    return *curbuf-&gt;b_p_def != NUL</a>
<a name="ln3817">           ? (char_u *)&amp;(curbuf-&gt;b_p_def) : p-&gt;var;</a>
<a name="ln3818">  case PV_INC:</a>
<a name="ln3819">    return *curbuf-&gt;b_p_inc != NUL</a>
<a name="ln3820">           ? (char_u *)&amp;(curbuf-&gt;b_p_inc) : p-&gt;var;</a>
<a name="ln3821">  case PV_DICT:</a>
<a name="ln3822">    return *curbuf-&gt;b_p_dict != NUL</a>
<a name="ln3823">           ? (char_u *)&amp;(curbuf-&gt;b_p_dict) : p-&gt;var;</a>
<a name="ln3824">  case PV_TSR:</a>
<a name="ln3825">    return *curbuf-&gt;b_p_tsr != NUL</a>
<a name="ln3826">           ? (char_u *)&amp;(curbuf-&gt;b_p_tsr) : p-&gt;var;</a>
<a name="ln3827">  case PV_TSRFU:</a>
<a name="ln3828">    return *curbuf-&gt;b_p_tsrfu != NUL</a>
<a name="ln3829">           ? (char_u *)&amp;(curbuf-&gt;b_p_tsrfu) : p-&gt;var;</a>
<a name="ln3830">  case PV_FP:</a>
<a name="ln3831">    return *curbuf-&gt;b_p_fp != NUL</a>
<a name="ln3832">           ? (char_u *)&amp;(curbuf-&gt;b_p_fp) : p-&gt;var;</a>
<a name="ln3833">  case PV_EFM:</a>
<a name="ln3834">    return *curbuf-&gt;b_p_efm != NUL</a>
<a name="ln3835">           ? (char_u *)&amp;(curbuf-&gt;b_p_efm) : p-&gt;var;</a>
<a name="ln3836">  case PV_GP:</a>
<a name="ln3837">    return *curbuf-&gt;b_p_gp != NUL</a>
<a name="ln3838">           ? (char_u *)&amp;(curbuf-&gt;b_p_gp) : p-&gt;var;</a>
<a name="ln3839">  case PV_MP:</a>
<a name="ln3840">    return *curbuf-&gt;b_p_mp != NUL</a>
<a name="ln3841">           ? (char_u *)&amp;(curbuf-&gt;b_p_mp) : p-&gt;var;</a>
<a name="ln3842">  case PV_SBR:</a>
<a name="ln3843">    return *curwin-&gt;w_p_sbr != NUL</a>
<a name="ln3844">           ? (char_u *)&amp;(curwin-&gt;w_p_sbr) : p-&gt;var;</a>
<a name="ln3845">  case PV_STL:</a>
<a name="ln3846">    return *curwin-&gt;w_p_stl != NUL</a>
<a name="ln3847">           ? (char_u *)&amp;(curwin-&gt;w_p_stl) : p-&gt;var;</a>
<a name="ln3848">  case PV_WBR:</a>
<a name="ln3849">    return *curwin-&gt;w_p_wbr != NUL</a>
<a name="ln3850">           ? (char_u *)&amp;(curwin-&gt;w_p_wbr) : p-&gt;var;</a>
<a name="ln3851">  case PV_UL:</a>
<a name="ln3852">    return curbuf-&gt;b_p_ul != NO_LOCAL_UNDOLEVEL</a>
<a name="ln3853">           ? (char_u *)&amp;(curbuf-&gt;b_p_ul) : p-&gt;var;</a>
<a name="ln3854">  case PV_LW:</a>
<a name="ln3855">    return *curbuf-&gt;b_p_lw != NUL</a>
<a name="ln3856">           ? (char_u *)&amp;(curbuf-&gt;b_p_lw) : p-&gt;var;</a>
<a name="ln3857">  case PV_MENC:</a>
<a name="ln3858">    return *curbuf-&gt;b_p_menc != NUL</a>
<a name="ln3859">           ? (char_u *)&amp;(curbuf-&gt;b_p_menc) : p-&gt;var;</a>
<a name="ln3860">  case PV_FCS:</a>
<a name="ln3861">    return *curwin-&gt;w_p_fcs != NUL</a>
<a name="ln3862">           ? (char_u *)&amp;(curwin-&gt;w_p_fcs) : p-&gt;var;</a>
<a name="ln3863">  case PV_LCS:</a>
<a name="ln3864">    return *curwin-&gt;w_p_lcs != NUL</a>
<a name="ln3865">           ? (char_u *)&amp;(curwin-&gt;w_p_lcs) : p-&gt;var;</a>
<a name="ln3866">  case PV_VE:</a>
<a name="ln3867">    return *curwin-&gt;w_p_ve != NUL</a>
<a name="ln3868">           ? (char_u *)&amp;curwin-&gt;w_p_ve : p-&gt;var;</a>
<a name="ln3869"> </a>
<a name="ln3870">  case PV_ARAB:</a>
<a name="ln3871">    return (char_u *)&amp;(curwin-&gt;w_p_arab);</a>
<a name="ln3872">  case PV_LIST:</a>
<a name="ln3873">    return (char_u *)&amp;(curwin-&gt;w_p_list);</a>
<a name="ln3874">  case PV_SPELL:</a>
<a name="ln3875">    return (char_u *)&amp;(curwin-&gt;w_p_spell);</a>
<a name="ln3876">  case PV_CUC:</a>
<a name="ln3877">    return (char_u *)&amp;(curwin-&gt;w_p_cuc);</a>
<a name="ln3878">  case PV_CUL:</a>
<a name="ln3879">    return (char_u *)&amp;(curwin-&gt;w_p_cul);</a>
<a name="ln3880">  case PV_CULOPT:</a>
<a name="ln3881">    return (char_u *)&amp;(curwin-&gt;w_p_culopt);</a>
<a name="ln3882">  case PV_CC:</a>
<a name="ln3883">    return (char_u *)&amp;(curwin-&gt;w_p_cc);</a>
<a name="ln3884">  case PV_DIFF:</a>
<a name="ln3885">    return (char_u *)&amp;(curwin-&gt;w_p_diff);</a>
<a name="ln3886">  case PV_FDC:</a>
<a name="ln3887">    return (char_u *)&amp;(curwin-&gt;w_p_fdc);</a>
<a name="ln3888">  case PV_FEN:</a>
<a name="ln3889">    return (char_u *)&amp;(curwin-&gt;w_p_fen);</a>
<a name="ln3890">  case PV_FDI:</a>
<a name="ln3891">    return (char_u *)&amp;(curwin-&gt;w_p_fdi);</a>
<a name="ln3892">  case PV_FDL:</a>
<a name="ln3893">    return (char_u *)&amp;(curwin-&gt;w_p_fdl);</a>
<a name="ln3894">  case PV_FDM:</a>
<a name="ln3895">    return (char_u *)&amp;(curwin-&gt;w_p_fdm);</a>
<a name="ln3896">  case PV_FML:</a>
<a name="ln3897">    return (char_u *)&amp;(curwin-&gt;w_p_fml);</a>
<a name="ln3898">  case PV_FDN:</a>
<a name="ln3899">    return (char_u *)&amp;(curwin-&gt;w_p_fdn);</a>
<a name="ln3900">  case PV_FDE:</a>
<a name="ln3901">    return (char_u *)&amp;(curwin-&gt;w_p_fde);</a>
<a name="ln3902">  case PV_FDT:</a>
<a name="ln3903">    return (char_u *)&amp;(curwin-&gt;w_p_fdt);</a>
<a name="ln3904">  case PV_FMR:</a>
<a name="ln3905">    return (char_u *)&amp;(curwin-&gt;w_p_fmr);</a>
<a name="ln3906">  case PV_NU:</a>
<a name="ln3907">    return (char_u *)&amp;(curwin-&gt;w_p_nu);</a>
<a name="ln3908">  case PV_RNU:</a>
<a name="ln3909">    return (char_u *)&amp;(curwin-&gt;w_p_rnu);</a>
<a name="ln3910">  case PV_NUW:</a>
<a name="ln3911">    return (char_u *)&amp;(curwin-&gt;w_p_nuw);</a>
<a name="ln3912">  case PV_WFH:</a>
<a name="ln3913">    return (char_u *)&amp;(curwin-&gt;w_p_wfh);</a>
<a name="ln3914">  case PV_WFW:</a>
<a name="ln3915">    return (char_u *)&amp;(curwin-&gt;w_p_wfw);</a>
<a name="ln3916">  case PV_PVW:</a>
<a name="ln3917">    return (char_u *)&amp;(curwin-&gt;w_p_pvw);</a>
<a name="ln3918">  case PV_RL:</a>
<a name="ln3919">    return (char_u *)&amp;(curwin-&gt;w_p_rl);</a>
<a name="ln3920">  case PV_RLC:</a>
<a name="ln3921">    return (char_u *)&amp;(curwin-&gt;w_p_rlc);</a>
<a name="ln3922">  case PV_SCROLL:</a>
<a name="ln3923">    return (char_u *)&amp;(curwin-&gt;w_p_scr);</a>
<a name="ln3924">  case PV_WRAP:</a>
<a name="ln3925">    return (char_u *)&amp;(curwin-&gt;w_p_wrap);</a>
<a name="ln3926">  case PV_LBR:</a>
<a name="ln3927">    return (char_u *)&amp;(curwin-&gt;w_p_lbr);</a>
<a name="ln3928">  case PV_BRI:</a>
<a name="ln3929">    return (char_u *)&amp;(curwin-&gt;w_p_bri);</a>
<a name="ln3930">  case PV_BRIOPT:</a>
<a name="ln3931">    return (char_u *)&amp;(curwin-&gt;w_p_briopt);</a>
<a name="ln3932">  case PV_SCBIND:</a>
<a name="ln3933">    return (char_u *)&amp;(curwin-&gt;w_p_scb);</a>
<a name="ln3934">  case PV_CRBIND:</a>
<a name="ln3935">    return (char_u *)&amp;(curwin-&gt;w_p_crb);</a>
<a name="ln3936">  case PV_COCU:</a>
<a name="ln3937">    return (char_u *)&amp;(curwin-&gt;w_p_cocu);</a>
<a name="ln3938">  case PV_COLE:</a>
<a name="ln3939">    return (char_u *)&amp;(curwin-&gt;w_p_cole);</a>
<a name="ln3940"> </a>
<a name="ln3941">  case PV_AI:</a>
<a name="ln3942">    return (char_u *)&amp;(curbuf-&gt;b_p_ai);</a>
<a name="ln3943">  case PV_BIN:</a>
<a name="ln3944">    return (char_u *)&amp;(curbuf-&gt;b_p_bin);</a>
<a name="ln3945">  case PV_BOMB:</a>
<a name="ln3946">    return (char_u *)&amp;(curbuf-&gt;b_p_bomb);</a>
<a name="ln3947">  case PV_BH:</a>
<a name="ln3948">    return (char_u *)&amp;(curbuf-&gt;b_p_bh);</a>
<a name="ln3949">  case PV_BT:</a>
<a name="ln3950">    return (char_u *)&amp;(curbuf-&gt;b_p_bt);</a>
<a name="ln3951">  case PV_BL:</a>
<a name="ln3952">    return (char_u *)&amp;(curbuf-&gt;b_p_bl);</a>
<a name="ln3953">  case PV_CHANNEL:</a>
<a name="ln3954">    return (char_u *)&amp;(curbuf-&gt;b_p_channel);</a>
<a name="ln3955">  case PV_CI:</a>
<a name="ln3956">    return (char_u *)&amp;(curbuf-&gt;b_p_ci);</a>
<a name="ln3957">  case PV_CIN:</a>
<a name="ln3958">    return (char_u *)&amp;(curbuf-&gt;b_p_cin);</a>
<a name="ln3959">  case PV_CINK:</a>
<a name="ln3960">    return (char_u *)&amp;(curbuf-&gt;b_p_cink);</a>
<a name="ln3961">  case PV_CINO:</a>
<a name="ln3962">    return (char_u *)&amp;(curbuf-&gt;b_p_cino);</a>
<a name="ln3963">  case PV_CINSD:</a>
<a name="ln3964">    return (char_u *)&amp;(curbuf-&gt;b_p_cinsd);</a>
<a name="ln3965">  case PV_CINW:</a>
<a name="ln3966">    return (char_u *)&amp;(curbuf-&gt;b_p_cinw);</a>
<a name="ln3967">  case PV_COM:</a>
<a name="ln3968">    return (char_u *)&amp;(curbuf-&gt;b_p_com);</a>
<a name="ln3969">  case PV_CMS:</a>
<a name="ln3970">    return (char_u *)&amp;(curbuf-&gt;b_p_cms);</a>
<a name="ln3971">  case PV_CPT:</a>
<a name="ln3972">    return (char_u *)&amp;(curbuf-&gt;b_p_cpt);</a>
<a name="ln3973">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3974">  case PV_CSL:</a>
<a name="ln3975">    return (char_u *)&amp;(curbuf-&gt;b_p_csl);</a>
<a name="ln3976">#endif</a>
<a name="ln3977">  case PV_CFU:</a>
<a name="ln3978">    return (char_u *)&amp;(curbuf-&gt;b_p_cfu);</a>
<a name="ln3979">  case PV_OFU:</a>
<a name="ln3980">    return (char_u *)&amp;(curbuf-&gt;b_p_ofu);</a>
<a name="ln3981">  case PV_EOL:</a>
<a name="ln3982">    return (char_u *)&amp;(curbuf-&gt;b_p_eol);</a>
<a name="ln3983">  case PV_FIXEOL:</a>
<a name="ln3984">    return (char_u *)&amp;(curbuf-&gt;b_p_fixeol);</a>
<a name="ln3985">  case PV_ET:</a>
<a name="ln3986">    return (char_u *)&amp;(curbuf-&gt;b_p_et);</a>
<a name="ln3987">  case PV_FENC:</a>
<a name="ln3988">    return (char_u *)&amp;(curbuf-&gt;b_p_fenc);</a>
<a name="ln3989">  case PV_FF:</a>
<a name="ln3990">    return (char_u *)&amp;(curbuf-&gt;b_p_ff);</a>
<a name="ln3991">  case PV_FT:</a>
<a name="ln3992">    return (char_u *)&amp;(curbuf-&gt;b_p_ft);</a>
<a name="ln3993">  case PV_FO:</a>
<a name="ln3994">    return (char_u *)&amp;(curbuf-&gt;b_p_fo);</a>
<a name="ln3995">  case PV_FLP:</a>
<a name="ln3996">    return (char_u *)&amp;(curbuf-&gt;b_p_flp);</a>
<a name="ln3997">  case PV_IMI:</a>
<a name="ln3998">    return (char_u *)&amp;(curbuf-&gt;b_p_iminsert);</a>
<a name="ln3999">  case PV_IMS:</a>
<a name="ln4000">    return (char_u *)&amp;(curbuf-&gt;b_p_imsearch);</a>
<a name="ln4001">  case PV_INF:</a>
<a name="ln4002">    return (char_u *)&amp;(curbuf-&gt;b_p_inf);</a>
<a name="ln4003">  case PV_ISK:</a>
<a name="ln4004">    return (char_u *)&amp;(curbuf-&gt;b_p_isk);</a>
<a name="ln4005">  case PV_INEX:</a>
<a name="ln4006">    return (char_u *)&amp;(curbuf-&gt;b_p_inex);</a>
<a name="ln4007">  case PV_INDE:</a>
<a name="ln4008">    return (char_u *)&amp;(curbuf-&gt;b_p_inde);</a>
<a name="ln4009">  case PV_INDK:</a>
<a name="ln4010">    return (char_u *)&amp;(curbuf-&gt;b_p_indk);</a>
<a name="ln4011">  case PV_FEX:</a>
<a name="ln4012">    return (char_u *)&amp;(curbuf-&gt;b_p_fex);</a>
<a name="ln4013">  case PV_LISP:</a>
<a name="ln4014">    return (char_u *)&amp;(curbuf-&gt;b_p_lisp);</a>
<a name="ln4015">  case PV_LOP:</a>
<a name="ln4016">    return (char_u *)&amp;(curbuf-&gt;b_p_lop);</a>
<a name="ln4017">  case PV_ML:</a>
<a name="ln4018">    return (char_u *)&amp;(curbuf-&gt;b_p_ml);</a>
<a name="ln4019">  case PV_MPS:</a>
<a name="ln4020">    return (char_u *)&amp;(curbuf-&gt;b_p_mps);</a>
<a name="ln4021">  case PV_MA:</a>
<a name="ln4022">    return (char_u *)&amp;(curbuf-&gt;b_p_ma);</a>
<a name="ln4023">  case PV_MOD:</a>
<a name="ln4024">    return (char_u *)&amp;(curbuf-&gt;b_changed);</a>
<a name="ln4025">  case PV_NF:</a>
<a name="ln4026">    return (char_u *)&amp;(curbuf-&gt;b_p_nf);</a>
<a name="ln4027">  case PV_PI:</a>
<a name="ln4028">    return (char_u *)&amp;(curbuf-&gt;b_p_pi);</a>
<a name="ln4029">  case PV_QE:</a>
<a name="ln4030">    return (char_u *)&amp;(curbuf-&gt;b_p_qe);</a>
<a name="ln4031">  case PV_RO:</a>
<a name="ln4032">    return (char_u *)&amp;(curbuf-&gt;b_p_ro);</a>
<a name="ln4033">  case PV_SCBK:</a>
<a name="ln4034">    return (char_u *)&amp;(curbuf-&gt;b_p_scbk);</a>
<a name="ln4035">  case PV_SI:</a>
<a name="ln4036">    return (char_u *)&amp;(curbuf-&gt;b_p_si);</a>
<a name="ln4037">  case PV_STS:</a>
<a name="ln4038">    return (char_u *)&amp;(curbuf-&gt;b_p_sts);</a>
<a name="ln4039">  case PV_SUA:</a>
<a name="ln4040">    return (char_u *)&amp;(curbuf-&gt;b_p_sua);</a>
<a name="ln4041">  case PV_SWF:</a>
<a name="ln4042">    return (char_u *)&amp;(curbuf-&gt;b_p_swf);</a>
<a name="ln4043">  case PV_SMC:</a>
<a name="ln4044">    return (char_u *)&amp;(curbuf-&gt;b_p_smc);</a>
<a name="ln4045">  case PV_SYN:</a>
<a name="ln4046">    return (char_u *)&amp;(curbuf-&gt;b_p_syn);</a>
<a name="ln4047">  case PV_SPC:</a>
<a name="ln4048">    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spc);</a>
<a name="ln4049">  case PV_SPF:</a>
<a name="ln4050">    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln4051">  case PV_SPL:</a>
<a name="ln4052">    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spl);</a>
<a name="ln4053">  case PV_SPO:</a>
<a name="ln4054">    return (char_u *)&amp;(curwin-&gt;w_s-&gt;b_p_spo);</a>
<a name="ln4055">  case PV_SW:</a>
<a name="ln4056">    return (char_u *)&amp;(curbuf-&gt;b_p_sw);</a>
<a name="ln4057">  case PV_TFU:</a>
<a name="ln4058">    return (char_u *)&amp;(curbuf-&gt;b_p_tfu);</a>
<a name="ln4059">  case PV_TS:</a>
<a name="ln4060">    return (char_u *)&amp;(curbuf-&gt;b_p_ts);</a>
<a name="ln4061">  case PV_TW:</a>
<a name="ln4062">    return (char_u *)&amp;(curbuf-&gt;b_p_tw);</a>
<a name="ln4063">  case PV_UDF:</a>
<a name="ln4064">    return (char_u *)&amp;(curbuf-&gt;b_p_udf);</a>
<a name="ln4065">  case PV_WM:</a>
<a name="ln4066">    return (char_u *)&amp;(curbuf-&gt;b_p_wm);</a>
<a name="ln4067">  case PV_VSTS:</a>
<a name="ln4068">    return (char_u *)&amp;(curbuf-&gt;b_p_vsts);</a>
<a name="ln4069">  case PV_VTS:</a>
<a name="ln4070">    return (char_u *)&amp;(curbuf-&gt;b_p_vts);</a>
<a name="ln4071">  case PV_KMAP:</a>
<a name="ln4072">    return (char_u *)&amp;(curbuf-&gt;b_p_keymap);</a>
<a name="ln4073">  case PV_SCL:</a>
<a name="ln4074">    return (char_u *)&amp;(curwin-&gt;w_p_scl);</a>
<a name="ln4075">  case PV_WINHL:</a>
<a name="ln4076">    return (char_u *)&amp;(curwin-&gt;w_p_winhl);</a>
<a name="ln4077">  case PV_WINBL:</a>
<a name="ln4078">    return (char_u *)&amp;(curwin-&gt;w_p_winbl);</a>
<a name="ln4079">  default:</a>
<a name="ln4080">    iemsg(_(&quot;E356: get_varp ERROR&quot;));</a>
<a name="ln4081">  }</a>
<a name="ln4082">  // always return a valid pointer to avoid a crash!</a>
<a name="ln4083">  return (char_u *)&amp;(curbuf-&gt;b_p_wm);</a>
<a name="ln4084">}</a>
<a name="ln4085"> </a>
<a name="ln4086">/// Get the value of 'equalprg', either the buffer-local one or the global one.</a>
<a name="ln4087">char_u *get_equalprg(void)</a>
<a name="ln4088">{</a>
<a name="ln4089">  if (*curbuf-&gt;b_p_ep == NUL) {</a>
<a name="ln4090">    return p_ep;</a>
<a name="ln4091">  }</a>
<a name="ln4092">  return (char_u *)curbuf-&gt;b_p_ep;</a>
<a name="ln4093">}</a>
<a name="ln4094"> </a>
<a name="ln4095">/// Copy options from one window to another.</a>
<a name="ln4096">/// Used when splitting a window.</a>
<a name="ln4097">void win_copy_options(win_T *wp_from, win_T *wp_to)</a>
<a name="ln4098">{</a>
<a name="ln4099">  copy_winopt(&amp;wp_from-&gt;w_onebuf_opt, &amp;wp_to-&gt;w_onebuf_opt);</a>
<a name="ln4100">  copy_winopt(&amp;wp_from-&gt;w_allbuf_opt, &amp;wp_to-&gt;w_allbuf_opt);</a>
<a name="ln4101">  didset_window_options(wp_to, true);</a>
<a name="ln4102">}</a>
<a name="ln4103"> </a>
<a name="ln4104">static char *copy_option_val(const char *val)</a>
<a name="ln4105">{</a>
<a name="ln4106">  if (val == empty_option) {</a>
<a name="ln4107">    return empty_option;  // no need to allocate memory</a>
<a name="ln4108">  }</a>
<a name="ln4109">  return xstrdup(val);</a>
<a name="ln4110">}</a>
<a name="ln4111"> </a>
<a name="ln4112">/// Copy the options from one winopt_T to another.</a>
<a name="ln4113">/// Doesn't free the old option values in &quot;to&quot;, use clear_winopt() for that.</a>
<a name="ln4114">/// The 'scroll' option is not copied, because it depends on the window height.</a>
<a name="ln4115">/// The 'previewwindow' option is reset, there can be only one preview window.</a>
<a name="ln4116">void copy_winopt(winopt_T *from, winopt_T *to)</a>
<a name="ln4117">{</a>
<a name="ln4118">  to-&gt;wo_arab = from-&gt;wo_arab;</a>
<a name="ln4119">  to-&gt;wo_list = from-&gt;wo_list;</a>
<a name="ln4120">  to-&gt;wo_lcs = copy_option_val(from-&gt;wo_lcs);</a>
<a name="ln4121">  to-&gt;wo_fcs = copy_option_val(from-&gt;wo_fcs);</a>
<a name="ln4122">  to-&gt;wo_nu = from-&gt;wo_nu;</a>
<a name="ln4123">  to-&gt;wo_rnu = from-&gt;wo_rnu;</a>
<a name="ln4124">  to-&gt;wo_ve = copy_option_val(from-&gt;wo_ve);</a>
<a name="ln4125">  to-&gt;wo_ve_flags = from-&gt;wo_ve_flags;</a>
<a name="ln4126">  to-&gt;wo_nuw = from-&gt;wo_nuw;</a>
<a name="ln4127">  to-&gt;wo_rl  = from-&gt;wo_rl;</a>
<a name="ln4128">  to-&gt;wo_rlc = copy_option_val(from-&gt;wo_rlc);</a>
<a name="ln4129">  to-&gt;wo_sbr = copy_option_val(from-&gt;wo_sbr);</a>
<a name="ln4130">  to-&gt;wo_stl = copy_option_val(from-&gt;wo_stl);</a>
<a name="ln4131">  to-&gt;wo_wbr = copy_option_val(from-&gt;wo_wbr);</a>
<a name="ln4132">  to-&gt;wo_wrap = from-&gt;wo_wrap;</a>
<a name="ln4133">  to-&gt;wo_wrap_save = from-&gt;wo_wrap_save;</a>
<a name="ln4134">  to-&gt;wo_lbr = from-&gt;wo_lbr;</a>
<a name="ln4135">  to-&gt;wo_bri = from-&gt;wo_bri;</a>
<a name="ln4136">  to-&gt;wo_briopt = copy_option_val(from-&gt;wo_briopt);</a>
<a name="ln4137">  to-&gt;wo_scb = from-&gt;wo_scb;</a>
<a name="ln4138">  to-&gt;wo_scb_save = from-&gt;wo_scb_save;</a>
<a name="ln4139">  to-&gt;wo_crb = from-&gt;wo_crb;</a>
<a name="ln4140">  to-&gt;wo_crb_save = from-&gt;wo_crb_save;</a>
<a name="ln4141">  to-&gt;wo_spell = from-&gt;wo_spell;</a>
<a name="ln4142">  to-&gt;wo_cuc = from-&gt;wo_cuc;</a>
<a name="ln4143">  to-&gt;wo_cul = from-&gt;wo_cul;</a>
<a name="ln4144">  to-&gt;wo_culopt = copy_option_val(from-&gt;wo_culopt);</a>
<a name="ln4145">  to-&gt;wo_cc = copy_option_val(from-&gt;wo_cc);</a>
<a name="ln4146">  to-&gt;wo_diff = from-&gt;wo_diff;</a>
<a name="ln4147">  to-&gt;wo_diff_saved = from-&gt;wo_diff_saved;</a>
<a name="ln4148">  to-&gt;wo_cocu = copy_option_val(from-&gt;wo_cocu);</a>
<a name="ln4149">  to-&gt;wo_cole = from-&gt;wo_cole;</a>
<a name="ln4150">  to-&gt;wo_fdc = copy_option_val(from-&gt;wo_fdc);</a>
<a name="ln4151">  to-&gt;wo_fdc_save = from-&gt;wo_diff_saved ? xstrdup(from-&gt;wo_fdc_save) : empty_option;</a>
<a name="ln4152">  to-&gt;wo_fen = from-&gt;wo_fen;</a>
<a name="ln4153">  to-&gt;wo_fen_save = from-&gt;wo_fen_save;</a>
<a name="ln4154">  to-&gt;wo_fdi = copy_option_val(from-&gt;wo_fdi);</a>
<a name="ln4155">  to-&gt;wo_fml = from-&gt;wo_fml;</a>
<a name="ln4156">  to-&gt;wo_fdl = from-&gt;wo_fdl;</a>
<a name="ln4157">  to-&gt;wo_fdl_save = from-&gt;wo_fdl_save;</a>
<a name="ln4158">  to-&gt;wo_fdm = copy_option_val(from-&gt;wo_fdm);</a>
<a name="ln4159">  to-&gt;wo_fdm_save = from-&gt;wo_diff_saved ? xstrdup(from-&gt;wo_fdm_save) : empty_option;</a>
<a name="ln4160">  to-&gt;wo_fdn = from-&gt;wo_fdn;</a>
<a name="ln4161">  to-&gt;wo_fde = copy_option_val(from-&gt;wo_fde);</a>
<a name="ln4162">  to-&gt;wo_fdt = copy_option_val(from-&gt;wo_fdt);</a>
<a name="ln4163">  to-&gt;wo_fmr = copy_option_val(from-&gt;wo_fmr);</a>
<a name="ln4164">  to-&gt;wo_scl = copy_option_val(from-&gt;wo_scl);</a>
<a name="ln4165">  to-&gt;wo_winhl = copy_option_val(from-&gt;wo_winhl);</a>
<a name="ln4166">  to-&gt;wo_winbl = from-&gt;wo_winbl;</a>
<a name="ln4167"> </a>
<a name="ln4168">  // Copy the script context so that we know were the value was last set.</a>
<a name="ln4169">  memmove(to-&gt;wo_script_ctx, from-&gt;wo_script_ctx, sizeof(to-&gt;wo_script_ctx));</a>
<a name="ln4170">  check_winopt(to);             // don't want NULL pointers</a>
<a name="ln4171">}</a>
<a name="ln4172"> </a>
<a name="ln4173">/// Check string options in a window for a NULL value.</a>
<a name="ln4174">void check_win_options(win_T *win)</a>
<a name="ln4175">{</a>
<a name="ln4176">  check_winopt(&amp;win-&gt;w_onebuf_opt);</a>
<a name="ln4177">  check_winopt(&amp;win-&gt;w_allbuf_opt);</a>
<a name="ln4178">}</a>
<a name="ln4179"> </a>
<a name="ln4180">/// Check for NULL pointers in a winopt_T and replace them with empty_option.</a>
<a name="ln4181">static void check_winopt(winopt_T *wop)</a>
<a name="ln4182">{</a>
<a name="ln4183">  check_string_option(&amp;wop-&gt;wo_fdc);</a>
<a name="ln4184">  check_string_option(&amp;wop-&gt;wo_fdc_save);</a>
<a name="ln4185">  check_string_option(&amp;wop-&gt;wo_fdi);</a>
<a name="ln4186">  check_string_option(&amp;wop-&gt;wo_fdm);</a>
<a name="ln4187">  check_string_option(&amp;wop-&gt;wo_fdm_save);</a>
<a name="ln4188">  check_string_option(&amp;wop-&gt;wo_fde);</a>
<a name="ln4189">  check_string_option(&amp;wop-&gt;wo_fdt);</a>
<a name="ln4190">  check_string_option(&amp;wop-&gt;wo_fmr);</a>
<a name="ln4191">  check_string_option(&amp;wop-&gt;wo_scl);</a>
<a name="ln4192">  check_string_option(&amp;wop-&gt;wo_rlc);</a>
<a name="ln4193">  check_string_option(&amp;wop-&gt;wo_sbr);</a>
<a name="ln4194">  check_string_option(&amp;wop-&gt;wo_stl);</a>
<a name="ln4195">  check_string_option(&amp;wop-&gt;wo_culopt);</a>
<a name="ln4196">  check_string_option(&amp;wop-&gt;wo_cc);</a>
<a name="ln4197">  check_string_option(&amp;wop-&gt;wo_cocu);</a>
<a name="ln4198">  check_string_option(&amp;wop-&gt;wo_briopt);</a>
<a name="ln4199">  check_string_option(&amp;wop-&gt;wo_winhl);</a>
<a name="ln4200">  check_string_option(&amp;wop-&gt;wo_lcs);</a>
<a name="ln4201">  check_string_option(&amp;wop-&gt;wo_fcs);</a>
<a name="ln4202">  check_string_option(&amp;wop-&gt;wo_ve);</a>
<a name="ln4203">  check_string_option(&amp;wop-&gt;wo_wbr);</a>
<a name="ln4204">}</a>
<a name="ln4205"> </a>
<a name="ln4206">/// Free the allocated memory inside a winopt_T.</a>
<a name="ln4207">void clear_winopt(winopt_T *wop)</a>
<a name="ln4208">{</a>
<a name="ln4209">  clear_string_option(&amp;wop-&gt;wo_fdc);</a>
<a name="ln4210">  clear_string_option(&amp;wop-&gt;wo_fdc_save);</a>
<a name="ln4211">  clear_string_option(&amp;wop-&gt;wo_fdi);</a>
<a name="ln4212">  clear_string_option(&amp;wop-&gt;wo_fdm);</a>
<a name="ln4213">  clear_string_option(&amp;wop-&gt;wo_fdm_save);</a>
<a name="ln4214">  clear_string_option(&amp;wop-&gt;wo_fde);</a>
<a name="ln4215">  clear_string_option(&amp;wop-&gt;wo_fdt);</a>
<a name="ln4216">  clear_string_option(&amp;wop-&gt;wo_fmr);</a>
<a name="ln4217">  clear_string_option(&amp;wop-&gt;wo_scl);</a>
<a name="ln4218">  clear_string_option(&amp;wop-&gt;wo_rlc);</a>
<a name="ln4219">  clear_string_option(&amp;wop-&gt;wo_sbr);</a>
<a name="ln4220">  clear_string_option(&amp;wop-&gt;wo_stl);</a>
<a name="ln4221">  clear_string_option(&amp;wop-&gt;wo_culopt);</a>
<a name="ln4222">  clear_string_option(&amp;wop-&gt;wo_cc);</a>
<a name="ln4223">  clear_string_option(&amp;wop-&gt;wo_cocu);</a>
<a name="ln4224">  clear_string_option(&amp;wop-&gt;wo_briopt);</a>
<a name="ln4225">  clear_string_option(&amp;wop-&gt;wo_winhl);</a>
<a name="ln4226">  clear_string_option(&amp;wop-&gt;wo_lcs);</a>
<a name="ln4227">  clear_string_option(&amp;wop-&gt;wo_fcs);</a>
<a name="ln4228">  clear_string_option(&amp;wop-&gt;wo_ve);</a>
<a name="ln4229">  clear_string_option(&amp;wop-&gt;wo_wbr);</a>
<a name="ln4230">}</a>
<a name="ln4231"> </a>
<a name="ln4232">void didset_window_options(win_T *wp, bool valid_cursor)</a>
<a name="ln4233">{</a>
<a name="ln4234">  check_colorcolumn(wp);</a>
<a name="ln4235">  briopt_check(wp);</a>
<a name="ln4236">  fill_culopt_flags(NULL, wp);</a>
<a name="ln4237">  set_chars_option(wp, &amp;wp-&gt;w_p_fcs, true);</a>
<a name="ln4238">  set_chars_option(wp, &amp;wp-&gt;w_p_lcs, true);</a>
<a name="ln4239">  parse_winhl_opt(wp);  // sets w_hl_needs_update also for w_p_winbl</a>
<a name="ln4240">  check_blending(wp);</a>
<a name="ln4241">  set_winbar_win(wp, false, valid_cursor);</a>
<a name="ln4242">  wp-&gt;w_grid_alloc.blending = wp-&gt;w_p_winbl &gt; 0;</a>
<a name="ln4243">}</a>
<a name="ln4244"> </a>
<a name="ln4245">/// Index into the options table for a buffer-local option enum.</a>
<a name="ln4246">static int buf_opt_idx[BV_COUNT];</a>
<a name="ln4247">#define COPY_OPT_SCTX(buf, bv) buf-&gt;b_p_script_ctx[bv] = options[buf_opt_idx[bv]].last_set</a>
<a name="ln4248"> </a>
<a name="ln4249">/// Initialize buf_opt_idx[] if not done already.</a>
<a name="ln4250">static void init_buf_opt_idx(void)</a>
<a name="ln4251">{</a>
<a name="ln4252">  static int did_init_buf_opt_idx = false;</a>
<a name="ln4253"> </a>
<a name="ln4254">  if (did_init_buf_opt_idx) {</a>
<a name="ln4255">    return;</a>
<a name="ln4256">  }</a>
<a name="ln4257">  did_init_buf_opt_idx = true;</a>
<a name="ln4258">  for (int i = 0; options[i].fullname != NULL; i++) {</a>
<a name="ln4259">    if (options[i].indir &amp; PV_BUF) {</a>
<a name="ln4260">      buf_opt_idx[options[i].indir &amp; PV_MASK] = i;</a>
<a name="ln4261">    }</a>
<a name="ln4262">  }</a>
<a name="ln4263">}</a>
<a name="ln4264"> </a>
<a name="ln4265">/// Copy global option values to local options for one buffer.</a>
<a name="ln4266">/// Used when creating a new buffer and sometimes when entering a buffer.</a>
<a name="ln4267">/// flags:</a>
<a name="ln4268">/// BCO_ENTER    We will enter the buffer &quot;buf&quot;.</a>
<a name="ln4269">/// BCO_ALWAYS   Always copy the options, but only set b_p_initialized when</a>
<a name="ln4270">///      appropriate.</a>
<a name="ln4271">/// BCO_NOHELP   Don't copy the values to a help buffer.</a>
<a name="ln4272">void buf_copy_options(buf_T *buf, int flags)</a>
<a name="ln4273">{</a>
<a name="ln4274">  int should_copy = true;</a>
<a name="ln4275">  char_u *save_p_isk = NULL;           // init for GCC</a>
<a name="ln4276">  int dont_do_help;</a>
<a name="ln4277">  int did_isk = false;</a>
<a name="ln4278"> </a>
<a name="ln4279">  // Skip this when the option defaults have not been set yet.  Happens when</a>
<a name="ln4280">  // main() allocates the first buffer.</a>
<a name="ln4281">  if (p_cpo != NULL) {</a>
<a name="ln4282">    //</a>
<a name="ln4283">    // Always copy when entering and 'cpo' contains 'S'.</a>
<a name="ln4284">    // Don't copy when already initialized.</a>
<a name="ln4285">    // Don't copy when 'cpo' contains 's' and not entering.</a>
<a name="ln4286">    //    'S'      BCO_ENTER  initialized  's'  should_copy</a>
<a name="ln4287">    //    yes        yes          X         X      true</a>
<a name="ln4288">    //    yes        no          yes        X      false</a>
<a name="ln4289">    //    no          X          yes        X      false</a>
<a name="ln4290">    //     X         no          no        yes     false</a>
<a name="ln4291">    //     X         no          no        no      true</a>
<a name="ln4292">    //    no         yes         no         X      true</a>
<a name="ln4293">    ///</a>
<a name="ln4294">    if ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags &amp; BCO_ENTER))</a>
<a name="ln4295">        &amp;&amp; (buf-&gt;b_p_initialized</a>
<a name="ln4296">            || (!(flags &amp; BCO_ENTER)</a>
<a name="ln4297">                &amp;&amp; vim_strchr(p_cpo, CPO_BUFOPT) != NULL))) {</a>
<a name="ln4298">      should_copy = false;</a>
<a name="ln4299">    }</a>
<a name="ln4300"> </a>
<a name="ln4301">    if (should_copy || (flags &amp; BCO_ALWAYS)) {</a>
<a name="ln4302">      CLEAR_FIELD(buf-&gt;b_p_script_ctx);</a>
<a name="ln4303">      init_buf_opt_idx();</a>
<a name="ln4304">      // Don't copy the options specific to a help buffer when</a>
<a name="ln4305">      // BCO_NOHELP is given or the options were initialized already</a>
<a name="ln4306">      // (jumping back to a help file with CTRL-T or CTRL-O)</a>
<a name="ln4307">      dont_do_help = ((flags &amp; BCO_NOHELP) &amp;&amp; buf-&gt;b_help) || buf-&gt;b_p_initialized;</a>
<a name="ln4308">      if (dont_do_help) {               // don't free b_p_isk</a>
<a name="ln4309">        save_p_isk = (char_u *)buf-&gt;b_p_isk;</a>
<a name="ln4310">        buf-&gt;b_p_isk = NULL;</a>
<a name="ln4311">      }</a>
<a name="ln4312">      // Always free the allocated strings.  If not already initialized,</a>
<a name="ln4313">      // reset 'readonly' and copy 'fileformat'.</a>
<a name="ln4314">      if (!buf-&gt;b_p_initialized) {</a>
<a name="ln4315">        free_buf_options(buf, true);</a>
<a name="ln4316">        buf-&gt;b_p_ro = false;                    // don't copy readonly</a>
<a name="ln4317">        buf-&gt;b_p_fenc = xstrdup(p_fenc);</a>
<a name="ln4318">        switch (*p_ffs) {</a>
<a name="ln4319">        case 'm':</a>
<a name="ln4320">          buf-&gt;b_p_ff = xstrdup(FF_MAC);</a>
<a name="ln4321">          break;</a>
<a name="ln4322">        case 'd':</a>
<a name="ln4323">          buf-&gt;b_p_ff = xstrdup(FF_DOS);</a>
<a name="ln4324">          break;</a>
<a name="ln4325">        case 'u':</a>
<a name="ln4326">          buf-&gt;b_p_ff = xstrdup(FF_UNIX);</a>
<a name="ln4327">          break;</a>
<a name="ln4328">        default:</a>
<a name="ln4329">          buf-&gt;b_p_ff = xstrdup(p_ff);</a>
<a name="ln4330">          break;</a>
<a name="ln4331">        }</a>
<a name="ln4332">        buf-&gt;b_p_bh = empty_option;</a>
<a name="ln4333">        buf-&gt;b_p_bt = empty_option;</a>
<a name="ln4334">      } else {</a>
<a name="ln4335">        free_buf_options(buf, false);</a>
<a name="ln4336">      }</a>
<a name="ln4337"> </a>
<a name="ln4338">      buf-&gt;b_p_ai = p_ai;</a>
<a name="ln4339">      COPY_OPT_SCTX(buf, BV_AI);</a>
<a name="ln4340">      buf-&gt;b_p_ai_nopaste = p_ai_nopaste;</a>
<a name="ln4341">      buf-&gt;b_p_sw = p_sw;</a>
<a name="ln4342">      COPY_OPT_SCTX(buf, BV_SW);</a>
<a name="ln4343">      buf-&gt;b_p_scbk = p_scbk;</a>
<a name="ln4344">      COPY_OPT_SCTX(buf, BV_SCBK);</a>
<a name="ln4345">      buf-&gt;b_p_tw = p_tw;</a>
<a name="ln4346">      COPY_OPT_SCTX(buf, BV_TW);</a>
<a name="ln4347">      buf-&gt;b_p_tw_nopaste = p_tw_nopaste;</a>
<a name="ln4348">      buf-&gt;b_p_tw_nobin = p_tw_nobin;</a>
<a name="ln4349">      buf-&gt;b_p_wm = p_wm;</a>
<a name="ln4350">      COPY_OPT_SCTX(buf, BV_WM);</a>
<a name="ln4351">      buf-&gt;b_p_wm_nopaste = p_wm_nopaste;</a>
<a name="ln4352">      buf-&gt;b_p_wm_nobin = p_wm_nobin;</a>
<a name="ln4353">      buf-&gt;b_p_bin = p_bin;</a>
<a name="ln4354">      COPY_OPT_SCTX(buf, BV_BIN);</a>
<a name="ln4355">      buf-&gt;b_p_bomb = p_bomb;</a>
<a name="ln4356">      COPY_OPT_SCTX(buf, BV_BOMB);</a>
<a name="ln4357">      buf-&gt;b_p_et = p_et;</a>
<a name="ln4358">      COPY_OPT_SCTX(buf, BV_ET);</a>
<a name="ln4359">      buf-&gt;b_p_fixeol = p_fixeol;</a>
<a name="ln4360">      COPY_OPT_SCTX(buf, BV_FIXEOL);</a>
<a name="ln4361">      buf-&gt;b_p_et_nobin = p_et_nobin;</a>
<a name="ln4362">      buf-&gt;b_p_et_nopaste = p_et_nopaste;</a>
<a name="ln4363">      buf-&gt;b_p_ml = p_ml;</a>
<a name="ln4364">      COPY_OPT_SCTX(buf, BV_ML);</a>
<a name="ln4365">      buf-&gt;b_p_ml_nobin = p_ml_nobin;</a>
<a name="ln4366">      buf-&gt;b_p_inf = p_inf;</a>
<a name="ln4367">      COPY_OPT_SCTX(buf, BV_INF);</a>
<a name="ln4368">      if (cmdmod.cmod_flags &amp; CMOD_NOSWAPFILE) {</a>
<a name="ln4369">        buf-&gt;b_p_swf = false;</a>
<a name="ln4370">      } else {</a>
<a name="ln4371">        buf-&gt;b_p_swf = p_swf;</a>
<a name="ln4372">        COPY_OPT_SCTX(buf, BV_SWF);</a>
<a name="ln4373">      }</a>
<a name="ln4374">      buf-&gt;b_p_cpt = xstrdup(p_cpt);</a>
<a name="ln4375">      COPY_OPT_SCTX(buf, BV_CPT);</a>
<a name="ln4376">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln4377">      buf-&gt;b_p_csl = xstrdup(p_csl);</a>
<a name="ln4378">      COPY_OPT_SCTX(buf, BV_CSL);</a>
<a name="ln4379">#endif</a>
<a name="ln4380">      buf-&gt;b_p_cfu = xstrdup(p_cfu);</a>
<a name="ln4381">      COPY_OPT_SCTX(buf, BV_CFU);</a>
<a name="ln4382">      buf-&gt;b_p_ofu = xstrdup(p_ofu);</a>
<a name="ln4383">      COPY_OPT_SCTX(buf, BV_OFU);</a>
<a name="ln4384">      buf-&gt;b_p_tfu = xstrdup(p_tfu);</a>
<a name="ln4385">      COPY_OPT_SCTX(buf, BV_TFU);</a>
<a name="ln4386">      buf-&gt;b_p_sts = p_sts;</a>
<a name="ln4387">      COPY_OPT_SCTX(buf, BV_STS);</a>
<a name="ln4388">      buf-&gt;b_p_sts_nopaste = p_sts_nopaste;</a>
<a name="ln4389">      buf-&gt;b_p_vsts = xstrdup(p_vsts);</a>
<a name="ln4390">      COPY_OPT_SCTX(buf, BV_VSTS);</a>
<a name="ln4391">      if (p_vsts &amp;&amp; p_vsts != empty_option) {</a>
<a name="ln4392">        (void)tabstop_set(p_vsts, &amp;buf-&gt;b_p_vsts_array);</a>
<a name="ln4393">      } else {</a>
<a name="ln4394">        buf-&gt;b_p_vsts_array = NULL;</a>
<a name="ln4395">      }</a>
<a name="ln4396">      buf-&gt;b_p_vsts_nopaste = p_vsts_nopaste ? xstrdup(p_vsts_nopaste) : NULL;</a>
<a name="ln4397">      buf-&gt;b_p_com = xstrdup(p_com);</a>
<a name="ln4398">      COPY_OPT_SCTX(buf, BV_COM);</a>
<a name="ln4399">      buf-&gt;b_p_cms = xstrdup(p_cms);</a>
<a name="ln4400">      COPY_OPT_SCTX(buf, BV_CMS);</a>
<a name="ln4401">      buf-&gt;b_p_fo = xstrdup(p_fo);</a>
<a name="ln4402">      COPY_OPT_SCTX(buf, BV_FO);</a>
<a name="ln4403">      buf-&gt;b_p_flp = xstrdup(p_flp);</a>
<a name="ln4404">      COPY_OPT_SCTX(buf, BV_FLP);</a>
<a name="ln4405">      buf-&gt;b_p_nf = xstrdup(p_nf);</a>
<a name="ln4406">      COPY_OPT_SCTX(buf, BV_NF);</a>
<a name="ln4407">      buf-&gt;b_p_mps = xstrdup(p_mps);</a>
<a name="ln4408">      COPY_OPT_SCTX(buf, BV_MPS);</a>
<a name="ln4409">      buf-&gt;b_p_si = p_si;</a>
<a name="ln4410">      COPY_OPT_SCTX(buf, BV_SI);</a>
<a name="ln4411">      buf-&gt;b_p_channel = 0;</a>
<a name="ln4412">      buf-&gt;b_p_ci = p_ci;</a>
<a name="ln4413"> </a>
<a name="ln4414">      COPY_OPT_SCTX(buf, BV_CI);</a>
<a name="ln4415">      buf-&gt;b_p_cin = p_cin;</a>
<a name="ln4416">      COPY_OPT_SCTX(buf, BV_CIN);</a>
<a name="ln4417">      buf-&gt;b_p_cink = xstrdup(p_cink);</a>
<a name="ln4418">      COPY_OPT_SCTX(buf, BV_CINK);</a>
<a name="ln4419">      buf-&gt;b_p_cino = xstrdup(p_cino);</a>
<a name="ln4420">      COPY_OPT_SCTX(buf, BV_CINO);</a>
<a name="ln4421">      buf-&gt;b_p_cinsd = xstrdup(p_cinsd);</a>
<a name="ln4422">      COPY_OPT_SCTX(buf, BV_CINSD);</a>
<a name="ln4423">      buf-&gt;b_p_lop = xstrdup(p_lop);</a>
<a name="ln4424">      COPY_OPT_SCTX(buf, BV_LOP);</a>
<a name="ln4425"> </a>
<a name="ln4426">      // Don't copy 'filetype', it must be detected</a>
<a name="ln4427">      buf-&gt;b_p_ft = empty_option;</a>
<a name="ln4428">      buf-&gt;b_p_pi = p_pi;</a>
<a name="ln4429">      COPY_OPT_SCTX(buf, BV_PI);</a>
<a name="ln4430">      buf-&gt;b_p_cinw = xstrdup(p_cinw);</a>
<a name="ln4431">      COPY_OPT_SCTX(buf, BV_CINW);</a>
<a name="ln4432">      buf-&gt;b_p_lisp = p_lisp;</a>
<a name="ln4433">      COPY_OPT_SCTX(buf, BV_LISP);</a>
<a name="ln4434">      // Don't copy 'syntax', it must be set</a>
<a name="ln4435">      buf-&gt;b_p_syn = empty_option;</a>
<a name="ln4436">      buf-&gt;b_p_smc = p_smc;</a>
<a name="ln4437">      COPY_OPT_SCTX(buf, BV_SMC);</a>
<a name="ln4438">      buf-&gt;b_s.b_syn_isk = empty_option;</a>
<a name="ln4439">      buf-&gt;b_s.b_p_spc = xstrdup(p_spc);</a>
<a name="ln4440">      COPY_OPT_SCTX(buf, BV_SPC);</a>
<a name="ln4441">      (void)compile_cap_prog(&amp;buf-&gt;b_s);</a>
<a name="ln4442">      buf-&gt;b_s.b_p_spf = xstrdup(p_spf);</a>
<a name="ln4443">      COPY_OPT_SCTX(buf, BV_SPF);</a>
<a name="ln4444">      buf-&gt;b_s.b_p_spl = xstrdup(p_spl);</a>
<a name="ln4445">      COPY_OPT_SCTX(buf, BV_SPL);</a>
<a name="ln4446">      buf-&gt;b_s.b_p_spo = xstrdup(p_spo);</a>
<a name="ln4447">      COPY_OPT_SCTX(buf, BV_SPO);</a>
<a name="ln4448">      buf-&gt;b_p_inde = xstrdup(p_inde);</a>
<a name="ln4449">      COPY_OPT_SCTX(buf, BV_INDE);</a>
<a name="ln4450">      buf-&gt;b_p_indk = xstrdup(p_indk);</a>
<a name="ln4451">      COPY_OPT_SCTX(buf, BV_INDK);</a>
<a name="ln4452">      buf-&gt;b_p_fp = empty_option;</a>
<a name="ln4453">      buf-&gt;b_p_fex = xstrdup(p_fex);</a>
<a name="ln4454">      COPY_OPT_SCTX(buf, BV_FEX);</a>
<a name="ln4455">      buf-&gt;b_p_sua = xstrdup(p_sua);</a>
<a name="ln4456">      COPY_OPT_SCTX(buf, BV_SUA);</a>
<a name="ln4457">      buf-&gt;b_p_keymap = xstrdup(p_keymap);</a>
<a name="ln4458">      COPY_OPT_SCTX(buf, BV_KMAP);</a>
<a name="ln4459">      buf-&gt;b_kmap_state |= KEYMAP_INIT;</a>
<a name="ln4460">      // This isn't really an option, but copying the langmap and IME</a>
<a name="ln4461">      // state from the current buffer is better than resetting it.</a>
<a name="ln4462">      buf-&gt;b_p_iminsert = p_iminsert;</a>
<a name="ln4463">      COPY_OPT_SCTX(buf, BV_IMI);</a>
<a name="ln4464">      buf-&gt;b_p_imsearch = p_imsearch;</a>
<a name="ln4465">      COPY_OPT_SCTX(buf, BV_IMS);</a>
<a name="ln4466"> </a>
<a name="ln4467">      // options that are normally global but also have a local value</a>
<a name="ln4468">      // are not copied, start using the global value</a>
<a name="ln4469">      buf-&gt;b_p_ar = -1;</a>
<a name="ln4470">      buf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln4471">      buf-&gt;b_p_bkc = empty_option;</a>
<a name="ln4472">      buf-&gt;b_bkc_flags = 0;</a>
<a name="ln4473">      buf-&gt;b_p_gp = empty_option;</a>
<a name="ln4474">      buf-&gt;b_p_mp = empty_option;</a>
<a name="ln4475">      buf-&gt;b_p_efm = empty_option;</a>
<a name="ln4476">      buf-&gt;b_p_ep = empty_option;</a>
<a name="ln4477">      buf-&gt;b_p_kp = empty_option;</a>
<a name="ln4478">      buf-&gt;b_p_path = empty_option;</a>
<a name="ln4479">      buf-&gt;b_p_tags = empty_option;</a>
<a name="ln4480">      buf-&gt;b_p_tc = empty_option;</a>
<a name="ln4481">      buf-&gt;b_tc_flags = 0;</a>
<a name="ln4482">      buf-&gt;b_p_def = empty_option;</a>
<a name="ln4483">      buf-&gt;b_p_inc = empty_option;</a>
<a name="ln4484">      buf-&gt;b_p_inex = xstrdup(p_inex);</a>
<a name="ln4485">      COPY_OPT_SCTX(buf, BV_INEX);</a>
<a name="ln4486">      buf-&gt;b_p_dict = empty_option;</a>
<a name="ln4487">      buf-&gt;b_p_tsr = empty_option;</a>
<a name="ln4488">      buf-&gt;b_p_tsrfu = empty_option;</a>
<a name="ln4489">      buf-&gt;b_p_qe = xstrdup(p_qe);</a>
<a name="ln4490">      COPY_OPT_SCTX(buf, BV_QE);</a>
<a name="ln4491">      buf-&gt;b_p_udf = p_udf;</a>
<a name="ln4492">      COPY_OPT_SCTX(buf, BV_UDF);</a>
<a name="ln4493">      buf-&gt;b_p_lw = empty_option;</a>
<a name="ln4494">      buf-&gt;b_p_menc = empty_option;</a>
<a name="ln4495"> </a>
<a name="ln4496">      // Don't copy the options set by ex_help(), use the saved values,</a>
<a name="ln4497">      // when going from a help buffer to a non-help buffer.</a>
<a name="ln4498">      // Don't touch these at all when BCO_NOHELP is used and going from</a>
<a name="ln4499">      // or to a help buffer.</a>
<a name="ln4500">      if (dont_do_help) {</a>
<a name="ln4501">        buf-&gt;b_p_isk = (char *)save_p_isk;</a>
<a name="ln4502">        if (p_vts &amp;&amp; p_vts != empty_option &amp;&amp; !buf-&gt;b_p_vts_array) {</a>
<a name="ln4503">          (void)tabstop_set(p_vts, &amp;buf-&gt;b_p_vts_array);</a>
<a name="ln4504">        } else {</a>
<a name="ln4505">          buf-&gt;b_p_vts_array = NULL;</a>
<a name="ln4506">        }</a>
<a name="ln4507">      } else {</a>
<a name="ln4508">        buf-&gt;b_p_isk = xstrdup(p_isk);</a>
<a name="ln4509">        COPY_OPT_SCTX(buf, BV_ISK);</a>
<a name="ln4510">        did_isk = true;</a>
<a name="ln4511">        buf-&gt;b_p_ts = p_ts;</a>
<a name="ln4512">        COPY_OPT_SCTX(buf, BV_TS);</a>
<a name="ln4513">        buf-&gt;b_p_vts = xstrdup(p_vts);</a>
<a name="ln4514">        COPY_OPT_SCTX(buf, BV_VTS);</a>
<a name="ln4515">        if (p_vts &amp;&amp; p_vts != empty_option &amp;&amp; !buf-&gt;b_p_vts_array) {</a>
<a name="ln4516">          (void)tabstop_set(p_vts, &amp;buf-&gt;b_p_vts_array);</a>
<a name="ln4517">        } else {</a>
<a name="ln4518">          buf-&gt;b_p_vts_array = NULL;</a>
<a name="ln4519">        }</a>
<a name="ln4520">        buf-&gt;b_help = false;</a>
<a name="ln4521">        if (buf-&gt;b_p_bt[0] == 'h') {</a>
<a name="ln4522">          clear_string_option(&amp;buf-&gt;b_p_bt);</a>
<a name="ln4523">        }</a>
<a name="ln4524">        buf-&gt;b_p_ma = p_ma;</a>
<a name="ln4525">        COPY_OPT_SCTX(buf, BV_MA);</a>
<a name="ln4526">      }</a>
<a name="ln4527">    }</a>
<a name="ln4528"> </a>
<a name="ln4529">    // When the options should be copied (ignoring BCO_ALWAYS), set the</a>
<a name="ln4530">    // flag that indicates that the options have been initialized.</a>
<a name="ln4531">    if (should_copy) {</a>
<a name="ln4532">      buf-&gt;b_p_initialized = true;</a>
<a name="ln4533">    }</a>
<a name="ln4534">  }</a>
<a name="ln4535"> </a>
<a name="ln4536">  check_buf_options(buf);           // make sure we don't have NULLs</a>
<a name="ln4537">  if (did_isk) {</a>
<a name="ln4538">    (void)buf_init_chartab(buf, false);</a>
<a name="ln4539">  }</a>
<a name="ln4540">}</a>
<a name="ln4541"> </a>
<a name="ln4542">/// Reset the 'modifiable' option and its default value.</a>
<a name="ln4543">void reset_modifiable(void)</a>
<a name="ln4544">{</a>
<a name="ln4545">  int opt_idx;</a>
<a name="ln4546"> </a>
<a name="ln4547">  curbuf-&gt;b_p_ma = false;</a>
<a name="ln4548">  p_ma = false;</a>
<a name="ln4549">  opt_idx = findoption(&quot;ma&quot;);</a>
<a name="ln4550">  if (opt_idx &gt;= 0) {</a>
<a name="ln4551">    options[opt_idx].def_val = false;</a>
<a name="ln4552">  }</a>
<a name="ln4553">}</a>
<a name="ln4554"> </a>
<a name="ln4555">/// Set the global value for 'iminsert' to the local value.</a>
<a name="ln4556">void set_iminsert_global(void)</a>
<a name="ln4557">{</a>
<a name="ln4558">  p_iminsert = curbuf-&gt;b_p_iminsert;</a>
<a name="ln4559">}</a>
<a name="ln4560"> </a>
<a name="ln4561">/// Set the global value for 'imsearch' to the local value.</a>
<a name="ln4562">void set_imsearch_global(void)</a>
<a name="ln4563">{</a>
<a name="ln4564">  p_imsearch = curbuf-&gt;b_p_imsearch;</a>
<a name="ln4565">}</a>
<a name="ln4566"> </a>
<a name="ln4567">static int expand_option_idx = -1;</a>
<a name="ln4568">static char_u expand_option_name[5] = { 't', '_', NUL, NUL, NUL };</a>
<a name="ln4569">static int expand_option_flags = 0;</a>
<a name="ln4570"> </a>
<a name="ln4571">/// @param opt_flags  OPT_GLOBAL and/or OPT_LOCAL</a>
<a name="ln4572">void set_context_in_set_cmd(expand_T *xp, char_u *arg, int opt_flags)</a>
<a name="ln4573">{</a>
<a name="ln4574">  char_u nextchar;</a>
<a name="ln4575">  uint32_t flags = 0;           // init for GCC</a>
<a name="ln4576">  int opt_idx = 0;              // init for GCC</a>
<a name="ln4577">  char_u *p;</a>
<a name="ln4578">  char_u *s;</a>
<a name="ln4579">  int is_term_option = false;</a>
<a name="ln4580">  int key;</a>
<a name="ln4581"> </a>
<a name="ln4582">  expand_option_flags = opt_flags;</a>
<a name="ln4583"> </a>
<a name="ln4584">  xp-&gt;xp_context = EXPAND_SETTINGS;</a>
<a name="ln4585">  if (*arg == NUL) {</a>
<a name="ln4586">    xp-&gt;xp_pattern = (char *)arg;</a>
<a name="ln4587">    return;</a>
<a name="ln4588">  }</a>
<a name="ln4589">  p = arg + STRLEN(arg) - 1;</a>
<a name="ln4590">  if (*p == ' ' &amp;&amp; *(p - 1) != '\\') {</a>
<a name="ln4591">    xp-&gt;xp_pattern = (char *)p + 1;</a>
<a name="ln4592">    return;</a>
<a name="ln4593">  }</a>
<a name="ln4594">  while (p &gt; arg) {</a>
<a name="ln4595">    s = p;</a>
<a name="ln4596">    // count number of backslashes before ' ' or ','</a>
<a name="ln4597">    if (*p == ' ' || *p == ',') {</a>
<a name="ln4598">      while (s &gt; arg &amp;&amp; *(s - 1) == '\\') {</a>
<a name="ln4599">        s--;</a>
<a name="ln4600">      }</a>
<a name="ln4601">    }</a>
<a name="ln4602">    // break at a space with an even number of backslashes</a>
<a name="ln4603">    if (*p == ' ' &amp;&amp; ((p - s) &amp; 1) == 0) {</a>
<a name="ln4604">      p++;</a>
<a name="ln4605">      break;</a>
<a name="ln4606">    }</a>
<a name="ln4607">    p--;</a>
<a name="ln4608">  }</a>
<a name="ln4609">  if (STRNCMP(p, &quot;no&quot;, 2) == 0) {</a>
<a name="ln4610">    xp-&gt;xp_context = EXPAND_BOOL_SETTINGS;</a>
<a name="ln4611">    p += 2;</a>
<a name="ln4612">  }</a>
<a name="ln4613">  if (STRNCMP(p, &quot;inv&quot;, 3) == 0) {</a>
<a name="ln4614">    xp-&gt;xp_context = EXPAND_BOOL_SETTINGS;</a>
<a name="ln4615">    p += 3;</a>
<a name="ln4616">  }</a>
<a name="ln4617">  xp-&gt;xp_pattern = (char *)p;</a>
<a name="ln4618">  arg = p;</a>
<a name="ln4619">  if (*arg == '&lt;') {</a>
<a name="ln4620">    while (*p != '&gt;') {</a>
<a name="ln4621">      if (*p++ == NUL) {            // expand terminal option name</a>
<a name="ln4622">        return;</a>
<a name="ln4623">      }</a>
<a name="ln4624">    }</a>
<a name="ln4625">    key = get_special_key_code(arg + 1);</a>
<a name="ln4626">    if (key == 0) {                 // unknown name</a>
<a name="ln4627">      xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln4628">      return;</a>
<a name="ln4629">    }</a>
<a name="ln4630">    nextchar = *++p;</a>
<a name="ln4631">    is_term_option = true;</a>
<a name="ln4632">    expand_option_name[2] = (char_u)KEY2TERMCAP0(key);</a>
<a name="ln4633">    expand_option_name[3] = KEY2TERMCAP1(key);</a>
<a name="ln4634">  } else {</a>
<a name="ln4635">    if (p[0] == 't' &amp;&amp; p[1] == '_') {</a>
<a name="ln4636">      p += 2;</a>
<a name="ln4637">      if (*p != NUL) {</a>
<a name="ln4638">        p++;</a>
<a name="ln4639">      }</a>
<a name="ln4640">      if (*p == NUL) {</a>
<a name="ln4641">        return;                 // expand option name</a>
<a name="ln4642">      }</a>
<a name="ln4643">      nextchar = *++p;</a>
<a name="ln4644">      is_term_option = true;</a>
<a name="ln4645">      expand_option_name[2] = p[-2];</a>
<a name="ln4646">      expand_option_name[3] = p[-1];</a>
<a name="ln4647">    } else {</a>
<a name="ln4648">      // Allow * wildcard.</a>
<a name="ln4649">      while (ASCII_ISALNUM(*p) || *p == '_' || *p == '*') {</a>
<a name="ln4650">        p++;</a>
<a name="ln4651">      }</a>
<a name="ln4652">      if (*p == NUL) {</a>
<a name="ln4653">        return;</a>
<a name="ln4654">      }</a>
<a name="ln4655">      nextchar = *p;</a>
<a name="ln4656">      opt_idx = findoption_len((const char *)arg, (size_t)(p - arg));</a>
<a name="ln4657">      if (opt_idx == -1 || options[opt_idx].var == NULL) {</a>
<a name="ln4658">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln4659">        return;</a>
<a name="ln4660">      }</a>
<a name="ln4661">      flags = options[opt_idx].flags;</a>
<a name="ln4662">      if (flags &amp; P_BOOL) {</a>
<a name="ln4663">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln4664">        return;</a>
<a name="ln4665">      }</a>
<a name="ln4666">    }</a>
<a name="ln4667">  }</a>
<a name="ln4668">  // handle &quot;-=&quot; and &quot;+=&quot;</a>
<a name="ln4669">  if ((nextchar == '-' || nextchar == '+' || nextchar == '^') &amp;&amp; p[1] == '=') {</a>
<a name="ln4670">    p++;</a>
<a name="ln4671">    nextchar = '=';</a>
<a name="ln4672">  }</a>
<a name="ln4673">  if ((nextchar != '=' &amp;&amp; nextchar != ':')</a>
<a name="ln4674">      || xp-&gt;xp_context == EXPAND_BOOL_SETTINGS) {</a>
<a name="ln4675">    xp-&gt;xp_context = EXPAND_UNSUCCESSFUL;</a>
<a name="ln4676">    return;</a>
<a name="ln4677">  }</a>
<a name="ln4678">  if (p[1] == NUL) {</a>
<a name="ln4679">    xp-&gt;xp_context = EXPAND_OLD_SETTING;</a>
<a name="ln4680">    if (is_term_option) {</a>
<a name="ln4681">      expand_option_idx = -1;</a>
<a name="ln4682">    } else {</a>
<a name="ln4683">      expand_option_idx = opt_idx;</a>
<a name="ln4684">    }</a>
<a name="ln4685">    xp-&gt;xp_pattern = (char *)p + 1;</a>
<a name="ln4686">    return;</a>
<a name="ln4687">  }</a>
<a name="ln4688">  xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln4689">  if (is_term_option || (flags &amp; P_NUM)) {</a>
<a name="ln4690">    return;</a>
<a name="ln4691">  }</a>
<a name="ln4692"> </a>
<a name="ln4693">  xp-&gt;xp_pattern = (char *)p + 1;</a>
<a name="ln4694"> </a>
<a name="ln4695">  if (flags &amp; P_EXPAND) {</a>
<a name="ln4696">    p = options[opt_idx].var;</a>
<a name="ln4697">    if (p == (char_u *)&amp;p_bdir</a>
<a name="ln4698">        || p == (char_u *)&amp;p_dir</a>
<a name="ln4699">        || p == (char_u *)&amp;p_path</a>
<a name="ln4700">        || p == (char_u *)&amp;p_pp</a>
<a name="ln4701">        || p == (char_u *)&amp;p_rtp</a>
<a name="ln4702">        || p == (char_u *)&amp;p_cdpath</a>
<a name="ln4703">        || p == (char_u *)&amp;p_vdir) {</a>
<a name="ln4704">      xp-&gt;xp_context = EXPAND_DIRECTORIES;</a>
<a name="ln4705">      if (p == (char_u *)&amp;p_path</a>
<a name="ln4706">          || p == (char_u *)&amp;p_cdpath) {</a>
<a name="ln4707">        xp-&gt;xp_backslash = XP_BS_THREE;</a>
<a name="ln4708">      } else {</a>
<a name="ln4709">        xp-&gt;xp_backslash = XP_BS_ONE;</a>
<a name="ln4710">      }</a>
<a name="ln4711">    } else if (p == (char_u *)&amp;p_ft) {</a>
<a name="ln4712">      xp-&gt;xp_context = EXPAND_FILETYPE;</a>
<a name="ln4713">    } else {</a>
<a name="ln4714">      xp-&gt;xp_context = EXPAND_FILES;</a>
<a name="ln4715">      // for 'tags' need three backslashes for a space</a>
<a name="ln4716">      if (p == (char_u *)&amp;p_tags) {</a>
<a name="ln4717">        xp-&gt;xp_backslash = XP_BS_THREE;</a>
<a name="ln4718">      } else {</a>
<a name="ln4719">        xp-&gt;xp_backslash = XP_BS_ONE;</a>
<a name="ln4720">      }</a>
<a name="ln4721">    }</a>
<a name="ln4722">  }</a>
<a name="ln4723"> </a>
<a name="ln4724">  // For an option that is a list of file names, find the start of the</a>
<a name="ln4725">  // last file name.</a>
<a name="ln4726">  for (p = arg + STRLEN(arg) - 1; p &gt; (char_u *)xp-&gt;xp_pattern; p--) {</a>
<a name="ln4727">    // count number of backslashes before ' ' or ','</a>
<a name="ln4728">    if (*p == ' ' || *p == ',') {</a>
<a name="ln4729">      s = p;</a>
<a name="ln4730">      while (s &gt; (char_u *)xp-&gt;xp_pattern &amp;&amp; *(s - 1) == '\\') {</a>
<a name="ln4731">        s--;</a>
<a name="ln4732">      }</a>
<a name="ln4733">      if ((*p == ' ' &amp;&amp; (xp-&gt;xp_backslash == XP_BS_THREE &amp;&amp; (p - s) &lt; 3))</a>
<a name="ln4734">          || (*p == ',' &amp;&amp; (flags &amp; P_COMMA) &amp;&amp; ((p - s) &amp; 1) == 0)) {</a>
<a name="ln4735">        xp-&gt;xp_pattern = (char *)p + 1;</a>
<a name="ln4736">        break;</a>
<a name="ln4737">      }</a>
<a name="ln4738">    }</a>
<a name="ln4739"> </a>
<a name="ln4740">    // for 'spellsuggest' start at &quot;file:&quot;</a>
<a name="ln4741">    if (options[opt_idx].var == (char_u *)&amp;p_sps</a>
<a name="ln4742">        &amp;&amp; STRNCMP(p, &quot;file:&quot;, 5) == 0) {</a>
<a name="ln4743">      xp-&gt;xp_pattern = (char *)p + 5;</a>
<a name="ln4744">      break;</a>
<a name="ln4745">    }</a>
<a name="ln4746">  }</a>
<a name="ln4747">}</a>
<a name="ln4748"> </a>
<a name="ln4749">int ExpandSettings(expand_T *xp, regmatch_T *regmatch, int *num_file, char ***file)</a>
<a name="ln4750">{</a>
<a name="ln4751">  int num_normal = 0;  // Nr of matching non-term-code settings</a>
<a name="ln4752">  int match;</a>
<a name="ln4753">  int count = 0;</a>
<a name="ln4754">  char *str;</a>
<a name="ln4755">  int loop;</a>
<a name="ln4756">  static char *(names[]) = { &quot;all&quot; };</a>
<a name="ln4757">  int ic = regmatch-&gt;rm_ic;  // remember the ignore-case flag</a>
<a name="ln4758"> </a>
<a name="ln4759">  // do this loop twice:</a>
<a name="ln4760">  // loop == 0: count the number of matching options</a>
<a name="ln4761">  // loop == 1: copy the matching options into allocated memory</a>
<a name="ln4762">  for (loop = 0; loop &lt;= 1; loop++) {</a>
<a name="ln4763">    regmatch-&gt;rm_ic = ic;</a>
<a name="ln4764">    if (xp-&gt;xp_context != EXPAND_BOOL_SETTINGS) {</a>
<a name="ln4765">      for (match = 0; match &lt; (int)ARRAY_SIZE(names);</a>
<a name="ln4766">           match++) {</a>
<a name="ln4767">        if (vim_regexec(regmatch, names[match], (colnr_T)0)) {</a>
<a name="ln4768">          if (loop == 0) {</a>
<a name="ln4769">            num_normal++;</a>
<a name="ln4770">          } else {</a>
<a name="ln4771">            (*file)[count++] = xstrdup(names[match]);</a>
<a name="ln4772">          }</a>
<a name="ln4773">        }</a>
<a name="ln4774">      }</a>
<a name="ln4775">    }</a>
<a name="ln4776">    for (size_t opt_idx = 0; (str = options[opt_idx].fullname) != NULL;</a>
<a name="ln4777">         opt_idx++) {</a>
<a name="ln4778">      if (options[opt_idx].var == NULL) {</a>
<a name="ln4779">        continue;</a>
<a name="ln4780">      }</a>
<a name="ln4781">      if (xp-&gt;xp_context == EXPAND_BOOL_SETTINGS</a>
<a name="ln4782">          &amp;&amp; !(options[opt_idx].flags &amp; P_BOOL)) {</a>
<a name="ln4783">        continue;</a>
<a name="ln4784">      }</a>
<a name="ln4785">      match = false;</a>
<a name="ln4786">      if (vim_regexec(regmatch, str, (colnr_T)0)</a>
<a name="ln4787">          || (options[opt_idx].shortname != NULL</a>
<a name="ln4788">              &amp;&amp; vim_regexec(regmatch,</a>
<a name="ln4789">                             options[opt_idx].shortname,</a>
<a name="ln4790">                             (colnr_T)0))) {</a>
<a name="ln4791">        match = true;</a>
<a name="ln4792">      }</a>
<a name="ln4793"> </a>
<a name="ln4794">      if (match) {</a>
<a name="ln4795">        if (loop == 0) {</a>
<a name="ln4796">          num_normal++;</a>
<a name="ln4797">        } else {</a>
<a name="ln4798">          (*file)[count++] = xstrdup(str);</a>
<a name="ln4799">        }</a>
<a name="ln4800">      }</a>
<a name="ln4801">    }</a>
<a name="ln4802"> </a>
<a name="ln4803">    if (loop == 0) {</a>
<a name="ln4804">      if (num_normal &gt; 0) {</a>
<a name="ln4805">        *num_file = num_normal;</a>
<a name="ln4806">      } else {</a>
<a name="ln4807">        return OK;</a>
<a name="ln4808">      }</a>
<a name="ln4809">      *file = xmalloc((size_t)(*num_file) * sizeof(char *));</a>
<a name="ln4810">    }</a>
<a name="ln4811">  }</a>
<a name="ln4812">  return OK;</a>
<a name="ln4813">}</a>
<a name="ln4814"> </a>
<a name="ln4815">void ExpandOldSetting(int *num_file, char ***file)</a>
<a name="ln4816">{</a>
<a name="ln4817">  char_u *var = NULL;</a>
<a name="ln4818"> </a>
<a name="ln4819">  *num_file = 0;</a>
<a name="ln4820">  *file = xmalloc(sizeof(char_u *));</a>
<a name="ln4821"> </a>
<a name="ln4822">  // For a terminal key code expand_option_idx is &lt; 0.</a>
<a name="ln4823">  if (expand_option_idx &lt; 0) {</a>
<a name="ln4824">    expand_option_idx = findoption((const char *)expand_option_name);</a>
<a name="ln4825">  }</a>
<a name="ln4826"> </a>
<a name="ln4827">  if (expand_option_idx &gt;= 0) {</a>
<a name="ln4828">    // Put string of option value in NameBuff.</a>
<a name="ln4829">    option_value2string(&amp;options[expand_option_idx], expand_option_flags);</a>
<a name="ln4830">    var = (char_u *)NameBuff;</a>
<a name="ln4831">  } else {</a>
<a name="ln4832">    var = (char_u *)&quot;&quot;;</a>
<a name="ln4833">  }</a>
<a name="ln4834"> </a>
<a name="ln4835">  // A backslash is required before some characters.  This is the reverse of</a>
<a name="ln4836">  // what happens in do_set().</a>
<a name="ln4837">  char_u *buf = vim_strsave_escaped(var, escape_chars);</a>
<a name="ln4838"> </a>
<a name="ln4839">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln4840">  // For MS-Windows et al. we don't double backslashes at the start and</a>
<a name="ln4841">  // before a file name character.</a>
<a name="ln4842">  for (var = buf; *var != NUL; MB_PTR_ADV(var)) {</a>
<a name="ln4843">    if (var[0] == '\\' &amp;&amp; var[1] == '\\'</a>
<a name="ln4844">        &amp;&amp; expand_option_idx &gt;= 0</a>
<a name="ln4845">        &amp;&amp; (options[expand_option_idx].flags &amp; P_EXPAND)</a>
<a name="ln4846">        &amp;&amp; vim_isfilec(var[2])</a>
<a name="ln4847">        &amp;&amp; (var[2] != '\\' || (var == buf &amp;&amp; var[4] != '\\'))) {</a>
<a name="ln4848">      STRMOVE(var, var + 1);</a>
<a name="ln4849">    }</a>
<a name="ln4850">  }</a>
<a name="ln4851">#endif</a>
<a name="ln4852"> </a>
<a name="ln4853">  *file[0] = (char *)buf;</a>
<a name="ln4854">  *num_file = 1;</a>
<a name="ln4855">}</a>
<a name="ln4856"> </a>
<a name="ln4857">/// Get the value for the numeric or string option///opp in a nice format into</a>
<a name="ln4858">/// NameBuff[].  Must not be called with a hidden option!</a>
<a name="ln4859">///</a>
<a name="ln4860">/// @param opt_flags  OPT_GLOBAL and/or OPT_LOCAL</a>
<a name="ln4861">static void option_value2string(vimoption_T *opp, int opt_flags)</a>
<a name="ln4862">{</a>
<a name="ln4863">  char_u *varp = (char_u *)get_varp_scope(opp, opt_flags);</a>
<a name="ln4864"> </a>
<a name="ln4865">  if (opp-&gt;flags &amp; P_NUM) {</a>
<a name="ln4866">    long wc = 0;</a>
<a name="ln4867"> </a>
<a name="ln4868">    if (wc_use_keyname(varp, &amp;wc)) {</a>
<a name="ln4869">      STRLCPY(NameBuff, get_special_key_name((int)wc, 0), sizeof(NameBuff));</a>
<a name="ln4870">    } else if (wc != 0) {</a>
<a name="ln4871">      STRLCPY(NameBuff, transchar((int)wc), sizeof(NameBuff));</a>
<a name="ln4872">    } else {</a>
<a name="ln4873">      snprintf((char *)NameBuff,</a>
<a name="ln4874">               sizeof(NameBuff),</a>
<a name="ln4875">               &quot;%&quot; PRId64,</a>
<a name="ln4876">               (int64_t)(*(long *)varp));</a>
<a name="ln4877">    }</a>
<a name="ln4878">  } else {  // P_STRING</a>
<a name="ln4879">    varp = *(char_u **)(varp);</a>
<a name="ln4880">    if (varp == NULL) {  // Just in case.</a>
<a name="ln4881">      NameBuff[0] = NUL;</a>
<a name="ln4882">    } else if (opp-&gt;flags &amp; P_EXPAND) {</a>
<a name="ln4883">      home_replace(NULL, (char *)varp, (char *)NameBuff, MAXPATHL, false);</a>
<a name="ln4884">      // Translate 'pastetoggle' into special key names.</a>
<a name="ln4885">    } else if ((char **)opp-&gt;var == &amp;p_pt) {</a>
<a name="ln4886">      str2specialbuf((const char *)p_pt, (char *)NameBuff, MAXPATHL);</a>
<a name="ln4887">    } else {</a>
<a name="ln4888">      STRLCPY(NameBuff, varp, MAXPATHL);</a>
<a name="ln4889">    }</a>
<a name="ln4890">  }</a>
<a name="ln4891">}</a>
<a name="ln4892"> </a>
<a name="ln4893">/// Return true if &quot;varp&quot; points to 'wildchar' or 'wildcharm' and it can be</a>
<a name="ln4894">/// printed as a keyname.</a>
<a name="ln4895">/// &quot;*wcp&quot; is set to the value of the option if it's 'wildchar' or 'wildcharm'.</a>
<a name="ln4896">static int wc_use_keyname(const char_u *varp, long *wcp)</a>
<a name="ln4897">{</a>
<a name="ln4898">  if (((long *)varp == &amp;p_wc) || ((long *)varp == &amp;p_wcm)) {</a>
<a name="ln4899">    *wcp = *(long *)varp;</a>
<a name="ln4900">    if (IS_SPECIAL(*wcp) || find_special_key_in_table((int)(*wcp)) &gt;= 0) {</a>
<a name="ln4901">      return true;</a>
<a name="ln4902">    }</a>
<a name="ln4903">  }</a>
<a name="ln4904">  return false;</a>
<a name="ln4905">}</a>
<a name="ln4906"> </a>
<a name="ln4907">/// @returns true if &quot;x&quot; is present in 'shortmess' option, or</a>
<a name="ln4908">/// 'shortmess' contains 'a' and &quot;x&quot; is present in SHM_ALL_ABBREVIATIONS.</a>
<a name="ln4909">bool shortmess(int x)</a>
<a name="ln4910">{</a>
<a name="ln4911">  return (p_shm != NULL</a>
<a name="ln4912">          &amp;&amp; (vim_strchr(p_shm, x) != NULL</a>
<a name="ln4913">              || (vim_strchr(p_shm, 'a') != NULL</a>
<a name="ln4914">                  &amp;&amp; vim_strchr(SHM_ALL_ABBREVIATIONS, x) != NULL)));</a>
<a name="ln4915">}</a>
<a name="ln4916"> </a>
<a name="ln4917">/// paste_option_changed() - Called after p_paste was set or reset.</a>
<a name="ln4918">static void paste_option_changed(void)</a>
<a name="ln4919">{</a>
<a name="ln4920">  static int old_p_paste = false;</a>
<a name="ln4921">  static int save_sm = 0;</a>
<a name="ln4922">  static int save_sta = 0;</a>
<a name="ln4923">  static int save_ru = 0;</a>
<a name="ln4924">  static int save_ri = 0;</a>
<a name="ln4925">  static int save_hkmap = 0;</a>
<a name="ln4926"> </a>
<a name="ln4927">  if (p_paste) {</a>
<a name="ln4928">    // Paste switched from off to on.</a>
<a name="ln4929">    // Save the current values, so they can be restored later.</a>
<a name="ln4930">    if (!old_p_paste) {</a>
<a name="ln4931">      // save options for each buffer</a>
<a name="ln4932">      FOR_ALL_BUFFERS(buf) {</a>
<a name="ln4933">        buf-&gt;b_p_tw_nopaste = buf-&gt;b_p_tw;</a>
<a name="ln4934">        buf-&gt;b_p_wm_nopaste = buf-&gt;b_p_wm;</a>
<a name="ln4935">        buf-&gt;b_p_sts_nopaste = buf-&gt;b_p_sts;</a>
<a name="ln4936">        buf-&gt;b_p_ai_nopaste = buf-&gt;b_p_ai;</a>
<a name="ln4937">        buf-&gt;b_p_et_nopaste = buf-&gt;b_p_et;</a>
<a name="ln4938">        if (buf-&gt;b_p_vsts_nopaste) {</a>
<a name="ln4939">          xfree(buf-&gt;b_p_vsts_nopaste);</a>
<a name="ln4940">        }</a>
<a name="ln4941">        buf-&gt;b_p_vsts_nopaste = buf-&gt;b_p_vsts &amp;&amp; buf-&gt;b_p_vsts != empty_option</a>
<a name="ln4942">                                    ? xstrdup(buf-&gt;b_p_vsts)</a>
<a name="ln4943">                                    : NULL;</a>
<a name="ln4944">      }</a>
<a name="ln4945"> </a>
<a name="ln4946">      // save global options</a>
<a name="ln4947">      save_sm = p_sm;</a>
<a name="ln4948">      save_sta = p_sta;</a>
<a name="ln4949">      save_ru = p_ru;</a>
<a name="ln4950">      save_ri = p_ri;</a>
<a name="ln4951">      save_hkmap = p_hkmap;</a>
<a name="ln4952">      // save global values for local buffer options</a>
<a name="ln4953">      p_ai_nopaste = p_ai;</a>
<a name="ln4954">      p_et_nopaste = p_et;</a>
<a name="ln4955">      p_sts_nopaste = p_sts;</a>
<a name="ln4956">      p_tw_nopaste = p_tw;</a>
<a name="ln4957">      p_wm_nopaste = p_wm;</a>
<a name="ln4958">      if (p_vsts_nopaste) {</a>
<a name="ln4959">        xfree(p_vsts_nopaste);</a>
<a name="ln4960">      }</a>
<a name="ln4961">      p_vsts_nopaste = p_vsts &amp;&amp; p_vsts != empty_option ? xstrdup(p_vsts) : NULL;</a>
<a name="ln4962">    }</a>
<a name="ln4963"> </a>
<a name="ln4964">    // Always set the option values, also when 'paste' is set when it is</a>
<a name="ln4965">    // already on.</a>
<a name="ln4966">    // set options for each buffer</a>
<a name="ln4967">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln4968">      buf-&gt;b_p_tw = 0;              // textwidth is 0</a>
<a name="ln4969">      buf-&gt;b_p_wm = 0;              // wrapmargin is 0</a>
<a name="ln4970">      buf-&gt;b_p_sts = 0;             // softtabstop is 0</a>
<a name="ln4971">      buf-&gt;b_p_ai = 0;              // no auto-indent</a>
<a name="ln4972">      buf-&gt;b_p_et = 0;              // no expandtab</a>
<a name="ln4973">      if (buf-&gt;b_p_vsts) {</a>
<a name="ln4974">        free_string_option(buf-&gt;b_p_vsts);</a>
<a name="ln4975">      }</a>
<a name="ln4976">      buf-&gt;b_p_vsts = empty_option;</a>
<a name="ln4977">      XFREE_CLEAR(buf-&gt;b_p_vsts_array);</a>
<a name="ln4978">    }</a>
<a name="ln4979"> </a>
<a name="ln4980">    // set global options</a>
<a name="ln4981">    p_sm = 0;                       // no showmatch</a>
<a name="ln4982">    p_sta = 0;                      // no smarttab</a>
<a name="ln4983">    if (p_ru) {</a>
<a name="ln4984">      status_redraw_all();          // redraw to remove the ruler</a>
<a name="ln4985">    }</a>
<a name="ln4986">    p_ru = 0;                       // no ruler</a>
<a name="ln4987">    p_ri = 0;                       // no reverse insert</a>
<a name="ln4988">    p_hkmap = 0;                    // no Hebrew keyboard</a>
<a name="ln4989">    // set global values for local buffer options</a>
<a name="ln4990">    p_tw = 0;</a>
<a name="ln4991">    p_wm = 0;</a>
<a name="ln4992">    p_sts = 0;</a>
<a name="ln4993">    p_ai = 0;</a>
<a name="ln4994">    if (p_vsts) {</a>
<a name="ln4995">      free_string_option(p_vsts);</a>
<a name="ln4996">    }</a>
<a name="ln4997">    p_vsts = empty_option;</a>
<a name="ln4998">  } else if (old_p_paste) {</a>
<a name="ln4999">    // Paste switched from on to off: Restore saved values.</a>
<a name="ln5000"> </a>
<a name="ln5001">    // restore options for each buffer</a>
<a name="ln5002">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln5003">      buf-&gt;b_p_tw = buf-&gt;b_p_tw_nopaste;</a>
<a name="ln5004">      buf-&gt;b_p_wm = buf-&gt;b_p_wm_nopaste;</a>
<a name="ln5005">      buf-&gt;b_p_sts = buf-&gt;b_p_sts_nopaste;</a>
<a name="ln5006">      buf-&gt;b_p_ai = buf-&gt;b_p_ai_nopaste;</a>
<a name="ln5007">      buf-&gt;b_p_et = buf-&gt;b_p_et_nopaste;</a>
<a name="ln5008">      if (buf-&gt;b_p_vsts) {</a>
<a name="ln5009">        free_string_option(buf-&gt;b_p_vsts);</a>
<a name="ln5010">      }</a>
<a name="ln5011">      buf-&gt;b_p_vsts = buf-&gt;b_p_vsts_nopaste ? xstrdup(buf-&gt;b_p_vsts_nopaste) : empty_option;</a>
<a name="ln5012">      xfree(buf-&gt;b_p_vsts_array);</a>
<a name="ln5013">      if (buf-&gt;b_p_vsts &amp;&amp; buf-&gt;b_p_vsts != empty_option) {</a>
<a name="ln5014">        (void)tabstop_set(buf-&gt;b_p_vsts, &amp;buf-&gt;b_p_vsts_array);</a>
<a name="ln5015">      } else {</a>
<a name="ln5016">        buf-&gt;b_p_vsts_array = NULL;</a>
<a name="ln5017">      }</a>
<a name="ln5018">    }</a>
<a name="ln5019"> </a>
<a name="ln5020">    // restore global options</a>
<a name="ln5021">    p_sm = save_sm;</a>
<a name="ln5022">    p_sta = save_sta;</a>
<a name="ln5023">    if (p_ru != save_ru) {</a>
<a name="ln5024">      status_redraw_all();          // redraw to draw the ruler</a>
<a name="ln5025">    }</a>
<a name="ln5026">    p_ru = save_ru;</a>
<a name="ln5027">    p_ri = save_ri;</a>
<a name="ln5028">    p_hkmap = save_hkmap;</a>
<a name="ln5029">    // set global values for local buffer options</a>
<a name="ln5030">    p_ai = p_ai_nopaste;</a>
<a name="ln5031">    p_et = p_et_nopaste;</a>
<a name="ln5032">    p_sts = p_sts_nopaste;</a>
<a name="ln5033">    p_tw = p_tw_nopaste;</a>
<a name="ln5034">    p_wm = p_wm_nopaste;</a>
<a name="ln5035">    if (p_vsts) {</a>
<a name="ln5036">      free_string_option(p_vsts);</a>
<a name="ln5037">    }</a>
<a name="ln5038">    p_vsts = p_vsts_nopaste ? xstrdup(p_vsts_nopaste) : empty_option;</a>
<a name="ln5039">  }</a>
<a name="ln5040"> </a>
<a name="ln5041">  old_p_paste = p_paste;</a>
<a name="ln5042">}</a>
<a name="ln5043"> </a>
<a name="ln5044">/// vimrc_found() - Called when a vimrc or &quot;VIMINIT&quot; has been found.</a>
<a name="ln5045">///</a>
<a name="ln5046">/// Set the values for options that didn't get set yet to the defaults.</a>
<a name="ln5047">/// When &quot;fname&quot; is not NULL, use it to set $&quot;envname&quot; when it wasn't set yet.</a>
<a name="ln5048">void vimrc_found(char *fname, char *envname)</a>
<a name="ln5049">{</a>
<a name="ln5050">  if (fname != NULL &amp;&amp; envname != NULL) {</a>
<a name="ln5051">    char *p = vim_getenv(envname);</a>
<a name="ln5052">    if (p == NULL) {</a>
<a name="ln5053">      // Set $MYVIMRC to the first vimrc file found.</a>
<a name="ln5054">      p = FullName_save(fname, false);</a>
<a name="ln5055">      if (p != NULL) {</a>
<a name="ln5056">        os_setenv(envname, p, 1);</a>
<a name="ln5057">        xfree(p);</a>
<a name="ln5058">      }</a>
<a name="ln5059">    } else {</a>
<a name="ln5060">      xfree(p);</a>
<a name="ln5061">    }</a>
<a name="ln5062">  }</a>
<a name="ln5063">}</a>
<a name="ln5064"> </a>
<a name="ln5065">/// Check whether global option has been set</a>
<a name="ln5066">///</a>
<a name="ln5067">/// @param[in]  name  Option name.</a>
<a name="ln5068">///</a>
<a name="ln5069">/// @return True if it was set.</a>
<a name="ln5070">bool option_was_set(const char *name)</a>
<a name="ln5071">{</a>
<a name="ln5072">  int idx;</a>
<a name="ln5073"> </a>
<a name="ln5074">  idx = findoption(name);</a>
<a name="ln5075">  if (idx &lt; 0) {  // Unknown option.</a>
<a name="ln5076">    return false;</a>
<a name="ln5077">  } else if (options[idx].flags &amp; P_WAS_SET) {</a>
<a name="ln5078">    return true;</a>
<a name="ln5079">  }</a>
<a name="ln5080">  return false;</a>
<a name="ln5081">}</a>
<a name="ln5082"> </a>
<a name="ln5083">/// Reset the flag indicating option &quot;name&quot; was set.</a>
<a name="ln5084">///</a>
<a name="ln5085">/// @param[in]  name  Option name.</a>
<a name="ln5086">void reset_option_was_set(const char *name)</a>
<a name="ln5087">{</a>
<a name="ln5088">  const int idx = findoption(name);</a>
<a name="ln5089"> </a>
<a name="ln5090">  if (idx &gt;= 0) {</a>
<a name="ln5091">    options[idx].flags &amp;= ~P_WAS_SET;</a>
<a name="ln5092">  }</a>
<a name="ln5093">}</a>
<a name="ln5094"> </a>
<a name="ln5095">/// fill_breakat_flags() -- called when 'breakat' changes value.</a>
<a name="ln5096">void fill_breakat_flags(void)</a>
<a name="ln5097">{</a>
<a name="ln5098">  char_u *p;</a>
<a name="ln5099">  int i;</a>
<a name="ln5100"> </a>
<a name="ln5101">  for (i = 0; i &lt; 256; i++) {</a>
<a name="ln5102">    breakat_flags[i] = false;</a>
<a name="ln5103">  }</a>
<a name="ln5104"> </a>
<a name="ln5105">  if (p_breakat != NULL) {</a>
<a name="ln5106">    for (p = (char_u *)p_breakat; *p; p++) {</a>
<a name="ln5107">      breakat_flags[*p] = true;</a>
<a name="ln5108">    }</a>
<a name="ln5109">  }</a>
<a name="ln5110">}</a>
<a name="ln5111"> </a>
<a name="ln5112">/// fill_culopt_flags() -- called when 'culopt' changes value</a>
<a name="ln5113">int fill_culopt_flags(char *val, win_T *wp)</a>
<a name="ln5114">{</a>
<a name="ln5115">  char *p;</a>
<a name="ln5116">  char_u culopt_flags_new = 0;</a>
<a name="ln5117"> </a>
<a name="ln5118">  if (val == NULL) {</a>
<a name="ln5119">    p = wp-&gt;w_p_culopt;</a>
<a name="ln5120">  } else {</a>
<a name="ln5121">    p = val;</a>
<a name="ln5122">  }</a>
<a name="ln5123">  while (*p != NUL) {</a>
<a name="ln5124">    if (STRNCMP(p, &quot;line&quot;, 4) == 0) {</a>
<a name="ln5125">      p += 4;</a>
<a name="ln5126">      culopt_flags_new |= CULOPT_LINE;</a>
<a name="ln5127">    } else if (STRNCMP(p, &quot;both&quot;, 4) == 0) {</a>
<a name="ln5128">      p += 4;</a>
<a name="ln5129">      culopt_flags_new |= CULOPT_LINE | CULOPT_NBR;</a>
<a name="ln5130">    } else if (STRNCMP(p, &quot;number&quot;, 6) == 0) {</a>
<a name="ln5131">      p += 6;</a>
<a name="ln5132">      culopt_flags_new |= CULOPT_NBR;</a>
<a name="ln5133">    } else if (STRNCMP(p, &quot;screenline&quot;, 10) == 0) {</a>
<a name="ln5134">      p += 10;</a>
<a name="ln5135">      culopt_flags_new |= CULOPT_SCRLINE;</a>
<a name="ln5136">    }</a>
<a name="ln5137"> </a>
<a name="ln5138">    if (*p != ',' &amp;&amp; *p != NUL) {</a>
<a name="ln5139">      return FAIL;</a>
<a name="ln5140">    }</a>
<a name="ln5141">    if (*p == ',') {</a>
<a name="ln5142">      p++;</a>
<a name="ln5143">    }</a>
<a name="ln5144">  }</a>
<a name="ln5145"> </a>
<a name="ln5146">  // Can't have both &quot;line&quot; and &quot;screenline&quot;.</a>
<a name="ln5147">  if ((culopt_flags_new &amp; CULOPT_LINE) &amp;&amp; (culopt_flags_new &amp; CULOPT_SCRLINE)) {</a>
<a name="ln5148">    return FAIL;</a>
<a name="ln5149">  }</a>
<a name="ln5150">  wp-&gt;w_p_culopt_flags = culopt_flags_new;</a>
<a name="ln5151"> </a>
<a name="ln5152">  return OK;</a>
<a name="ln5153">}</a>
<a name="ln5154"> </a>
<a name="ln5155">/// Set the callback function value for an option that accepts a function name,</a>
<a name="ln5156">/// lambda, et al. (e.g. 'operatorfunc', 'tagfunc', etc.)</a>
<a name="ln5157">/// @return  OK if the option is successfully set to a function, otherwise FAIL</a>
<a name="ln5158">int option_set_callback_func(char *optval, Callback *optcb)</a>
<a name="ln5159">{</a>
<a name="ln5160">  if (optval == NULL || *optval == NUL) {</a>
<a name="ln5161">    callback_free(optcb);</a>
<a name="ln5162">    return OK;</a>
<a name="ln5163">  }</a>
<a name="ln5164"> </a>
<a name="ln5165">  typval_T *tv;</a>
<a name="ln5166">  if (*optval == '{'</a>
<a name="ln5167">      || (STRNCMP(optval, &quot;function(&quot;, 9) == 0)</a>
<a name="ln5168">      || (STRNCMP(optval, &quot;funcref(&quot;, 8) == 0)) {</a>
<a name="ln5169">    // Lambda expression or a funcref</a>
<a name="ln5170">    tv = eval_expr(optval);</a>
<a name="ln5171">    if (tv == NULL) {</a>
<a name="ln5172">      return FAIL;</a>
<a name="ln5173">    }</a>
<a name="ln5174">  } else {</a>
<a name="ln5175">    // treat everything else as a function name string</a>
<a name="ln5176">    tv = xcalloc(1, sizeof(*tv));</a>
<a name="ln5177">    tv-&gt;v_type = VAR_STRING;</a>
<a name="ln5178">    tv-&gt;vval.v_string = xstrdup(optval);</a>
<a name="ln5179">  }</a>
<a name="ln5180"> </a>
<a name="ln5181">  Callback cb;</a>
<a name="ln5182">  if (!callback_from_typval(&amp;cb, tv)) {</a>
<a name="ln5183">    tv_free(tv);</a>
<a name="ln5184">    return FAIL;</a>
<a name="ln5185">  }</a>
<a name="ln5186"> </a>
<a name="ln5187">  callback_free(optcb);</a>
<a name="ln5188">  *optcb = cb;</a>
<a name="ln5189">  tv_free(tv);</a>
<a name="ln5190">  return OK;</a>
<a name="ln5191">}</a>
<a name="ln5192"> </a>
<a name="ln5193">/// Check if backspacing over something is allowed.</a>
<a name="ln5194">/// @param  what  BS_INDENT, BS_EOL, BS_START, or BS_NOSTOP</a>
<a name="ln5195">bool can_bs(int what)</a>
<a name="ln5196">{</a>
<a name="ln5197">  if (what == BS_START &amp;&amp; bt_prompt(curbuf)) {</a>
<a name="ln5198">    return false;</a>
<a name="ln5199">  }</a>
<a name="ln5200">  switch (*p_bs) {</a>
<a name="ln5201">  case '3':</a>
<a name="ln5202">    return true;</a>
<a name="ln5203">  case '2':</a>
<a name="ln5204">    return what != BS_NOSTOP;</a>
<a name="ln5205">  case '1':</a>
<a name="ln5206">    return what != BS_START;</a>
<a name="ln5207">  case '0':</a>
<a name="ln5208">    return false;</a>
<a name="ln5209">  }</a>
<a name="ln5210">  return vim_strchr(p_bs, what) != NULL;</a>
<a name="ln5211">}</a>
<a name="ln5212"> </a>
<a name="ln5213">/// Get the local or global value of 'backupcopy'.</a>
<a name="ln5214">///</a>
<a name="ln5215">/// @param buf The buffer.</a>
<a name="ln5216">unsigned int get_bkc_value(buf_T *buf)</a>
<a name="ln5217">{</a>
<a name="ln5218">  return buf-&gt;b_bkc_flags ? buf-&gt;b_bkc_flags : bkc_flags;</a>
<a name="ln5219">}</a>
<a name="ln5220"> </a>
<a name="ln5221">/// Get the local or global value of the 'virtualedit' flags.</a>
<a name="ln5222">unsigned int get_ve_flags(void)</a>
<a name="ln5223">{</a>
<a name="ln5224">  return (curwin-&gt;w_ve_flags ? curwin-&gt;w_ve_flags : ve_flags) &amp; ~(VE_NONE | VE_NONEU);</a>
<a name="ln5225">}</a>
<a name="ln5226"> </a>
<a name="ln5227">/// Get the local or global value of 'showbreak'.</a>
<a name="ln5228">///</a>
<a name="ln5229">/// @param win  If not NULL, the window to get the local option from; global</a>
<a name="ln5230">///             otherwise.</a>
<a name="ln5231">char_u *get_showbreak_value(win_T *const win)</a>
<a name="ln5232">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5233">{</a>
<a name="ln5234">  if (win-&gt;w_p_sbr == NULL || *win-&gt;w_p_sbr == NUL) {</a>
<a name="ln5235">    return (char_u *)p_sbr;</a>
<a name="ln5236">  }</a>
<a name="ln5237">  if (strcmp(win-&gt;w_p_sbr, &quot;NONE&quot;) == 0) {</a>
<a name="ln5238">    return (char_u *)empty_option;</a>
<a name="ln5239">  }</a>
<a name="ln5240">  return (char_u *)win-&gt;w_p_sbr;</a>
<a name="ln5241">}</a>
<a name="ln5242"> </a>
<a name="ln5243">/// Return the current end-of-line type: EOL_DOS, EOL_UNIX or EOL_MAC.</a>
<a name="ln5244">int get_fileformat(const buf_T *buf)</a>
<a name="ln5245">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5246">{</a>
<a name="ln5247">  int c = (unsigned char)(*buf-&gt;b_p_ff);</a>
<a name="ln5248"> </a>
<a name="ln5249">  if (buf-&gt;b_p_bin || c == 'u') {</a>
<a name="ln5250">    return EOL_UNIX;</a>
<a name="ln5251">  }</a>
<a name="ln5252">  if (c == 'm') {</a>
<a name="ln5253">    return EOL_MAC;</a>
<a name="ln5254">  }</a>
<a name="ln5255">  return EOL_DOS;</a>
<a name="ln5256">}</a>
<a name="ln5257"> </a>
<a name="ln5258">/// Like get_fileformat(), but override 'fileformat' with &quot;p&quot; for &quot;++opt=val&quot;</a>
<a name="ln5259">/// argument.</a>
<a name="ln5260">///</a>
<a name="ln5261">/// @param eap  can be NULL!</a>
<a name="ln5262">int get_fileformat_force(const buf_T *buf, const exarg_T *eap)</a>
<a name="ln5263">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln5264">{</a>
<a name="ln5265">  int c;</a>
<a name="ln5266"> </a>
<a name="ln5267">  if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln5268">    c = eap-&gt;force_ff;</a>
<a name="ln5269">  } else {</a>
<a name="ln5270">    if ((eap != NULL &amp;&amp; eap-&gt;force_bin != 0)</a>
<a name="ln5271">        ? (eap-&gt;force_bin == FORCE_BIN) : buf-&gt;b_p_bin) {</a>
<a name="ln5272">      return EOL_UNIX;</a>
<a name="ln5273">    }</a>
<a name="ln5274">    c = (unsigned char)(*buf-&gt;b_p_ff);</a>
<a name="ln5275">  }</a>
<a name="ln5276">  if (c == 'u') {</a>
<a name="ln5277">    return EOL_UNIX;</a>
<a name="ln5278">  }</a>
<a name="ln5279">  if (c == 'm') {</a>
<a name="ln5280">    return EOL_MAC;</a>
<a name="ln5281">  }</a>
<a name="ln5282">  return EOL_DOS;</a>
<a name="ln5283">}</a>
<a name="ln5284"> </a>
<a name="ln5285">/// Return the default fileformat from 'fileformats'.</a>
<a name="ln5286">int default_fileformat(void)</a>
<a name="ln5287">{</a>
<a name="ln5288">  switch (*p_ffs) {</a>
<a name="ln5289">  case 'm':</a>
<a name="ln5290">    return EOL_MAC;</a>
<a name="ln5291">  case 'd':</a>
<a name="ln5292">    return EOL_DOS;</a>
<a name="ln5293">  }</a>
<a name="ln5294">  return EOL_UNIX;</a>
<a name="ln5295">}</a>
<a name="ln5296"> </a>
<a name="ln5297">/// Set the current end-of-line type to EOL_UNIX, EOL_MAC, or EOL_DOS.</a>
<a name="ln5298">///</a>
<a name="ln5299">/// Sets 'fileformat'.</a>
<a name="ln5300">///</a>
<a name="ln5301">/// @param eol_style End-of-line style.</a>
<a name="ln5302">/// @param opt_flags OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln5303">void set_fileformat(int eol_style, int opt_flags)</a>
<a name="ln5304">{</a>
<a name="ln5305">  char *p = NULL;</a>
<a name="ln5306"> </a>
<a name="ln5307">  switch (eol_style) {</a>
<a name="ln5308">  case EOL_UNIX:</a>
<a name="ln5309">    p = FF_UNIX;</a>
<a name="ln5310">    break;</a>
<a name="ln5311">  case EOL_MAC:</a>
<a name="ln5312">    p = FF_MAC;</a>
<a name="ln5313">    break;</a>
<a name="ln5314">  case EOL_DOS:</a>
<a name="ln5315">    p = FF_DOS;</a>
<a name="ln5316">    break;</a>
<a name="ln5317">  }</a>
<a name="ln5318"> </a>
<a name="ln5319">  // p is NULL if &quot;eol_style&quot; is EOL_UNKNOWN.</a>
<a name="ln5320">  if (p != NULL) {</a>
<a name="ln5321">    set_string_option_direct(&quot;ff&quot;, -1, p, OPT_FREE | opt_flags, 0);</a>
<a name="ln5322">  }</a>
<a name="ln5323"> </a>
<a name="ln5324">  // This may cause the buffer to become (un)modified.</a>
<a name="ln5325">  redraw_buf_status_later(curbuf);</a>
<a name="ln5326">  redraw_tabline = true;</a>
<a name="ln5327">  need_maketitle = true;  // Set window title later.</a>
<a name="ln5328">}</a>
<a name="ln5329"> </a>
<a name="ln5330">/// Skip to next part of an option argument: skip space and comma</a>
<a name="ln5331">char *skip_to_option_part(const char *p)</a>
<a name="ln5332">{</a>
<a name="ln5333">  if (*p == ',') {</a>
<a name="ln5334">    p++;</a>
<a name="ln5335">  }</a>
<a name="ln5336">  while (*p == ' ') {</a>
<a name="ln5337">    p++;</a>
<a name="ln5338">  }</a>
<a name="ln5339">  return (char *)p;</a>
<a name="ln5340">}</a>
<a name="ln5341"> </a>
<a name="ln5342">/// Isolate one part of a string option separated by `sep_chars`.</a>
<a name="ln5343">///</a>
<a name="ln5344">/// @param[in,out]  option    advanced to the next part</a>
<a name="ln5345">/// @param[in,out]  buf       copy of the isolated part</a>
<a name="ln5346">/// @param[in]      maxlen    length of `buf`</a>
<a name="ln5347">/// @param[in]      sep_chars chars that separate the option parts</a>
<a name="ln5348">///</a>
<a name="ln5349">/// @return length of `*option`</a>
<a name="ln5350">size_t copy_option_part(char **option, char *buf, size_t maxlen, char *sep_chars)</a>
<a name="ln5351">{</a>
<a name="ln5352">  size_t len = 0;</a>
<a name="ln5353">  char *p = *option;</a>
<a name="ln5354"> </a>
<a name="ln5355">  // skip '.' at start of option part, for 'suffixes'</a>
<a name="ln5356">  if (*p == '.') {</a>
<a name="ln5357">    buf[len++] = *p++;</a>
<a name="ln5358">  }</a>
<a name="ln5359">  while (*p != NUL &amp;&amp; vim_strchr(sep_chars, *p) == NULL) {</a>
<a name="ln5360">    // Skip backslash before a separator character and space.</a>
<a name="ln5361">    if (p[0] == '\\' &amp;&amp; vim_strchr(sep_chars, p[1]) != NULL) {</a>
<a name="ln5362">      p++;</a>
<a name="ln5363">    }</a>
<a name="ln5364">    if (len &lt; maxlen - 1) {</a>
<a name="ln5365">      buf[len++] = *p;</a>
<a name="ln5366">    }</a>
<a name="ln5367">    p++;</a>
<a name="ln5368">  }</a>
<a name="ln5369">  buf[len] = NUL;</a>
<a name="ln5370"> </a>
<a name="ln5371">  if (*p != NUL &amp;&amp; *p != ',') {  // skip non-standard separator</a>
<a name="ln5372">    p++;</a>
<a name="ln5373">  }</a>
<a name="ln5374">  p = skip_to_option_part(p);    // p points to next file name</a>
<a name="ln5375"> </a>
<a name="ln5376">  *option = p;</a>
<a name="ln5377">  return len;</a>
<a name="ln5378">}</a>
<a name="ln5379"> </a>
<a name="ln5380">/// Return true when 'shell' has &quot;csh&quot; in the tail.</a>
<a name="ln5381">int csh_like_shell(void)</a>
<a name="ln5382">{</a>
<a name="ln5383">  return strstr(path_tail(p_sh), &quot;csh&quot;) != NULL;</a>
<a name="ln5384">}</a>
<a name="ln5385"> </a>
<a name="ln5386">/// Return true when 'shell' has &quot;fish&quot; in the tail.</a>
<a name="ln5387">bool fish_like_shell(void)</a>
<a name="ln5388">{</a>
<a name="ln5389">  return strstr(path_tail(p_sh), &quot;fish&quot;) != NULL;</a>
<a name="ln5390">}</a>
<a name="ln5391"> </a>
<a name="ln5392">/// Return the number of requested sign columns, based on current</a>
<a name="ln5393">/// buffer signs and on user configuration.</a>
<a name="ln5394">int win_signcol_count(win_T *wp)</a>
<a name="ln5395">{</a>
<a name="ln5396">  return win_signcol_configured(wp, NULL);</a>
<a name="ln5397">}</a>
<a name="ln5398"> </a>
<a name="ln5399">/// Return the number of requested sign columns, based on user / configuration.</a>
<a name="ln5400">int win_signcol_configured(win_T *wp, int *is_fixed)</a>
<a name="ln5401">{</a>
<a name="ln5402">  const char *scl = (const char *)wp-&gt;w_p_scl;</a>
<a name="ln5403"> </a>
<a name="ln5404">  if (is_fixed) {</a>
<a name="ln5405">    *is_fixed = 1;</a>
<a name="ln5406">  }</a>
<a name="ln5407"> </a>
<a name="ln5408">  // Note: It checks &quot;no&quot; or &quot;number&quot; in 'signcolumn' option</a>
<a name="ln5409">  if (*scl == 'n'</a>
<a name="ln5410">      &amp;&amp; (*(scl + 1) == 'o' || (*(scl + 1) == 'u'</a>
<a name="ln5411">                                &amp;&amp; (wp-&gt;w_p_nu || wp-&gt;w_p_rnu)))) {</a>
<a name="ln5412">    return 0;</a>
<a name="ln5413">  }</a>
<a name="ln5414"> </a>
<a name="ln5415">  // yes or yes</a>
<a name="ln5416">  if (!strncmp(scl, &quot;yes:&quot;, 4)) {</a>
<a name="ln5417">    // Fixed amount of columns</a>
<a name="ln5418">    return scl[4] - '0';</a>
<a name="ln5419">  }</a>
<a name="ln5420">  if (*scl == 'y') {</a>
<a name="ln5421">    return 1;</a>
<a name="ln5422">  }</a>
<a name="ln5423"> </a>
<a name="ln5424">  if (is_fixed) {</a>
<a name="ln5425">    // auto or auto:&lt;NUM&gt;</a>
<a name="ln5426">    *is_fixed = 0;</a>
<a name="ln5427">  }</a>
<a name="ln5428"> </a>
<a name="ln5429">  int minimum = 0, maximum = 1;</a>
<a name="ln5430"> </a>
<a name="ln5431">  if (!strncmp(scl, &quot;auto:&quot;, 5)) {</a>
<a name="ln5432">    // Variable depending on a configuration</a>
<a name="ln5433">    maximum = scl[5] - '0';</a>
<a name="ln5434">    // auto:&lt;NUM&gt;-&lt;NUM&gt;</a>
<a name="ln5435">    if (strlen(scl) == 8 &amp;&amp; *(scl + 6) == '-') {</a>
<a name="ln5436">      minimum = maximum;</a>
<a name="ln5437">      maximum = scl[7] - '0';</a>
<a name="ln5438">    }</a>
<a name="ln5439">  }</a>
<a name="ln5440"> </a>
<a name="ln5441">  int needed_signcols = buf_signcols(wp-&gt;w_buffer, maximum);</a>
<a name="ln5442">  int ret = MAX(minimum, MIN(maximum, needed_signcols));</a>
<a name="ln5443">  assert(ret &lt;= SIGN_SHOW_MAX);</a>
<a name="ln5444">  return ret;</a>
<a name="ln5445">}</a>
<a name="ln5446"> </a>
<a name="ln5447">/// Get window or buffer local options</a>
<a name="ln5448">dict_T *get_winbuf_options(const int bufopt)</a>
<a name="ln5449">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5450">{</a>
<a name="ln5451">  dict_T *const d = tv_dict_alloc();</a>
<a name="ln5452"> </a>
<a name="ln5453">  for (int opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln5454">    struct vimoption *opt = &amp;options[opt_idx];</a>
<a name="ln5455"> </a>
<a name="ln5456">    if ((bufopt &amp;&amp; (opt-&gt;indir &amp; PV_BUF))</a>
<a name="ln5457">        || (!bufopt &amp;&amp; (opt-&gt;indir &amp; PV_WIN))) {</a>
<a name="ln5458">      char_u *varp = get_varp(opt);</a>
<a name="ln5459"> </a>
<a name="ln5460">      if (varp != NULL) {</a>
<a name="ln5461">        if (opt-&gt;flags &amp; P_STRING) {</a>
<a name="ln5462">          tv_dict_add_str(d, opt-&gt;fullname, strlen(opt-&gt;fullname),</a>
<a name="ln5463">                          *(const char **)varp);</a>
<a name="ln5464">        } else if (opt-&gt;flags &amp; P_NUM) {</a>
<a name="ln5465">          tv_dict_add_nr(d, opt-&gt;fullname, strlen(opt-&gt;fullname),</a>
<a name="ln5466">                         *(long *)varp);</a>
<a name="ln5467">        } else {</a>
<a name="ln5468">          tv_dict_add_nr(d, opt-&gt;fullname, strlen(opt-&gt;fullname), *(int *)varp);</a>
<a name="ln5469">        }</a>
<a name="ln5470">      }</a>
<a name="ln5471">    }</a>
<a name="ln5472">  }</a>
<a name="ln5473"> </a>
<a name="ln5474">  return d;</a>
<a name="ln5475">}</a>
<a name="ln5476"> </a>
<a name="ln5477">/// Return the effective 'scrolloff' value for the current window, using the</a>
<a name="ln5478">/// global value when appropriate.</a>
<a name="ln5479">long get_scrolloff_value(win_T *wp)</a>
<a name="ln5480">{</a>
<a name="ln5481">  // Disallow scrolloff in terminal-mode. #11915</a>
<a name="ln5482">  if (State &amp; MODE_TERMINAL) {</a>
<a name="ln5483">    return 0;</a>
<a name="ln5484">  }</a>
<a name="ln5485">  return wp-&gt;w_p_so &lt; 0 ? p_so : wp-&gt;w_p_so;</a>
<a name="ln5486">}</a>
<a name="ln5487"> </a>
<a name="ln5488">/// Return the effective 'sidescrolloff' value for the current window, using the</a>
<a name="ln5489">/// global value when appropriate.</a>
<a name="ln5490">long get_sidescrolloff_value(win_T *wp)</a>
<a name="ln5491">{</a>
<a name="ln5492">  return wp-&gt;w_p_siso &lt; 0 ? p_siso : wp-&gt;w_p_siso;</a>
<a name="ln5493">}</a>
<a name="ln5494"> </a>
<a name="ln5495">Dictionary get_vimoption(String name, Error *err)</a>
<a name="ln5496">{</a>
<a name="ln5497">  int opt_idx = findoption_len((const char *)name.data, name.size);</a>
<a name="ln5498">  if (opt_idx &lt; 0) {</a>
<a name="ln5499">    api_set_error(err, kErrorTypeValidation, &quot;no such option: '%s'&quot;, name.data);</a>
<a name="ln5500">    return (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln5501">  }</a>
<a name="ln5502">  return vimoption2dict(&amp;options[opt_idx]);</a>
<a name="ln5503">}</a>
<a name="ln5504"> </a>
<a name="ln5505">Dictionary get_all_vimoptions(void)</a>
<a name="ln5506">{</a>
<a name="ln5507">  Dictionary retval = ARRAY_DICT_INIT;</a>
<a name="ln5508">  for (size_t i = 0; options[i].fullname != NULL; i++) {</a>
<a name="ln5509">    Dictionary opt_dict = vimoption2dict(&amp;options[i]);</a>
<a name="ln5510">    PUT(retval, options[i].fullname, DICTIONARY_OBJ(opt_dict));</a>
<a name="ln5511">  }</a>
<a name="ln5512">  return retval;</a>
<a name="ln5513">}</a>
<a name="ln5514"> </a>
<a name="ln5515">static Dictionary vimoption2dict(vimoption_T *opt)</a>
<a name="ln5516">{</a>
<a name="ln5517">  Dictionary dict = ARRAY_DICT_INIT;</a>
<a name="ln5518"> </a>
<a name="ln5519">  PUT(dict, &quot;name&quot;, CSTR_TO_OBJ(opt-&gt;fullname));</a>
<a name="ln5520">  PUT(dict, &quot;shortname&quot;, CSTR_TO_OBJ(opt-&gt;shortname));</a>
<a name="ln5521"> </a>
<a name="ln5522">  const char *scope;</a>
<a name="ln5523">  if (opt-&gt;indir &amp; PV_BUF) {</a>
<a name="ln5524">    scope = &quot;buf&quot;;</a>
<a name="ln5525">  } else if (opt-&gt;indir &amp; PV_WIN) {</a>
<a name="ln5526">    scope = &quot;win&quot;;</a>
<a name="ln5527">  } else {</a>
<a name="ln5528">    scope = &quot;global&quot;;</a>
<a name="ln5529">  }</a>
<a name="ln5530"> </a>
<a name="ln5531">  PUT(dict, &quot;scope&quot;, CSTR_TO_OBJ(scope));</a>
<a name="ln5532"> </a>
<a name="ln5533">  // welcome to the jungle</a>
<a name="ln5534">  PUT(dict, &quot;global_local&quot;, BOOL(opt-&gt;indir &amp; PV_BOTH));</a>
<a name="ln5535">  PUT(dict, &quot;commalist&quot;, BOOL(opt-&gt;flags &amp; P_COMMA));</a>
<a name="ln5536">  PUT(dict, &quot;flaglist&quot;, BOOL(opt-&gt;flags &amp; P_FLAGLIST));</a>
<a name="ln5537"> </a>
<a name="ln5538">  PUT(dict, &quot;was_set&quot;, BOOL(opt-&gt;flags &amp; P_WAS_SET));</a>
<a name="ln5539"> </a>
<a name="ln5540">  PUT(dict, &quot;last_set_sid&quot;, INTEGER_OBJ(opt-&gt;last_set.script_ctx.sc_sid));</a>
<a name="ln5541">  PUT(dict, &quot;last_set_linenr&quot;, INTEGER_OBJ(opt-&gt;last_set.script_ctx.sc_lnum));</a>
<a name="ln5542">  PUT(dict, &quot;last_set_chan&quot;, INTEGER_OBJ((int64_t)opt-&gt;last_set.channel_id));</a>
<a name="ln5543"> </a>
<a name="ln5544">  const char *type;</a>
<a name="ln5545">  Object def;</a>
<a name="ln5546">  // TODO(bfredl): do you even nocp?</a>
<a name="ln5547">  char_u *def_val = (char_u *)opt-&gt;def_val;</a>
<a name="ln5548">  if (opt-&gt;flags &amp; P_STRING) {</a>
<a name="ln5549">    type = &quot;string&quot;;</a>
<a name="ln5550">    def = CSTR_TO_OBJ(def_val ? (char *)def_val : &quot;&quot;);</a>
<a name="ln5551">  } else if (opt-&gt;flags &amp; P_NUM) {</a>
<a name="ln5552">    type = &quot;number&quot;;</a>
<a name="ln5553">    def = INTEGER_OBJ((Integer)(intptr_t)def_val);</a>
<a name="ln5554">  } else if (opt-&gt;flags &amp; P_BOOL) {</a>
<a name="ln5555">    type = &quot;boolean&quot;;</a>
<a name="ln5556">    def = BOOL((intptr_t)def_val);</a>
<a name="ln5557">  } else {</a>
<a name="ln5558">    type = &quot;&quot;; def = NIL;</a>
<a name="ln5559">  }</a>
<a name="ln5560">  PUT(dict, &quot;type&quot;, CSTR_TO_OBJ(type));</a>
<a name="ln5561">  PUT(dict, &quot;default&quot;, def);</a>
<a name="ln5562">  PUT(dict, &quot;allows_duplicates&quot;, BOOL(!(opt-&gt;flags &amp; P_NODUP)));</a>
<a name="ln5563"> </a>
<a name="ln5564">  return dict;</a>
<a name="ln5565">}</a>
</code></pre>
<div class="balloon" rel="880"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'strlen(whichwrap) - 1' index could reach 18446744073709551615.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>