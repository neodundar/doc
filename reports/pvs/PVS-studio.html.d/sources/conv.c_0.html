<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>conv.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &quot;conv.h&quot;</a>
<a name="ln5"> </a>
<a name="ln6">static int mpack_fits_single(double v);</a>
<a name="ln7">static mpack_value_t mpack_pack_ieee754(double v, unsigned m, unsigned e);</a>
<a name="ln8">static int mpack_is_be(void) FPURE;</a>
<a name="ln9">static double mpack_fmod_pow2_32(double a);</a>
<a name="ln10"> </a>
<a name="ln11"> </a>
<a name="ln12">#define POW2(n) \</a>
<a name="ln13">  ((double)(1 &lt;&lt; (n / 2)) * (double)(1 &lt;&lt; (n / 2)) * (double)(1 &lt;&lt; (n % 2)))</a>
<a name="ln14"> </a>
<a name="ln15">#define MPACK_SWAP_VALUE(val)                                  \</a>
<a name="ln16">  do {                                                         \</a>
<a name="ln17">    mpack_uint32_t lo = val.lo;                                \</a>
<a name="ln18">    val.lo = val.hi;                                           \</a>
<a name="ln19">    val.hi = lo;                                               \</a>
<a name="ln20">  } while (0)</a>
<a name="ln21"> </a>
<a name="ln22">MPACK_API mpack_token_t mpack_pack_nil(void)</a>
<a name="ln23">{</a>
<a name="ln24">  mpack_token_t rv;</a>
<a name="ln25">  rv.type = MPACK_TOKEN_NIL;</a>
<a name="ln26">  return rv;</a>
<a name="ln27">}</a>
<a name="ln28"> </a>
<a name="ln29">MPACK_API mpack_token_t mpack_pack_boolean(unsigned v)</a>
<a name="ln30">{</a>
<a name="ln31">  mpack_token_t rv;</a>
<a name="ln32">  rv.type = MPACK_TOKEN_BOOLEAN;</a>
<a name="ln33">  rv.data.value.lo = v ? 1 : 0;</a>
<a name="ln34">  rv.data.value.hi = 0;</a>
<a name="ln35">  return rv;</a>
<a name="ln36">}</a>
<a name="ln37"> </a>
<a name="ln38">MPACK_API mpack_token_t mpack_pack_uint(mpack_uintmax_t v)</a>
<a name="ln39">{</a>
<a name="ln40">  mpack_token_t rv;</a>
<a name="ln41">  rv.data.value.lo = v &amp; 0xffffffff;</a>
<a name="ln42">  rv.data.value.hi = (mpack_uint32_t)((v &gt;&gt; 31) &gt;&gt; 1);</a>
<a name="ln43">  rv.type = MPACK_TOKEN_UINT;</a>
<a name="ln44">  return rv;</a>
<a name="ln45">}</a>
<a name="ln46"> </a>
<a name="ln47">MPACK_API mpack_token_t mpack_pack_sint(mpack_sintmax_t v)</a>
<a name="ln48">{</a>
<a name="ln49">  if (v &lt; 0) {</a>
<a name="ln50">    mpack_token_t rv;</a>
<a name="ln51">    mpack_uintmax_t tc = -((mpack_uintmax_t)(v + 1)) + 1;</a>
<a name="ln52">    tc = ~tc + 1;</a>
<a name="ln53">    rv = mpack_pack_uint(tc);</a>
<a name="ln54">    rv.type = MPACK_TOKEN_SINT;</a>
<a name="ln55">    return rv;</a>
<a name="ln56">  }</a>
<a name="ln57"> </a>
<a name="ln58">  return mpack_pack_uint((mpack_uintmax_t)v);</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61">MPACK_API mpack_token_t mpack_pack_float_compat(double v)</a>
<a name="ln62">{</a>
<a name="ln63">  /* ieee754 single-precision limits to determine if &quot;v&quot; can be fully</a>
<a name="ln64">   * represented in 4 bytes */</a>
<a name="ln65">  mpack_token_t rv;</a>
<a name="ln66"> </a>
<a name="ln67">  if (mpack_fits_single(v)) {</a>
<a name="ln68">    rv.length = 4;</a>
<a name="ln69">    rv.data.value = mpack_pack_ieee754(v, 23, 8);</a>
<a name="ln70">  } else {</a>
<a name="ln71">    rv.length = 8;</a>
<a name="ln72">    rv.data.value = mpack_pack_ieee754(v, 52, 11);</a>
<a name="ln73">  }</a>
<a name="ln74"> </a>
<a name="ln75">  rv.type = MPACK_TOKEN_FLOAT;</a>
<a name="ln76">  return rv;</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">MPACK_API mpack_token_t mpack_pack_float_fast(double v)</a>
<a name="ln80">{</a>
<a name="ln81">  /* ieee754 single-precision limits to determine if &quot;v&quot; can be fully</a>
<a name="ln82">   * represented in 4 bytes */</a>
<a name="ln83">  mpack_token_t rv;</a>
<a name="ln84"> </a>
<a name="ln85">  if (mpack_fits_single(v)) {</a>
<a name="ln86">    union {</a>
<a name="ln87">      float f;</a>
<a name="ln88">      mpack_uint32_t m;</a>
<a name="ln89">    } conv;</a>
<a name="ln90">    conv.f = (float)v;</a>
<a name="ln91">    rv.length = 4;</a>
<a name="ln92">    rv.data.value.lo = conv.m;</a>
<a name="ln93">    rv.data.value.hi = 0;</a>
<a name="ln94">  } else {</a>
<a name="ln95">    union {</a>
<a name="ln96">      double d;</a>
<a name="ln97">      mpack_value_t m;</a>
<a name="ln98">    } conv;</a>
<a name="ln99">    conv.d = v;</a>
<a name="ln100">    rv.length = 8;</a>
<a name="ln101">    rv.data.value = conv.m;</a>
<a name="ln102">    if (mpack_is_be()) {</a>
<a name="ln103">      MPACK_SWAP_VALUE(rv.data.value);</a>
<a name="ln104">    }</a>
<a name="ln105">  }</a>
<a name="ln106"> </a>
<a name="ln107">  rv.type = MPACK_TOKEN_FLOAT;</a>
<a name="ln108">  return rv;</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">MPACK_API mpack_token_t mpack_pack_number(double v)</a>
<a name="ln112">{</a>
<a name="ln113">  mpack_token_t tok;</a>
<a name="ln114">  double vabs;</a>
<a name="ln115">  vabs = v &lt; 0 ? -v : v;</a>
<a name="ln116">  assert(v &lt;= 9007199254740991. &amp;&amp; v &gt;= -9007199254740991.);</a>
<a name="ln117">  tok.data.value.hi = (mpack_uint32_t)(vabs / POW2(32));</a>
<a name="ln118">  tok.data.value.lo = (mpack_uint32_t)mpack_fmod_pow2_32(vabs);</a>
<a name="ln119"> </a>
<a name="ln120">  if (v &lt; 0) {</a>
<a name="ln121">    /* Compute the two's complement */</a>
<a name="ln122">    tok.type = MPACK_TOKEN_SINT;</a>
<a name="ln123">    tok.data.value.hi = ~tok.data.value.hi;</a>
<a name="ln124">    tok.data.value.lo = ~tok.data.value.lo + 1;</a>
<a name="ln125">    if (!tok.data.value.lo) tok.data.value.hi++;</a>
<a name="ln126">    if (tok.data.value.lo == 0 &amp;&amp; tok.data.value.hi == 0) tok.length = 1;</a>
<a name="ln127">    else if (tok.data.value.lo &lt; 0x80000000) tok.length = 8;</a>
<a name="ln128">    else if (tok.data.value.lo &lt; 0xffff7fff) tok.length = 4;</a>
<a name="ln129">    else if (tok.data.value.lo &lt; 0xffffff7f) tok.length = 2;</a>
<a name="ln130">    else tok.length = 1;</a>
<a name="ln131">  } else {</a>
<a name="ln132">    tok.type = MPACK_TOKEN_UINT;</a>
<a name="ln133">    if (tok.data.value.hi) tok.length = 8;</a>
<a name="ln134">    else if (tok.data.value.lo &gt; 0xffff) tok.length = 4;</a>
<a name="ln135">    else if (tok.data.value.lo &gt; 0xff) tok.length = 2;</a>
<a name="ln136">    else tok.length = 1;</a>
<a name="ln137">  }</a>
<a name="ln138"> </a>
<a name="ln139">  if (mpack_unpack_number(tok) != v) {</a>
<a name="ln140">    return mpack_pack_float(v);</a>
<a name="ln141">  }</a>
<a name="ln142"> </a>
<a name="ln143">  return tok;</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">MPACK_API mpack_token_t mpack_pack_chunk(const char *p, mpack_uint32_t l)</a>
<a name="ln147">{</a>
<a name="ln148">  mpack_token_t rv;</a>
<a name="ln149">  rv.type = MPACK_TOKEN_CHUNK;</a>
<a name="ln150">  rv.data.chunk_ptr = p;</a>
<a name="ln151">  rv.length = l;</a>
<a name="ln152">  return rv;</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">MPACK_API mpack_token_t mpack_pack_str(mpack_uint32_t l)</a>
<a name="ln156">{</a>
<a name="ln157">  mpack_token_t rv;</a>
<a name="ln158">  rv.type = MPACK_TOKEN_STR;</a>
<a name="ln159">  rv.length = l;</a>
<a name="ln160">  return rv;</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">MPACK_API mpack_token_t mpack_pack_bin(mpack_uint32_t l)</a>
<a name="ln164">{</a>
<a name="ln165">  mpack_token_t rv;</a>
<a name="ln166">  rv.type = MPACK_TOKEN_BIN;</a>
<a name="ln167">  rv.length = l;</a>
<a name="ln168">  return rv;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">MPACK_API mpack_token_t mpack_pack_ext(int t, mpack_uint32_t l)</a>
<a name="ln172">{</a>
<a name="ln173">  mpack_token_t rv;</a>
<a name="ln174">  rv.type = MPACK_TOKEN_EXT;</a>
<a name="ln175">  rv.length = l;</a>
<a name="ln176">  rv.data.ext_type = t;</a>
<a name="ln177">  return rv;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">MPACK_API mpack_token_t mpack_pack_array(mpack_uint32_t l)</a>
<a name="ln181">{</a>
<a name="ln182">  mpack_token_t rv;</a>
<a name="ln183">  rv.type = MPACK_TOKEN_ARRAY;</a>
<a name="ln184">  rv.length = l;</a>
<a name="ln185">  return rv;</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">MPACK_API mpack_token_t mpack_pack_map(mpack_uint32_t l)</a>
<a name="ln189">{</a>
<a name="ln190">  mpack_token_t rv;</a>
<a name="ln191">  rv.type = MPACK_TOKEN_MAP;</a>
<a name="ln192">  rv.length = l;</a>
<a name="ln193">  return rv;</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196">MPACK_API bool mpack_unpack_boolean(mpack_token_t t)</a>
<a name="ln197">{</a>
<a name="ln198">  return t.data.value.lo || t.data.value.hi;</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">MPACK_API mpack_uintmax_t mpack_unpack_uint(mpack_token_t t)</a>
<a name="ln202">{</a>
<a name="ln203">  return (((mpack_uintmax_t)t.data.value.hi &lt;&lt; 31) &lt;&lt; 1) | t.data.value.lo;</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">/* unpack signed integer without relying on two's complement as internal</a>
<a name="ln207"> * representation */</a>
<a name="ln208">MPACK_API mpack_sintmax_t mpack_unpack_sint(mpack_token_t t)</a>
<a name="ln209">{</a>
<a name="ln210">  mpack_uint32_t hi = t.data.value.hi;</a>
<a name="ln211">  mpack_uint32_t lo = t.data.value.lo;</a>
<a name="ln212">  mpack_uintmax_t rv = lo;</a>
<a name="ln213">  assert(t.length &lt;= sizeof(mpack_sintmax_t));</a>
<a name="ln214"> </a>
<a name="ln215">  if (t.length == 8) {</a>
<a name="ln216">    rv |= (((mpack_uintmax_t)hi) &lt;&lt; 31) &lt;&lt; 1;</a>
<a name="ln217">  }</a>
<a name="ln218">  /* reverse the two's complement so that lo/hi contain the absolute value.</a>
<a name="ln219">   * note that we have to mask ~rv so that it reflects the two's complement</a>
<a name="ln220">   * of the appropriate byte length */</a>
<a name="ln221">  rv = (~rv &amp; (((mpack_uintmax_t)1 &lt;&lt; ((t.length * 8) - 1)) - 1)) + 1;</a>
<a name="ln222">  /* negate and return the absolute value, making sure mpack_sintmax_t can</a>
<a name="ln223">   * represent the positive cast. */</a>
<a name="ln224">  return -((mpack_sintmax_t)(rv - 1)) - 1;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">MPACK_API double mpack_unpack_float_compat(mpack_token_t t)</a>
<a name="ln228">{</a>
<a name="ln229">  mpack_uint32_t sign;</a>
<a name="ln230">  mpack_sint32_t exponent, bias;</a>
<a name="ln231">  unsigned mantbits;</a>
<a name="ln232">  unsigned expbits;</a>
<a name="ln233">  double mant;</a>
<a name="ln234"> </a>
<a name="ln235">  if (t.data.value.lo == 0 &amp;&amp; t.data.value.hi == 0)</a>
<a name="ln236">    /* nothing to do */</a>
<a name="ln237">    return 0;</a>
<a name="ln238"> </a>
<a name="ln239">  if (t.length == 4) mantbits = 23, expbits = 8;</a>
<a name="ln240">  else mantbits = 52, expbits = 11;</a>
<a name="ln241">  bias = (1 &lt;&lt; (expbits - 1)) - 1;</a>
<a name="ln242"> </a>
<a name="ln243">  /* restore sign/exponent/mantissa */</a>
<a name="ln244">  if (mantbits == 52) {</a>
<a name="ln245">    sign = t.data.value.hi &gt;&gt; 31;</a>
<a name="ln246">    exponent = (t.data.value.hi &gt;&gt; 20) &amp; ((1 &lt;&lt; 11) - 1);</a>
<a name="ln247">    mant = (t.data.value.hi &amp; ((1 &lt;&lt; 20) - 1)) * POW2(32);</a>
<a name="ln248">    mant += t.data.value.lo;</a>
<a name="ln249">  } else {</a>
<a name="ln250">    sign = t.data.value.lo &gt;&gt; 31;</a>
<a name="ln251">    exponent = (t.data.value.lo &gt;&gt; 23) &amp; ((1 &lt;&lt; 8) - 1);</a>
<a name="ln252">    mant = t.data.value.lo &amp; ((1 &lt;&lt; 23) - 1);</a>
<a name="ln253">  }</a>
<a name="ln254"> </a>
<a name="ln255">  mant /= POW2(mantbits);</a>
<a name="ln256">  if (exponent) mant += 1.0; /* restore leading 1 */</a>
<a name="ln257">  else exponent = 1; /* subnormal */</a>
<a name="ln258">  exponent -= bias;</a>
<a name="ln259"> </a>
<a name="ln260">  /* restore original value */</a>
<a name="ln261">  while (exponent &gt; 0) mant *= 2.0, exponent--;</a>
<a name="ln262">  while (exponent &lt; 0) mant /= 2.0, exponent++;</a>
<a name="ln263">  return mant * (sign ? -1 : 1);</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">MPACK_API double mpack_unpack_float_fast(mpack_token_t t)</a>
<a name="ln267">{</a>
<a name="ln268">  if (t.length == 4) {</a>
<a name="ln269">    union {</a>
<a name="ln270">      float f;</a>
<a name="ln271">      mpack_uint32_t m;</a>
<a name="ln272">    } conv;</a>
<a name="ln273">    conv.m = t.data.value.lo;</a>
<a name="ln274">    return conv.f;</a>
<a name="ln275">  } else {</a>
<a name="ln276">    union {</a>
<a name="ln277">      double d;</a>
<a name="ln278">      mpack_value_t m;</a>
<a name="ln279">    } conv;</a>
<a name="ln280">    conv.m = t.data.value;</a>
<a name="ln281">    </a>
<a name="ln282">    if (mpack_is_be()) {</a>
<a name="ln283">      MPACK_SWAP_VALUE(conv.m);</a>
<a name="ln284">    }</a>
<a name="ln285"> </a>
<a name="ln286">    return conv.d;</a>
<a name="ln287">  }</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">MPACK_API double mpack_unpack_number(mpack_token_t t)</a>
<a name="ln291">{</a>
<a name="ln292">  double rv;</a>
<a name="ln293">  mpack_uint32_t hi, lo;</a>
<a name="ln294">  if (t.type == MPACK_TOKEN_FLOAT) return mpack_unpack_float(t);</a>
<a name="ln295">  assert(t.type == MPACK_TOKEN_UINT || t.type == MPACK_TOKEN_SINT);</a>
<a name="ln296">  hi = t.data.value.hi;</a>
<a name="ln297">  lo = t.data.value.lo;</a>
<a name="ln298">  if (t.type == MPACK_TOKEN_SINT) {</a>
<a name="ln299">    /* same idea as mpack_unpack_sint, except here we shouldn't rely on</a>
<a name="ln300">     * mpack_uintmax_t having 64-bits, operating on the 32-bit words separately.</a>
<a name="ln301">     */</a>
<a name="ln302">    if (!hi) {</a>
<a name="ln303">      assert(t.length &lt;= 4);</a>
<a name="ln304">      lo = (~lo &amp; (((mpack_uint32_t)1 &lt;&lt; ((t.length * 8) - 1)) - 1));</a>
<a name="ln305">    } else {</a>
<a name="ln306">      hi = ~hi;</a>
<a name="ln307">      lo = ~lo;</a>
<a name="ln308">    }</a>
<a name="ln309">    lo++;</a>
<a name="ln310">    if (!lo) hi++;</a>
<a name="ln311">  }</a>
<a name="ln312">  rv = (double)lo + POW2(32) * hi;</a>
<a name="ln313">  return t.type == MPACK_TOKEN_SINT ? -rv : rv;</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">static int mpack_fits_single(double v)</a>
<a name="ln317">{</a>
<a name="ln318">  return (float)v == v;</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">static mpack_value_t mpack_pack_ieee754(double v, unsigned mantbits,</a>
<a name="ln322">    unsigned expbits)</a>
<a name="ln323">{</a>
<a name="ln324">  mpack_value_t rv = {0, 0};</a>
<a name="ln325">  mpack_sint32_t exponent, bias = (1 &lt;&lt; (expbits - 1)) - 1;</a>
<a name="ln326">  mpack_uint32_t sign;</a>
<a name="ln327">  double mant;</a>
<a name="ln328"> </a>
<a name="ln329">  if (v == 0) {</a>
<a name="ln330">    rv.lo = 0;</a>
<a name="ln331">    rv.hi = 0;</a>
<a name="ln332">    goto end;</a>
<a name="ln333">  }</a>
<a name="ln334"> </a>
<a name="ln335">  if (v &lt; 0) sign = 1, mant = -v;</a>
<a name="ln336">  else sign = 0, mant = v;</a>
<a name="ln337"> </a>
<a name="ln338">  exponent = 0;</a>
<a name="ln339">  while (mant &gt;= 2.0) mant /= 2.0, exponent++;</a>
<a name="ln340">  while (mant &lt; 1.0 &amp;&amp; exponent &gt; -(bias - 1)) mant *= 2.0, exponent--;</a>
<a name="ln341"> </a>
<a name="ln342">  if (mant &lt; 1.0) exponent = -bias; /* subnormal value */</a>
<a name="ln343">  else mant = mant - 1.0; /* remove leading 1 */</a>
<a name="ln344">  exponent += bias;</a>
<a name="ln345">  mant *= POW2(mantbits);</a>
<a name="ln346"> </a>
<a name="ln347">  if (mantbits == 52) {</a>
<a name="ln348">    rv.hi = (mpack_uint32_t)(mant / POW2(32));</a>
<a name="ln349">    rv.lo = (mpack_uint32_t)(mant - rv.hi * POW2(32));</a>
<a name="ln350">    rv.hi |= ((mpack_uint32_t)exponent &lt;&lt; 20) | (sign &lt;&lt; 31);</a>
<a name="ln351">  } else if (mantbits == 23) {</a>
<a name="ln352">    rv.hi = 0;</a>
<a name="ln353">    rv.lo = (mpack_uint32_t)mant;</a>
<a name="ln354">    rv.lo |= ((mpack_uint32_t)exponent &lt;&lt; 23) | (sign &lt;&lt; 31);</a>
<a name="ln355">  }</a>
<a name="ln356"> </a>
<a name="ln357">end:</a>
<a name="ln358">  return rv;</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">static int mpack_is_be(void)</a>
<a name="ln362">{</a>
<a name="ln363">  union {</a>
<a name="ln364">    mpack_uint32_t i;</a>
<a name="ln365">    char c[sizeof(mpack_uint32_t)];</a>
<a name="ln366">  } test;</a>
<a name="ln367"> </a>
<a name="ln368">  test.i = 1;</a>
<a name="ln369">  return test.c[0] == 0;</a>
<a name="ln370">}</a>
<a name="ln371"> </a>
<a name="ln372">/* this simplified version of `fmod` that returns the remainder of double</a>
<a name="ln373"> * division by 0xffffffff, which is enough for our purposes */</a>
<a name="ln374">static double mpack_fmod_pow2_32(double a)</a>
<a name="ln375">{</a>
<a name="ln376">  return a - ((double)(mpack_uint32_t)(a / POW2(32)) * POW2(32));</a>
<a name="ln377">}</a>
</code></pre>
<div class="balloon" rel="330"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1048/" target="_blank">V1048</a> The 'rv.lo' variable was assigned the same value.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>