<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fileio.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// fileio.c: read from and write to a file</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;errno.h&gt;</a>
<a name="ln8">#include &lt;fcntl.h&gt;</a>
<a name="ln9">#include &lt;inttypes.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln14">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln15">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln16">#include &quot;nvim/buffer_updates.h&quot;</a>
<a name="ln17">#include &quot;nvim/change.h&quot;</a>
<a name="ln18">#include &quot;nvim/charset.h&quot;</a>
<a name="ln19">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln20">#include &quot;nvim/diff.h&quot;</a>
<a name="ln21">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln22">#include &quot;nvim/edit.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln25">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln28">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln29">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln30">#include &quot;nvim/fold.h&quot;</a>
<a name="ln31">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln32">#include &quot;nvim/garray.h&quot;</a>
<a name="ln33">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln34">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln35">#include &quot;nvim/iconv.h&quot;</a>
<a name="ln36">#include &quot;nvim/input.h&quot;</a>
<a name="ln37">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln38">#include &quot;nvim/memfile.h&quot;</a>
<a name="ln39">#include &quot;nvim/memline.h&quot;</a>
<a name="ln40">#include &quot;nvim/memory.h&quot;</a>
<a name="ln41">#include &quot;nvim/message.h&quot;</a>
<a name="ln42">#include &quot;nvim/move.h&quot;</a>
<a name="ln43">#include &quot;nvim/normal.h&quot;</a>
<a name="ln44">#include &quot;nvim/option.h&quot;</a>
<a name="ln45">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln46">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln48">#include &quot;nvim/os/os_defs.h&quot;</a>
<a name="ln49">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln50">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln51">#include &quot;nvim/path.h&quot;</a>
<a name="ln52">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln53">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln54">#include &quot;nvim/search.h&quot;</a>
<a name="ln55">#include &quot;nvim/sha256.h&quot;</a>
<a name="ln56">#include &quot;nvim/shada.h&quot;</a>
<a name="ln57">#include &quot;nvim/state.h&quot;</a>
<a name="ln58">#include &quot;nvim/strings.h&quot;</a>
<a name="ln59">#include &quot;nvim/types.h&quot;</a>
<a name="ln60">#include &quot;nvim/ui.h&quot;</a>
<a name="ln61">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln62">#include &quot;nvim/undo.h&quot;</a>
<a name="ln63">#include &quot;nvim/vim.h&quot;</a>
<a name="ln64">#include &quot;nvim/window.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">#define BUFSIZE         8192    // size of normal write buffer</a>
<a name="ln67">#define SMBUFSIZE       256     // size of emergency write buffer</a>
<a name="ln68"> </a>
<a name="ln69">// For compatibility with libuv &lt; 1.20.0 (tested on 1.18.0)</a>
<a name="ln70">#ifndef UV_FS_COPYFILE_FICLONE</a>
<a name="ln71"># define UV_FS_COPYFILE_FICLONE 0</a>
<a name="ln72">#endif</a>
<a name="ln73"> </a>
<a name="ln74">#define HAS_BW_FLAGS</a>
<a name="ln75">#define FIO_LATIN1     0x01    // convert Latin1</a>
<a name="ln76">#define FIO_UTF8       0x02    // convert UTF-8</a>
<a name="ln77">#define FIO_UCS2       0x04    // convert UCS-2</a>
<a name="ln78">#define FIO_UCS4       0x08    // convert UCS-4</a>
<a name="ln79">#define FIO_UTF16      0x10    // convert UTF-16</a>
<a name="ln80">#define FIO_ENDIAN_L   0x80    // little endian</a>
<a name="ln81">#define FIO_NOCONVERT  0x2000  // skip encoding conversion</a>
<a name="ln82">#define FIO_UCSBOM     0x4000  // check for BOM at start of file</a>
<a name="ln83">#define FIO_ALL        (-1)    // allow all formats</a>
<a name="ln84"> </a>
<a name="ln85">// When converting, a read() or write() may leave some bytes to be converted</a>
<a name="ln86">// for the next call.  The value is guessed...</a>
<a name="ln87">#define CONV_RESTLEN 30</a>
<a name="ln88"> </a>
<a name="ln89">// We have to guess how much a sequence of bytes may expand when converting</a>
<a name="ln90">// with iconv() to be able to allocate a buffer.</a>
<a name="ln91">#define ICONV_MULT 8</a>
<a name="ln92"> </a>
<a name="ln93">// Structure to pass arguments from buf_write() to buf_write_bytes().</a>
<a name="ln94">struct bw_info {</a>
<a name="ln95">  int bw_fd;                     // file descriptor</a>
<a name="ln96">  char_u *bw_buf;           // buffer with data to be written</a>
<a name="ln97">  int bw_len;                    // length of data</a>
<a name="ln98">#ifdef HAS_BW_FLAGS</a>
<a name="ln99">  int bw_flags;                  // FIO_ flags</a>
<a name="ln100">#endif</a>
<a name="ln101">  char_u bw_rest[CONV_RESTLEN];  // not converted bytes</a>
<a name="ln102">  int bw_restlen;                // nr of bytes in bw_rest[]</a>
<a name="ln103">  int bw_first;                  // first write call</a>
<a name="ln104">  char_u *bw_conv_buf;           // buffer for writing converted chars</a>
<a name="ln105">  size_t bw_conv_buflen;         // size of bw_conv_buf</a>
<a name="ln106">  int bw_conv_error;             // set for conversion error</a>
<a name="ln107">  linenr_T bw_conv_error_lnum;   // first line with error or zero</a>
<a name="ln108">  linenr_T bw_start_lnum;        // line number at start of buffer</a>
<a name="ln109">#ifdef HAVE_ICONV</a>
<a name="ln110">  iconv_t bw_iconv_fd;           // descriptor for iconv() or -1</a>
<a name="ln111">#endif</a>
<a name="ln112">};</a>
<a name="ln113"> </a>
<a name="ln114">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln115"># include &quot;fileio.c.generated.h&quot;</a>
<a name="ln116">#endif</a>
<a name="ln117"> </a>
<a name="ln118">static char *e_auchangedbuf = N_(&quot;E812: Autocommands changed buffer or buffer name&quot;);</a>
<a name="ln119">static char e_no_matching_autocommands_for_buftype_str_buffer[]</a>
<a name="ln120">  = N_(&quot;E676: No matching autocommands for buftype=%s buffer&quot;);</a>
<a name="ln121"> </a>
<a name="ln122">void filemess(buf_T *buf, char *name, char *s, int attr)</a>
<a name="ln123">{</a>
<a name="ln124">  int msg_scroll_save;</a>
<a name="ln125"> </a>
<a name="ln126">  if (msg_silent != 0) {</a>
<a name="ln127">    return;</a>
<a name="ln128">  }</a>
<a name="ln129">  add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)name);</a>
<a name="ln130">  // Avoid an over-long translation to cause trouble.</a>
<a name="ln131">  xstrlcat(IObuff, s, IOSIZE);</a>
<a name="ln132">  // For the first message may have to start a new line.</a>
<a name="ln133">  // For further ones overwrite the previous one, reset msg_scroll before</a>
<a name="ln134">  // calling filemess().</a>
<a name="ln135">  msg_scroll_save = msg_scroll;</a>
<a name="ln136">  if (shortmess(SHM_OVERALL) &amp;&amp; !exiting &amp;&amp; p_verbose == 0) {</a>
<a name="ln137">    msg_scroll = false;</a>
<a name="ln138">  }</a>
<a name="ln139">  if (!msg_scroll) {    // wait a bit when overwriting an error msg</a>
<a name="ln140">    check_for_delay(false);</a>
<a name="ln141">  }</a>
<a name="ln142">  msg_start();</a>
<a name="ln143">  msg_scroll = msg_scroll_save;</a>
<a name="ln144">  msg_scrolled_ign = true;</a>
<a name="ln145">  // may truncate the message to avoid a hit-return prompt</a>
<a name="ln146">  msg_outtrans_attr(msg_may_trunc(false, (char *)IObuff), attr);</a>
<a name="ln147">  msg_clr_eos();</a>
<a name="ln148">  ui_flush();</a>
<a name="ln149">  msg_scrolled_ign = false;</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">/// Read lines from file &quot;fname&quot; into the buffer after line &quot;from&quot;.</a>
<a name="ln153">///</a>
<a name="ln154">/// 1. We allocate blocks with try_malloc, as big as possible.</a>
<a name="ln155">/// 2. Each block is filled with characters from the file with a single read().</a>
<a name="ln156">/// 3. The lines are inserted in the buffer with ml_append().</a>
<a name="ln157">///</a>
<a name="ln158">/// (caller must check that fname != NULL, unless READ_STDIN is used)</a>
<a name="ln159">///</a>
<a name="ln160">/// &quot;lines_to_skip&quot; is the number of lines that must be skipped</a>
<a name="ln161">/// &quot;lines_to_read&quot; is the number of lines that are appended</a>
<a name="ln162">/// When not recovering lines_to_skip is 0 and lines_to_read MAXLNUM.</a>
<a name="ln163">///</a>
<a name="ln164">/// flags:</a>
<a name="ln165">/// READ_NEW     starting to edit a new buffer</a>
<a name="ln166">/// READ_FILTER  reading filter output</a>
<a name="ln167">/// READ_STDIN   read from stdin instead of a file</a>
<a name="ln168">/// READ_BUFFER  read from curbuf instead of a file (converting after reading</a>
<a name="ln169">///              stdin)</a>
<a name="ln170">/// READ_NOFILE  do not read a file, only trigger BufReadCmd</a>
<a name="ln171">/// READ_DUMMY   read into a dummy buffer (to check if file contents changed)</a>
<a name="ln172">/// READ_KEEP_UNDO  don't clear undo info or read it from a file</a>
<a name="ln173">/// READ_FIFO    read from fifo/socket instead of a file</a>
<a name="ln174">///</a>
<a name="ln175">/// @param eap  can be NULL!</a>
<a name="ln176">///</a>
<a name="ln177">/// @return     FAIL for failure, NOTDONE for directory (failure), or OK</a>
<a name="ln178">int readfile(char *fname, char *sfname, linenr_T from, linenr_T lines_to_skip,</a>
<a name="ln179">             linenr_T lines_to_read, exarg_T *eap, int flags, bool silent)</a>
<a name="ln180">{</a>
<a name="ln181">  int fd = stdin_fd &gt;= 0 ? stdin_fd : 0;</a>
<a name="ln182">  int newfile = (flags &amp; READ_NEW);</a>
<a name="ln183">  int check_readonly;</a>
<a name="ln184">  int filtering = (flags &amp; READ_FILTER);</a>
<a name="ln185">  int read_stdin = (flags &amp; READ_STDIN);</a>
<a name="ln186">  int read_buffer = (flags &amp; READ_BUFFER);</a>
<a name="ln187">  int read_fifo = (flags &amp; READ_FIFO);</a>
<a name="ln188">  int set_options = newfile || read_buffer</a>
<a name="ln189">                    || (eap != NULL &amp;&amp; eap-&gt;read_edit);</a>
<a name="ln190">  linenr_T read_buf_lnum = 1;           // next line to read from curbuf</a>
<a name="ln191">  colnr_T read_buf_col = 0;             // next char to read from this line</a>
<a name="ln192">  char c;</a>
<a name="ln193">  linenr_T lnum = from;</a>
<a name="ln194">  char *ptr = NULL;              // pointer into read buffer</a>
<a name="ln195">  char *buffer = NULL;           // read buffer</a>
<a name="ln196">  char *new_buffer = NULL;       // init to shut up gcc</a>
<a name="ln197">  char *line_start = NULL;       // init to shut up gcc</a>
<a name="ln198">  int wasempty;                         // buffer was empty before reading</a>
<a name="ln199">  colnr_T len;</a>
<a name="ln200">  long size = 0;</a>
<a name="ln201">  uint8_t *p = NULL;</a>
<a name="ln202">  off_T filesize = 0;</a>
<a name="ln203">  bool skip_read = false;</a>
<a name="ln204">  context_sha256_T sha_ctx;</a>
<a name="ln205">  int read_undo_file = false;</a>
<a name="ln206">  int split = 0;  // number of split lines</a>
<a name="ln207">  linenr_T linecnt;</a>
<a name="ln208">  bool error = false;                   // errors encountered</a>
<a name="ln209">  int ff_error = EOL_UNKNOWN;           // file format with errors</a>
<a name="ln210">  long linerest = 0;                    // remaining chars in line</a>
<a name="ln211">  int perm = 0;</a>
<a name="ln212">#ifdef UNIX</a>
<a name="ln213">  int swap_mode = -1;                   // protection bits for swap file</a>
<a name="ln214">#endif</a>
<a name="ln215">  int fileformat = 0;                   // end-of-line format</a>
<a name="ln216">  bool keep_fileformat = false;</a>
<a name="ln217">  FileInfo file_info;</a>
<a name="ln218">  linenr_T skip_count = 0;</a>
<a name="ln219">  linenr_T read_count = 0;</a>
<a name="ln220">  int msg_save = msg_scroll;</a>
<a name="ln221">  linenr_T read_no_eol_lnum = 0;        // non-zero lnum when last line of</a>
<a name="ln222">                                        // last read was missing the eol</a>
<a name="ln223">  bool file_rewind = false;</a>
<a name="ln224">  int can_retry;</a>
<a name="ln225">  linenr_T conv_error = 0;              // line nr with conversion error</a>
<a name="ln226">  linenr_T illegal_byte = 0;            // line nr with illegal byte</a>
<a name="ln227">  bool keep_dest_enc = false;           // don't retry when char doesn't fit</a>
<a name="ln228">                                        // in destination encoding</a>
<a name="ln229">  int bad_char_behavior = BAD_REPLACE;</a>
<a name="ln230">  // BAD_KEEP, BAD_DROP or character to</a>
<a name="ln231">  // replace with</a>
<a name="ln232">  char *tmpname = NULL;          // name of 'charconvert' output file</a>
<a name="ln233">  int fio_flags = 0;</a>
<a name="ln234">  char *fenc;                    // fileencoding to use</a>
<a name="ln235">  bool fenc_alloced;                    // fenc_next is in allocated memory</a>
<a name="ln236">  char *fenc_next = NULL;        // next item in 'fencs' or NULL</a>
<a name="ln237">  bool advance_fenc = false;</a>
<a name="ln238">  long real_size = 0;</a>
<a name="ln239">#ifdef HAVE_ICONV</a>
<a name="ln240">  iconv_t iconv_fd = (iconv_t)-1;       // descriptor for iconv() or -1</a>
<a name="ln241">  bool did_iconv = false;               // true when iconv() failed and trying</a>
<a name="ln242">                                        // 'charconvert' next</a>
<a name="ln243">#endif</a>
<a name="ln244">  bool converted = false;                // true if conversion done</a>
<a name="ln245">  bool notconverted = false;             // true if conversion wanted but it wasn't possible</a>
<a name="ln246">  char conv_rest[CONV_RESTLEN];</a>
<a name="ln247">  int conv_restlen = 0;                 // nr of bytes in conv_rest[]</a>
<a name="ln248">  pos_T orig_start;</a>
<a name="ln249">  buf_T *old_curbuf;</a>
<a name="ln250">  char *old_b_ffname;</a>
<a name="ln251">  char *old_b_fname;</a>
<a name="ln252">  int using_b_ffname;</a>
<a name="ln253">  int using_b_fname;</a>
<a name="ln254">  static char *msg_is_a_directory = N_(&quot;is a directory&quot;);</a>
<a name="ln255"> </a>
<a name="ln256">  au_did_filetype = false;  // reset before triggering any autocommands</a>
<a name="ln257"> </a>
<a name="ln258">  curbuf-&gt;b_no_eol_lnum = 0;    // in case it was set by the previous read</a>
<a name="ln259"> </a>
<a name="ln260">  // If there is no file name yet, use the one for the read file.</a>
<a name="ln261">  // BF_NOTEDITED is set to reflect this.</a>
<a name="ln262">  // Don't do this for a read from a filter.</a>
<a name="ln263">  // Only do this when 'cpoptions' contains the 'f' flag.</a>
<a name="ln264">  if (curbuf-&gt;b_ffname == NULL</a>
<a name="ln265">      &amp;&amp; !filtering</a>
<a name="ln266">      &amp;&amp; fname != NULL</a>
<a name="ln267">      &amp;&amp; vim_strchr(p_cpo, CPO_FNAMER) != NULL</a>
<a name="ln268">      &amp;&amp; !(flags &amp; READ_DUMMY)) {</a>
<a name="ln269">    if (set_rw_fname((char_u *)fname, (char_u *)sfname) == FAIL) {</a>
<a name="ln270">      return FAIL;</a>
<a name="ln271">    }</a>
<a name="ln272">  }</a>
<a name="ln273"> </a>
<a name="ln274">  // Remember the initial values of curbuf, curbuf-&gt;b_ffname and</a>
<a name="ln275">  // curbuf-&gt;b_fname to detect whether they are altered as a result of</a>
<a name="ln276">  // executing nasty autocommands.  Also check if &quot;fname&quot; and &quot;sfname&quot;</a>
<a name="ln277">  // point to one of these values.</a>
<a name="ln278">  old_curbuf = curbuf;</a>
<a name="ln279">  old_b_ffname = curbuf-&gt;b_ffname;</a>
<a name="ln280">  old_b_fname = curbuf-&gt;b_fname;</a>
<a name="ln281">  using_b_ffname = (fname == curbuf-&gt;b_ffname) || (sfname == curbuf-&gt;b_ffname);</a>
<a name="ln282">  using_b_fname = (fname == curbuf-&gt;b_fname) || (sfname == curbuf-&gt;b_fname);</a>
<a name="ln283"> </a>
<a name="ln284">  // After reading a file the cursor line changes but we don't want to</a>
<a name="ln285">  // display the line.</a>
<a name="ln286">  ex_no_reprint = true;</a>
<a name="ln287"> </a>
<a name="ln288">  // don't display the file info for another buffer now</a>
<a name="ln289">  need_fileinfo = false;</a>
<a name="ln290"> </a>
<a name="ln291">  // For Unix: Use the short file name whenever possible.</a>
<a name="ln292">  // Avoids problems with networks and when directory names are changed.</a>
<a name="ln293">  // Don't do this for Windows, a &quot;cd&quot; in a sub-shell may have moved us to</a>
<a name="ln294">  // another directory, which we don't detect.</a>
<a name="ln295">  if (sfname == NULL) {</a>
<a name="ln296">    sfname = fname;</a>
<a name="ln297">  }</a>
<a name="ln298">#if defined(UNIX)</a>
<a name="ln299">  fname = sfname;</a>
<a name="ln300">#endif</a>
<a name="ln301"> </a>
<a name="ln302">  // The BufReadCmd and FileReadCmd events intercept the reading process by</a>
<a name="ln303">  // executing the associated commands instead.</a>
<a name="ln304">  if (!filtering &amp;&amp; !read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln305">    orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln306"> </a>
<a name="ln307">    // Set '[ mark to the line above where the lines go (line 1 if zero).</a>
<a name="ln308">    curbuf-&gt;b_op_start.lnum = ((from == 0) ? 1 : from);</a>
<a name="ln309">    curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln310"> </a>
<a name="ln311">    if (newfile) {</a>
<a name="ln312">      if (apply_autocmds_exarg(EVENT_BUFREADCMD, NULL, sfname,</a>
<a name="ln313">                               false, curbuf, eap)) {</a>
<a name="ln314">        int status = OK;</a>
<a name="ln315"> </a>
<a name="ln316">        if (aborting()) {</a>
<a name="ln317">          status = FAIL;</a>
<a name="ln318">        }</a>
<a name="ln319"> </a>
<a name="ln320">        // The BufReadCmd code usually uses &quot;:read&quot; to get the text and</a>
<a name="ln321">        // perhaps &quot;:file&quot; to change the buffer name. But we should</a>
<a name="ln322">        // consider this to work like &quot;:edit&quot;, thus reset the</a>
<a name="ln323">        // BF_NOTEDITED flag.  Then &quot;:write&quot; will work to overwrite the</a>
<a name="ln324">        // same file.</a>
<a name="ln325">        if (status == OK) {</a>
<a name="ln326">          curbuf-&gt;b_flags &amp;= ~BF_NOTEDITED;</a>
<a name="ln327">        }</a>
<a name="ln328">        return status;</a>
<a name="ln329">      }</a>
<a name="ln330">    } else if (apply_autocmds_exarg(EVENT_FILEREADCMD, sfname, sfname,</a>
<a name="ln331">                                    false, NULL, eap)) {</a>
<a name="ln332">      return aborting() ? FAIL : OK;</a>
<a name="ln333">    }</a>
<a name="ln334"> </a>
<a name="ln335">    curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln336"> </a>
<a name="ln337">    if (flags &amp; READ_NOFILE) {</a>
<a name="ln338">      // Return NOTDONE instead of FAIL so that BufEnter can be triggered</a>
<a name="ln339">      // and other operations don't fail.</a>
<a name="ln340">      return NOTDONE;</a>
<a name="ln341">    }</a>
<a name="ln342">  }</a>
<a name="ln343"> </a>
<a name="ln344">  if ((shortmess(SHM_OVER) || curbuf-&gt;b_help) &amp;&amp; p_verbose == 0) {</a>
<a name="ln345">    msg_scroll = false;         // overwrite previous file message</a>
<a name="ln346">  } else {</a>
<a name="ln347">    msg_scroll = true;          // don't overwrite previous file message</a>
<a name="ln348">  }</a>
<a name="ln349">  // If the name is too long we might crash further on, quit here.</a>
<a name="ln350">  if (fname != NULL &amp;&amp; *fname != NUL) {</a>
<a name="ln351">    size_t namelen = strlen(fname);</a>
<a name="ln352"> </a>
<a name="ln353">    // If the name is too long we might crash further on, quit here.</a>
<a name="ln354">    if (namelen &gt;= MAXPATHL) {</a>
<a name="ln355">      filemess(curbuf, fname, _(&quot;Illegal file name&quot;), 0);</a>
<a name="ln356">      msg_end();</a>
<a name="ln357">      msg_scroll = msg_save;</a>
<a name="ln358">      return FAIL;</a>
<a name="ln359">    }</a>
<a name="ln360"> </a>
<a name="ln361">    // If the name ends in a path separator, we can't open it.  Check here,</a>
<a name="ln362">    // because reading the file may actually work, but then creating the</a>
<a name="ln363">    // swap file may destroy it!  Reported on MS-DOS and Win 95.</a>
<a name="ln364">    if (after_pathsep(fname, fname + namelen)) {</a>
<a name="ln365">      if (!silent) {</a>
<a name="ln366">        filemess(curbuf, fname, _(msg_is_a_directory), 0);</a>
<a name="ln367">      }</a>
<a name="ln368">      msg_end();</a>
<a name="ln369">      msg_scroll = msg_save;</a>
<a name="ln370">      return NOTDONE;</a>
<a name="ln371">    }</a>
<a name="ln372">  }</a>
<a name="ln373"> </a>
<a name="ln374">  if (!read_buffer &amp;&amp; !read_stdin &amp;&amp; !read_fifo) {</a>
<a name="ln375">    perm = os_getperm(fname);</a>
<a name="ln376">    // On Unix it is possible to read a directory, so we have to</a>
<a name="ln377">    // check for it before os_open().</a>
<a name="ln378">    if (perm &gt;= 0 &amp;&amp; !S_ISREG(perm)                 // not a regular file ...</a>
<a name="ln379">        &amp;&amp; !S_ISFIFO(perm)                          // ... or fifo</a>
<a name="ln380">        &amp;&amp; !S_ISSOCK(perm)                          // ... or socket</a>
<a name="ln381">#ifdef OPEN_CHR_FILES</a>
<a name="ln382">        &amp;&amp; !(S_ISCHR(perm) &amp;&amp; is_dev_fd_file(fname))</a>
<a name="ln383">        // ... or a character special file named /dev/fd/&lt;n&gt;</a>
<a name="ln384">#endif</a>
<a name="ln385">        ) {</a>
<a name="ln386">      if (S_ISDIR(perm)) {</a>
<a name="ln387">        if (!silent) {</a>
<a name="ln388">          filemess(curbuf, fname, _(msg_is_a_directory), 0);</a>
<a name="ln389">        }</a>
<a name="ln390">      } else {</a>
<a name="ln391">        filemess(curbuf, fname, _(&quot;is not a file&quot;), 0);</a>
<a name="ln392">      }</a>
<a name="ln393">      msg_end();</a>
<a name="ln394">      msg_scroll = msg_save;</a>
<a name="ln395">      return S_ISDIR(perm) ? NOTDONE : FAIL;</a>
<a name="ln396">    }</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">  // Set default or forced 'fileformat' and 'binary'.</a>
<a name="ln400">  set_file_options(set_options, eap);</a>
<a name="ln401"> </a>
<a name="ln402">  // When opening a new file we take the readonly flag from the file.</a>
<a name="ln403">  // Default is r/w, can be set to r/o below.</a>
<a name="ln404">  // Don't reset it when in readonly mode</a>
<a name="ln405">  // Only set/reset b_p_ro when BF_CHECK_RO is set.</a>
<a name="ln406">  check_readonly = (newfile &amp;&amp; (curbuf-&gt;b_flags &amp; BF_CHECK_RO));</a>
<a name="ln407">  if (check_readonly &amp;&amp; !readonlymode) {</a>
<a name="ln408">    curbuf-&gt;b_p_ro = false;</a>
<a name="ln409">  }</a>
<a name="ln410"> </a>
<a name="ln411">  if (newfile &amp;&amp; !read_stdin &amp;&amp; !read_buffer &amp;&amp; !read_fifo) {</a>
<a name="ln412">    // Remember time of file.</a>
<a name="ln413">    if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln414">      buf_store_file_info(curbuf, &amp;file_info);</a>
<a name="ln415">      curbuf-&gt;b_mtime_read = curbuf-&gt;b_mtime;</a>
<a name="ln416">      curbuf-&gt;b_mtime_read_ns = curbuf-&gt;b_mtime_ns;</a>
<a name="ln417">#ifdef UNIX</a>
<a name="ln418">      // Use the protection bits of the original file for the swap file.</a>
<a name="ln419">      // This makes it possible for others to read the name of the</a>
<a name="ln420">      // edited file from the swapfile, but only if they can read the</a>
<a name="ln421">      // edited file.</a>
<a name="ln422">      // Remove the &quot;write&quot; and &quot;execute&quot; bits for group and others</a>
<a name="ln423">      // (they must not write the swapfile).</a>
<a name="ln424">      // Add the &quot;read&quot; and &quot;write&quot; bits for the user, otherwise we may</a>
<a name="ln425">      // not be able to write to the file ourselves.</a>
<a name="ln426">      // Setting the bits is done below, after creating the swap file.</a>
<a name="ln427">      swap_mode = ((int)file_info.stat.st_mode &amp; 0644) | 0600;</a>
<a name="ln428">#endif</a>
<a name="ln429">    } else {</a>
<a name="ln430">      curbuf-&gt;b_mtime = 0;</a>
<a name="ln431">      curbuf-&gt;b_mtime_ns = 0;</a>
<a name="ln432">      curbuf-&gt;b_mtime_read = 0;</a>
<a name="ln433">      curbuf-&gt;b_mtime_read_ns = 0;</a>
<a name="ln434">      curbuf-&gt;b_orig_size = 0;</a>
<a name="ln435">      curbuf-&gt;b_orig_mode = 0;</a>
<a name="ln436">    }</a>
<a name="ln437"> </a>
<a name="ln438">    // Reset the &quot;new file&quot; flag.  It will be set again below when the</a>
<a name="ln439">    // file doesn't exist.</a>
<a name="ln440">    curbuf-&gt;b_flags &amp;= ~(BF_NEW | BF_NEW_W);</a>
<a name="ln441">  }</a>
<a name="ln442"> </a>
<a name="ln443">  // Check readonly.</a>
<a name="ln444">  bool file_readonly = false;</a>
<a name="ln445">  if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln446">    if (!newfile || readonlymode || !(perm &amp; 0222)</a>
<a name="ln447">        || !os_file_is_writable(fname)) {</a>
<a name="ln448">      file_readonly = true;</a>
<a name="ln449">    }</a>
<a name="ln450">    fd = os_open(fname, O_RDONLY, 0);</a>
<a name="ln451">  }</a>
<a name="ln452"> </a>
<a name="ln453">  if (fd &lt; 0) {                     // cannot open at all</a>
<a name="ln454">    msg_scroll = msg_save;</a>
<a name="ln455">    if (!newfile) {</a>
<a name="ln456">      return FAIL;</a>
<a name="ln457">    }</a>
<a name="ln458">    if (perm == UV_ENOENT) {  // check if the file exists</a>
<a name="ln459">      // Set the 'new-file' flag, so that when the file has</a>
<a name="ln460">      // been created by someone else, a &quot;:w&quot; will complain.</a>
<a name="ln461">      curbuf-&gt;b_flags |= BF_NEW;</a>
<a name="ln462"> </a>
<a name="ln463">      // Create a swap file now, so that other Vims are warned</a>
<a name="ln464">      // that we are editing this file.  Don't do this for a</a>
<a name="ln465">      // &quot;nofile&quot; or &quot;nowrite&quot; buffer type.</a>
<a name="ln466">      if (!bt_dontwrite(curbuf)) {</a>
<a name="ln467">        check_need_swap(newfile);</a>
<a name="ln468">        // SwapExists autocommand may mess things up</a>
<a name="ln469">        if (curbuf != old_curbuf</a>
<a name="ln470">            || (using_b_ffname</a>
<a name="ln471">                &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln472">            || (using_b_fname</a>
<a name="ln473">                &amp;&amp; (old_b_fname != curbuf-&gt;b_fname))) {</a>
<a name="ln474">          emsg(_(e_auchangedbuf));</a>
<a name="ln475">          return FAIL;</a>
<a name="ln476">        }</a>
<a name="ln477">      }</a>
<a name="ln478">      if (!silent) {</a>
<a name="ln479">        if (dir_of_file_exists((char_u *)fname)) {</a>
<a name="ln480">          filemess(curbuf, sfname, new_file_message(), 0);</a>
<a name="ln481">        } else {</a>
<a name="ln482">          filemess(curbuf, sfname, _(&quot;[New DIRECTORY]&quot;), 0);</a>
<a name="ln483">        }</a>
<a name="ln484">      }</a>
<a name="ln485">      // Even though this is a new file, it might have been</a>
<a name="ln486">      // edited before and deleted.  Get the old marks.</a>
<a name="ln487">      check_marks_read();</a>
<a name="ln488">      // Set forced 'fileencoding'.</a>
<a name="ln489">      if (eap != NULL) {</a>
<a name="ln490">        set_forced_fenc(eap);</a>
<a name="ln491">      }</a>
<a name="ln492">      apply_autocmds_exarg(EVENT_BUFNEWFILE, sfname, sfname,</a>
<a name="ln493">                           false, curbuf, eap);</a>
<a name="ln494">      // remember the current fileformat</a>
<a name="ln495">      save_file_ff(curbuf);</a>
<a name="ln496"> </a>
<a name="ln497">      if (aborting()) {             // autocmds may abort script processing</a>
<a name="ln498">        return FAIL;</a>
<a name="ln499">      }</a>
<a name="ln500">      return OK;                  // a new file is not an error</a>
<a name="ln501">    } else {</a>
<a name="ln502">      filemess(curbuf, sfname, ((fd == UV_EFBIG) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln503">#if defined(UNIX) &amp;&amp; defined(EOVERFLOW)</a>
<a name="ln504">                                // libuv only returns -errno</a>
<a name="ln505">                                // in Unix and in Windows</a>
<a name="ln506">                                // open() does not set</a>
<a name="ln507">                                // EOVERFLOW</a>
<a name="ln508">                                (fd == -EOVERFLOW) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln509">#endif</a>
<a name="ln510">                                _(&quot;[Permission Denied]&quot;)), 0);</a>
<a name="ln511">      curbuf-&gt;b_p_ro = true;                  // must use &quot;w!&quot; now</a>
<a name="ln512">    }</a>
<a name="ln513"> </a>
<a name="ln514">    return FAIL;</a>
<a name="ln515">  }</a>
<a name="ln516"> </a>
<a name="ln517">  // Only set the 'ro' flag for readonly files the first time they are</a>
<a name="ln518">  // loaded.    Help files always get readonly mode</a>
<a name="ln519">  if ((check_readonly &amp;&amp; file_readonly) || curbuf-&gt;b_help) {</a>
<a name="ln520">    curbuf-&gt;b_p_ro = true;</a>
<a name="ln521">  }</a>
<a name="ln522"> </a>
<a name="ln523">  if (set_options) {</a>
<a name="ln524">    // Don't change 'eol' if reading from buffer as it will already be</a>
<a name="ln525">    // correctly set when reading stdin.</a>
<a name="ln526">    if (!read_buffer) {</a>
<a name="ln527">      curbuf-&gt;b_p_eof = false;</a>
<a name="ln528">      curbuf-&gt;b_start_eof = false;</a>
<a name="ln529">      curbuf-&gt;b_p_eol = true;</a>
<a name="ln530">      curbuf-&gt;b_start_eol = true;</a>
<a name="ln531">    }</a>
<a name="ln532">    curbuf-&gt;b_p_bomb = false;</a>
<a name="ln533">    curbuf-&gt;b_start_bomb = false;</a>
<a name="ln534">  }</a>
<a name="ln535"> </a>
<a name="ln536">  // Create a swap file now, so that other Vims are warned that we are</a>
<a name="ln537">  // editing this file.</a>
<a name="ln538">  // Don't do this for a &quot;nofile&quot; or &quot;nowrite&quot; buffer type.</a>
<a name="ln539">  if (!bt_dontwrite(curbuf)) {</a>
<a name="ln540">    check_need_swap(newfile);</a>
<a name="ln541">    if (!read_stdin</a>
<a name="ln542">        &amp;&amp; (curbuf != old_curbuf</a>
<a name="ln543">            || (using_b_ffname &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln544">            || (using_b_fname &amp;&amp; (old_b_fname != curbuf-&gt;b_fname)))) {</a>
<a name="ln545">      emsg(_(e_auchangedbuf));</a>
<a name="ln546">      if (!read_buffer) {</a>
<a name="ln547">        close(fd);</a>
<a name="ln548">      }</a>
<a name="ln549">      return FAIL;</a>
<a name="ln550">    }</a>
<a name="ln551">#ifdef UNIX</a>
<a name="ln552">    // Set swap file protection bits after creating it.</a>
<a name="ln553">    if (swap_mode &gt; 0 &amp;&amp; curbuf-&gt;b_ml.ml_mfp != NULL</a>
<a name="ln554">        &amp;&amp; curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname != NULL) {</a>
<a name="ln555">      const char *swap_fname = (const char *)curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname;</a>
<a name="ln556"> </a>
<a name="ln557">      // If the group-read bit is set but not the world-read bit, then</a>
<a name="ln558">      // the group must be equal to the group of the original file.  If</a>
<a name="ln559">      // we can't make that happen then reset the group-read bit.  This</a>
<a name="ln560">      // avoids making the swap file readable to more users when the</a>
<a name="ln561">      // primary group of the user is too permissive.</a>
<a name="ln562">      if ((swap_mode &amp; 044) == 040) {</a>
<a name="ln563">        FileInfo swap_info;</a>
<a name="ln564"> </a>
<a name="ln565">        if (os_fileinfo(swap_fname, &amp;swap_info)</a>
<a name="ln566">            &amp;&amp; file_info.stat.st_gid != swap_info.stat.st_gid</a>
<a name="ln567">            &amp;&amp; os_fchown(curbuf-&gt;b_ml.ml_mfp-&gt;mf_fd, (uv_uid_t)(-1),</a>
<a name="ln568">                         (uv_gid_t)file_info.stat.st_gid)</a>
<a name="ln569">            == -1) {</a>
<a name="ln570">          swap_mode &amp;= 0600;</a>
<a name="ln571">        }</a>
<a name="ln572">      }</a>
<a name="ln573"> </a>
<a name="ln574">      (void)os_setperm(swap_fname, swap_mode);</a>
<a name="ln575">    }</a>
<a name="ln576">#endif</a>
<a name="ln577">  }</a>
<a name="ln578"> </a>
<a name="ln579">  // If &quot;Quit&quot; selected at ATTENTION dialog, don't load the file.</a>
<a name="ln580">  if (swap_exists_action == SEA_QUIT) {</a>
<a name="ln581">    if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln582">      close(fd);</a>
<a name="ln583">    }</a>
<a name="ln584">    return FAIL;</a>
<a name="ln585">  }</a>
<a name="ln586"> </a>
<a name="ln587">  no_wait_return++;         // don't wait for return yet</a>
<a name="ln588"> </a>
<a name="ln589">  // Set '[ mark to the line above where the lines go (line 1 if zero).</a>
<a name="ln590">  orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln591">  curbuf-&gt;b_op_start.lnum = ((from == 0) ? 1 : from);</a>
<a name="ln592">  curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln593"> </a>
<a name="ln594">  int try_mac = (vim_strchr(p_ffs, 'm') != NULL);</a>
<a name="ln595">  int try_dos = (vim_strchr(p_ffs, 'd') != NULL);</a>
<a name="ln596">  int try_unix = (vim_strchr(p_ffs, 'x') != NULL);</a>
<a name="ln597"> </a>
<a name="ln598">  if (!read_buffer) {</a>
<a name="ln599">    int m = msg_scroll;</a>
<a name="ln600">    int n = msg_scrolled;</a>
<a name="ln601"> </a>
<a name="ln602">    // The file must be closed again, the autocommands may want to change</a>
<a name="ln603">    // the file before reading it.</a>
<a name="ln604">    if (!read_stdin) {</a>
<a name="ln605">      close(fd);                // ignore errors</a>
<a name="ln606">    }</a>
<a name="ln607"> </a>
<a name="ln608">    // The output from the autocommands should not overwrite anything and</a>
<a name="ln609">    // should not be overwritten: Set msg_scroll, restore its value if no</a>
<a name="ln610">    // output was done.</a>
<a name="ln611">    msg_scroll = true;</a>
<a name="ln612">    if (filtering) {</a>
<a name="ln613">      apply_autocmds_exarg(EVENT_FILTERREADPRE, NULL, sfname,</a>
<a name="ln614">                           false, curbuf, eap);</a>
<a name="ln615">    } else if (read_stdin) {</a>
<a name="ln616">      apply_autocmds_exarg(EVENT_STDINREADPRE, NULL, sfname,</a>
<a name="ln617">                           false, curbuf, eap);</a>
<a name="ln618">    } else if (newfile) {</a>
<a name="ln619">      apply_autocmds_exarg(EVENT_BUFREADPRE, NULL, sfname,</a>
<a name="ln620">                           false, curbuf, eap);</a>
<a name="ln621">    } else {</a>
<a name="ln622">      apply_autocmds_exarg(EVENT_FILEREADPRE, sfname, sfname,</a>
<a name="ln623">                           false, NULL, eap);</a>
<a name="ln624">    }</a>
<a name="ln625"> </a>
<a name="ln626">    // autocommands may have changed it</a>
<a name="ln627">    try_mac = (vim_strchr(p_ffs, 'm') != NULL);</a>
<a name="ln628">    try_dos = (vim_strchr(p_ffs, 'd') != NULL);</a>
<a name="ln629">    try_unix = (vim_strchr(p_ffs, 'x') != NULL);</a>
<a name="ln630">    curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln631"> </a>
<a name="ln632">    if (msg_scrolled == n) {</a>
<a name="ln633">      msg_scroll = m;</a>
<a name="ln634">    }</a>
<a name="ln635"> </a>
<a name="ln636">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln637">      no_wait_return--;</a>
<a name="ln638">      msg_scroll = msg_save;</a>
<a name="ln639">      curbuf-&gt;b_p_ro = true;            // must use &quot;w!&quot; now</a>
<a name="ln640">      return FAIL;</a>
<a name="ln641">    }</a>
<a name="ln642">    // Don't allow the autocommands to change the current buffer.</a>
<a name="ln643">    // Try to re-open the file.</a>
<a name="ln644">    //</a>
<a name="ln645">    // Don't allow the autocommands to change the buffer name either</a>
<a name="ln646">    // (cd for example) if it invalidates fname or sfname.</a>
<a name="ln647">    if (!read_stdin &amp;&amp; (curbuf != old_curbuf</a>
<a name="ln648">                        || (using_b_ffname &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln649">                        || (using_b_fname &amp;&amp; (old_b_fname != curbuf-&gt;b_fname))</a>
<a name="ln650">                        || (fd = os_open(fname, O_RDONLY, 0)) &lt; 0)) {</a>
<a name="ln651">      no_wait_return--;</a>
<a name="ln652">      msg_scroll = msg_save;</a>
<a name="ln653">      if (fd &lt; 0) {</a>
<a name="ln654">        emsg(_(&quot;E200: *ReadPre autocommands made the file unreadable&quot;));</a>
<a name="ln655">      } else {</a>
<a name="ln656">        emsg(_(&quot;E201: *ReadPre autocommands must not change current buffer&quot;));</a>
<a name="ln657">      }</a>
<a name="ln658">      curbuf-&gt;b_p_ro = true;            // must use &quot;w!&quot; now</a>
<a name="ln659">      return FAIL;</a>
<a name="ln660">    }</a>
<a name="ln661">  }</a>
<a name="ln662"> </a>
<a name="ln663">  // Autocommands may add lines to the file, need to check if it is empty</a>
<a name="ln664">  wasempty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln665"> </a>
<a name="ln666">  if (!recoverymode &amp;&amp; !filtering &amp;&amp; !(flags &amp; READ_DUMMY) &amp;&amp; !silent) {</a>
<a name="ln667">    if (!read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln668">      filemess(curbuf, sfname, &quot;&quot;, 0);</a>
<a name="ln669">    }</a>
<a name="ln670">  }</a>
<a name="ln671"> </a>
<a name="ln672">  msg_scroll = false;                   // overwrite the file message</a>
<a name="ln673"> </a>
<a name="ln674">  // Set linecnt now, before the &quot;retry&quot; caused by a wrong guess for</a>
<a name="ln675">  // fileformat, and after the autocommands, which may change them.</a>
<a name="ln676">  linecnt = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln677"> </a>
<a name="ln678">  // &quot;++bad=&quot; argument.</a>
<a name="ln679">  if (eap != NULL &amp;&amp; eap-&gt;bad_char != 0) {</a>
<a name="ln680">    bad_char_behavior = eap-&gt;bad_char;</a>
<a name="ln681">    if (set_options) {</a>
<a name="ln682">      curbuf-&gt;b_bad_char = eap-&gt;bad_char;</a>
<a name="ln683">    }</a>
<a name="ln684">  } else {</a>
<a name="ln685">    curbuf-&gt;b_bad_char = 0;</a>
<a name="ln686">  }</a>
<a name="ln687"> </a>
<a name="ln688">  // Decide which 'encoding' to use or use first.</a>
<a name="ln689">  if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln690">    fenc = enc_canonize(eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln691">    fenc_alloced = true;</a>
<a name="ln692">    keep_dest_enc = true;</a>
<a name="ln693">  } else if (curbuf-&gt;b_p_bin) {</a>
<a name="ln694">    fenc = &quot;&quot;;                // binary: don't convert</a>
<a name="ln695">    fenc_alloced = false;</a>
<a name="ln696">  } else if (curbuf-&gt;b_help) {</a>
<a name="ln697">    // Help files are either utf-8 or latin1.  Try utf-8 first, if this</a>
<a name="ln698">    // fails it must be latin1.</a>
<a name="ln699">    // It is needed when the first line contains non-ASCII characters.</a>
<a name="ln700">    // That is only in *.??x files.</a>
<a name="ln701">    fenc_next = &quot;latin1&quot;;</a>
<a name="ln702">    fenc = &quot;utf-8&quot;;</a>
<a name="ln703"> </a>
<a name="ln704">    fenc_alloced = false;</a>
<a name="ln705">  } else if (*p_fencs == NUL) {</a>
<a name="ln706">    fenc = curbuf-&gt;b_p_fenc;            // use format from buffer</a>
<a name="ln707">    fenc_alloced = false;</a>
<a name="ln708">  } else {</a>
<a name="ln709">    fenc_next = p_fencs;                // try items in 'fileencodings'</a>
<a name="ln710">    fenc = next_fenc(&amp;fenc_next, &amp;fenc_alloced);</a>
<a name="ln711">  }</a>
<a name="ln712"> </a>
<a name="ln713">  // Jump back here to retry reading the file in different ways.</a>
<a name="ln714">  // Reasons to retry:</a>
<a name="ln715">  // - encoding conversion failed: try another one from &quot;fenc_next&quot;</a>
<a name="ln716">  // - BOM detected and fenc was set, need to setup conversion</a>
<a name="ln717">  // - &quot;fileformat&quot; check failed: try another</a>
<a name="ln718">  //</a>
<a name="ln719">  // Variables set for special retry actions:</a>
<a name="ln720">  // &quot;file_rewind&quot;      Rewind the file to start reading it again.</a>
<a name="ln721">  // &quot;advance_fenc&quot;     Advance &quot;fenc&quot; using &quot;fenc_next&quot;.</a>
<a name="ln722">  // &quot;skip_read&quot;        Re-use already read bytes (BOM detected).</a>
<a name="ln723">  // &quot;did_iconv&quot;        iconv() conversion failed, try 'charconvert'.</a>
<a name="ln724">  // &quot;keep_fileformat&quot; Don't reset &quot;fileformat&quot;.</a>
<a name="ln725">  //</a>
<a name="ln726">  // Other status indicators:</a>
<a name="ln727">  // &quot;tmpname&quot;  When != NULL did conversion with 'charconvert'.</a>
<a name="ln728">  //                    Output file has to be deleted afterwards.</a>
<a name="ln729">  // &quot;iconv_fd&quot; When != -1 did conversion with iconv().</a>
<a name="ln730">retry:</a>
<a name="ln731"> </a>
<a name="ln732">  if (file_rewind) {</a>
<a name="ln733">    if (read_buffer) {</a>
<a name="ln734">      read_buf_lnum = 1;</a>
<a name="ln735">      read_buf_col = 0;</a>
<a name="ln736">    } else if (read_stdin || vim_lseek(fd, (off_T)0L, SEEK_SET) != 0) {</a>
<a name="ln737">      // Can't rewind the file, give up.</a>
<a name="ln738">      error = true;</a>
<a name="ln739">      goto failed;</a>
<a name="ln740">    }</a>
<a name="ln741">    // Delete the previously read lines.</a>
<a name="ln742">    while (lnum &gt; from) {</a>
<a name="ln743">      ml_delete(lnum--, false);</a>
<a name="ln744">    }</a>
<a name="ln745">    file_rewind = false;</a>
<a name="ln746">    if (set_options) {</a>
<a name="ln747">      curbuf-&gt;b_p_bomb = false;</a>
<a name="ln748">      curbuf-&gt;b_start_bomb = false;</a>
<a name="ln749">    }</a>
<a name="ln750">    conv_error = 0;</a>
<a name="ln751">  }</a>
<a name="ln752"> </a>
<a name="ln753">  // When retrying with another &quot;fenc&quot; and the first time &quot;fileformat&quot;</a>
<a name="ln754">  // will be reset.</a>
<a name="ln755">  if (keep_fileformat) {</a>
<a name="ln756">    keep_fileformat = false;</a>
<a name="ln757">  } else {</a>
<a name="ln758">    if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln759">      fileformat = get_fileformat_force(curbuf, eap);</a>
<a name="ln760">      try_unix = try_dos = try_mac = false;</a>
<a name="ln761">    } else if (curbuf-&gt;b_p_bin) {</a>
<a name="ln762">      fileformat = EOL_UNIX;                    // binary: use Unix format</a>
<a name="ln763">    } else if (*p_ffs ==</a>
<a name="ln764">               NUL) {</a>
<a name="ln765">      fileformat = get_fileformat(curbuf);      // use format from buffer</a>
<a name="ln766">    } else {</a>
<a name="ln767">      fileformat = EOL_UNKNOWN;                 // detect from file</a>
<a name="ln768">    }</a>
<a name="ln769">  }</a>
<a name="ln770"> </a>
<a name="ln771">#ifdef HAVE_ICONV</a>
<a name="ln772">  if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln773">    // aborted conversion with iconv(), close the descriptor</a>
<a name="ln774">    iconv_close(iconv_fd);</a>
<a name="ln775">    iconv_fd = (iconv_t)-1;</a>
<a name="ln776">  }</a>
<a name="ln777">#endif</a>
<a name="ln778"> </a>
<a name="ln779">  if (advance_fenc) {</a>
<a name="ln780">    // Try the next entry in 'fileencodings'.</a>
<a name="ln781">    advance_fenc = false;</a>
<a name="ln782"> </a>
<a name="ln783">    if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln784">      // Conversion given with &quot;++cc=&quot; wasn't possible, read</a>
<a name="ln785">      // without conversion.</a>
<a name="ln786">      notconverted = true;</a>
<a name="ln787">      conv_error = 0;</a>
<a name="ln788">      if (fenc_alloced) {</a>
<a name="ln789">        xfree(fenc);</a>
<a name="ln790">      }</a>
<a name="ln791">      fenc = &quot;&quot;;</a>
<a name="ln792">      fenc_alloced = false;</a>
<a name="ln793">    } else {</a>
<a name="ln794">      if (fenc_alloced) {</a>
<a name="ln795">        xfree(fenc);</a>
<a name="ln796">      }</a>
<a name="ln797">      if (fenc_next != NULL) {</a>
<a name="ln798">        fenc = next_fenc(&amp;fenc_next, &amp;fenc_alloced);</a>
<a name="ln799">      } else {</a>
<a name="ln800">        fenc = &quot;&quot;;</a>
<a name="ln801">        fenc_alloced = false;</a>
<a name="ln802">      }</a>
<a name="ln803">    }</a>
<a name="ln804">    if (tmpname != NULL) {</a>
<a name="ln805">      os_remove(tmpname);  // delete converted file</a>
<a name="ln806">      XFREE_CLEAR(tmpname);</a>
<a name="ln807">    }</a>
<a name="ln808">  }</a>
<a name="ln809"> </a>
<a name="ln810">  // Conversion may be required when the encoding of the file is different</a>
<a name="ln811">  // from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4.</a>
<a name="ln812">  fio_flags = 0;</a>
<a name="ln813">  converted = need_conversion(fenc);</a>
<a name="ln814">  if (converted) {</a>
<a name="ln815">    // &quot;ucs-bom&quot; means we need to check the first bytes of the file</a>
<a name="ln816">    // for a BOM.</a>
<a name="ln817">    if (strcmp(fenc, ENC_UCSBOM) == 0) {</a>
<a name="ln818">      fio_flags = FIO_UCSBOM;</a>
<a name="ln819">    } else {</a>
<a name="ln820">      // Check if UCS-2/4 or Latin1 to UTF-8 conversion needs to be</a>
<a name="ln821">      // done.  This is handled below after read().  Prepare the</a>
<a name="ln822">      // fio_flags to avoid having to parse the string each time.</a>
<a name="ln823">      // Also check for Unicode to Latin1 conversion, because iconv()</a>
<a name="ln824">      // appears not to handle this correctly.  This works just like</a>
<a name="ln825">      // conversion to UTF-8 except how the resulting character is put in</a>
<a name="ln826">      // the buffer.</a>
<a name="ln827">      fio_flags = get_fio_flags((char_u *)fenc);</a>
<a name="ln828">    }</a>
<a name="ln829"> </a>
<a name="ln830">#ifdef HAVE_ICONV</a>
<a name="ln831">    // Try using iconv() if we can't convert internally.</a>
<a name="ln832">    if (fio_flags == 0</a>
<a name="ln833">        &amp;&amp; !did_iconv) {</a>
<a name="ln834">      iconv_fd = (iconv_t)my_iconv_open((char_u *)&quot;utf-8&quot;, (char_u *)fenc);</a>
<a name="ln835">    }</a>
<a name="ln836">#endif</a>
<a name="ln837"> </a>
<a name="ln838">    // Use the 'charconvert' expression when conversion is required</a>
<a name="ln839">    // and we can't do it internally or with iconv().</a>
<a name="ln840">    if (fio_flags == 0 &amp;&amp; !read_stdin &amp;&amp; !read_buffer &amp;&amp; *p_ccv != NUL</a>
<a name="ln841">        &amp;&amp; !read_fifo</a>
<a name="ln842">#ifdef HAVE_ICONV</a>
<a name="ln843">        &amp;&amp; iconv_fd == (iconv_t)-1</a>
<a name="ln844">#endif</a>
<a name="ln845">        ) {</a>
<a name="ln846">#ifdef HAVE_ICONV</a>
<a name="ln847">      did_iconv = false;</a>
<a name="ln848">#endif</a>
<a name="ln849">      // Skip conversion when it's already done (retry for wrong</a>
<a name="ln850">      // &quot;fileformat&quot;).</a>
<a name="ln851">      if (tmpname == NULL) {</a>
<a name="ln852">        tmpname = (char *)readfile_charconvert((char_u *)fname, (char_u *)fenc, &amp;fd);</a>
<a name="ln853">        if (tmpname == NULL) {</a>
<a name="ln854">          // Conversion failed.  Try another one.</a>
<a name="ln855">          advance_fenc = true;</a>
<a name="ln856">          if (fd &lt; 0) {</a>
<a name="ln857">            // Re-opening the original file failed!</a>
<a name="ln858">            emsg(_(&quot;E202: Conversion made file unreadable!&quot;));</a>
<a name="ln859">            error = true;</a>
<a name="ln860">            goto failed;</a>
<a name="ln861">          }</a>
<a name="ln862">          goto retry;</a>
<a name="ln863">        }</a>
<a name="ln864">      }</a>
<a name="ln865">    } else {</a>
<a name="ln866">      if (fio_flags == 0</a>
<a name="ln867">#ifdef HAVE_ICONV</a>
<a name="ln868">          &amp;&amp; iconv_fd == (iconv_t)-1</a>
<a name="ln869">#endif</a>
<a name="ln870">          ) {</a>
<a name="ln871">        // Conversion wanted but we can't.</a>
<a name="ln872">        // Try the next conversion in 'fileencodings'</a>
<a name="ln873">        advance_fenc = true;</a>
<a name="ln874">        goto retry;</a>
<a name="ln875">      }</a>
<a name="ln876">    }</a>
<a name="ln877">  }</a>
<a name="ln878"> </a>
<a name="ln879">  // Set &quot;can_retry&quot; when it's possible to rewind the file and try with</a>
<a name="ln880">  // another &quot;fenc&quot; value.  It's false when no other &quot;fenc&quot; to try, reading</a>
<a name="ln881">  // stdin or fixed at a specific encoding.</a>
<a name="ln882">  can_retry = (*fenc != NUL &amp;&amp; !read_stdin &amp;&amp; !keep_dest_enc &amp;&amp; !read_fifo);</a>
<a name="ln883"> </a>
<a name="ln884">  if (!skip_read) {</a>
<a name="ln885">    linerest = 0;</a>
<a name="ln886">    filesize = 0;</a>
<a name="ln887">    skip_count = lines_to_skip;</a>
<a name="ln888">    read_count = lines_to_read;</a>
<a name="ln889">    conv_restlen = 0;</a>
<a name="ln890">    read_undo_file = (newfile &amp;&amp; (flags &amp; READ_KEEP_UNDO) == 0</a>
<a name="ln891">                      &amp;&amp; curbuf-&gt;b_ffname != NULL</a>
<a name="ln892">                      &amp;&amp; curbuf-&gt;b_p_udf</a>
<a name="ln893">                      &amp;&amp; !filtering</a>
<a name="ln894">                      &amp;&amp; !read_fifo</a>
<a name="ln895">                      &amp;&amp; !read_stdin</a>
<a name="ln896">                      &amp;&amp; !read_buffer);</a>
<a name="ln897">    if (read_undo_file) {</a>
<a name="ln898">      sha256_start(&amp;sha_ctx);</a>
<a name="ln899">    }</a>
<a name="ln900">  }</a>
<a name="ln901"> </a>
<a name="ln902">  while (!error &amp;&amp; !got_int) {</a>
<a name="ln903">    // We allocate as much space for the file as we can get, plus</a>
<a name="ln904">    // space for the old line plus room for one terminating NUL.</a>
<a name="ln905">    // The amount is limited by the fact that read() only can read</a>
<a name="ln906">    // up to max_unsigned characters (and other things).</a>
<a name="ln907">    {</a>
<a name="ln908">      if (!skip_read) {</a>
<a name="ln909">        // Use buffer &gt;= 64K.  Add linerest to double the size if the</a>
<a name="ln910">        // line gets very long, to avoid a lot of copying. But don't</a>
<a name="ln911">        // read more than 1 Mbyte at a time, so we can be interrupted.</a>
<a name="ln912">        size = 0x10000L + linerest;</a>
<a name="ln913">        if (size &gt; 0x100000L) {</a>
<a name="ln914">          size = 0x100000L;</a>
<a name="ln915">        }</a>
<a name="ln916">      }</a>
<a name="ln917"> </a>
<a name="ln918">      // Protect against the argument of lalloc() going negative.</a>
<a name="ln919">      if (size &lt; 0 || size + linerest + 1 &lt; 0 || linerest &gt;= MAXCOL) {</a>
<a name="ln920">        split++;</a>
<a name="ln921">        *ptr = NL;  // split line by inserting a NL</a>
<a name="ln922">        size = 1;</a>
<a name="ln923">      } else if (!skip_read) {</a>
<a name="ln924">        for (; size &gt;= 10; size /= 2) {</a>
<a name="ln925">          new_buffer = verbose_try_malloc((size_t)size + (size_t)linerest + 1);</a>
<a name="ln926">          if (new_buffer) {</a>
<a name="ln927">            break;</a>
<a name="ln928">          }</a>
<a name="ln929">        }</a>
<a name="ln930">        if (new_buffer == NULL) {</a>
<a name="ln931">          error = true;</a>
<a name="ln932">          break;</a>
<a name="ln933">        }</a>
<a name="ln934">        if (linerest) {         // copy characters from the previous buffer</a>
<a name="ln935">          memmove(new_buffer, ptr - linerest, (size_t)linerest);</a>
<a name="ln936">        }</a>
<a name="ln937">        xfree(buffer);</a>
<a name="ln938">        buffer = new_buffer;</a>
<a name="ln939">        ptr = buffer + linerest;</a>
<a name="ln940">        line_start = buffer;</a>
<a name="ln941"> </a>
<a name="ln942">        // May need room to translate into.</a>
<a name="ln943">        // For iconv() we don't really know the required space, use a</a>
<a name="ln944">        // factor ICONV_MULT.</a>
<a name="ln945">        // latin1 to utf-8: 1 byte becomes up to 2 bytes</a>
<a name="ln946">        // utf-16 to utf-8: 2 bytes become up to 3 bytes, 4 bytes</a>
<a name="ln947">        // become up to 4 bytes, size must be multiple of 2</a>
<a name="ln948">        // ucs-2 to utf-8: 2 bytes become up to 3 bytes, size must be</a>
<a name="ln949">        // multiple of 2</a>
<a name="ln950">        // ucs-4 to utf-8: 4 bytes become up to 6 bytes, size must be</a>
<a name="ln951">        // multiple of 4</a>
<a name="ln952">        real_size = (int)size;</a>
<a name="ln953">#ifdef HAVE_ICONV</a>
<a name="ln954">        if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln955">          size = size / ICONV_MULT;</a>
<a name="ln956">        } else {</a>
<a name="ln957">#endif</a>
<a name="ln958">        if (fio_flags &amp; FIO_LATIN1) {</a>
<a name="ln959">          size = size / 2;</a>
<a name="ln960">        } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln961">          size = (size * 2 / 3) &amp; ~1;</a>
<a name="ln962">        } else if (fio_flags &amp; FIO_UCS4) {</a>
<a name="ln963">          size = (size * 2 / 3) &amp; ~3;</a>
<a name="ln964">        } else if (fio_flags == FIO_UCSBOM) {</a>
<a name="ln965">          size = size / ICONV_MULT;  // worst case</a>
<a name="ln966">        }</a>
<a name="ln967">#ifdef HAVE_ICONV</a>
<a name="ln968">      }</a>
<a name="ln969">#endif</a>
<a name="ln970">        if (conv_restlen &gt; 0) {</a>
<a name="ln971">          // Insert unconverted bytes from previous line.</a>
<a name="ln972">          memmove(ptr, conv_rest, (size_t)conv_restlen);  // -V614</a>
<a name="ln973">          ptr += conv_restlen;</a>
<a name="ln974">          size -= conv_restlen;</a>
<a name="ln975">        }</a>
<a name="ln976"> </a>
<a name="ln977">        if (read_buffer) {</a>
<a name="ln978">          // Read bytes from curbuf.  Used for converting text read</a>
<a name="ln979">          // from stdin.</a>
<a name="ln980">          if (read_buf_lnum &gt; from) {</a>
<a name="ln981">            size = 0;</a>
<a name="ln982">          } else {</a>
<a name="ln983">            int n, ni;</a>
<a name="ln984">            long tlen;</a>
<a name="ln985"> </a>
<a name="ln986">            tlen = 0;</a>
<a name="ln987">            for (;;) {</a>
<a name="ln988">              p = (char_u *)ml_get(read_buf_lnum) + read_buf_col;</a>
<a name="ln989">              n = (int)STRLEN(p);</a>
<a name="ln990">              if ((int)tlen + n + 1 &gt; size) {</a>
<a name="ln991">                // Filled up to &quot;size&quot;, append partial line.</a>
<a name="ln992">                // Change NL to NUL to reverse the effect done</a>
<a name="ln993">                // below.</a>
<a name="ln994">                n = (int)(size - tlen);</a>
<a name="ln995">                for (ni = 0; ni &lt; n; ni++) {</a>
<a name="ln996">                  if (p[ni] == NL) {</a>
<a name="ln997">                    ptr[tlen++] = NUL;</a>
<a name="ln998">                  } else {</a>
<a name="ln999">                    ptr[tlen++] = (char)p[ni];</a>
<a name="ln1000">                  }</a>
<a name="ln1001">                }</a>
<a name="ln1002">                read_buf_col += n;</a>
<a name="ln1003">                break;</a>
<a name="ln1004">              }</a>
<a name="ln1005"> </a>
<a name="ln1006">              // Append whole line and new-line.  Change NL</a>
<a name="ln1007">              // to NUL to reverse the effect done below.</a>
<a name="ln1008">              for (ni = 0; ni &lt; n; ni++) {</a>
<a name="ln1009">                if (p[ni] == NL) {</a>
<a name="ln1010">                  ptr[tlen++] = NUL;</a>
<a name="ln1011">                } else {</a>
<a name="ln1012">                  ptr[tlen++] = (char)p[ni];</a>
<a name="ln1013">                }</a>
<a name="ln1014">              }</a>
<a name="ln1015">              ptr[tlen++] = NL;</a>
<a name="ln1016">              read_buf_col = 0;</a>
<a name="ln1017">              if (++read_buf_lnum &gt; from) {</a>
<a name="ln1018">                // When the last line didn't have an</a>
<a name="ln1019">                // end-of-line don't add it now either.</a>
<a name="ln1020">                if (!curbuf-&gt;b_p_eol) {</a>
<a name="ln1021">                  tlen--;</a>
<a name="ln1022">                }</a>
<a name="ln1023">                size = tlen;</a>
<a name="ln1024">                break;</a>
<a name="ln1025">              }</a>
<a name="ln1026">            }</a>
<a name="ln1027">          }</a>
<a name="ln1028">        } else {</a>
<a name="ln1029">          // Read bytes from the file.</a>
<a name="ln1030">          size = read_eintr(fd, ptr, (size_t)size);</a>
<a name="ln1031">        }</a>
<a name="ln1032"> </a>
<a name="ln1033">        if (size &lt;= 0) {</a>
<a name="ln1034">          if (size &lt; 0) {                           // read error</a>
<a name="ln1035">            error = true;</a>
<a name="ln1036">          } else if (conv_restlen &gt; 0) {</a>
<a name="ln1037">            // Reached end-of-file but some trailing bytes could</a>
<a name="ln1038">            // not be converted.  Truncated file?</a>
<a name="ln1039"> </a>
<a name="ln1040">            // When we did a conversion report an error.</a>
<a name="ln1041">            if (fio_flags != 0</a>
<a name="ln1042">#ifdef HAVE_ICONV</a>
<a name="ln1043">                || iconv_fd != (iconv_t)-1</a>
<a name="ln1044">#endif</a>
<a name="ln1045">                ) {</a>
<a name="ln1046">              if (can_retry) {</a>
<a name="ln1047">                goto rewind_retry;</a>
<a name="ln1048">              }</a>
<a name="ln1049">              if (conv_error == 0) {</a>
<a name="ln1050">                conv_error = curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln1051">                             - linecnt + 1;</a>
<a name="ln1052">              }</a>
<a name="ln1053">            } else if (illegal_byte == 0) {</a>
<a name="ln1054">              // Remember the first linenr with an illegal byte</a>
<a name="ln1055">              illegal_byte = curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln1056">                             - linecnt + 1;</a>
<a name="ln1057">            }</a>
<a name="ln1058">            if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1059">              *(ptr - conv_restlen) = NUL;</a>
<a name="ln1060">              conv_restlen = 0;</a>
<a name="ln1061">            } else {</a>
<a name="ln1062">              // Replace the trailing bytes with the replacement</a>
<a name="ln1063">              // character if we were converting; if we weren't,</a>
<a name="ln1064">              // leave the UTF8 checking code to do it, as it</a>
<a name="ln1065">              // works slightly differently.</a>
<a name="ln1066">              if (bad_char_behavior != BAD_KEEP &amp;&amp; (fio_flags != 0</a>
<a name="ln1067">#ifdef HAVE_ICONV</a>
<a name="ln1068">                                                    || iconv_fd != (iconv_t)-1</a>
<a name="ln1069">#endif</a>
<a name="ln1070">                                                    )) {  // NOLINT(whitespace/parens)</a>
<a name="ln1071">                while (conv_restlen &gt; 0) {</a>
<a name="ln1072">                  *(--ptr) = (char)bad_char_behavior;</a>
<a name="ln1073">                  conv_restlen--;</a>
<a name="ln1074">                }</a>
<a name="ln1075">              }</a>
<a name="ln1076">              fio_flags = 0;  // don't convert this</a>
<a name="ln1077">#ifdef HAVE_ICONV</a>
<a name="ln1078">              if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1079">                iconv_close(iconv_fd);</a>
<a name="ln1080">                iconv_fd = (iconv_t)-1;</a>
<a name="ln1081">              }</a>
<a name="ln1082">#endif</a>
<a name="ln1083">            }</a>
<a name="ln1084">          }</a>
<a name="ln1085">        }</a>
<a name="ln1086">      }</a>
<a name="ln1087"> </a>
<a name="ln1088">      skip_read = false;</a>
<a name="ln1089"> </a>
<a name="ln1090">      // At start of file: Check for BOM.</a>
<a name="ln1091">      // Also check for a BOM for other Unicode encodings, but not after</a>
<a name="ln1092">      // converting with 'charconvert' or when a BOM has already been</a>
<a name="ln1093">      // found.</a>
<a name="ln1094">      if ((filesize == 0)</a>
<a name="ln1095">          &amp;&amp; (fio_flags == FIO_UCSBOM</a>
<a name="ln1096">              || (!curbuf-&gt;b_p_bomb</a>
<a name="ln1097">                  &amp;&amp; tmpname == NULL</a>
<a name="ln1098">                  &amp;&amp; (*fenc == 'u' || *fenc == NUL)))) {</a>
<a name="ln1099">        char_u *ccname;</a>
<a name="ln1100">        int blen = 0;</a>
<a name="ln1101"> </a>
<a name="ln1102">        // no BOM detection in a short file or in binary mode</a>
<a name="ln1103">        if (size &lt; 2 || curbuf-&gt;b_p_bin) {</a>
<a name="ln1104">          ccname = NULL;</a>
<a name="ln1105">        } else {</a>
<a name="ln1106">          ccname = check_for_bom((char_u *)ptr, size, &amp;blen,</a>
<a name="ln1107">                                 fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags((char_u *)fenc));</a>
<a name="ln1108">        }</a>
<a name="ln1109">        if (ccname != NULL) {</a>
<a name="ln1110">          // Remove BOM from the text</a>
<a name="ln1111">          filesize += blen;</a>
<a name="ln1112">          size -= blen;</a>
<a name="ln1113">          memmove(ptr, ptr + blen, (size_t)size);</a>
<a name="ln1114">          if (set_options) {</a>
<a name="ln1115">            curbuf-&gt;b_p_bomb = true;</a>
<a name="ln1116">            curbuf-&gt;b_start_bomb = true;</a>
<a name="ln1117">          }</a>
<a name="ln1118">        }</a>
<a name="ln1119"> </a>
<a name="ln1120">        if (fio_flags == FIO_UCSBOM) {</a>
<a name="ln1121">          if (ccname == NULL) {</a>
<a name="ln1122">            // No BOM detected: retry with next encoding.</a>
<a name="ln1123">            advance_fenc = true;</a>
<a name="ln1124">          } else {</a>
<a name="ln1125">            // BOM detected: set &quot;fenc&quot; and jump back</a>
<a name="ln1126">            if (fenc_alloced) {</a>
<a name="ln1127">              xfree(fenc);</a>
<a name="ln1128">            }</a>
<a name="ln1129">            fenc = (char *)ccname;</a>
<a name="ln1130">            fenc_alloced = false;</a>
<a name="ln1131">          }</a>
<a name="ln1132">          // retry reading without getting new bytes or rewinding</a>
<a name="ln1133">          skip_read = true;</a>
<a name="ln1134">          goto retry;</a>
<a name="ln1135">        }</a>
<a name="ln1136">      }</a>
<a name="ln1137"> </a>
<a name="ln1138">      // Include not converted bytes.</a>
<a name="ln1139">      ptr -= conv_restlen;</a>
<a name="ln1140">      size += conv_restlen;</a>
<a name="ln1141">      conv_restlen = 0;</a>
<a name="ln1142">      // Break here for a read error or end-of-file.</a>
<a name="ln1143">      if (size &lt;= 0) {</a>
<a name="ln1144">        break;</a>
<a name="ln1145">      }</a>
<a name="ln1146"> </a>
<a name="ln1147">#ifdef HAVE_ICONV</a>
<a name="ln1148">      if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1149">        // Attempt conversion of the read bytes to 'encoding' using iconv().</a>
<a name="ln1150">        const char *fromp = ptr;</a>
<a name="ln1151">        size_t from_size = (size_t)size;</a>
<a name="ln1152">        ptr += size;</a>
<a name="ln1153">        char *top = ptr;</a>
<a name="ln1154">        size_t to_size = (size_t)(real_size - size);</a>
<a name="ln1155"> </a>
<a name="ln1156">        // If there is conversion error or not enough room try using</a>
<a name="ln1157">        // another conversion.  Except for when there is no</a>
<a name="ln1158">        // alternative (help files).</a>
<a name="ln1159">        while ((iconv(iconv_fd, (void *)&amp;fromp, &amp;from_size,</a>
<a name="ln1160">                      &amp;top, &amp;to_size)</a>
<a name="ln1161">                == (size_t)-1 &amp;&amp; ICONV_ERRNO != ICONV_EINVAL)</a>
<a name="ln1162">               || from_size &gt; CONV_RESTLEN) {</a>
<a name="ln1163">          if (can_retry) {</a>
<a name="ln1164">            goto rewind_retry;</a>
<a name="ln1165">          }</a>
<a name="ln1166">          if (conv_error == 0) {</a>
<a name="ln1167">            conv_error = readfile_linenr(linecnt, (char_u *)ptr, (char_u *)top);</a>
<a name="ln1168">          }</a>
<a name="ln1169"> </a>
<a name="ln1170">          // Deal with a bad byte and continue with the next.</a>
<a name="ln1171">          fromp++;</a>
<a name="ln1172">          from_size--;</a>
<a name="ln1173">          if (bad_char_behavior == BAD_KEEP) {</a>
<a name="ln1174">            *top++ = *(fromp - 1);</a>
<a name="ln1175">            to_size--;</a>
<a name="ln1176">          } else if (bad_char_behavior != BAD_DROP) {</a>
<a name="ln1177">            *top++ = (char)bad_char_behavior;</a>
<a name="ln1178">            to_size--;</a>
<a name="ln1179">          }</a>
<a name="ln1180">        }</a>
<a name="ln1181"> </a>
<a name="ln1182">        if (from_size &gt; 0) {</a>
<a name="ln1183">          // Some remaining characters, keep them for the next</a>
<a name="ln1184">          // round.</a>
<a name="ln1185">          memmove(conv_rest, (char_u *)fromp, from_size);</a>
<a name="ln1186">          conv_restlen = (int)from_size;</a>
<a name="ln1187">        }</a>
<a name="ln1188"> </a>
<a name="ln1189">        // move the linerest to before the converted characters</a>
<a name="ln1190">        line_start = ptr - linerest;</a>
<a name="ln1191">        memmove(line_start, buffer, (size_t)linerest);</a>
<a name="ln1192">        size = (top - ptr);</a>
<a name="ln1193">      }</a>
<a name="ln1194">#endif</a>
<a name="ln1195"> </a>
<a name="ln1196">      if (fio_flags != 0) {</a>
<a name="ln1197">        unsigned int u8c;</a>
<a name="ln1198">        char *dest;</a>
<a name="ln1199">        char *tail = NULL;</a>
<a name="ln1200"> </a>
<a name="ln1201">        // Convert Unicode or Latin1 to UTF-8.</a>
<a name="ln1202">        // Go from end to start through the buffer, because the number</a>
<a name="ln1203">        // of bytes may increase.</a>
<a name="ln1204">        // &quot;dest&quot; points to after where the UTF-8 bytes go, &quot;p&quot; points</a>
<a name="ln1205">        // to after the next character to convert.</a>
<a name="ln1206">        dest = ptr + real_size;</a>
<a name="ln1207">        if (fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8) {</a>
<a name="ln1208">          p = (uint8_t *)ptr + size;</a>
<a name="ln1209">          if (fio_flags == FIO_UTF8) {</a>
<a name="ln1210">            // Check for a trailing incomplete UTF-8 sequence</a>
<a name="ln1211">            tail = ptr + size - 1;</a>
<a name="ln1212">            while (tail &gt; ptr &amp;&amp; (*tail &amp; 0xc0) == 0x80) {</a>
<a name="ln1213">              tail--;</a>
<a name="ln1214">            }</a>
<a name="ln1215">            if (tail + utf_byte2len(*tail) &lt;= ptr + size) {</a>
<a name="ln1216">              tail = NULL;</a>
<a name="ln1217">            } else {</a>
<a name="ln1218">              p = (uint8_t *)tail;</a>
<a name="ln1219">            }</a>
<a name="ln1220">          }</a>
<a name="ln1221">        } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln1222">          // Check for a trailing byte</a>
<a name="ln1223">          p = (uint8_t *)ptr + (size &amp; ~1);</a>
<a name="ln1224">          if (size &amp; 1) {</a>
<a name="ln1225">            tail = (char *)p;</a>
<a name="ln1226">          }</a>
<a name="ln1227">          if ((fio_flags &amp; FIO_UTF16) &amp;&amp; p &gt; (uint8_t *)ptr) {</a>
<a name="ln1228">            // Check for a trailing leading word</a>
<a name="ln1229">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1230">              u8c = (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1231">              u8c += *--p;</a>
<a name="ln1232">            } else {</a>
<a name="ln1233">              u8c = *--p;</a>
<a name="ln1234">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1235">            }</a>
<a name="ln1236">            if (u8c &gt;= 0xd800 &amp;&amp; u8c &lt;= 0xdbff) {</a>
<a name="ln1237">              tail = (char *)p;</a>
<a name="ln1238">            } else {</a>
<a name="ln1239">              p += 2;</a>
<a name="ln1240">            }</a>
<a name="ln1241">          }</a>
<a name="ln1242">        } else {   //  FIO_UCS4</a>
<a name="ln1243">                   // Check for trailing 1, 2 or 3 bytes</a>
<a name="ln1244">          p = (uint8_t *)ptr + (size &amp; ~3);</a>
<a name="ln1245">          if (size &amp; 3) {</a>
<a name="ln1246">            tail = (char *)p;</a>
<a name="ln1247">          }</a>
<a name="ln1248">        }</a>
<a name="ln1249"> </a>
<a name="ln1250">        // If there is a trailing incomplete sequence move it to</a>
<a name="ln1251">        // conv_rest[].</a>
<a name="ln1252">        if (tail != NULL) {</a>
<a name="ln1253">          conv_restlen = (int)((ptr + size) - tail);</a>
<a name="ln1254">          memmove(conv_rest, tail, (size_t)conv_restlen);</a>
<a name="ln1255">          size -= conv_restlen;</a>
<a name="ln1256">        }</a>
<a name="ln1257"> </a>
<a name="ln1258">        while (p &gt; (uint8_t *)ptr) {</a>
<a name="ln1259">          if (fio_flags &amp; FIO_LATIN1) {</a>
<a name="ln1260">            u8c = *--p;</a>
<a name="ln1261">          } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln1262">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1263">              u8c = (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1264">              u8c += *--p;</a>
<a name="ln1265">            } else {</a>
<a name="ln1266">              u8c = *--p;</a>
<a name="ln1267">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1268">            }</a>
<a name="ln1269">            if ((fio_flags &amp; FIO_UTF16)</a>
<a name="ln1270">                &amp;&amp; u8c &gt;= 0xdc00 &amp;&amp; u8c &lt;= 0xdfff) {</a>
<a name="ln1271">              int u16c;</a>
<a name="ln1272"> </a>
<a name="ln1273">              if (p == (uint8_t *)ptr) {</a>
<a name="ln1274">                // Missing leading word.</a>
<a name="ln1275">                if (can_retry) {</a>
<a name="ln1276">                  goto rewind_retry;</a>
<a name="ln1277">                }</a>
<a name="ln1278">                if (conv_error == 0) {</a>
<a name="ln1279">                  conv_error = readfile_linenr(linecnt, (char_u *)ptr, p);</a>
<a name="ln1280">                }</a>
<a name="ln1281">                if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1282">                  continue;</a>
<a name="ln1283">                }</a>
<a name="ln1284">                if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1285">                  u8c = (unsigned)bad_char_behavior;</a>
<a name="ln1286">                }</a>
<a name="ln1287">              }</a>
<a name="ln1288"> </a>
<a name="ln1289">              // found second word of double-word, get the first</a>
<a name="ln1290">              // word and compute the resulting character</a>
<a name="ln1291">              if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1292">                u16c = (*--p &lt;&lt; 8);</a>
<a name="ln1293">                u16c += *--p;</a>
<a name="ln1294">              } else {</a>
<a name="ln1295">                u16c = *--p;</a>
<a name="ln1296">                u16c += (*--p &lt;&lt; 8);</a>
<a name="ln1297">              }</a>
<a name="ln1298">              u8c = 0x10000 + (((unsigned)u16c &amp; 0x3ff) &lt;&lt; 10)</a>
<a name="ln1299">                    + (u8c &amp; 0x3ff);</a>
<a name="ln1300"> </a>
<a name="ln1301">              // Check if the word is indeed a leading word.</a>
<a name="ln1302">              if (u16c &lt; 0xd800 || u16c &gt; 0xdbff) {</a>
<a name="ln1303">                if (can_retry) {</a>
<a name="ln1304">                  goto rewind_retry;</a>
<a name="ln1305">                }</a>
<a name="ln1306">                if (conv_error == 0) {</a>
<a name="ln1307">                  conv_error = readfile_linenr(linecnt, (char_u *)ptr, p);</a>
<a name="ln1308">                }</a>
<a name="ln1309">                if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1310">                  continue;</a>
<a name="ln1311">                }</a>
<a name="ln1312">                if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1313">                  u8c = (unsigned)bad_char_behavior;</a>
<a name="ln1314">                }</a>
<a name="ln1315">              }</a>
<a name="ln1316">            }</a>
<a name="ln1317">          } else if (fio_flags &amp; FIO_UCS4) {</a>
<a name="ln1318">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1319">              u8c = (unsigned)(*--p) &lt;&lt; 24;</a>
<a name="ln1320">              u8c += (unsigned)(*--p) &lt;&lt; 16;</a>
<a name="ln1321">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1322">              u8c += *--p;</a>
<a name="ln1323">            } else {          // big endian</a>
<a name="ln1324">              u8c = *--p;</a>
<a name="ln1325">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1326">              u8c += (unsigned)(*--p) &lt;&lt; 16;</a>
<a name="ln1327">              u8c += (unsigned)(*--p) &lt;&lt; 24;</a>
<a name="ln1328">            }</a>
<a name="ln1329">            // Replace characters over INT_MAX with Unicode replacement character</a>
<a name="ln1330">            if (u8c &gt; INT_MAX) {</a>
<a name="ln1331">              u8c = 0xfffd;</a>
<a name="ln1332">            }</a>
<a name="ln1333">          } else {        // UTF-8</a>
<a name="ln1334">            if (*--p &lt; 0x80) {</a>
<a name="ln1335">              u8c = *p;</a>
<a name="ln1336">            } else {</a>
<a name="ln1337">              len = utf_head_off(ptr, (char *)p);</a>
<a name="ln1338">              p -= len;</a>
<a name="ln1339">              u8c = (unsigned)utf_ptr2char((char *)p);</a>
<a name="ln1340">              if (len == 0) {</a>
<a name="ln1341">                // Not a valid UTF-8 character, retry with</a>
<a name="ln1342">                // another fenc when possible, otherwise just</a>
<a name="ln1343">                // report the error.</a>
<a name="ln1344">                if (can_retry) {</a>
<a name="ln1345">                  goto rewind_retry;</a>
<a name="ln1346">                }</a>
<a name="ln1347">                if (conv_error == 0) {</a>
<a name="ln1348">                  conv_error = readfile_linenr(linecnt, (char_u *)ptr, p);</a>
<a name="ln1349">                }</a>
<a name="ln1350">                if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1351">                  continue;</a>
<a name="ln1352">                }</a>
<a name="ln1353">                if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1354">                  u8c = (unsigned)bad_char_behavior;</a>
<a name="ln1355">                }</a>
<a name="ln1356">              }</a>
<a name="ln1357">            }</a>
<a name="ln1358">          }</a>
<a name="ln1359">          assert(u8c &lt;= INT_MAX);</a>
<a name="ln1360">          // produce UTF-8</a>
<a name="ln1361">          dest -= utf_char2len((int)u8c);</a>
<a name="ln1362">          (void)utf_char2bytes((int)u8c, dest);</a>
<a name="ln1363">        }</a>
<a name="ln1364"> </a>
<a name="ln1365">        // move the linerest to before the converted characters</a>
<a name="ln1366">        line_start = dest - linerest;</a>
<a name="ln1367">        memmove(line_start, buffer, (size_t)linerest);</a>
<a name="ln1368">        size = ((ptr + real_size) - dest);</a>
<a name="ln1369">        ptr = dest;</a>
<a name="ln1370">      } else if (!curbuf-&gt;b_p_bin) {</a>
<a name="ln1371">        bool incomplete_tail = false;</a>
<a name="ln1372"> </a>
<a name="ln1373">        // Reading UTF-8: Check if the bytes are valid UTF-8.</a>
<a name="ln1374">        for (p = (uint8_t *)ptr;; p++) {</a>
<a name="ln1375">          int todo = (int)(((uint8_t *)ptr + size) - p);</a>
<a name="ln1376">          int l;</a>
<a name="ln1377"> </a>
<a name="ln1378">          if (todo &lt;= 0) {</a>
<a name="ln1379">            break;</a>
<a name="ln1380">          }</a>
<a name="ln1381">          if (*p &gt;= 0x80) {</a>
<a name="ln1382">            // A length of 1 means it's an illegal byte.  Accept</a>
<a name="ln1383">            // an incomplete character at the end though, the next</a>
<a name="ln1384">            // read() will get the next bytes, we'll check it</a>
<a name="ln1385">            // then.</a>
<a name="ln1386">            l = utf_ptr2len_len(p, todo);</a>
<a name="ln1387">            if (l &gt; todo &amp;&amp; !incomplete_tail) {</a>
<a name="ln1388">              // Avoid retrying with a different encoding when</a>
<a name="ln1389">              // a truncated file is more likely, or attempting</a>
<a name="ln1390">              // to read the rest of an incomplete sequence when</a>
<a name="ln1391">              // we have already done so.</a>
<a name="ln1392">              if (p &gt; (uint8_t *)ptr || filesize &gt; 0) {</a>
<a name="ln1393">                incomplete_tail = true;</a>
<a name="ln1394">              }</a>
<a name="ln1395">              // Incomplete byte sequence, move it to conv_rest[]</a>
<a name="ln1396">              // and try to read the rest of it, unless we've</a>
<a name="ln1397">              // already done so.</a>
<a name="ln1398">              if (p &gt; (uint8_t *)ptr) {</a>
<a name="ln1399">                conv_restlen = todo;</a>
<a name="ln1400">                memmove(conv_rest, p, (size_t)conv_restlen);</a>
<a name="ln1401">                size -= conv_restlen;</a>
<a name="ln1402">                break;</a>
<a name="ln1403">              }</a>
<a name="ln1404">            }</a>
<a name="ln1405">            if (l == 1 || l &gt; todo) {</a>
<a name="ln1406">              // Illegal byte.  If we can try another encoding</a>
<a name="ln1407">              // do that, unless at EOF where a truncated</a>
<a name="ln1408">              // file is more likely than a conversion error.</a>
<a name="ln1409">              if (can_retry &amp;&amp; !incomplete_tail) {</a>
<a name="ln1410">                break;</a>
<a name="ln1411">              }</a>
<a name="ln1412">#ifdef HAVE_ICONV</a>
<a name="ln1413">              // When we did a conversion report an error.</a>
<a name="ln1414">              if (iconv_fd != (iconv_t)-1 &amp;&amp; conv_error == 0) {</a>
<a name="ln1415">                conv_error = readfile_linenr(linecnt, (char_u *)ptr, p);</a>
<a name="ln1416">              }</a>
<a name="ln1417">#endif</a>
<a name="ln1418">              // Remember the first linenr with an illegal byte</a>
<a name="ln1419">              if (conv_error == 0 &amp;&amp; illegal_byte == 0) {</a>
<a name="ln1420">                illegal_byte = readfile_linenr(linecnt, (char_u *)ptr, p);</a>
<a name="ln1421">              }</a>
<a name="ln1422"> </a>
<a name="ln1423">              // Drop, keep or replace the bad byte.</a>
<a name="ln1424">              if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1425">                memmove(p, p + 1, (size_t)(todo - 1));</a>
<a name="ln1426">                p--;</a>
<a name="ln1427">                size--;</a>
<a name="ln1428">              } else if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1429">                *p = (uint8_t)bad_char_behavior;</a>
<a name="ln1430">              }</a>
<a name="ln1431">            } else {</a>
<a name="ln1432">              p += l - 1;</a>
<a name="ln1433">            }</a>
<a name="ln1434">          }</a>
<a name="ln1435">        }</a>
<a name="ln1436">        if (p &lt; (uint8_t *)ptr + size &amp;&amp; !incomplete_tail) {</a>
<a name="ln1437">          // Detected a UTF-8 error.</a>
<a name="ln1438">rewind_retry:</a>
<a name="ln1439">          // Retry reading with another conversion.</a>
<a name="ln1440">#ifdef HAVE_ICONV</a>
<a name="ln1441">          if (*p_ccv != NUL &amp;&amp; iconv_fd != (iconv_t)-1) {</a>
<a name="ln1442">            // iconv() failed, try 'charconvert'</a>
<a name="ln1443">            did_iconv = true;</a>
<a name="ln1444">          } else {</a>
<a name="ln1445">#endif</a>
<a name="ln1446">          // use next item from 'fileencodings'</a>
<a name="ln1447">          advance_fenc = true;</a>
<a name="ln1448">#ifdef HAVE_ICONV</a>
<a name="ln1449">        }</a>
<a name="ln1450">#endif</a>
<a name="ln1451">          file_rewind = true;</a>
<a name="ln1452">          goto retry;</a>
<a name="ln1453">        }</a>
<a name="ln1454">      }</a>
<a name="ln1455"> </a>
<a name="ln1456">      // count the number of characters (after conversion!)</a>
<a name="ln1457">      filesize += size;</a>
<a name="ln1458"> </a>
<a name="ln1459">      // when reading the first part of a file: guess EOL type</a>
<a name="ln1460">      if (fileformat == EOL_UNKNOWN) {</a>
<a name="ln1461">        // First try finding a NL, for Dos and Unix</a>
<a name="ln1462">        if (try_dos || try_unix) {</a>
<a name="ln1463">          // Reset the carriage return counter.</a>
<a name="ln1464">          if (try_mac) {</a>
<a name="ln1465">            try_mac = 1;</a>
<a name="ln1466">          }</a>
<a name="ln1467"> </a>
<a name="ln1468">          for (p = (uint8_t *)ptr; p &lt; (uint8_t *)ptr + size; p++) {</a>
<a name="ln1469">            if (*p == NL) {</a>
<a name="ln1470">              if (!try_unix</a>
<a name="ln1471">                  || (try_dos &amp;&amp; p &gt; (uint8_t *)ptr &amp;&amp; p[-1] == CAR)) {</a>
<a name="ln1472">                fileformat = EOL_DOS;</a>
<a name="ln1473">              } else {</a>
<a name="ln1474">                fileformat = EOL_UNIX;</a>
<a name="ln1475">              }</a>
<a name="ln1476">              break;</a>
<a name="ln1477">            } else if (*p == CAR &amp;&amp; try_mac) {</a>
<a name="ln1478">              try_mac++;</a>
<a name="ln1479">            }</a>
<a name="ln1480">          }</a>
<a name="ln1481"> </a>
<a name="ln1482">          // Don't give in to EOL_UNIX if EOL_MAC is more likely</a>
<a name="ln1483">          if (fileformat == EOL_UNIX &amp;&amp; try_mac) {</a>
<a name="ln1484">            // Need to reset the counters when retrying fenc.</a>
<a name="ln1485">            try_mac = 1;</a>
<a name="ln1486">            try_unix = 1;</a>
<a name="ln1487">            for (; p &gt;= (uint8_t *)ptr &amp;&amp; *p != CAR; p--) {}</a>
<a name="ln1488">            if (p &gt;= (uint8_t *)ptr) {</a>
<a name="ln1489">              for (p = (uint8_t *)ptr; p &lt; (uint8_t *)ptr + size; p++) {</a>
<a name="ln1490">                if (*p == NL) {</a>
<a name="ln1491">                  try_unix++;</a>
<a name="ln1492">                } else if (*p == CAR) {</a>
<a name="ln1493">                  try_mac++;</a>
<a name="ln1494">                }</a>
<a name="ln1495">              }</a>
<a name="ln1496">              if (try_mac &gt; try_unix) {</a>
<a name="ln1497">                fileformat = EOL_MAC;</a>
<a name="ln1498">              }</a>
<a name="ln1499">            }</a>
<a name="ln1500">          } else if (fileformat == EOL_UNKNOWN &amp;&amp; try_mac == 1) {</a>
<a name="ln1501">            // Looking for CR but found no end-of-line markers at all:</a>
<a name="ln1502">            // use the default format.</a>
<a name="ln1503">            fileformat = default_fileformat();</a>
<a name="ln1504">          }</a>
<a name="ln1505">        }</a>
<a name="ln1506"> </a>
<a name="ln1507">        // No NL found: may use Mac format</a>
<a name="ln1508">        if (fileformat == EOL_UNKNOWN &amp;&amp; try_mac) {</a>
<a name="ln1509">          fileformat = EOL_MAC;</a>
<a name="ln1510">        }</a>
<a name="ln1511"> </a>
<a name="ln1512">        // Still nothing found?  Use first format in 'ffs'</a>
<a name="ln1513">        if (fileformat == EOL_UNKNOWN) {</a>
<a name="ln1514">          fileformat = default_fileformat();</a>
<a name="ln1515">        }</a>
<a name="ln1516"> </a>
<a name="ln1517">        // May set 'p_ff' if editing a new file.</a>
<a name="ln1518">        if (set_options) {</a>
<a name="ln1519">          set_fileformat(fileformat, OPT_LOCAL);</a>
<a name="ln1520">        }</a>
<a name="ln1521">      }</a>
<a name="ln1522">    }</a>
<a name="ln1523"> </a>
<a name="ln1524">    // This loop is executed once for every character read.</a>
<a name="ln1525">    // Keep it fast!</a>
<a name="ln1526">    if (fileformat == EOL_MAC) {</a>
<a name="ln1527">      ptr--;</a>
<a name="ln1528">      while (++ptr, --size &gt;= 0) {</a>
<a name="ln1529">        // catch most common case first</a>
<a name="ln1530">        if ((c = *ptr) != NUL &amp;&amp; c != CAR &amp;&amp; c != NL) {</a>
<a name="ln1531">          continue;</a>
<a name="ln1532">        }</a>
<a name="ln1533">        if (c == NUL) {</a>
<a name="ln1534">          *ptr = NL;            // NULs are replaced by newlines!</a>
<a name="ln1535">        } else if (c == NL) {</a>
<a name="ln1536">          *ptr = CAR;           // NLs are replaced by CRs!</a>
<a name="ln1537">        } else {</a>
<a name="ln1538">          if (skip_count == 0) {</a>
<a name="ln1539">            *ptr = NUL;                     // end of line</a>
<a name="ln1540">            len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1541">            if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1542">              error = true;</a>
<a name="ln1543">              break;</a>
<a name="ln1544">            }</a>
<a name="ln1545">            if (read_undo_file) {</a>
<a name="ln1546">              sha256_update(&amp;sha_ctx, (char_u *)line_start, (size_t)len);</a>
<a name="ln1547">            }</a>
<a name="ln1548">            lnum++;</a>
<a name="ln1549">            if (--read_count == 0) {</a>
<a name="ln1550">              error = true;                     // break loop</a>
<a name="ln1551">              line_start = ptr;                 // nothing left to write</a>
<a name="ln1552">              break;</a>
<a name="ln1553">            }</a>
<a name="ln1554">          } else {</a>
<a name="ln1555">            skip_count--;</a>
<a name="ln1556">          }</a>
<a name="ln1557">          line_start = ptr + 1;</a>
<a name="ln1558">        }</a>
<a name="ln1559">      }</a>
<a name="ln1560">    } else {</a>
<a name="ln1561">      ptr--;</a>
<a name="ln1562">      while (++ptr, --size &gt;= 0) {</a>
<a name="ln1563">        if ((c = *ptr) != NUL &amp;&amp; c != NL) {        // catch most common case</a>
<a name="ln1564">          continue;</a>
<a name="ln1565">        }</a>
<a name="ln1566">        if (c == NUL) {</a>
<a name="ln1567">          *ptr = NL;            // NULs are replaced by newlines!</a>
<a name="ln1568">        } else {</a>
<a name="ln1569">          if (skip_count == 0) {</a>
<a name="ln1570">            *ptr = NUL;                         // end of line</a>
<a name="ln1571">            len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1572">            if (fileformat == EOL_DOS) {</a>
<a name="ln1573">              if (ptr &gt; line_start &amp;&amp; ptr[-1] == CAR) {</a>
<a name="ln1574">                // remove CR before NL</a>
<a name="ln1575">                ptr[-1] = NUL;</a>
<a name="ln1576">                len--;</a>
<a name="ln1577">              } else if (ff_error != EOL_DOS) {</a>
<a name="ln1578">                // Reading in Dos format, but no CR-LF found!</a>
<a name="ln1579">                // When 'fileformats' includes &quot;unix&quot;, delete all</a>
<a name="ln1580">                // the lines read so far and start all over again.</a>
<a name="ln1581">                // Otherwise give an error message later.</a>
<a name="ln1582">                if (try_unix</a>
<a name="ln1583">                    &amp;&amp; !read_stdin</a>
<a name="ln1584">                    &amp;&amp; (read_buffer</a>
<a name="ln1585">                        || vim_lseek(fd, (off_T)0L, SEEK_SET) == 0)) {</a>
<a name="ln1586">                  fileformat = EOL_UNIX;</a>
<a name="ln1587">                  if (set_options) {</a>
<a name="ln1588">                    set_fileformat(EOL_UNIX, OPT_LOCAL);</a>
<a name="ln1589">                  }</a>
<a name="ln1590">                  file_rewind = true;</a>
<a name="ln1591">                  keep_fileformat = true;</a>
<a name="ln1592">                  goto retry;</a>
<a name="ln1593">                }</a>
<a name="ln1594">                ff_error = EOL_DOS;</a>
<a name="ln1595">              }</a>
<a name="ln1596">            }</a>
<a name="ln1597">            if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1598">              error = true;</a>
<a name="ln1599">              break;</a>
<a name="ln1600">            }</a>
<a name="ln1601">            if (read_undo_file) {</a>
<a name="ln1602">              sha256_update(&amp;sha_ctx, (char_u *)line_start, (size_t)len);</a>
<a name="ln1603">            }</a>
<a name="ln1604">            lnum++;</a>
<a name="ln1605">            if (--read_count == 0) {</a>
<a name="ln1606">              error = true;                         // break loop</a>
<a name="ln1607">              line_start = ptr;                 // nothing left to write</a>
<a name="ln1608">              break;</a>
<a name="ln1609">            }</a>
<a name="ln1610">          } else {</a>
<a name="ln1611">            skip_count--;</a>
<a name="ln1612">          }</a>
<a name="ln1613">          line_start = ptr + 1;</a>
<a name="ln1614">        }</a>
<a name="ln1615">      }</a>
<a name="ln1616">    }</a>
<a name="ln1617">    linerest = (ptr - line_start);</a>
<a name="ln1618">    os_breakcheck();</a>
<a name="ln1619">  }</a>
<a name="ln1620"> </a>
<a name="ln1621">failed:</a>
<a name="ln1622">  // not an error, max. number of lines reached</a>
<a name="ln1623">  if (error &amp;&amp; read_count == 0) {</a>
<a name="ln1624">    error = false;</a>
<a name="ln1625">  }</a>
<a name="ln1626"> </a>
<a name="ln1627">  // If we get EOF in the middle of a line, note the fact and</a>
<a name="ln1628">  // complete the line ourselves.</a>
<a name="ln1629">  // In Dos format ignore a trailing CTRL-Z, unless 'binary' set.</a>
<a name="ln1630">  if (!error</a>
<a name="ln1631">      &amp;&amp; !got_int</a>
<a name="ln1632">      &amp;&amp; linerest != 0</a>
<a name="ln1633">      // TODO(vim): should we handle CTRL-Z differently here for 'endoffile'?</a>
<a name="ln1634">      &amp;&amp; !(!curbuf-&gt;b_p_bin</a>
<a name="ln1635">           &amp;&amp; fileformat == EOL_DOS</a>
<a name="ln1636">           &amp;&amp; *line_start == Ctrl_Z</a>
<a name="ln1637">           &amp;&amp; ptr == line_start + 1)) {</a>
<a name="ln1638">    // remember for when writing</a>
<a name="ln1639">    if (set_options) {</a>
<a name="ln1640">      curbuf-&gt;b_p_eol = false;</a>
<a name="ln1641">      if (*line_start == Ctrl_Z &amp;&amp; ptr == line_start + 1) {</a>
<a name="ln1642">        curbuf-&gt;b_p_eof = true;</a>
<a name="ln1643">      }</a>
<a name="ln1644">    }</a>
<a name="ln1645">    *ptr = NUL;</a>
<a name="ln1646">    len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1647">    if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1648">      error = true;</a>
<a name="ln1649">    } else {</a>
<a name="ln1650">      if (read_undo_file) {</a>
<a name="ln1651">        sha256_update(&amp;sha_ctx, (char_u *)line_start, (size_t)len);</a>
<a name="ln1652">      }</a>
<a name="ln1653">      read_no_eol_lnum = ++lnum;</a>
<a name="ln1654">    }</a>
<a name="ln1655">  }</a>
<a name="ln1656"> </a>
<a name="ln1657">  if (set_options) {</a>
<a name="ln1658">    // Remember the current file format.</a>
<a name="ln1659">    save_file_ff(curbuf);</a>
<a name="ln1660">    // If editing a new file: set 'fenc' for the current buffer.</a>
<a name="ln1661">    // Also for &quot;:read ++edit file&quot;.</a>
<a name="ln1662">    set_string_option_direct(&quot;fenc&quot;, -1, fenc, OPT_FREE | OPT_LOCAL, 0);</a>
<a name="ln1663">  }</a>
<a name="ln1664">  if (fenc_alloced) {</a>
<a name="ln1665">    xfree(fenc);</a>
<a name="ln1666">  }</a>
<a name="ln1667">#ifdef HAVE_ICONV</a>
<a name="ln1668">  if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1669">    iconv_close(iconv_fd);</a>
<a name="ln1670">  }</a>
<a name="ln1671">#endif</a>
<a name="ln1672"> </a>
<a name="ln1673">  if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln1674">    close(fd);  // errors are ignored</a>
<a name="ln1675">  } else {</a>
<a name="ln1676">    (void)os_set_cloexec(fd);</a>
<a name="ln1677">  }</a>
<a name="ln1678">  xfree(buffer);</a>
<a name="ln1679"> </a>
<a name="ln1680">  if (read_stdin) {</a>
<a name="ln1681">    close(fd);</a>
<a name="ln1682">    if (stdin_fd &lt; 0) {</a>
<a name="ln1683">#ifndef MSWIN</a>
<a name="ln1684">      // On Unix, use stderr for stdin, makes shell commands work.</a>
<a name="ln1685">      vim_ignored = dup(2);</a>
<a name="ln1686">#else</a>
<a name="ln1687">      // On Windows, use the console input handle for stdin.</a>
<a name="ln1688">      HANDLE conin = CreateFile(&quot;CONIN$&quot;, GENERIC_READ | GENERIC_WRITE,</a>
<a name="ln1689">                                FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)NULL,</a>
<a name="ln1690">                                OPEN_EXISTING, 0, (HANDLE)NULL);</a>
<a name="ln1691">      vim_ignored = _open_osfhandle((intptr_t)conin, _O_RDONLY);</a>
<a name="ln1692">#endif</a>
<a name="ln1693">    }</a>
<a name="ln1694">  }</a>
<a name="ln1695"> </a>
<a name="ln1696">  if (tmpname != NULL) {</a>
<a name="ln1697">    os_remove(tmpname);  // delete converted file</a>
<a name="ln1698">    xfree(tmpname);</a>
<a name="ln1699">  }</a>
<a name="ln1700">  no_wait_return--;                     // may wait for return now</a>
<a name="ln1701"> </a>
<a name="ln1702">  // In recovery mode everything but autocommands is skipped.</a>
<a name="ln1703">  if (!recoverymode) {</a>
<a name="ln1704">    // need to delete the last line, which comes from the empty buffer</a>
<a name="ln1705">    if (newfile &amp;&amp; wasempty &amp;&amp; !(curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)) {</a>
<a name="ln1706">      ml_delete(curbuf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln1707">      linecnt--;</a>
<a name="ln1708">    }</a>
<a name="ln1709">    curbuf-&gt;deleted_bytes = 0;</a>
<a name="ln1710">    curbuf-&gt;deleted_bytes2 = 0;</a>
<a name="ln1711">    curbuf-&gt;deleted_codepoints = 0;</a>
<a name="ln1712">    curbuf-&gt;deleted_codeunits = 0;</a>
<a name="ln1713">    linecnt = curbuf-&gt;b_ml.ml_line_count - linecnt;</a>
<a name="ln1714">    if (filesize == 0) {</a>
<a name="ln1715">      linecnt = 0;</a>
<a name="ln1716">    }</a>
<a name="ln1717">    if (newfile || read_buffer) {</a>
<a name="ln1718">      redraw_curbuf_later(UPD_NOT_VALID);</a>
<a name="ln1719">      // After reading the text into the buffer the diff info needs to</a>
<a name="ln1720">      // be updated.</a>
<a name="ln1721">      diff_invalidate(curbuf);</a>
<a name="ln1722">      // All folds in the window are invalid now.  Mark them for update</a>
<a name="ln1723">      // before triggering autocommands.</a>
<a name="ln1724">      foldUpdateAll(curwin);</a>
<a name="ln1725">    } else if (linecnt) {               // appended at least one line</a>
<a name="ln1726">      appended_lines_mark(from, linecnt);</a>
<a name="ln1727">    }</a>
<a name="ln1728"> </a>
<a name="ln1729">    if (got_int) {</a>
<a name="ln1730">      if (!(flags &amp; READ_DUMMY)) {</a>
<a name="ln1731">        filemess(curbuf, sfname, _(e_interr), 0);</a>
<a name="ln1732">        if (newfile) {</a>
<a name="ln1733">          curbuf-&gt;b_p_ro = true;                // must use &quot;w!&quot; now</a>
<a name="ln1734">        }</a>
<a name="ln1735">      }</a>
<a name="ln1736">      msg_scroll = msg_save;</a>
<a name="ln1737">      check_marks_read();</a>
<a name="ln1738">      return OK;                // an interrupt isn't really an error</a>
<a name="ln1739">    }</a>
<a name="ln1740"> </a>
<a name="ln1741">    if (!filtering &amp;&amp; !(flags &amp; READ_DUMMY) &amp;&amp; !silent) {</a>
<a name="ln1742">      add_quoted_fname((char *)IObuff, IOSIZE, curbuf, (const char *)sfname);</a>
<a name="ln1743">      c = false;</a>
<a name="ln1744"> </a>
<a name="ln1745">#ifdef UNIX</a>
<a name="ln1746">      if (S_ISFIFO(perm)) {             // fifo</a>
<a name="ln1747">        STRCAT(IObuff, _(&quot;[fifo]&quot;));</a>
<a name="ln1748">        c = true;</a>
<a name="ln1749">      }</a>
<a name="ln1750">      if (S_ISSOCK(perm)) {            // or socket</a>
<a name="ln1751">        STRCAT(IObuff, _(&quot;[socket]&quot;));</a>
<a name="ln1752">        c = true;</a>
<a name="ln1753">      }</a>
<a name="ln1754"># ifdef OPEN_CHR_FILES</a>
<a name="ln1755">      if (S_ISCHR(perm)) {                          // or character special</a>
<a name="ln1756">        STRCAT(IObuff, _(&quot;[character special]&quot;));</a>
<a name="ln1757">        c = true;</a>
<a name="ln1758">      }</a>
<a name="ln1759"># endif</a>
<a name="ln1760">#endif</a>
<a name="ln1761">      if (curbuf-&gt;b_p_ro) {</a>
<a name="ln1762">        STRCAT(IObuff, shortmess(SHM_RO) ? _(&quot;[RO]&quot;) : _(&quot;[readonly]&quot;));</a>
<a name="ln1763">        c = true;</a>
<a name="ln1764">      }</a>
<a name="ln1765">      if (read_no_eol_lnum) {</a>
<a name="ln1766">        msg_add_eol();</a>
<a name="ln1767">        c = true;</a>
<a name="ln1768">      }</a>
<a name="ln1769">      if (ff_error == EOL_DOS) {</a>
<a name="ln1770">        STRCAT(IObuff, _(&quot;[CR missing]&quot;));</a>
<a name="ln1771">        c = true;</a>
<a name="ln1772">      }</a>
<a name="ln1773">      if (split) {</a>
<a name="ln1774">        STRCAT(IObuff, _(&quot;[long lines split]&quot;));</a>
<a name="ln1775">        c = true;</a>
<a name="ln1776">      }</a>
<a name="ln1777">      if (notconverted) {</a>
<a name="ln1778">        STRCAT(IObuff, _(&quot;[NOT converted]&quot;));</a>
<a name="ln1779">        c = true;</a>
<a name="ln1780">      } else if (converted) {</a>
<a name="ln1781">        STRCAT(IObuff, _(&quot;[converted]&quot;));</a>
<a name="ln1782">        c = true;</a>
<a name="ln1783">      }</a>
<a name="ln1784">      if (conv_error != 0) {</a>
<a name="ln1785">        snprintf(IObuff + strlen(IObuff), IOSIZE - strlen(IObuff),</a>
<a name="ln1786">                 _(&quot;[CONVERSION ERROR in line %&quot; PRId64 &quot;]&quot;), (int64_t)conv_error);</a>
<a name="ln1787">        c = true;</a>
<a name="ln1788">      } else if (illegal_byte &gt; 0) {</a>
<a name="ln1789">        snprintf(IObuff + strlen(IObuff), IOSIZE - strlen(IObuff),</a>
<a name="ln1790">                 _(&quot;[ILLEGAL BYTE in line %&quot; PRId64 &quot;]&quot;), (int64_t)illegal_byte);</a>
<a name="ln1791">        c = true;</a>
<a name="ln1792">      } else if (error) {</a>
<a name="ln1793">        STRCAT(IObuff, _(&quot;[READ ERRORS]&quot;));</a>
<a name="ln1794">        c = true;</a>
<a name="ln1795">      }</a>
<a name="ln1796">      if (msg_add_fileformat(fileformat)) {</a>
<a name="ln1797">        c = true;</a>
<a name="ln1798">      }</a>
<a name="ln1799"> </a>
<a name="ln1800">      msg_add_lines(c, (long)linecnt, filesize);</a>
<a name="ln1801"> </a>
<a name="ln1802">      XFREE_CLEAR(keep_msg);</a>
<a name="ln1803">      p = NULL;</a>
<a name="ln1804">      msg_scrolled_ign = true;</a>
<a name="ln1805"> </a>
<a name="ln1806">      if (!read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln1807">        p = (char_u *)msg_trunc_attr((char *)IObuff, false, 0);</a>
<a name="ln1808">      }</a>
<a name="ln1809"> </a>
<a name="ln1810">      if (read_stdin || read_buffer || restart_edit != 0</a>
<a name="ln1811">          || (msg_scrolled != 0 &amp;&amp; !need_wait_return)) {</a>
<a name="ln1812">        // Need to repeat the message after redrawing when:</a>
<a name="ln1813">        // - When reading from stdin (the screen will be cleared next).</a>
<a name="ln1814">        // - When restart_edit is set (otherwise there will be a delay before</a>
<a name="ln1815">        //   redrawing).</a>
<a name="ln1816">        // - When the screen was scrolled but there is no wait-return prompt.</a>
<a name="ln1817">        set_keep_msg((char *)p, 0);</a>
<a name="ln1818">      }</a>
<a name="ln1819">      msg_scrolled_ign = false;</a>
<a name="ln1820">    }</a>
<a name="ln1821"> </a>
<a name="ln1822">    // with errors writing the file requires &quot;:w!&quot;</a>
<a name="ln1823">    if (newfile &amp;&amp; (error</a>
<a name="ln1824">                    || conv_error != 0</a>
<a name="ln1825">                    || (illegal_byte &gt; 0 &amp;&amp; bad_char_behavior != BAD_KEEP))) {</a>
<a name="ln1826">      curbuf-&gt;b_p_ro = true;</a>
<a name="ln1827">    }</a>
<a name="ln1828"> </a>
<a name="ln1829">    u_clearline();          // cannot use &quot;U&quot; command after adding lines</a>
<a name="ln1830"> </a>
<a name="ln1831">    // In Ex mode: cursor at last new line.</a>
<a name="ln1832">    // Otherwise: cursor at first new line.</a>
<a name="ln1833">    if (exmode_active) {</a>
<a name="ln1834">      curwin-&gt;w_cursor.lnum = from + linecnt;</a>
<a name="ln1835">    } else {</a>
<a name="ln1836">      curwin-&gt;w_cursor.lnum = from + 1;</a>
<a name="ln1837">    }</a>
<a name="ln1838">    check_cursor_lnum();</a>
<a name="ln1839">    beginline(BL_WHITE | BL_FIX);           // on first non-blank</a>
<a name="ln1840"> </a>
<a name="ln1841">    if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln1842">      // Set '[ and '] marks to the newly read lines.</a>
<a name="ln1843">      curbuf-&gt;b_op_start.lnum = from + 1;</a>
<a name="ln1844">      curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln1845">      curbuf-&gt;b_op_end.lnum = from + linecnt;</a>
<a name="ln1846">      curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln1847">    }</a>
<a name="ln1848">  }</a>
<a name="ln1849">  msg_scroll = msg_save;</a>
<a name="ln1850"> </a>
<a name="ln1851">  // Get the marks before executing autocommands, so they can be used there.</a>
<a name="ln1852">  check_marks_read();</a>
<a name="ln1853"> </a>
<a name="ln1854">  // We remember if the last line of the read didn't have</a>
<a name="ln1855">  // an eol even when 'binary' is off, to support turning 'fixeol' off,</a>
<a name="ln1856">  // or writing the read again with 'binary' on.  The latter is required</a>
<a name="ln1857">  // for &quot;:autocmd FileReadPost *.gz set bin|'[,']!gunzip&quot; to work.</a>
<a name="ln1858">  curbuf-&gt;b_no_eol_lnum = read_no_eol_lnum;</a>
<a name="ln1859"> </a>
<a name="ln1860">  // When reloading a buffer put the cursor at the first line that is</a>
<a name="ln1861">  // different.</a>
<a name="ln1862">  if (flags &amp; READ_KEEP_UNDO) {</a>
<a name="ln1863">    u_find_first_changed();</a>
<a name="ln1864">  }</a>
<a name="ln1865"> </a>
<a name="ln1866">  // When opening a new file locate undo info and read it.</a>
<a name="ln1867">  if (read_undo_file) {</a>
<a name="ln1868">    char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln1869"> </a>
<a name="ln1870">    sha256_finish(&amp;sha_ctx, hash);</a>
<a name="ln1871">    u_read_undo(NULL, hash, (char_u *)fname);</a>
<a name="ln1872">  }</a>
<a name="ln1873"> </a>
<a name="ln1874">  if (!read_stdin &amp;&amp; !read_fifo &amp;&amp; (!read_buffer || sfname != NULL)) {</a>
<a name="ln1875">    int m = msg_scroll;</a>
<a name="ln1876">    int n = msg_scrolled;</a>
<a name="ln1877"> </a>
<a name="ln1878">    // Save the fileformat now, otherwise the buffer will be considered</a>
<a name="ln1879">    // modified if the format/encoding was automatically detected.</a>
<a name="ln1880">    if (set_options) {</a>
<a name="ln1881">      save_file_ff(curbuf);</a>
<a name="ln1882">    }</a>
<a name="ln1883"> </a>
<a name="ln1884">    // The output from the autocommands should not overwrite anything and</a>
<a name="ln1885">    // should not be overwritten: Set msg_scroll, restore its value if no</a>
<a name="ln1886">    // output was done.</a>
<a name="ln1887">    msg_scroll = true;</a>
<a name="ln1888">    if (filtering) {</a>
<a name="ln1889">      apply_autocmds_exarg(EVENT_FILTERREADPOST, NULL, sfname,</a>
<a name="ln1890">                           false, curbuf, eap);</a>
<a name="ln1891">    } else if (newfile || (read_buffer &amp;&amp; sfname != NULL)) {</a>
<a name="ln1892">      apply_autocmds_exarg(EVENT_BUFREADPOST, NULL, sfname,</a>
<a name="ln1893">                           false, curbuf, eap);</a>
<a name="ln1894">      if (!au_did_filetype &amp;&amp; *curbuf-&gt;b_p_ft != NUL) {</a>
<a name="ln1895">        // EVENT_FILETYPE was not triggered but the buffer already has a</a>
<a name="ln1896">        // filetype.  Trigger EVENT_FILETYPE using the existing filetype.</a>
<a name="ln1897">        apply_autocmds(EVENT_FILETYPE, curbuf-&gt;b_p_ft, curbuf-&gt;b_fname, true, curbuf);</a>
<a name="ln1898">      }</a>
<a name="ln1899">    } else {</a>
<a name="ln1900">      apply_autocmds_exarg(EVENT_FILEREADPOST, sfname, sfname,</a>
<a name="ln1901">                           false, NULL, eap);</a>
<a name="ln1902">    }</a>
<a name="ln1903">    if (msg_scrolled == n) {</a>
<a name="ln1904">      msg_scroll = m;</a>
<a name="ln1905">    }</a>
<a name="ln1906">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln1907">      return FAIL;</a>
<a name="ln1908">    }</a>
<a name="ln1909">  }</a>
<a name="ln1910"> </a>
<a name="ln1911">  if (recoverymode &amp;&amp; error) {</a>
<a name="ln1912">    return FAIL;</a>
<a name="ln1913">  }</a>
<a name="ln1914">  return OK;</a>
<a name="ln1915">}</a>
<a name="ln1916"> </a>
<a name="ln1917">#ifdef OPEN_CHR_FILES</a>
<a name="ln1918">/// Returns true if the file name argument is of the form &quot;/dev/fd/\d\+&quot;,</a>
<a name="ln1919">/// which is the name of files used for process substitution output by</a>
<a name="ln1920">/// some shells on some operating systems, e.g., bash on SunOS.</a>
<a name="ln1921">/// Do not accept &quot;/dev/fd/[012]&quot;, opening these may hang Vim.</a>
<a name="ln1922">///</a>
<a name="ln1923">/// @param fname file name to check</a>
<a name="ln1924">bool is_dev_fd_file(char *fname)</a>
<a name="ln1925">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1926">{</a>
<a name="ln1927">  return STRNCMP(fname, &quot;/dev/fd/&quot;, 8) == 0</a>
<a name="ln1928">         &amp;&amp; ascii_isdigit((uint8_t)fname[8])</a>
<a name="ln1929">         &amp;&amp; *skipdigits(fname + 9) == NUL</a>
<a name="ln1930">         &amp;&amp; (fname[9] != NUL</a>
<a name="ln1931">             || (fname[8] != '0' &amp;&amp; fname[8] != '1' &amp;&amp; fname[8] != '2'));</a>
<a name="ln1932">}</a>
<a name="ln1933">#endif</a>
<a name="ln1934"> </a>
<a name="ln1935">/// From the current line count and characters read after that, estimate the</a>
<a name="ln1936">/// line number where we are now.</a>
<a name="ln1937">/// Used for error messages that include a line number.</a>
<a name="ln1938">///</a>
<a name="ln1939">/// @param linecnt  line count before reading more bytes</a>
<a name="ln1940">/// @param p        start of more bytes read</a>
<a name="ln1941">/// @param endp     end of more bytes read</a>
<a name="ln1942">static linenr_T readfile_linenr(linenr_T linecnt, char_u *p, const char_u *endp)</a>
<a name="ln1943">{</a>
<a name="ln1944">  char_u *s;</a>
<a name="ln1945">  linenr_T lnum;</a>
<a name="ln1946"> </a>
<a name="ln1947">  lnum = curbuf-&gt;b_ml.ml_line_count - linecnt + 1;</a>
<a name="ln1948">  for (s = p; s &lt; endp; s++) {</a>
<a name="ln1949">    if (*s == '\n') {</a>
<a name="ln1950">      lnum++;</a>
<a name="ln1951">    }</a>
<a name="ln1952">  }</a>
<a name="ln1953">  return lnum;</a>
<a name="ln1954">}</a>
<a name="ln1955"> </a>
<a name="ln1956">/// Fill &quot;*eap&quot; to force the 'fileencoding', 'fileformat' and 'binary' to be</a>
<a name="ln1957">/// equal to the buffer &quot;buf&quot;.  Used for calling readfile().</a>
<a name="ln1958">void prep_exarg(exarg_T *eap, const buf_T *buf)</a>
<a name="ln1959">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1960">{</a>
<a name="ln1961">  const size_t cmd_len = 15 + strlen(buf-&gt;b_p_fenc);</a>
<a name="ln1962">  eap-&gt;cmd = xmalloc(cmd_len);</a>
<a name="ln1963"> </a>
<a name="ln1964">  snprintf(eap-&gt;cmd, cmd_len, &quot;e ++enc=%s&quot;, buf-&gt;b_p_fenc);</a>
<a name="ln1965">  eap-&gt;force_enc = 8;</a>
<a name="ln1966">  eap-&gt;bad_char = buf-&gt;b_bad_char;</a>
<a name="ln1967">  eap-&gt;force_ff = (unsigned char)(*buf-&gt;b_p_ff);</a>
<a name="ln1968"> </a>
<a name="ln1969">  eap-&gt;force_bin = buf-&gt;b_p_bin ? FORCE_BIN : FORCE_NOBIN;</a>
<a name="ln1970">  eap-&gt;read_edit = false;</a>
<a name="ln1971">  eap-&gt;forceit = false;</a>
<a name="ln1972">}</a>
<a name="ln1973"> </a>
<a name="ln1974">/// Set default or forced 'fileformat' and 'binary'.</a>
<a name="ln1975">void set_file_options(int set_options, exarg_T *eap)</a>
<a name="ln1976">{</a>
<a name="ln1977">  // set default 'fileformat'</a>
<a name="ln1978">  if (set_options) {</a>
<a name="ln1979">    if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln1980">      set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);</a>
<a name="ln1981">    } else if (*p_ffs != NUL) {</a>
<a name="ln1982">      set_fileformat(default_fileformat(), OPT_LOCAL);</a>
<a name="ln1983">    }</a>
<a name="ln1984">  }</a>
<a name="ln1985"> </a>
<a name="ln1986">  // set or reset 'binary'</a>
<a name="ln1987">  if (eap != NULL &amp;&amp; eap-&gt;force_bin != 0) {</a>
<a name="ln1988">    int oldval = curbuf-&gt;b_p_bin;</a>
<a name="ln1989"> </a>
<a name="ln1990">    curbuf-&gt;b_p_bin = (eap-&gt;force_bin == FORCE_BIN);</a>
<a name="ln1991">    set_options_bin(oldval, curbuf-&gt;b_p_bin, OPT_LOCAL);</a>
<a name="ln1992">  }</a>
<a name="ln1993">}</a>
<a name="ln1994"> </a>
<a name="ln1995">/// Set forced 'fileencoding'.</a>
<a name="ln1996">void set_forced_fenc(exarg_T *eap)</a>
<a name="ln1997">{</a>
<a name="ln1998">  if (eap-&gt;force_enc != 0) {</a>
<a name="ln1999">    char *fenc = enc_canonize(eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln2000">    set_string_option_direct(&quot;fenc&quot;, -1, fenc, OPT_FREE|OPT_LOCAL, 0);</a>
<a name="ln2001">    xfree(fenc);</a>
<a name="ln2002">  }</a>
<a name="ln2003">}</a>
<a name="ln2004"> </a>
<a name="ln2005">/// Find next fileencoding to use from 'fileencodings'.</a>
<a name="ln2006">/// &quot;pp&quot; points to fenc_next.  It's advanced to the next item.</a>
<a name="ln2007">/// When there are no more items, an empty string is returned and *pp is set to</a>
<a name="ln2008">/// NULL.</a>
<a name="ln2009">/// When *pp is not set to NULL, the result is in allocated memory and &quot;alloced&quot;</a>
<a name="ln2010">/// is set to true.</a>
<a name="ln2011">static char *next_fenc(char **pp, bool *alloced)</a>
<a name="ln2012">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln2013">{</a>
<a name="ln2014">  char *p;</a>
<a name="ln2015">  char *r;</a>
<a name="ln2016"> </a>
<a name="ln2017">  *alloced = false;</a>
<a name="ln2018">  if (**pp == NUL) {</a>
<a name="ln2019">    *pp = NULL;</a>
<a name="ln2020">    return &quot;&quot;;</a>
<a name="ln2021">  }</a>
<a name="ln2022">  p = vim_strchr((*pp), ',');</a>
<a name="ln2023">  if (p == NULL) {</a>
<a name="ln2024">    r = enc_canonize(*pp);</a>
<a name="ln2025">    *pp += strlen(*pp);</a>
<a name="ln2026">  } else {</a>
<a name="ln2027">    r = xstrnsave(*pp, (size_t)(p - *pp));</a>
<a name="ln2028">    *pp = p + 1;</a>
<a name="ln2029">    p = enc_canonize(r);</a>
<a name="ln2030">    xfree(r);</a>
<a name="ln2031">    r = p;</a>
<a name="ln2032">  }</a>
<a name="ln2033">  *alloced = true;</a>
<a name="ln2034">  return r;</a>
<a name="ln2035">}</a>
<a name="ln2036"> </a>
<a name="ln2037">/// Convert a file with the 'charconvert' expression.</a>
<a name="ln2038">/// This closes the file which is to be read, converts it and opens the</a>
<a name="ln2039">/// resulting file for reading.</a>
<a name="ln2040">///</a>
<a name="ln2041">/// @param fname  name of input file</a>
<a name="ln2042">/// @param fenc   converted from</a>
<a name="ln2043">/// @param fdp    in/out: file descriptor of file</a>
<a name="ln2044">///</a>
<a name="ln2045">/// @return       name of the resulting converted file (the caller should delete it after reading it).</a>
<a name="ln2046">///               Returns NULL if the conversion failed (&quot;*fdp&quot; is not set) .</a>
<a name="ln2047">static char_u *readfile_charconvert(char_u *fname, char_u *fenc, int *fdp)</a>
<a name="ln2048">{</a>
<a name="ln2049">  char_u *tmpname;</a>
<a name="ln2050">  char *errmsg = NULL;</a>
<a name="ln2051"> </a>
<a name="ln2052">  tmpname = (char_u *)vim_tempname();</a>
<a name="ln2053">  if (tmpname == NULL) {</a>
<a name="ln2054">    errmsg = _(&quot;Can't find temp file for conversion&quot;);</a>
<a name="ln2055">  } else {</a>
<a name="ln2056">    close(*fdp);                // close the input file, ignore errors</a>
<a name="ln2057">    *fdp = -1;</a>
<a name="ln2058">    if (eval_charconvert((char *)fenc, &quot;utf-8&quot;,</a>
<a name="ln2059">                         (char *)fname, (char *)tmpname) == FAIL) {</a>
<a name="ln2060">      errmsg = _(&quot;Conversion with 'charconvert' failed&quot;);</a>
<a name="ln2061">    }</a>
<a name="ln2062">    if (errmsg == NULL &amp;&amp; (*fdp = os_open((char *)tmpname, O_RDONLY, 0)) &lt; 0) {</a>
<a name="ln2063">      errmsg = _(&quot;can't read output of 'charconvert'&quot;);</a>
<a name="ln2064">    }</a>
<a name="ln2065">  }</a>
<a name="ln2066"> </a>
<a name="ln2067">  if (errmsg != NULL) {</a>
<a name="ln2068">    // Don't use emsg(), it breaks mappings, the retry with</a>
<a name="ln2069">    // another type of conversion might still work.</a>
<a name="ln2070">    msg(errmsg);</a>
<a name="ln2071">    if (tmpname != NULL) {</a>
<a name="ln2072">      os_remove((char *)tmpname);  // delete converted file</a>
<a name="ln2073">      XFREE_CLEAR(tmpname);</a>
<a name="ln2074">    }</a>
<a name="ln2075">  }</a>
<a name="ln2076"> </a>
<a name="ln2077">  // If the input file is closed, open it (caller should check for error).</a>
<a name="ln2078">  if (*fdp &lt; 0) {</a>
<a name="ln2079">    *fdp = os_open((char *)fname, O_RDONLY, 0);</a>
<a name="ln2080">  }</a>
<a name="ln2081"> </a>
<a name="ln2082">  return tmpname;</a>
<a name="ln2083">}</a>
<a name="ln2084"> </a>
<a name="ln2085">/// Read marks for the current buffer from the ShaDa file, when we support</a>
<a name="ln2086">/// buffer marks and the buffer has a name.</a>
<a name="ln2087">static void check_marks_read(void)</a>
<a name="ln2088">{</a>
<a name="ln2089">  if (!curbuf-&gt;b_marks_read &amp;&amp; get_shada_parameter('\'') &gt; 0</a>
<a name="ln2090">      &amp;&amp; curbuf-&gt;b_ffname != NULL) {</a>
<a name="ln2091">    shada_read_marks();</a>
<a name="ln2092">  }</a>
<a name="ln2093"> </a>
<a name="ln2094">  // Always set b_marks_read; needed when 'shada' is changed to include</a>
<a name="ln2095">  // the ' parameter after opening a buffer.</a>
<a name="ln2096">  curbuf-&gt;b_marks_read = true;</a>
<a name="ln2097">}</a>
<a name="ln2098"> </a>
<a name="ln2099">char *new_file_message(void)</a>
<a name="ln2100">{</a>
<a name="ln2101">  return shortmess(SHM_NEW) ? _(&quot;[New]&quot;) : _(&quot;[New File]&quot;);</a>
<a name="ln2102">}</a>
<a name="ln2103"> </a>
<a name="ln2104">/// buf_write() - write to file &quot;fname&quot; lines &quot;start&quot; through &quot;end&quot;</a>
<a name="ln2105">///</a>
<a name="ln2106">/// We do our own buffering here because fwrite() is so slow.</a>
<a name="ln2107">///</a>
<a name="ln2108">/// If &quot;forceit&quot; is true, we don't care for errors when attempting backups.</a>
<a name="ln2109">/// In case of an error everything possible is done to restore the original</a>
<a name="ln2110">/// file.  But when &quot;forceit&quot; is true, we risk losing it.</a>
<a name="ln2111">///</a>
<a name="ln2112">/// When &quot;reset_changed&quot; is true and &quot;append&quot; == false and &quot;start&quot; == 1 and</a>
<a name="ln2113">/// &quot;end&quot; == curbuf-&gt;b_ml.ml_line_count, reset curbuf-&gt;b_changed.</a>
<a name="ln2114">///</a>
<a name="ln2115">/// This function must NOT use NameBuff (because it's called by autowrite()).</a>
<a name="ln2116">///</a>
<a name="ln2117">///</a>
<a name="ln2118">/// @param eap     for forced 'ff' and 'fenc', can be NULL!</a>
<a name="ln2119">/// @param append  append to the file</a>
<a name="ln2120">///</a>
<a name="ln2121">/// @return        FAIL for failure, OK otherwise</a>
<a name="ln2122">int buf_write(buf_T *buf, char *fname, char *sfname, linenr_T start, linenr_T end, exarg_T *eap,</a>
<a name="ln2123">              int append, int forceit, int reset_changed, int filtering)</a>
<a name="ln2124">{</a>
<a name="ln2125">  int fd;</a>
<a name="ln2126">  char *backup = NULL;</a>
<a name="ln2127">  int backup_copy = false;               // copy the original file?</a>
<a name="ln2128">  int dobackup;</a>
<a name="ln2129">  char *ffname;</a>
<a name="ln2130">  char *wfname = NULL;       // name of file to write to</a>
<a name="ln2131">  char *s;</a>
<a name="ln2132">  char *ptr;</a>
<a name="ln2133">  char c;</a>
<a name="ln2134">  int len;</a>
<a name="ln2135">  linenr_T lnum;</a>
<a name="ln2136">  long nchars;</a>
<a name="ln2137">#define SET_ERRMSG_NUM(num, msg) \</a>
<a name="ln2138">  errnum = (num), errmsg = (msg), errmsgarg = 0</a>
<a name="ln2139">#define SET_ERRMSG_ARG(msg, error) \</a>
<a name="ln2140">  errnum = NULL, errmsg = (msg), errmsgarg = error</a>
<a name="ln2141">#define SET_ERRMSG(msg) \</a>
<a name="ln2142">  errnum = NULL, errmsg = (msg), errmsgarg = 0</a>
<a name="ln2143">  const char *errnum = NULL;</a>
<a name="ln2144">  char *errmsg = NULL;</a>
<a name="ln2145">  int errmsgarg = 0;</a>
<a name="ln2146">  bool errmsg_allocated = false;</a>
<a name="ln2147">  char *buffer;</a>
<a name="ln2148">  char smallbuf[SMBUFSIZE];</a>
<a name="ln2149">  char *backup_ext;</a>
<a name="ln2150">  int bufsize;</a>
<a name="ln2151">  long perm;                                // file permissions</a>
<a name="ln2152">  int retval = OK;</a>
<a name="ln2153">  int newfile = false;                      // true if file doesn't exist yet</a>
<a name="ln2154">  int msg_save = msg_scroll;</a>
<a name="ln2155">  int overwriting;                          // true if writing over original</a>
<a name="ln2156">  int no_eol = false;                       // no end-of-line written</a>
<a name="ln2157">  int device = false;                       // writing to a device</a>
<a name="ln2158">  int prev_got_int = got_int;</a>
<a name="ln2159">  int checking_conversion;</a>
<a name="ln2160">  bool file_readonly = false;               // overwritten file is read-only</a>
<a name="ln2161">  static char *err_readonly =</a>
<a name="ln2162">    &quot;is read-only (cannot override: \&quot;W\&quot; in 'cpoptions')&quot;;</a>
<a name="ln2163">#if defined(UNIX)</a>
<a name="ln2164">  int made_writable = false;                // 'w' bit has been set</a>
<a name="ln2165">#endif</a>
<a name="ln2166">  // writing everything</a>
<a name="ln2167">  int whole = (start == 1 &amp;&amp; end == buf-&gt;b_ml.ml_line_count);</a>
<a name="ln2168">  linenr_T old_line_count = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2169">  int fileformat;</a>
<a name="ln2170">  int write_bin;</a>
<a name="ln2171">  struct bw_info write_info;            // info for buf_write_bytes()</a>
<a name="ln2172">  int converted = false;</a>
<a name="ln2173">  int notconverted = false;</a>
<a name="ln2174">  char *fenc;                // effective 'fileencoding'</a>
<a name="ln2175">  char *fenc_tofree = NULL;   // allocated &quot;fenc&quot;</a>
<a name="ln2176">#ifdef HAS_BW_FLAGS</a>
<a name="ln2177">  int wb_flags = 0;</a>
<a name="ln2178">#endif</a>
<a name="ln2179">#ifdef HAVE_ACL</a>
<a name="ln2180">  vim_acl_T acl = NULL;                 // ACL copied from original file to</a>
<a name="ln2181">                                        // backup or new file</a>
<a name="ln2182">#endif</a>
<a name="ln2183">  int write_undo_file = false;</a>
<a name="ln2184">  context_sha256_T sha_ctx;</a>
<a name="ln2185">  unsigned int bkc = get_bkc_value(buf);</a>
<a name="ln2186">  const pos_T orig_start = buf-&gt;b_op_start;</a>
<a name="ln2187">  const pos_T orig_end = buf-&gt;b_op_end;</a>
<a name="ln2188"> </a>
<a name="ln2189">  if (fname == NULL || *fname == NUL) {  // safety check</a>
<a name="ln2190">    return FAIL;</a>
<a name="ln2191">  }</a>
<a name="ln2192">  if (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2193">    // This can happen during startup when there is a stray &quot;w&quot; in the</a>
<a name="ln2194">    // vimrc file.</a>
<a name="ln2195">    emsg(_(e_emptybuf));</a>
<a name="ln2196">    return FAIL;</a>
<a name="ln2197">  }</a>
<a name="ln2198"> </a>
<a name="ln2199">  // Disallow writing from .exrc and .vimrc in current directory for</a>
<a name="ln2200">  // security reasons.</a>
<a name="ln2201">  if (check_secure()) {</a>
<a name="ln2202">    return FAIL;</a>
<a name="ln2203">  }</a>
<a name="ln2204"> </a>
<a name="ln2205">  // Avoid a crash for a long name.</a>
<a name="ln2206">  if (strlen(fname) &gt;= MAXPATHL) {</a>
<a name="ln2207">    emsg(_(e_longname));</a>
<a name="ln2208">    return FAIL;</a>
<a name="ln2209">  }</a>
<a name="ln2210"> </a>
<a name="ln2211">  // must init bw_conv_buf and bw_iconv_fd before jumping to &quot;fail&quot;</a>
<a name="ln2212">  write_info.bw_conv_buf = NULL;</a>
<a name="ln2213">  write_info.bw_conv_error = false;</a>
<a name="ln2214">  write_info.bw_conv_error_lnum = 0;</a>
<a name="ln2215">  write_info.bw_restlen = 0;</a>
<a name="ln2216">#ifdef HAVE_ICONV</a>
<a name="ln2217">  write_info.bw_iconv_fd = (iconv_t)-1;</a>
<a name="ln2218">#endif</a>
<a name="ln2219"> </a>
<a name="ln2220">  // After writing a file changedtick changes but we don't want to display</a>
<a name="ln2221">  // the line.</a>
<a name="ln2222">  ex_no_reprint = true;</a>
<a name="ln2223"> </a>
<a name="ln2224">  // If there is no file name yet, use the one for the written file.</a>
<a name="ln2225">  // BF_NOTEDITED is set to reflect this (in case the write fails).</a>
<a name="ln2226">  // Don't do this when the write is for a filter command.</a>
<a name="ln2227">  // Don't do this when appending.</a>
<a name="ln2228">  // Only do this when 'cpoptions' contains the 'F' flag.</a>
<a name="ln2229">  if (buf-&gt;b_ffname == NULL</a>
<a name="ln2230">      &amp;&amp; reset_changed</a>
<a name="ln2231">      &amp;&amp; whole</a>
<a name="ln2232">      &amp;&amp; buf == curbuf</a>
<a name="ln2233">      &amp;&amp; !bt_nofilename(buf)</a>
<a name="ln2234">      &amp;&amp; !filtering</a>
<a name="ln2235">      &amp;&amp; (!append || vim_strchr(p_cpo, CPO_FNAMEAPP) != NULL)</a>
<a name="ln2236">      &amp;&amp; vim_strchr(p_cpo, CPO_FNAMEW) != NULL) {</a>
<a name="ln2237">    if (set_rw_fname((char_u *)fname, (char_u *)sfname) == FAIL) {</a>
<a name="ln2238">      return FAIL;</a>
<a name="ln2239">    }</a>
<a name="ln2240">    buf = curbuf;           // just in case autocmds made &quot;buf&quot; invalid</a>
<a name="ln2241">  }</a>
<a name="ln2242"> </a>
<a name="ln2243">  if (sfname == NULL) {</a>
<a name="ln2244">    sfname = fname;</a>
<a name="ln2245">  }</a>
<a name="ln2246"> </a>
<a name="ln2247">  // For Unix: Use the short file name whenever possible.</a>
<a name="ln2248">  // Avoids problems with networks and when directory names are changed.</a>
<a name="ln2249">  // Don't do this for Windows, a &quot;cd&quot; in a sub-shell may have moved us to</a>
<a name="ln2250">  // another directory, which we don't detect.</a>
<a name="ln2251">  ffname = fname;                           // remember full fname</a>
<a name="ln2252">#ifdef UNIX</a>
<a name="ln2253">  fname = sfname;</a>
<a name="ln2254">#endif</a>
<a name="ln2255"> </a>
<a name="ln2256">  if (buf-&gt;b_ffname != NULL &amp;&amp; path_fnamecmp(ffname, buf-&gt;b_ffname) == 0) {</a>
<a name="ln2257">    overwriting = true;</a>
<a name="ln2258">  } else {</a>
<a name="ln2259">    overwriting = false;</a>
<a name="ln2260">  }</a>
<a name="ln2261"> </a>
<a name="ln2262">  no_wait_return++;                 // don't wait for return yet</a>
<a name="ln2263"> </a>
<a name="ln2264">  // Set '[ and '] marks to the lines to be written.</a>
<a name="ln2265">  buf-&gt;b_op_start.lnum = start;</a>
<a name="ln2266">  buf-&gt;b_op_start.col = 0;</a>
<a name="ln2267">  buf-&gt;b_op_end.lnum = end;</a>
<a name="ln2268">  buf-&gt;b_op_end.col = 0;</a>
<a name="ln2269"> </a>
<a name="ln2270">  {</a>
<a name="ln2271">    aco_save_T aco;</a>
<a name="ln2272">    int buf_ffname = false;</a>
<a name="ln2273">    int buf_sfname = false;</a>
<a name="ln2274">    int buf_fname_f = false;</a>
<a name="ln2275">    int buf_fname_s = false;</a>
<a name="ln2276">    int did_cmd = false;</a>
<a name="ln2277">    int nofile_err = false;</a>
<a name="ln2278">    int empty_memline = (buf-&gt;b_ml.ml_mfp == NULL);</a>
<a name="ln2279">    bufref_T bufref;</a>
<a name="ln2280"> </a>
<a name="ln2281">    // Apply PRE autocommands.</a>
<a name="ln2282">    // Set curbuf to the buffer to be written.</a>
<a name="ln2283">    // Careful: The autocommands may call buf_write() recursively!</a>
<a name="ln2284">    if (ffname == buf-&gt;b_ffname) {</a>
<a name="ln2285">      buf_ffname = true;</a>
<a name="ln2286">    }</a>
<a name="ln2287">    if (sfname == buf-&gt;b_sfname) {</a>
<a name="ln2288">      buf_sfname = true;</a>
<a name="ln2289">    }</a>
<a name="ln2290">    if (fname == buf-&gt;b_ffname) {</a>
<a name="ln2291">      buf_fname_f = true;</a>
<a name="ln2292">    }</a>
<a name="ln2293">    if (fname == buf-&gt;b_sfname) {</a>
<a name="ln2294">      buf_fname_s = true;</a>
<a name="ln2295">    }</a>
<a name="ln2296"> </a>
<a name="ln2297">    // Set curwin/curbuf to buf and save a few things.</a>
<a name="ln2298">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln2299">    set_bufref(&amp;bufref, buf);</a>
<a name="ln2300"> </a>
<a name="ln2301">    if (append) {</a>
<a name="ln2302">      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,</a>
<a name="ln2303">                                           sfname, sfname, false, curbuf, eap))) {</a>
<a name="ln2304">        if (overwriting &amp;&amp; bt_nofilename(curbuf)) {</a>
<a name="ln2305">          nofile_err = true;</a>
<a name="ln2306">        } else {</a>
<a name="ln2307">          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,</a>
<a name="ln2308">                               sfname, sfname, false, curbuf, eap);</a>
<a name="ln2309">        }</a>
<a name="ln2310">      }</a>
<a name="ln2311">    } else if (filtering) {</a>
<a name="ln2312">      apply_autocmds_exarg(EVENT_FILTERWRITEPRE,</a>
<a name="ln2313">                           NULL, sfname, false, curbuf, eap);</a>
<a name="ln2314">    } else if (reset_changed &amp;&amp; whole) {</a>
<a name="ln2315">      int was_changed = curbufIsChanged();</a>
<a name="ln2316"> </a>
<a name="ln2317">      did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,</a>
<a name="ln2318">                                     sfname, sfname, false, curbuf, eap);</a>
<a name="ln2319">      if (did_cmd) {</a>
<a name="ln2320">        if (was_changed &amp;&amp; !curbufIsChanged()) {</a>
<a name="ln2321">          // Written everything correctly and BufWriteCmd has reset</a>
<a name="ln2322">          // 'modified': Correct the undo information so that an</a>
<a name="ln2323">          // undo now sets 'modified'.</a>
<a name="ln2324">          u_unchanged(curbuf);</a>
<a name="ln2325">          u_update_save_nr(curbuf);</a>
<a name="ln2326">        }</a>
<a name="ln2327">      } else {</a>
<a name="ln2328">        if (overwriting &amp;&amp; bt_nofilename(curbuf)) {</a>
<a name="ln2329">          nofile_err = true;</a>
<a name="ln2330">        } else {</a>
<a name="ln2331">          apply_autocmds_exarg(EVENT_BUFWRITEPRE,</a>
<a name="ln2332">                               sfname, sfname, false, curbuf, eap);</a>
<a name="ln2333">        }</a>
<a name="ln2334">      }</a>
<a name="ln2335">    } else {</a>
<a name="ln2336">      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,</a>
<a name="ln2337">                                           sfname, sfname, false, curbuf, eap))) {</a>
<a name="ln2338">        if (overwriting &amp;&amp; bt_nofilename(curbuf)) {</a>
<a name="ln2339">          nofile_err = true;</a>
<a name="ln2340">        } else {</a>
<a name="ln2341">          apply_autocmds_exarg(EVENT_FILEWRITEPRE,</a>
<a name="ln2342">                               sfname, sfname, false, curbuf, eap);</a>
<a name="ln2343">        }</a>
<a name="ln2344">      }</a>
<a name="ln2345">    }</a>
<a name="ln2346"> </a>
<a name="ln2347">    // restore curwin/curbuf and a few other things</a>
<a name="ln2348">    aucmd_restbuf(&amp;aco);</a>
<a name="ln2349"> </a>
<a name="ln2350">    // In three situations we return here and don't write the file:</a>
<a name="ln2351">    // 1. the autocommands deleted or unloaded the buffer.</a>
<a name="ln2352">    // 2. The autocommands abort script processing.</a>
<a name="ln2353">    // 3. If one of the &quot;Cmd&quot; autocommands was executed.</a>
<a name="ln2354">    if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2355">      buf = NULL;</a>
<a name="ln2356">    }</a>
<a name="ln2357">    if (buf == NULL || (buf-&gt;b_ml.ml_mfp == NULL &amp;&amp; !empty_memline)</a>
<a name="ln2358">        || did_cmd || nofile_err</a>
<a name="ln2359">        || aborting()) {</a>
<a name="ln2360">      if (buf != NULL &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS)) {</a>
<a name="ln2361">        // restore the original '[ and '] positions</a>
<a name="ln2362">        buf-&gt;b_op_start = orig_start;</a>
<a name="ln2363">        buf-&gt;b_op_end = orig_end;</a>
<a name="ln2364">      }</a>
<a name="ln2365"> </a>
<a name="ln2366">      no_wait_return--;</a>
<a name="ln2367">      msg_scroll = msg_save;</a>
<a name="ln2368">      if (nofile_err) {</a>
<a name="ln2369">        semsg(_(e_no_matching_autocommands_for_buftype_str_buffer), curbuf-&gt;b_p_bt);</a>
<a name="ln2370">      }</a>
<a name="ln2371"> </a>
<a name="ln2372">      if (nofile_err</a>
<a name="ln2373">          || aborting()) {</a>
<a name="ln2374">        // An aborting error, interrupt or exception in the</a>
<a name="ln2375">        // autocommands.</a>
<a name="ln2376">        return FAIL;</a>
<a name="ln2377">      }</a>
<a name="ln2378">      if (did_cmd) {</a>
<a name="ln2379">        if (buf == NULL) {</a>
<a name="ln2380">          // The buffer was deleted.  We assume it was written</a>
<a name="ln2381">          // (can't retry anyway).</a>
<a name="ln2382">          return OK;</a>
<a name="ln2383">        }</a>
<a name="ln2384">        if (overwriting) {</a>
<a name="ln2385">          // Assume the buffer was written, update the timestamp.</a>
<a name="ln2386">          ml_timestamp(buf);</a>
<a name="ln2387">          if (append) {</a>
<a name="ln2388">            buf-&gt;b_flags &amp;= ~BF_NEW;</a>
<a name="ln2389">          } else {</a>
<a name="ln2390">            buf-&gt;b_flags &amp;= ~BF_WRITE_MASK;</a>
<a name="ln2391">          }</a>
<a name="ln2392">        }</a>
<a name="ln2393">        if (reset_changed &amp;&amp; buf-&gt;b_changed &amp;&amp; !append</a>
<a name="ln2394">            &amp;&amp; (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL)) {</a>
<a name="ln2395">          // Buffer still changed, the autocommands didn't work properly.</a>
<a name="ln2396">          return FAIL;</a>
<a name="ln2397">        }</a>
<a name="ln2398">        return OK;</a>
<a name="ln2399">      }</a>
<a name="ln2400">      if (!aborting()) {</a>
<a name="ln2401">        emsg(_(&quot;E203: Autocommands deleted or unloaded buffer to be written&quot;));</a>
<a name="ln2402">      }</a>
<a name="ln2403">      return FAIL;</a>
<a name="ln2404">    }</a>
<a name="ln2405"> </a>
<a name="ln2406">    // The autocommands may have changed the number of lines in the file.</a>
<a name="ln2407">    // When writing the whole file, adjust the end.</a>
<a name="ln2408">    // When writing part of the file, assume that the autocommands only</a>
<a name="ln2409">    // changed the number of lines that are to be written (tricky!).</a>
<a name="ln2410">    if (buf-&gt;b_ml.ml_line_count != old_line_count) {</a>
<a name="ln2411">      if (whole) {                                              // write all</a>
<a name="ln2412">        end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2413">      } else if (buf-&gt;b_ml.ml_line_count &gt; old_line_count) {           // more lines</a>
<a name="ln2414">        end += buf-&gt;b_ml.ml_line_count - old_line_count;</a>
<a name="ln2415">      } else {                                                    // less lines</a>
<a name="ln2416">        end -= old_line_count - buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2417">        if (end &lt; start) {</a>
<a name="ln2418">          no_wait_return--;</a>
<a name="ln2419">          msg_scroll = msg_save;</a>
<a name="ln2420">          emsg(_(&quot;E204: Autocommand changed number of lines in unexpected way&quot;));</a>
<a name="ln2421">          return FAIL;</a>
<a name="ln2422">        }</a>
<a name="ln2423">      }</a>
<a name="ln2424">    }</a>
<a name="ln2425"> </a>
<a name="ln2426">    // The autocommands may have changed the name of the buffer, which may</a>
<a name="ln2427">    // be kept in fname, ffname and sfname.</a>
<a name="ln2428">    if (buf_ffname) {</a>
<a name="ln2429">      ffname = buf-&gt;b_ffname;</a>
<a name="ln2430">    }</a>
<a name="ln2431">    if (buf_sfname) {</a>
<a name="ln2432">      sfname = buf-&gt;b_sfname;</a>
<a name="ln2433">    }</a>
<a name="ln2434">    if (buf_fname_f) {</a>
<a name="ln2435">      fname = buf-&gt;b_ffname;</a>
<a name="ln2436">    }</a>
<a name="ln2437">    if (buf_fname_s) {</a>
<a name="ln2438">      fname = buf-&gt;b_sfname;</a>
<a name="ln2439">    }</a>
<a name="ln2440">  }</a>
<a name="ln2441"> </a>
<a name="ln2442">  if (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) {</a>
<a name="ln2443">    // restore the original '[ and '] positions</a>
<a name="ln2444">    buf-&gt;b_op_start = orig_start;</a>
<a name="ln2445">    buf-&gt;b_op_end = orig_end;</a>
<a name="ln2446">  }</a>
<a name="ln2447"> </a>
<a name="ln2448">  if (shortmess(SHM_OVER) &amp;&amp; !exiting) {</a>
<a name="ln2449">    msg_scroll = false;             // overwrite previous file message</a>
<a name="ln2450">  } else {</a>
<a name="ln2451">    msg_scroll = true;              // don't overwrite previous file message</a>
<a name="ln2452">  }</a>
<a name="ln2453">  if (!filtering) {</a>
<a name="ln2454">    filemess(buf,</a>
<a name="ln2455">#ifndef UNIX</a>
<a name="ln2456">             (char_u *)sfname,</a>
<a name="ln2457">#else</a>
<a name="ln2458">             fname,</a>
<a name="ln2459">#endif</a>
<a name="ln2460">             &quot;&quot;, 0);               // show that we are busy</a>
<a name="ln2461">  }</a>
<a name="ln2462">  msg_scroll = false;               // always overwrite the file message now</a>
<a name="ln2463"> </a>
<a name="ln2464">  buffer = verbose_try_malloc(BUFSIZE);</a>
<a name="ln2465">  // can't allocate big buffer, use small one (to be able to write when out of</a>
<a name="ln2466">  // memory)</a>
<a name="ln2467">  if (buffer == NULL) {</a>
<a name="ln2468">    buffer = smallbuf;</a>
<a name="ln2469">    bufsize = SMBUFSIZE;</a>
<a name="ln2470">  } else {</a>
<a name="ln2471">    bufsize = BUFSIZE;</a>
<a name="ln2472">  }</a>
<a name="ln2473"> </a>
<a name="ln2474">  // Get information about original file (if there is one).</a>
<a name="ln2475">  FileInfo file_info_old;</a>
<a name="ln2476">#if defined(UNIX)</a>
<a name="ln2477">  perm = -1;</a>
<a name="ln2478">  if (!os_fileinfo(fname, &amp;file_info_old)) {</a>
<a name="ln2479">    newfile = true;</a>
<a name="ln2480">  } else {</a>
<a name="ln2481">    perm = (long)file_info_old.stat.st_mode;</a>
<a name="ln2482">    if (!S_ISREG(file_info_old.stat.st_mode)) {             // not a file</a>
<a name="ln2483">      if (S_ISDIR(file_info_old.stat.st_mode)) {</a>
<a name="ln2484">        SET_ERRMSG_NUM(&quot;E502&quot;, _(&quot;is a directory&quot;));</a>
<a name="ln2485">        goto fail;</a>
<a name="ln2486">      }</a>
<a name="ln2487">      if (os_nodetype(fname) != NODE_WRITABLE) {</a>
<a name="ln2488">        SET_ERRMSG_NUM(&quot;E503&quot;, _(&quot;is not a file or writable device&quot;));</a>
<a name="ln2489">        goto fail;</a>
<a name="ln2490">      }</a>
<a name="ln2491">      // It's a device of some kind (or a fifo) which we can write to</a>
<a name="ln2492">      // but for which we can't make a backup.</a>
<a name="ln2493">      device = true;</a>
<a name="ln2494">      newfile = true;</a>
<a name="ln2495">      perm = -1;</a>
<a name="ln2496">    }</a>
<a name="ln2497">  }</a>
<a name="ln2498">#else  // win32</a>
<a name="ln2499">  // Check for a writable device name.</a>
<a name="ln2500">  c = fname == NULL ? NODE_OTHER : os_nodetype((char *)fname);</a>
<a name="ln2501">  if (c == NODE_OTHER) {</a>
<a name="ln2502">    SET_ERRMSG_NUM(&quot;E503&quot;, _(&quot;is not a file or writable device&quot;));</a>
<a name="ln2503">    goto fail;</a>
<a name="ln2504">  }</a>
<a name="ln2505">  if (c == NODE_WRITABLE) {</a>
<a name="ln2506">    device = true;</a>
<a name="ln2507">    newfile = true;</a>
<a name="ln2508">    perm = -1;</a>
<a name="ln2509">  } else {</a>
<a name="ln2510">    perm = os_getperm((const char *)fname);</a>
<a name="ln2511">    if (perm &lt; 0) {</a>
<a name="ln2512">      newfile = true;</a>
<a name="ln2513">    } else if (os_isdir(fname)) {</a>
<a name="ln2514">      SET_ERRMSG_NUM(&quot;E502&quot;, _(&quot;is a directory&quot;));</a>
<a name="ln2515">      goto fail;</a>
<a name="ln2516">    }</a>
<a name="ln2517">    if (overwriting) {</a>
<a name="ln2518">      os_fileinfo((char *)fname, &amp;file_info_old);</a>
<a name="ln2519">    }</a>
<a name="ln2520">  }</a>
<a name="ln2521">#endif  // !UNIX</a>
<a name="ln2522"> </a>
<a name="ln2523">  if (!device &amp;&amp; !newfile) {</a>
<a name="ln2524">    // Check if the file is really writable (when renaming the file to</a>
<a name="ln2525">    // make a backup we won't discover it later).</a>
<a name="ln2526">    file_readonly = !os_file_is_writable(fname);</a>
<a name="ln2527"> </a>
<a name="ln2528">    if (!forceit &amp;&amp; file_readonly) {</a>
<a name="ln2529">      if (vim_strchr(p_cpo, CPO_FWRITE) != NULL) {</a>
<a name="ln2530">        SET_ERRMSG_NUM(&quot;E504&quot;, _(err_readonly));</a>
<a name="ln2531">      } else {</a>
<a name="ln2532">        SET_ERRMSG_NUM(&quot;E505&quot;, _(&quot;is read-only (add ! to override)&quot;));</a>
<a name="ln2533">      }</a>
<a name="ln2534">      goto fail;</a>
<a name="ln2535">    }</a>
<a name="ln2536"> </a>
<a name="ln2537">    // If 'forceit' is false, check if the timestamp hasn't changed since reading the file.</a>
<a name="ln2538">    if (overwriting &amp;&amp; !forceit) {</a>
<a name="ln2539">      retval = check_mtime(buf, &amp;file_info_old);</a>
<a name="ln2540">      if (retval == FAIL) {</a>
<a name="ln2541">        goto fail;</a>
<a name="ln2542">      }</a>
<a name="ln2543">    }</a>
<a name="ln2544">  }</a>
<a name="ln2545"> </a>
<a name="ln2546">#ifdef HAVE_ACL</a>
<a name="ln2547">  // For systems that support ACL: get the ACL from the original file.</a>
<a name="ln2548">  if (!newfile) {</a>
<a name="ln2549">    acl = mch_get_acl((char_u *)fname);</a>
<a name="ln2550">  }</a>
<a name="ln2551">#endif</a>
<a name="ln2552"> </a>
<a name="ln2553">  // If 'backupskip' is not empty, don't make a backup for some files.</a>
<a name="ln2554">  dobackup = (p_wb || p_bk || *p_pm != NUL);</a>
<a name="ln2555">  if (dobackup &amp;&amp; *p_bsk != NUL &amp;&amp; match_file_list(p_bsk, (char_u *)sfname, (char_u *)ffname)) {</a>
<a name="ln2556">    dobackup = false;</a>
<a name="ln2557">  }</a>
<a name="ln2558"> </a>
<a name="ln2559">  // Save the value of got_int and reset it.  We don't want a previous</a>
<a name="ln2560">  // interruption cancel writing, only hitting CTRL-C while writing should</a>
<a name="ln2561">  // abort it.</a>
<a name="ln2562">  prev_got_int = got_int;</a>
<a name="ln2563">  got_int = false;</a>
<a name="ln2564"> </a>
<a name="ln2565">  // Mark the buffer as 'being saved' to prevent changed buffer warnings</a>
<a name="ln2566">  buf-&gt;b_saving = true;</a>
<a name="ln2567"> </a>
<a name="ln2568">  // If we are not appending or filtering, the file exists, and the</a>
<a name="ln2569">  // 'writebackup', 'backup' or 'patchmode' option is set, need a backup.</a>
<a name="ln2570">  // When 'patchmode' is set also make a backup when appending.</a>
<a name="ln2571">  //</a>
<a name="ln2572">  // Do not make any backup, if 'writebackup' and 'backup' are both switched</a>
<a name="ln2573">  // off.  This helps when editing large files on almost-full disks.</a>
<a name="ln2574">  if (!(append &amp;&amp; *p_pm == NUL) &amp;&amp; !filtering &amp;&amp; perm &gt;= 0 &amp;&amp; dobackup) {</a>
<a name="ln2575">    FileInfo file_info;</a>
<a name="ln2576">    const bool no_prepend_dot = false;</a>
<a name="ln2577"> </a>
<a name="ln2578">    if ((bkc &amp; BKC_YES) || append) {       // &quot;yes&quot;</a>
<a name="ln2579">      backup_copy = true;</a>
<a name="ln2580">    } else if ((bkc &amp; BKC_AUTO)) {          // &quot;auto&quot;</a>
<a name="ln2581">      int i;</a>
<a name="ln2582"> </a>
<a name="ln2583">      // Don't rename the file when:</a>
<a name="ln2584">      // - it's a hard link</a>
<a name="ln2585">      // - it's a symbolic link</a>
<a name="ln2586">      // - we don't have write permission in the directory</a>
<a name="ln2587">      if (os_fileinfo_hardlinks(&amp;file_info_old) &gt; 1</a>
<a name="ln2588">          || !os_fileinfo_link(fname, &amp;file_info)</a>
<a name="ln2589">          || !os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old)) {</a>
<a name="ln2590">        backup_copy = true;</a>
<a name="ln2591">      } else {</a>
<a name="ln2592">        // Check if we can create a file and set the owner/group to</a>
<a name="ln2593">        // the ones from the original file.</a>
<a name="ln2594">        // First find a file name that doesn't exist yet (use some</a>
<a name="ln2595">        // arbitrary numbers).</a>
<a name="ln2596">        STRCPY(IObuff, fname);</a>
<a name="ln2597">        for (i = 4913;; i += 123) {</a>
<a name="ln2598">          char *tail = path_tail((char *)IObuff);</a>
<a name="ln2599">          size_t size = (size_t)(tail - IObuff);</a>
<a name="ln2600">          snprintf(tail, IOSIZE - size, &quot;%d&quot;, i);</a>
<a name="ln2601">          if (!os_fileinfo_link((char *)IObuff, &amp;file_info)) {</a>
<a name="ln2602">            break;</a>
<a name="ln2603">          }</a>
<a name="ln2604">        }</a>
<a name="ln2605">        fd = os_open((char *)IObuff,</a>
<a name="ln2606">                     O_CREAT|O_WRONLY|O_EXCL|O_NOFOLLOW, (int)perm);</a>
<a name="ln2607">        if (fd &lt; 0) {           // can't write in directory</a>
<a name="ln2608">          backup_copy = true;</a>
<a name="ln2609">        } else {</a>
<a name="ln2610">#ifdef UNIX</a>
<a name="ln2611">          os_fchown(fd, (uv_uid_t)file_info_old.stat.st_uid, (uv_gid_t)file_info_old.stat.st_gid);</a>
<a name="ln2612">          if (!os_fileinfo((char *)IObuff, &amp;file_info)</a>
<a name="ln2613">              || file_info.stat.st_uid != file_info_old.stat.st_uid</a>
<a name="ln2614">              || file_info.stat.st_gid != file_info_old.stat.st_gid</a>
<a name="ln2615">              || (long)file_info.stat.st_mode != perm) {</a>
<a name="ln2616">            backup_copy = true;</a>
<a name="ln2617">          }</a>
<a name="ln2618">#endif</a>
<a name="ln2619">          // Close the file before removing it, on MS-Windows we</a>
<a name="ln2620">          // can't delete an open file.</a>
<a name="ln2621">          close(fd);</a>
<a name="ln2622">          os_remove((char *)IObuff);</a>
<a name="ln2623">        }</a>
<a name="ln2624">      }</a>
<a name="ln2625">    }</a>
<a name="ln2626"> </a>
<a name="ln2627">    // Break symlinks and/or hardlinks if we've been asked to.</a>
<a name="ln2628">    if ((bkc &amp; BKC_BREAKSYMLINK) || (bkc &amp; BKC_BREAKHARDLINK)) {</a>
<a name="ln2629">#ifdef UNIX</a>
<a name="ln2630">      bool file_info_link_ok = os_fileinfo_link(fname, &amp;file_info);</a>
<a name="ln2631"> </a>
<a name="ln2632">      // Symlinks.</a>
<a name="ln2633">      if ((bkc &amp; BKC_BREAKSYMLINK)</a>
<a name="ln2634">          &amp;&amp; file_info_link_ok</a>
<a name="ln2635">          &amp;&amp; !os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old)) {</a>
<a name="ln2636">        backup_copy = false;</a>
<a name="ln2637">      }</a>
<a name="ln2638"> </a>
<a name="ln2639">      // Hardlinks.</a>
<a name="ln2640">      if ((bkc &amp; BKC_BREAKHARDLINK)</a>
<a name="ln2641">          &amp;&amp; os_fileinfo_hardlinks(&amp;file_info_old) &gt; 1</a>
<a name="ln2642">          &amp;&amp; (!file_info_link_ok</a>
<a name="ln2643">              || os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old))) {</a>
<a name="ln2644">        backup_copy = false;</a>
<a name="ln2645">      }</a>
<a name="ln2646">#endif</a>
<a name="ln2647">    }</a>
<a name="ln2648"> </a>
<a name="ln2649">    // make sure we have a valid backup extension to use</a>
<a name="ln2650">    if (*p_bex == NUL) {</a>
<a name="ln2651">      backup_ext = &quot;.bak&quot;;</a>
<a name="ln2652">    } else {</a>
<a name="ln2653">      backup_ext = p_bex;</a>
<a name="ln2654">    }</a>
<a name="ln2655"> </a>
<a name="ln2656">    if (backup_copy) {</a>
<a name="ln2657">      char *wp;</a>
<a name="ln2658">      int some_error = false;</a>
<a name="ln2659">      char *dirp;</a>
<a name="ln2660">      char *rootname;</a>
<a name="ln2661">      char *p;</a>
<a name="ln2662"> </a>
<a name="ln2663">      // Try to make the backup in each directory in the 'bdir' option.</a>
<a name="ln2664">      //</a>
<a name="ln2665">      // Unix semantics has it, that we may have a writable file,</a>
<a name="ln2666">      // that cannot be recreated with a simple open(..., O_CREAT, ) e.g:</a>
<a name="ln2667">      //  - the directory is not writable,</a>
<a name="ln2668">      //  - the file may be a symbolic link,</a>
<a name="ln2669">      //  - the file may belong to another user/group, etc.</a>
<a name="ln2670">      //</a>
<a name="ln2671">      // For these reasons, the existing writable file must be truncated</a>
<a name="ln2672">      // and reused. Creation of a backup COPY will be attempted.</a>
<a name="ln2673">      dirp = p_bdir;</a>
<a name="ln2674">      while (*dirp) {</a>
<a name="ln2675">        // Isolate one directory name, using an entry in 'bdir'.</a>
<a name="ln2676">        size_t dir_len = copy_option_part(&amp;dirp, (char *)IObuff, IOSIZE, &quot;,&quot;);</a>
<a name="ln2677">        p = (char *)IObuff + dir_len;</a>
<a name="ln2678">        bool trailing_pathseps = after_pathsep((char *)IObuff, p) &amp;&amp; p[-1] == p[-2];</a>
<a name="ln2679">        if (trailing_pathseps) {</a>
<a name="ln2680">          IObuff[dir_len - 2] = NUL;</a>
<a name="ln2681">        }</a>
<a name="ln2682">        if (*dirp == NUL &amp;&amp; !os_isdir((char *)IObuff)) {</a>
<a name="ln2683">          int ret;</a>
<a name="ln2684">          char *failed_dir;</a>
<a name="ln2685">          if ((ret = os_mkdir_recurse((char *)IObuff, 0755, &amp;failed_dir)) != 0) {</a>
<a name="ln2686">            semsg(_(&quot;E303: Unable to create directory \&quot;%s\&quot; for backup file: %s&quot;),</a>
<a name="ln2687">                  failed_dir, os_strerror(ret));</a>
<a name="ln2688">            xfree(failed_dir);</a>
<a name="ln2689">          }</a>
<a name="ln2690">        }</a>
<a name="ln2691">        if (trailing_pathseps) {</a>
<a name="ln2692">          // Ends with '//', Use Full path</a>
<a name="ln2693">          if ((p = make_percent_swname((char *)IObuff, fname))</a>
<a name="ln2694">              != NULL) {</a>
<a name="ln2695">            backup = modname(p, backup_ext, no_prepend_dot);</a>
<a name="ln2696">            xfree(p);</a>
<a name="ln2697">          }</a>
<a name="ln2698">        }</a>
<a name="ln2699"> </a>
<a name="ln2700">        rootname = get_file_in_dir(fname, (char *)IObuff);</a>
<a name="ln2701">        if (rootname == NULL) {</a>
<a name="ln2702">          some_error = true;                // out of memory</a>
<a name="ln2703">          goto nobackup;</a>
<a name="ln2704">        }</a>
<a name="ln2705"> </a>
<a name="ln2706">        FileInfo file_info_new;</a>
<a name="ln2707">        {</a>
<a name="ln2708">          //</a>
<a name="ln2709">          // Make the backup file name.</a>
<a name="ln2710">          //</a>
<a name="ln2711">          if (backup == NULL) {</a>
<a name="ln2712">            backup = modname(rootname, backup_ext, no_prepend_dot);</a>
<a name="ln2713">          }</a>
<a name="ln2714"> </a>
<a name="ln2715">          if (backup == NULL) {</a>
<a name="ln2716">            xfree(rootname);</a>
<a name="ln2717">            some_error = true;                          // out of memory</a>
<a name="ln2718">            goto nobackup;</a>
<a name="ln2719">          }</a>
<a name="ln2720"> </a>
<a name="ln2721">          // Check if backup file already exists.</a>
<a name="ln2722">          if (os_fileinfo(backup, &amp;file_info_new)) {</a>
<a name="ln2723">            if (os_fileinfo_id_equal(&amp;file_info_new, &amp;file_info_old)) {</a>
<a name="ln2724">              //</a>
<a name="ln2725">              // Backup file is same as original file.</a>
<a name="ln2726">              // May happen when modname() gave the same file back (e.g. silly</a>
<a name="ln2727">              // link). If we don't check here, we either ruin the file when</a>
<a name="ln2728">              // copying or erase it after writing.</a>
<a name="ln2729">              //</a>
<a name="ln2730">              XFREE_CLEAR(backup);              // no backup file to delete</a>
<a name="ln2731">            } else if (!p_bk) {</a>
<a name="ln2732">              // We are not going to keep the backup file, so don't</a>
<a name="ln2733">              // delete an existing one, and try to use another name instead.</a>
<a name="ln2734">              // Change one character, just before the extension.</a>
<a name="ln2735">              //</a>
<a name="ln2736">              wp = backup + strlen(backup) - 1 - strlen(backup_ext);</a>
<a name="ln2737">              if (wp &lt; backup) {                // empty file name ???</a>
<a name="ln2738">                wp = backup;</a>
<a name="ln2739">              }</a>
<a name="ln2740">              *wp = 'z';</a>
<a name="ln2741">              while (*wp &gt; 'a' &amp;&amp; os_fileinfo(backup, &amp;file_info_new)) {</a>
<a name="ln2742">                (*wp)--;</a>
<a name="ln2743">              }</a>
<a name="ln2744">              // They all exist??? Must be something wrong.</a>
<a name="ln2745">              if (*wp == 'a') {</a>
<a name="ln2746">                XFREE_CLEAR(backup);</a>
<a name="ln2747">              }</a>
<a name="ln2748">            }</a>
<a name="ln2749">          }</a>
<a name="ln2750">        }</a>
<a name="ln2751">        xfree(rootname);</a>
<a name="ln2752"> </a>
<a name="ln2753">        // Try to create the backup file</a>
<a name="ln2754">        if (backup != NULL) {</a>
<a name="ln2755">          // remove old backup, if present</a>
<a name="ln2756">          os_remove(backup);</a>
<a name="ln2757"> </a>
<a name="ln2758">          // set file protection same as original file, but</a>
<a name="ln2759">          // strip s-bit.</a>
<a name="ln2760">          (void)os_setperm((const char *)backup, perm &amp; 0777);</a>
<a name="ln2761"> </a>
<a name="ln2762">#ifdef UNIX</a>
<a name="ln2763">          //</a>
<a name="ln2764">          // Try to set the group of the backup same as the original file. If</a>
<a name="ln2765">          // this fails, set the protection bits for the group same as the</a>
<a name="ln2766">          // protection bits for others.</a>
<a name="ln2767">          //</a>
<a name="ln2768">          if (file_info_new.stat.st_gid != file_info_old.stat.st_gid</a>
<a name="ln2769">              &amp;&amp; os_chown(backup, (uv_uid_t)-1, (uv_gid_t)file_info_old.stat.st_gid) != 0) {</a>
<a name="ln2770">            os_setperm((const char *)backup,</a>
<a name="ln2771">                       ((int)perm &amp; 0707) | (((int)perm &amp; 07) &lt;&lt; 3));</a>
<a name="ln2772">          }</a>
<a name="ln2773">#endif</a>
<a name="ln2774"> </a>
<a name="ln2775">          // copy the file</a>
<a name="ln2776">          if (os_copy(fname, backup, UV_FS_COPYFILE_FICLONE)</a>
<a name="ln2777">              != 0) {</a>
<a name="ln2778">            SET_ERRMSG(_(&quot;E506: Can't write to backup file &quot;</a>
<a name="ln2779">                         &quot;(add ! to override)&quot;));</a>
<a name="ln2780">          }</a>
<a name="ln2781"> </a>
<a name="ln2782">#ifdef UNIX</a>
<a name="ln2783">          os_file_settime(backup,</a>
<a name="ln2784">                          (double)file_info_old.stat.st_atim.tv_sec,</a>
<a name="ln2785">                          (double)file_info_old.stat.st_mtim.tv_sec);</a>
<a name="ln2786">#endif</a>
<a name="ln2787">#ifdef HAVE_ACL</a>
<a name="ln2788">          mch_set_acl((char_u *)backup, acl);</a>
<a name="ln2789">#endif</a>
<a name="ln2790">          break;</a>
<a name="ln2791">        }</a>
<a name="ln2792">      }</a>
<a name="ln2793"> </a>
<a name="ln2794">nobackup:</a>
<a name="ln2795">      if (backup == NULL &amp;&amp; errmsg == NULL) {</a>
<a name="ln2796">        SET_ERRMSG(_(&quot;E509: Cannot create backup file (add ! to override)&quot;));</a>
<a name="ln2797">      }</a>
<a name="ln2798">      // Ignore errors when forceit is true.</a>
<a name="ln2799">      if ((some_error || errmsg != NULL) &amp;&amp; !forceit) {</a>
<a name="ln2800">        retval = FAIL;</a>
<a name="ln2801">        goto fail;</a>
<a name="ln2802">      }</a>
<a name="ln2803">      SET_ERRMSG(NULL);</a>
<a name="ln2804">    } else {</a>
<a name="ln2805">      char *dirp;</a>
<a name="ln2806">      char *p;</a>
<a name="ln2807">      char *rootname;</a>
<a name="ln2808"> </a>
<a name="ln2809">      // Make a backup by renaming the original file.</a>
<a name="ln2810"> </a>
<a name="ln2811">      // If 'cpoptions' includes the &quot;W&quot; flag, we don't want to</a>
<a name="ln2812">      // overwrite a read-only file.  But rename may be possible</a>
<a name="ln2813">      // anyway, thus we need an extra check here.</a>
<a name="ln2814">      if (file_readonly &amp;&amp; vim_strchr(p_cpo, CPO_FWRITE) != NULL) {</a>
<a name="ln2815">        SET_ERRMSG_NUM(&quot;E504&quot;, _(err_readonly));</a>
<a name="ln2816">        goto fail;</a>
<a name="ln2817">      }</a>
<a name="ln2818"> </a>
<a name="ln2819">      // Form the backup file name - change path/fo.o.h to</a>
<a name="ln2820">      // path/fo.o.h.bak Try all directories in 'backupdir', first one</a>
<a name="ln2821">      // that works is used.</a>
<a name="ln2822">      dirp = p_bdir;</a>
<a name="ln2823">      while (*dirp) {</a>
<a name="ln2824">        // Isolate one directory name and make the backup file name.</a>
<a name="ln2825">        size_t dir_len = copy_option_part(&amp;dirp, (char *)IObuff, IOSIZE, &quot;,&quot;);</a>
<a name="ln2826">        p = (char *)IObuff + dir_len;</a>
<a name="ln2827">        bool trailing_pathseps = after_pathsep((char *)IObuff, p) &amp;&amp; p[-1] == p[-2];</a>
<a name="ln2828">        if (trailing_pathseps) {</a>
<a name="ln2829">          IObuff[dir_len - 2] = NUL;</a>
<a name="ln2830">        }</a>
<a name="ln2831">        if (*dirp == NUL &amp;&amp; !os_isdir((char *)IObuff)) {</a>
<a name="ln2832">          int ret;</a>
<a name="ln2833">          char *failed_dir;</a>
<a name="ln2834">          if ((ret = os_mkdir_recurse((char *)IObuff, 0755, &amp;failed_dir)) != 0) {</a>
<a name="ln2835">            semsg(_(&quot;E303: Unable to create directory \&quot;%s\&quot; for backup file: %s&quot;),</a>
<a name="ln2836">                  failed_dir, os_strerror(ret));</a>
<a name="ln2837">            xfree(failed_dir);</a>
<a name="ln2838">          }</a>
<a name="ln2839">        }</a>
<a name="ln2840">        if (trailing_pathseps) {</a>
<a name="ln2841">          // path ends with '//', use full path</a>
<a name="ln2842">          if ((p = make_percent_swname((char *)IObuff, fname))</a>
<a name="ln2843">              != NULL) {</a>
<a name="ln2844">            backup = modname(p, backup_ext, no_prepend_dot);</a>
<a name="ln2845">            xfree(p);</a>
<a name="ln2846">          }</a>
<a name="ln2847">        }</a>
<a name="ln2848"> </a>
<a name="ln2849">        if (backup == NULL) {</a>
<a name="ln2850">          rootname = get_file_in_dir(fname, (char *)IObuff);</a>
<a name="ln2851">          if (rootname == NULL) {</a>
<a name="ln2852">            backup = NULL;</a>
<a name="ln2853">          } else {</a>
<a name="ln2854">            backup = modname(rootname, backup_ext, no_prepend_dot);</a>
<a name="ln2855">            xfree(rootname);</a>
<a name="ln2856">          }</a>
<a name="ln2857">        }</a>
<a name="ln2858"> </a>
<a name="ln2859">        if (backup != NULL) {</a>
<a name="ln2860">          // If we are not going to keep the backup file, don't</a>
<a name="ln2861">          // delete an existing one, try to use another name.</a>
<a name="ln2862">          // Change one character, just before the extension.</a>
<a name="ln2863">          if (!p_bk &amp;&amp; os_path_exists(backup)) {</a>
<a name="ln2864">            p = backup + strlen(backup) - 1 - strlen(backup_ext);</a>
<a name="ln2865">            if (p &lt; backup) {           // empty file name ???</a>
<a name="ln2866">              p = backup;</a>
<a name="ln2867">            }</a>
<a name="ln2868">            *p = 'z';</a>
<a name="ln2869">            while (*p &gt; 'a' &amp;&amp; os_path_exists(backup)) {</a>
<a name="ln2870">              (*p)--;</a>
<a name="ln2871">            }</a>
<a name="ln2872">            // They all exist??? Must be something wrong!</a>
<a name="ln2873">            if (*p == 'a') {</a>
<a name="ln2874">              XFREE_CLEAR(backup);</a>
<a name="ln2875">            }</a>
<a name="ln2876">          }</a>
<a name="ln2877">        }</a>
<a name="ln2878">        if (backup != NULL) {</a>
<a name="ln2879">          // Delete any existing backup and move the current version</a>
<a name="ln2880">          // to the backup. For safety, we don't remove the backup</a>
<a name="ln2881">          // until the write has finished successfully. And if the</a>
<a name="ln2882">          // 'backup' option is set, leave it around.</a>
<a name="ln2883"> </a>
<a name="ln2884">          // If the renaming of the original file to the backup file</a>
<a name="ln2885">          // works, quit here.</a>
<a name="ln2886">          ///</a>
<a name="ln2887">          if (vim_rename(fname, backup) == 0) {</a>
<a name="ln2888">            break;</a>
<a name="ln2889">          }</a>
<a name="ln2890"> </a>
<a name="ln2891">          XFREE_CLEAR(backup);             // don't do the rename below</a>
<a name="ln2892">        }</a>
<a name="ln2893">      }</a>
<a name="ln2894">      if (backup == NULL &amp;&amp; !forceit) {</a>
<a name="ln2895">        SET_ERRMSG(_(&quot;E510: Can't make backup file (add ! to override)&quot;));</a>
<a name="ln2896">        goto fail;</a>
<a name="ln2897">      }</a>
<a name="ln2898">    }</a>
<a name="ln2899">  }</a>
<a name="ln2900"> </a>
<a name="ln2901">#if defined(UNIX)</a>
<a name="ln2902">  // When using &quot;:w!&quot; and the file was read-only: make it writable</a>
<a name="ln2903">  if (forceit &amp;&amp; perm &gt;= 0 &amp;&amp; !(perm &amp; 0200)</a>
<a name="ln2904">      &amp;&amp; file_info_old.stat.st_uid == getuid()</a>
<a name="ln2905">      &amp;&amp; vim_strchr(p_cpo, CPO_FWRITE) == NULL) {</a>
<a name="ln2906">    perm |= 0200;</a>
<a name="ln2907">    (void)os_setperm((const char *)fname, (int)perm);</a>
<a name="ln2908">    made_writable = true;</a>
<a name="ln2909">  }</a>
<a name="ln2910">#endif</a>
<a name="ln2911"> </a>
<a name="ln2912">  // When using &quot;:w!&quot; and writing to the current file, 'readonly' makes no</a>
<a name="ln2913">  // sense, reset it, unless 'Z' appears in 'cpoptions'.</a>
<a name="ln2914">  if (forceit &amp;&amp; overwriting &amp;&amp; vim_strchr(p_cpo, CPO_KEEPRO) == NULL) {</a>
<a name="ln2915">    buf-&gt;b_p_ro = false;</a>
<a name="ln2916">    need_maketitle = true;          // set window title later</a>
<a name="ln2917">    status_redraw_all();            // redraw status lines later</a>
<a name="ln2918">  }</a>
<a name="ln2919"> </a>
<a name="ln2920">  if (end &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2921">    end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2922">  }</a>
<a name="ln2923">  if (buf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln2924">    start = end + 1;</a>
<a name="ln2925">  }</a>
<a name="ln2926"> </a>
<a name="ln2927">  // If the original file is being overwritten, there is a small chance that</a>
<a name="ln2928">  // we crash in the middle of writing. Therefore the file is preserved now.</a>
<a name="ln2929">  // This makes all block numbers positive so that recovery does not need</a>
<a name="ln2930">  // the original file.</a>
<a name="ln2931">  // Don't do this if there is a backup file and we are exiting.</a>
<a name="ln2932">  if (reset_changed &amp;&amp; !newfile &amp;&amp; overwriting</a>
<a name="ln2933">      &amp;&amp; !(exiting &amp;&amp; backup != NULL)) {</a>
<a name="ln2934">    ml_preserve(buf, false, !!p_fs);</a>
<a name="ln2935">    if (got_int) {</a>
<a name="ln2936">      SET_ERRMSG(_(e_interr));</a>
<a name="ln2937">      goto restore_backup;</a>
<a name="ln2938">    }</a>
<a name="ln2939">  }</a>
<a name="ln2940"> </a>
<a name="ln2941">  // Default: write the file directly.  May write to a temp file for</a>
<a name="ln2942">  // multi-byte conversion.</a>
<a name="ln2943">  wfname = fname;</a>
<a name="ln2944"> </a>
<a name="ln2945">  // Check for forced 'fileencoding' from &quot;++opt=val&quot; argument.</a>
<a name="ln2946">  if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln2947">    fenc = eap-&gt;cmd + eap-&gt;force_enc;</a>
<a name="ln2948">    fenc = enc_canonize(fenc);</a>
<a name="ln2949">    fenc_tofree = fenc;</a>
<a name="ln2950">  } else {</a>
<a name="ln2951">    fenc = buf-&gt;b_p_fenc;</a>
<a name="ln2952">  }</a>
<a name="ln2953"> </a>
<a name="ln2954">  // Check if the file needs to be converted.</a>
<a name="ln2955">  converted = need_conversion(fenc);</a>
<a name="ln2956"> </a>
<a name="ln2957">  // Check if UTF-8 to UCS-2/4 or Latin1 conversion needs to be done.  Or</a>
<a name="ln2958">  // Latin1 to Unicode conversion.  This is handled in buf_write_bytes().</a>
<a name="ln2959">  // Prepare the flags for it and allocate bw_conv_buf when needed.</a>
<a name="ln2960">  if (converted) {</a>
<a name="ln2961">    wb_flags = get_fio_flags((char_u *)fenc);</a>
<a name="ln2962">    if (wb_flags &amp; (FIO_UCS2 | FIO_UCS4 | FIO_UTF16 | FIO_UTF8)) {</a>
<a name="ln2963">      // Need to allocate a buffer to translate into.</a>
<a name="ln2964">      if (wb_flags &amp; (FIO_UCS2 | FIO_UTF16 | FIO_UTF8)) {</a>
<a name="ln2965">        write_info.bw_conv_buflen = (size_t)bufsize * 2;</a>
<a name="ln2966">      } else {       // FIO_UCS4</a>
<a name="ln2967">        write_info.bw_conv_buflen = (size_t)bufsize * 4;</a>
<a name="ln2968">      }</a>
<a name="ln2969">      write_info.bw_conv_buf = verbose_try_malloc(write_info.bw_conv_buflen);</a>
<a name="ln2970">      if (!write_info.bw_conv_buf) {</a>
<a name="ln2971">        end = 0;</a>
<a name="ln2972">      }</a>
<a name="ln2973">    }</a>
<a name="ln2974">  }</a>
<a name="ln2975"> </a>
<a name="ln2976">  if (converted &amp;&amp; wb_flags == 0) {</a>
<a name="ln2977">#ifdef HAVE_ICONV</a>
<a name="ln2978">    // Use iconv() conversion when conversion is needed and it's not done</a>
<a name="ln2979">    // internally.</a>
<a name="ln2980">    write_info.bw_iconv_fd = (iconv_t)my_iconv_open((char_u *)fenc, (char_u *)&quot;utf-8&quot;);</a>
<a name="ln2981">    if (write_info.bw_iconv_fd != (iconv_t)-1) {</a>
<a name="ln2982">      // We're going to use iconv(), allocate a buffer to convert in.</a>
<a name="ln2983">      write_info.bw_conv_buflen = (size_t)bufsize * ICONV_MULT;</a>
<a name="ln2984">      write_info.bw_conv_buf = verbose_try_malloc(write_info.bw_conv_buflen);</a>
<a name="ln2985">      if (!write_info.bw_conv_buf) {</a>
<a name="ln2986">        end = 0;</a>
<a name="ln2987">      }</a>
<a name="ln2988">      write_info.bw_first = true;</a>
<a name="ln2989">    } else {</a>
<a name="ln2990">#endif</a>
<a name="ln2991"> </a>
<a name="ln2992">    // When the file needs to be converted with 'charconvert' after</a>
<a name="ln2993">    // writing, write to a temp file instead and let the conversion</a>
<a name="ln2994">    // overwrite the original file.</a>
<a name="ln2995">    if (*p_ccv != NUL) {</a>
<a name="ln2996">      wfname = vim_tempname();</a>
<a name="ln2997">      if (wfname == NULL) {  // Can't write without a tempfile!</a>
<a name="ln2998">        SET_ERRMSG(_(&quot;E214: Can't find temp file for writing&quot;));</a>
<a name="ln2999">        goto restore_backup;</a>
<a name="ln3000">      }</a>
<a name="ln3001">    }</a>
<a name="ln3002">  }</a>
<a name="ln3003"> </a>
<a name="ln3004">#ifdef HAVE_ICONV</a>
<a name="ln3005">}</a>
<a name="ln3006">#endif</a>
<a name="ln3007"> </a>
<a name="ln3008">  if (converted &amp;&amp; wb_flags == 0</a>
<a name="ln3009">#ifdef HAVE_ICONV</a>
<a name="ln3010">      &amp;&amp; write_info.bw_iconv_fd == (iconv_t)-1</a>
<a name="ln3011">#endif</a>
<a name="ln3012">      &amp;&amp; wfname == fname) {</a>
<a name="ln3013">    if (!forceit) {</a>
<a name="ln3014">      SET_ERRMSG(_(&quot;E213: Cannot convert (add ! to write without conversion)&quot;));</a>
<a name="ln3015">      goto restore_backup;</a>
<a name="ln3016">    }</a>
<a name="ln3017">    notconverted = true;</a>
<a name="ln3018">  }</a>
<a name="ln3019"> </a>
<a name="ln3020">  // If conversion is taking place, we may first pretend to write and check</a>
<a name="ln3021">  // for conversion errors.  Then loop again to write for real.</a>
<a name="ln3022">  // When not doing conversion this writes for real right away.</a>
<a name="ln3023">  for (checking_conversion = true;; checking_conversion = false) {</a>
<a name="ln3024">    // There is no need to check conversion when:</a>
<a name="ln3025">    // - there is no conversion</a>
<a name="ln3026">    // - we make a backup file, that can be restored in case of conversion</a>
<a name="ln3027">    // failure.</a>
<a name="ln3028">    if (!converted || dobackup) {</a>
<a name="ln3029">      checking_conversion = false;</a>
<a name="ln3030">    }</a>
<a name="ln3031"> </a>
<a name="ln3032">    if (checking_conversion) {</a>
<a name="ln3033">      // Make sure we don't write anything.</a>
<a name="ln3034">      fd = -1;</a>
<a name="ln3035">      write_info.bw_fd = fd;</a>
<a name="ln3036">    } else {</a>
<a name="ln3037">      // Open the file &quot;wfname&quot; for writing.</a>
<a name="ln3038">      // We may try to open the file twice: If we can't write to the file</a>
<a name="ln3039">      // and forceit is true we delete the existing file and try to</a>
<a name="ln3040">      // create a new one. If this still fails we may have lost the</a>
<a name="ln3041">      // original file!  (this may happen when the user reached his</a>
<a name="ln3042">      // quotum for number of files).</a>
<a name="ln3043">      // Appending will fail if the file does not exist and forceit is</a>
<a name="ln3044">      // false.</a>
<a name="ln3045">      while ((fd = os_open(wfname,</a>
<a name="ln3046">                           O_WRONLY |</a>
<a name="ln3047">                           (append</a>
<a name="ln3048">                            ? (forceit</a>
<a name="ln3049">                               ? (O_APPEND | O_CREAT)</a>
<a name="ln3050">                               : O_APPEND)</a>
<a name="ln3051">                            : (O_CREAT | O_TRUNC)),</a>
<a name="ln3052">                           perm &lt; 0 ? 0666 : (perm &amp; 0777))) &lt; 0) {</a>
<a name="ln3053">        // A forced write will try to create a new file if the old one</a>
<a name="ln3054">        // is still readonly. This may also happen when the directory</a>
<a name="ln3055">        // is read-only. In that case the mch_remove() will fail.</a>
<a name="ln3056">        if (errmsg == NULL) {</a>
<a name="ln3057">#ifdef UNIX</a>
<a name="ln3058">          FileInfo file_info;</a>
<a name="ln3059"> </a>
<a name="ln3060">          // Don't delete the file when it's a hard or symbolic link.</a>
<a name="ln3061">          if ((!newfile &amp;&amp; os_fileinfo_hardlinks(&amp;file_info_old) &gt; 1)</a>
<a name="ln3062">              || (os_fileinfo_link(fname, &amp;file_info)</a>
<a name="ln3063">                  &amp;&amp; !os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old))) {</a>
<a name="ln3064">            SET_ERRMSG(_(&quot;E166: Can't open linked file for writing&quot;));</a>
<a name="ln3065">          } else {</a>
<a name="ln3066">#endif</a>
<a name="ln3067">          SET_ERRMSG_ARG(_(&quot;E212: Can't open file for writing: %s&quot;), fd);</a>
<a name="ln3068">          if (forceit &amp;&amp; vim_strchr(p_cpo, CPO_FWRITE) == NULL</a>
<a name="ln3069">              &amp;&amp; perm &gt;= 0) {</a>
<a name="ln3070">#ifdef UNIX</a>
<a name="ln3071">            // we write to the file, thus it should be marked</a>
<a name="ln3072">            // writable after all</a>
<a name="ln3073">            if (!(perm &amp; 0200)) {</a>
<a name="ln3074">              made_writable = true;</a>
<a name="ln3075">            }</a>
<a name="ln3076">            perm |= 0200;</a>
<a name="ln3077">            if (file_info_old.stat.st_uid != getuid()</a>
<a name="ln3078">                || file_info_old.stat.st_gid != getgid()) {</a>
<a name="ln3079">              perm &amp;= 0777;</a>
<a name="ln3080">            }</a>
<a name="ln3081">#endif</a>
<a name="ln3082">            if (!append) {                    // don't remove when appending</a>
<a name="ln3083">              os_remove(wfname);</a>
<a name="ln3084">            }</a>
<a name="ln3085">            continue;</a>
<a name="ln3086">          }</a>
<a name="ln3087">#ifdef UNIX</a>
<a name="ln3088">        }</a>
<a name="ln3089">#endif</a>
<a name="ln3090">        }</a>
<a name="ln3091"> </a>
<a name="ln3092">restore_backup:</a>
<a name="ln3093">        {</a>
<a name="ln3094">          // If we failed to open the file, we don't need a backup. Throw it</a>
<a name="ln3095">          // away.  If we moved or removed the original file try to put the</a>
<a name="ln3096">          // backup in its place.</a>
<a name="ln3097">          if (backup != NULL &amp;&amp; wfname == fname) {</a>
<a name="ln3098">            if (backup_copy) {</a>
<a name="ln3099">              // There is a small chance that we removed the original,</a>
<a name="ln3100">              // try to move the copy in its place.</a>
<a name="ln3101">              // This may not work if the vim_rename() fails.</a>
<a name="ln3102">              // In that case we leave the copy around.</a>
<a name="ln3103">              // If file does not exist, put the copy in its place</a>
<a name="ln3104">              if (!os_path_exists(fname)) {</a>
<a name="ln3105">                vim_rename(backup, fname);</a>
<a name="ln3106">              }</a>
<a name="ln3107">              // if original file does exist throw away the copy</a>
<a name="ln3108">              if (os_path_exists(fname)) {</a>
<a name="ln3109">                os_remove(backup);</a>
<a name="ln3110">              }</a>
<a name="ln3111">            } else {</a>
<a name="ln3112">              // try to put the original file back</a>
<a name="ln3113">              vim_rename(backup, fname);</a>
<a name="ln3114">            }</a>
<a name="ln3115">          }</a>
<a name="ln3116"> </a>
<a name="ln3117">          // if original file no longer exists give an extra warning</a>
<a name="ln3118">          if (!newfile &amp;&amp; !os_path_exists(fname)) {</a>
<a name="ln3119">            end = 0;</a>
<a name="ln3120">          }</a>
<a name="ln3121">        }</a>
<a name="ln3122"> </a>
<a name="ln3123">        if (wfname != fname) {</a>
<a name="ln3124">          xfree(wfname);</a>
<a name="ln3125">        }</a>
<a name="ln3126">        goto fail;</a>
<a name="ln3127">      }</a>
<a name="ln3128">      write_info.bw_fd = fd;</a>
<a name="ln3129">    }</a>
<a name="ln3130">    SET_ERRMSG(NULL);</a>
<a name="ln3131"> </a>
<a name="ln3132">    write_info.bw_buf = (char_u *)buffer;</a>
<a name="ln3133">    nchars = 0;</a>
<a name="ln3134"> </a>
<a name="ln3135">    // use &quot;++bin&quot;, &quot;++nobin&quot; or 'binary'</a>
<a name="ln3136">    if (eap != NULL &amp;&amp; eap-&gt;force_bin != 0) {</a>
<a name="ln3137">      write_bin = (eap-&gt;force_bin == FORCE_BIN);</a>
<a name="ln3138">    } else {</a>
<a name="ln3139">      write_bin = buf-&gt;b_p_bin;</a>
<a name="ln3140">    }</a>
<a name="ln3141"> </a>
<a name="ln3142">    // Skip the BOM when appending and the file already existed, the BOM</a>
<a name="ln3143">    // only makes sense at the start of the file.</a>
<a name="ln3144">    if (buf-&gt;b_p_bomb &amp;&amp; !write_bin &amp;&amp; (!append || perm &lt; 0)) {</a>
<a name="ln3145">      write_info.bw_len = make_bom((char_u *)buffer, (char_u *)fenc);</a>
<a name="ln3146">      if (write_info.bw_len &gt; 0) {</a>
<a name="ln3147">        // don't convert</a>
<a name="ln3148">        write_info.bw_flags = FIO_NOCONVERT | wb_flags;</a>
<a name="ln3149">        if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3150">          end = 0;</a>
<a name="ln3151">        } else {</a>
<a name="ln3152">          nchars += write_info.bw_len;</a>
<a name="ln3153">        }</a>
<a name="ln3154">      }</a>
<a name="ln3155">    }</a>
<a name="ln3156">    write_info.bw_start_lnum = start;</a>
<a name="ln3157"> </a>
<a name="ln3158">    write_undo_file = (buf-&gt;b_p_udf &amp;&amp; overwriting &amp;&amp; !append</a>
<a name="ln3159">                       &amp;&amp; !filtering &amp;&amp; reset_changed &amp;&amp; !checking_conversion);</a>
<a name="ln3160">    if (write_undo_file) {</a>
<a name="ln3161">      // Prepare for computing the hash value of the text.</a>
<a name="ln3162">      sha256_start(&amp;sha_ctx);</a>
<a name="ln3163">    }</a>
<a name="ln3164"> </a>
<a name="ln3165">    write_info.bw_len = bufsize;</a>
<a name="ln3166">#ifdef HAS_BW_FLAGS</a>
<a name="ln3167">    write_info.bw_flags = wb_flags;</a>
<a name="ln3168">#endif</a>
<a name="ln3169">    fileformat = get_fileformat_force(buf, eap);</a>
<a name="ln3170">    s = buffer;</a>
<a name="ln3171">    len = 0;</a>
<a name="ln3172">    for (lnum = start; lnum &lt;= end; lnum++) {</a>
<a name="ln3173">      // The next while loop is done once for each character written.</a>
<a name="ln3174">      // Keep it fast!</a>
<a name="ln3175">      ptr = ml_get_buf(buf, lnum, false) - 1;</a>
<a name="ln3176">      if (write_undo_file) {</a>
<a name="ln3177">        sha256_update(&amp;sha_ctx, (char_u *)ptr + 1, (uint32_t)(strlen(ptr + 1) + 1));</a>
<a name="ln3178">      }</a>
<a name="ln3179">      while ((c = *++ptr) != NUL) {</a>
<a name="ln3180">        if (c == NL) {</a>
<a name="ln3181">          *s = NUL;                       // replace newlines with NULs</a>
<a name="ln3182">        } else if (c == CAR &amp;&amp; fileformat == EOL_MAC) {</a>
<a name="ln3183">          *s = NL;                        // Mac: replace CRs with NLs</a>
<a name="ln3184">        } else {</a>
<a name="ln3185">          *s = c;</a>
<a name="ln3186">        }</a>
<a name="ln3187">        s++;</a>
<a name="ln3188">        if (++len != bufsize) {</a>
<a name="ln3189">          continue;</a>
<a name="ln3190">        }</a>
<a name="ln3191">        if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3192">          end = 0;                        // write error: break loop</a>
<a name="ln3193">          break;</a>
<a name="ln3194">        }</a>
<a name="ln3195">        nchars += bufsize;</a>
<a name="ln3196">        s = buffer;</a>
<a name="ln3197">        len = 0;</a>
<a name="ln3198">        write_info.bw_start_lnum = lnum;</a>
<a name="ln3199">      }</a>
<a name="ln3200">      if (!buf-&gt;b_p_fixeol &amp;&amp; buf-&gt;b_p_eof) {</a>
<a name="ln3201">        // write trailing CTRL-Z</a>
<a name="ln3202">        (void)write_eintr(write_info.bw_fd, &quot;\x1a&quot;, 1);</a>
<a name="ln3203">      }</a>
<a name="ln3204"> </a>
<a name="ln3205">      // write failed or last line has no EOL: stop here</a>
<a name="ln3206">      if (end == 0</a>
<a name="ln3207">          || (lnum == end</a>
<a name="ln3208">              &amp;&amp; (write_bin || !buf-&gt;b_p_fixeol)</a>
<a name="ln3209">              &amp;&amp; ((write_bin &amp;&amp; lnum == buf-&gt;b_no_eol_lnum)</a>
<a name="ln3210">                  || (lnum == buf-&gt;b_ml.ml_line_count &amp;&amp; !buf-&gt;b_p_eol)))) {</a>
<a name="ln3211">        lnum++;                           // written the line, count it</a>
<a name="ln3212">        no_eol = true;</a>
<a name="ln3213">        break;</a>
<a name="ln3214">      }</a>
<a name="ln3215">      if (fileformat == EOL_UNIX) {</a>
<a name="ln3216">        *s++ = NL;</a>
<a name="ln3217">      } else {</a>
<a name="ln3218">        *s++ = CAR;                       // EOL_MAC or EOL_DOS: write CR</a>
<a name="ln3219">        if (fileformat == EOL_DOS) {      // write CR-NL</a>
<a name="ln3220">          if (++len == bufsize) {</a>
<a name="ln3221">            if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3222">              end = 0;                    // write error: break loop</a>
<a name="ln3223">              break;</a>
<a name="ln3224">            }</a>
<a name="ln3225">            nchars += bufsize;</a>
<a name="ln3226">            s = buffer;</a>
<a name="ln3227">            len = 0;</a>
<a name="ln3228">          }</a>
<a name="ln3229">          *s++ = NL;</a>
<a name="ln3230">        }</a>
<a name="ln3231">      }</a>
<a name="ln3232">      if (++len == bufsize) {</a>
<a name="ln3233">        if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3234">          end = 0;  // Write error: break loop.</a>
<a name="ln3235">          break;</a>
<a name="ln3236">        }</a>
<a name="ln3237">        nchars += bufsize;</a>
<a name="ln3238">        s = buffer;</a>
<a name="ln3239">        len = 0;</a>
<a name="ln3240"> </a>
<a name="ln3241">        os_breakcheck();</a>
<a name="ln3242">        if (got_int) {</a>
<a name="ln3243">          end = 0;  // Interrupted, break loop.</a>
<a name="ln3244">          break;</a>
<a name="ln3245">        }</a>
<a name="ln3246">      }</a>
<a name="ln3247">    }</a>
<a name="ln3248">    if (len &gt; 0 &amp;&amp; end &gt; 0) {</a>
<a name="ln3249">      write_info.bw_len = len;</a>
<a name="ln3250">      if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3251">        end = 0;                      // write error</a>
<a name="ln3252">      }</a>
<a name="ln3253">      nchars += len;</a>
<a name="ln3254">    }</a>
<a name="ln3255"> </a>
<a name="ln3256">    // Stop when writing done or an error was encountered.</a>
<a name="ln3257">    if (!checking_conversion || end == 0) {</a>
<a name="ln3258">      break;</a>
<a name="ln3259">    }</a>
<a name="ln3260"> </a>
<a name="ln3261">    // If no error happened until now, writing should be ok, so loop to</a>
<a name="ln3262">    // really write the buffer.</a>
<a name="ln3263">  }</a>
<a name="ln3264"> </a>
<a name="ln3265">  // If we started writing, finish writing. Also when an error was</a>
<a name="ln3266">  // encountered.</a>
<a name="ln3267">  if (!checking_conversion) {</a>
<a name="ln3268">    // On many journalling file systems there is a bug that causes both the</a>
<a name="ln3269">    // original and the backup file to be lost when halting the system right</a>
<a name="ln3270">    // after writing the file.  That's because only the meta-data is</a>
<a name="ln3271">    // journalled.  Syncing the file slows down the system, but assures it has</a>
<a name="ln3272">    // been written to disk and we don't lose it.</a>
<a name="ln3273">    // For a device do try the fsync() but don't complain if it does not work</a>
<a name="ln3274">    // (could be a pipe).</a>
<a name="ln3275">    // If the 'fsync' option is false, don't fsync().  Useful for laptops.</a>
<a name="ln3276">    int error;</a>
<a name="ln3277">    if (p_fs &amp;&amp; (error = os_fsync(fd)) != 0 &amp;&amp; !device</a>
<a name="ln3278">        // fsync not supported on this storage.</a>
<a name="ln3279">        &amp;&amp; error != UV_ENOTSUP) {</a>
<a name="ln3280">      SET_ERRMSG_ARG(e_fsync, error);</a>
<a name="ln3281">      end = 0;</a>
<a name="ln3282">    }</a>
<a name="ln3283"> </a>
<a name="ln3284">#ifdef UNIX</a>
<a name="ln3285">    // When creating a new file, set its owner/group to that of the original</a>
<a name="ln3286">    // file.  Get the new device and inode number.</a>
<a name="ln3287">    if (backup != NULL &amp;&amp; !backup_copy) {</a>
<a name="ln3288">      // don't change the owner when it's already OK, some systems remove</a>
<a name="ln3289">      // permission or ACL stuff</a>
<a name="ln3290">      FileInfo file_info;</a>
<a name="ln3291">      if (!os_fileinfo(wfname, &amp;file_info)</a>
<a name="ln3292">          || file_info.stat.st_uid != file_info_old.stat.st_uid</a>
<a name="ln3293">          || file_info.stat.st_gid != file_info_old.stat.st_gid) {</a>
<a name="ln3294">        os_fchown(fd, (uv_uid_t)file_info_old.stat.st_uid, (uv_gid_t)file_info_old.stat.st_gid);</a>
<a name="ln3295">        if (perm &gt;= 0) {  // Set permission again, may have changed.</a>
<a name="ln3296">          (void)os_setperm(wfname, (int)perm);</a>
<a name="ln3297">        }</a>
<a name="ln3298">      }</a>
<a name="ln3299">      buf_set_file_id(buf);</a>
<a name="ln3300">    } else if (!buf-&gt;file_id_valid) {</a>
<a name="ln3301">      // Set the file_id when creating a new file.</a>
<a name="ln3302">      buf_set_file_id(buf);</a>
<a name="ln3303">    }</a>
<a name="ln3304">#endif</a>
<a name="ln3305"> </a>
<a name="ln3306">    if ((error = os_close(fd)) != 0) {</a>
<a name="ln3307">      SET_ERRMSG_ARG(_(&quot;E512: Close failed: %s&quot;), error);</a>
<a name="ln3308">      end = 0;</a>
<a name="ln3309">    }</a>
<a name="ln3310"> </a>
<a name="ln3311">#ifdef UNIX</a>
<a name="ln3312">    if (made_writable) {</a>
<a name="ln3313">      perm &amp;= ~0200;              // reset 'w' bit for security reasons</a>
<a name="ln3314">    }</a>
<a name="ln3315">#endif</a>
<a name="ln3316">    if (perm &gt;= 0) {  // Set perm. of new file same as old file.</a>
<a name="ln3317">      (void)os_setperm((const char *)wfname, (int)perm);</a>
<a name="ln3318">    }</a>
<a name="ln3319">#ifdef HAVE_ACL</a>
<a name="ln3320">    // Probably need to set the ACL before changing the user (can't set the</a>
<a name="ln3321">    // ACL on a file the user doesn't own).</a>
<a name="ln3322">    if (!backup_copy) {</a>
<a name="ln3323">      mch_set_acl((char_u *)wfname, acl);</a>
<a name="ln3324">    }</a>
<a name="ln3325">#endif</a>
<a name="ln3326"> </a>
<a name="ln3327">    if (wfname != fname) {</a>
<a name="ln3328">      // The file was written to a temp file, now it needs to be converted</a>
<a name="ln3329">      // with 'charconvert' to (overwrite) the output file.</a>
<a name="ln3330">      if (end != 0) {</a>
<a name="ln3331">        if (eval_charconvert(&quot;utf-8&quot;, fenc, wfname, fname) == FAIL) {</a>
<a name="ln3332">          write_info.bw_conv_error = true;</a>
<a name="ln3333">          end = 0;</a>
<a name="ln3334">        }</a>
<a name="ln3335">      }</a>
<a name="ln3336">      os_remove(wfname);</a>
<a name="ln3337">      xfree(wfname);</a>
<a name="ln3338">    }</a>
<a name="ln3339">  }</a>
<a name="ln3340"> </a>
<a name="ln3341">  if (end == 0) {</a>
<a name="ln3342">    // Error encountered.</a>
<a name="ln3343">    if (errmsg == NULL) {</a>
<a name="ln3344">      if (write_info.bw_conv_error) {</a>
<a name="ln3345">        if (write_info.bw_conv_error_lnum == 0) {</a>
<a name="ln3346">          SET_ERRMSG(_(&quot;E513: write error, conversion failed &quot;</a>
<a name="ln3347">                       &quot;(make 'fenc' empty to override)&quot;));</a>
<a name="ln3348">        } else {</a>
<a name="ln3349">          errmsg_allocated = true;</a>
<a name="ln3350">          SET_ERRMSG(xmalloc(300));</a>
<a name="ln3351">          vim_snprintf(errmsg, 300,  // NOLINT(runtime/printf)</a>
<a name="ln3352">                       _(&quot;E513: write error, conversion failed in line %&quot; PRIdLINENR</a>
<a name="ln3353">                         &quot; (make 'fenc' empty to override)&quot;),</a>
<a name="ln3354">                       write_info.bw_conv_error_lnum);</a>
<a name="ln3355">        }</a>
<a name="ln3356">      } else if (got_int) {</a>
<a name="ln3357">        SET_ERRMSG(_(e_interr));</a>
<a name="ln3358">      } else {</a>
<a name="ln3359">        SET_ERRMSG(_(&quot;E514: write error (file system full?)&quot;));</a>
<a name="ln3360">      }</a>
<a name="ln3361">    }</a>
<a name="ln3362"> </a>
<a name="ln3363">    // If we have a backup file, try to put it in place of the new file,</a>
<a name="ln3364">    // because the new file is probably corrupt.  This avoids losing the</a>
<a name="ln3365">    // original file when trying to make a backup when writing the file a</a>
<a name="ln3366">    // second time.</a>
<a name="ln3367">    // When &quot;backup_copy&quot; is set we need to copy the backup over the new</a>
<a name="ln3368">    // file.  Otherwise rename the backup file.</a>
<a name="ln3369">    // If this is OK, don't give the extra warning message.</a>
<a name="ln3370">    if (backup != NULL) {</a>
<a name="ln3371">      if (backup_copy) {</a>
<a name="ln3372">        // This may take a while, if we were interrupted let the user</a>
<a name="ln3373">        // know we got the message.</a>
<a name="ln3374">        if (got_int) {</a>
<a name="ln3375">          msg(_(e_interr));</a>
<a name="ln3376">          ui_flush();</a>
<a name="ln3377">        }</a>
<a name="ln3378"> </a>
<a name="ln3379">        // copy the file.</a>
<a name="ln3380">        if (os_copy(backup, fname, UV_FS_COPYFILE_FICLONE)</a>
<a name="ln3381">            == 0) {</a>
<a name="ln3382">          end = 1;  // success</a>
<a name="ln3383">        }</a>
<a name="ln3384">      } else {</a>
<a name="ln3385">        if (vim_rename(backup, fname) == 0) {</a>
<a name="ln3386">          end = 1;</a>
<a name="ln3387">        }</a>
<a name="ln3388">      }</a>
<a name="ln3389">    }</a>
<a name="ln3390">    goto fail;</a>
<a name="ln3391">  }</a>
<a name="ln3392"> </a>
<a name="ln3393">  lnum -= start;            // compute number of written lines</a>
<a name="ln3394">  no_wait_return--;         // may wait for return now</a>
<a name="ln3395"> </a>
<a name="ln3396">#if !defined(UNIX)</a>
<a name="ln3397">  fname = sfname;           // use shortname now, for the messages</a>
<a name="ln3398">#endif</a>
<a name="ln3399">  if (!filtering) {</a>
<a name="ln3400">    add_quoted_fname((char *)IObuff, IOSIZE, buf, (const char *)fname);</a>
<a name="ln3401">    c = false;</a>
<a name="ln3402">    if (write_info.bw_conv_error) {</a>
<a name="ln3403">      STRCAT(IObuff, _(&quot; CONVERSION ERROR&quot;));</a>
<a name="ln3404">      c = true;</a>
<a name="ln3405">      if (write_info.bw_conv_error_lnum != 0) {</a>
<a name="ln3406">        vim_snprintf_add((char *)IObuff, IOSIZE, _(&quot; in line %&quot; PRId64 &quot;;&quot;),</a>
<a name="ln3407">                         (int64_t)write_info.bw_conv_error_lnum);</a>
<a name="ln3408">      }</a>
<a name="ln3409">    } else if (notconverted) {</a>
<a name="ln3410">      STRCAT(IObuff, _(&quot;[NOT converted]&quot;));</a>
<a name="ln3411">      c = true;</a>
<a name="ln3412">    } else if (converted) {</a>
<a name="ln3413">      STRCAT(IObuff, _(&quot;[converted]&quot;));</a>
<a name="ln3414">      c = true;</a>
<a name="ln3415">    }</a>
<a name="ln3416">    if (device) {</a>
<a name="ln3417">      STRCAT(IObuff, _(&quot;[Device]&quot;));</a>
<a name="ln3418">      c = true;</a>
<a name="ln3419">    } else if (newfile) {</a>
<a name="ln3420">      STRCAT(IObuff, new_file_message());</a>
<a name="ln3421">      c = true;</a>
<a name="ln3422">    }</a>
<a name="ln3423">    if (no_eol) {</a>
<a name="ln3424">      msg_add_eol();</a>
<a name="ln3425">      c = true;</a>
<a name="ln3426">    }</a>
<a name="ln3427">    // may add [unix/dos/mac]</a>
<a name="ln3428">    if (msg_add_fileformat(fileformat)) {</a>
<a name="ln3429">      c = true;</a>
<a name="ln3430">    }</a>
<a name="ln3431">    msg_add_lines(c, (long)lnum, nchars);       // add line/char count</a>
<a name="ln3432">    if (!shortmess(SHM_WRITE)) {</a>
<a name="ln3433">      if (append) {</a>
<a name="ln3434">        STRCAT(IObuff, shortmess(SHM_WRI) ? _(&quot; [a]&quot;) : _(&quot; appended&quot;));</a>
<a name="ln3435">      } else {</a>
<a name="ln3436">        STRCAT(IObuff, shortmess(SHM_WRI) ? _(&quot; [w]&quot;) : _(&quot; written&quot;));</a>
<a name="ln3437">      }</a>
<a name="ln3438">    }</a>
<a name="ln3439"> </a>
<a name="ln3440">    set_keep_msg(msg_trunc_attr((char *)IObuff, false, 0), 0);</a>
<a name="ln3441">  }</a>
<a name="ln3442"> </a>
<a name="ln3443">  // When written everything correctly: reset 'modified'.  Unless not</a>
<a name="ln3444">  // writing to the original file and '+' is not in 'cpoptions'.</a>
<a name="ln3445">  if (reset_changed &amp;&amp; whole &amp;&amp; !append</a>
<a name="ln3446">      &amp;&amp; !write_info.bw_conv_error</a>
<a name="ln3447">      &amp;&amp; (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL)) {</a>
<a name="ln3448">    unchanged(buf, true, false);</a>
<a name="ln3449">    const varnumber_T changedtick = buf_get_changedtick(buf);</a>
<a name="ln3450">    if (buf-&gt;b_last_changedtick + 1 == changedtick) {</a>
<a name="ln3451">      // b:changedtick may be incremented in unchanged() but that</a>
<a name="ln3452">      // should not trigger a TextChanged event.</a>
<a name="ln3453">      buf-&gt;b_last_changedtick = changedtick;</a>
<a name="ln3454">    }</a>
<a name="ln3455">    u_unchanged(buf);</a>
<a name="ln3456">    u_update_save_nr(buf);</a>
<a name="ln3457">  }</a>
<a name="ln3458"> </a>
<a name="ln3459">  // If written to the current file, update the timestamp of the swap file</a>
<a name="ln3460">  // and reset the BF_WRITE_MASK flags. Also sets buf-&gt;b_mtime.</a>
<a name="ln3461">  if (overwriting) {</a>
<a name="ln3462">    ml_timestamp(buf);</a>
<a name="ln3463">    if (append) {</a>
<a name="ln3464">      buf-&gt;b_flags &amp;= ~BF_NEW;</a>
<a name="ln3465">    } else {</a>
<a name="ln3466">      buf-&gt;b_flags &amp;= ~BF_WRITE_MASK;</a>
<a name="ln3467">    }</a>
<a name="ln3468">  }</a>
<a name="ln3469"> </a>
<a name="ln3470">  // If we kept a backup until now, and we are in patch mode, then we make</a>
<a name="ln3471">  // the backup file our 'original' file.</a>
<a name="ln3472">  if (*p_pm &amp;&amp; dobackup) {</a>
<a name="ln3473">    char *const org = modname(fname, p_pm, false);</a>
<a name="ln3474"> </a>
<a name="ln3475">    if (backup != NULL) {</a>
<a name="ln3476">      // If the original file does not exist yet</a>
<a name="ln3477">      // the current backup file becomes the original file</a>
<a name="ln3478">      if (org == NULL) {</a>
<a name="ln3479">        emsg(_(&quot;E205: Patchmode: can't save original file&quot;));</a>
<a name="ln3480">      } else if (!os_path_exists(org)) {</a>
<a name="ln3481">        vim_rename(backup, org);</a>
<a name="ln3482">        XFREE_CLEAR(backup);                   // don't delete the file</a>
<a name="ln3483">#ifdef UNIX</a>
<a name="ln3484">        os_file_settime(org,</a>
<a name="ln3485">                        (double)file_info_old.stat.st_atim.tv_sec,</a>
<a name="ln3486">                        (double)file_info_old.stat.st_mtim.tv_sec);</a>
<a name="ln3487">#endif</a>
<a name="ln3488">      }</a>
<a name="ln3489">    } else {</a>
<a name="ln3490">      // If there is no backup file, remember that a (new) file was</a>
<a name="ln3491">      // created.</a>
<a name="ln3492">      int empty_fd;</a>
<a name="ln3493"> </a>
<a name="ln3494">      if (org == NULL</a>
<a name="ln3495">          || (empty_fd = os_open(org,</a>
<a name="ln3496">                                 O_CREAT | O_EXCL | O_NOFOLLOW,</a>
<a name="ln3497">                                 perm &lt; 0 ? 0666 : (perm &amp; 0777))) &lt; 0) {</a>
<a name="ln3498">        emsg(_(&quot;E206: patchmode: can't touch empty original file&quot;));</a>
<a name="ln3499">      } else {</a>
<a name="ln3500">        close(empty_fd);</a>
<a name="ln3501">      }</a>
<a name="ln3502">    }</a>
<a name="ln3503">    if (org != NULL) {</a>
<a name="ln3504">      os_setperm(org, os_getperm((const char *)fname) &amp; 0777);</a>
<a name="ln3505">      xfree(org);</a>
<a name="ln3506">    }</a>
<a name="ln3507">  }</a>
<a name="ln3508"> </a>
<a name="ln3509">  // Remove the backup unless 'backup' option is set</a>
<a name="ln3510">  if (!p_bk &amp;&amp; backup != NULL</a>
<a name="ln3511">      &amp;&amp; !write_info.bw_conv_error</a>
<a name="ln3512">      &amp;&amp; os_remove(backup) != 0) {</a>
<a name="ln3513">    emsg(_(&quot;E207: Can't delete backup file&quot;));</a>
<a name="ln3514">  }</a>
<a name="ln3515"> </a>
<a name="ln3516">  goto nofail;</a>
<a name="ln3517"> </a>
<a name="ln3518">  // Finish up.  We get here either after failure or success.</a>
<a name="ln3519">fail:</a>
<a name="ln3520">  no_wait_return--;             // may wait for return now</a>
<a name="ln3521">nofail:</a>
<a name="ln3522"> </a>
<a name="ln3523">  // Done saving, we accept changed buffer warnings again</a>
<a name="ln3524">  buf-&gt;b_saving = false;</a>
<a name="ln3525"> </a>
<a name="ln3526">  xfree(backup);</a>
<a name="ln3527">  if (buffer != smallbuf) {</a>
<a name="ln3528">    xfree(buffer);</a>
<a name="ln3529">  }</a>
<a name="ln3530">  xfree(fenc_tofree);</a>
<a name="ln3531">  xfree(write_info.bw_conv_buf);</a>
<a name="ln3532">#ifdef HAVE_ICONV</a>
<a name="ln3533">  if (write_info.bw_iconv_fd != (iconv_t)-1) {</a>
<a name="ln3534">    iconv_close(write_info.bw_iconv_fd);</a>
<a name="ln3535">    write_info.bw_iconv_fd = (iconv_t)-1;</a>
<a name="ln3536">  }</a>
<a name="ln3537">#endif</a>
<a name="ln3538">#ifdef HAVE_ACL</a>
<a name="ln3539">  mch_free_acl(acl);</a>
<a name="ln3540">#endif</a>
<a name="ln3541"> </a>
<a name="ln3542">  if (errmsg != NULL) {</a>
<a name="ln3543">    // - 100 to save some space for further error message</a>
<a name="ln3544">#ifndef UNIX</a>
<a name="ln3545">    add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)sfname);</a>
<a name="ln3546">#else</a>
<a name="ln3547">    add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)fname);</a>
<a name="ln3548">#endif</a>
<a name="ln3549">    if (errnum != NULL) {</a>
<a name="ln3550">      if (errmsgarg != 0) {</a>
<a name="ln3551">        semsg(&quot;%s: %s%s: %s&quot;, errnum, IObuff, errmsg, os_strerror(errmsgarg));</a>
<a name="ln3552">      } else {</a>
<a name="ln3553">        semsg(&quot;%s: %s%s&quot;, errnum, IObuff, errmsg);</a>
<a name="ln3554">      }</a>
<a name="ln3555">    } else if (errmsgarg != 0) {</a>
<a name="ln3556">      semsg(errmsg, os_strerror(errmsgarg));</a>
<a name="ln3557">    } else {</a>
<a name="ln3558">      emsg(errmsg);</a>
<a name="ln3559">    }</a>
<a name="ln3560">    if (errmsg_allocated) {</a>
<a name="ln3561">      xfree(errmsg);</a>
<a name="ln3562">    }</a>
<a name="ln3563"> </a>
<a name="ln3564">    retval = FAIL;</a>
<a name="ln3565">    if (end == 0) {</a>
<a name="ln3566">      const int attr = HL_ATTR(HLF_E);  // Set highlight for error messages.</a>
<a name="ln3567">      msg_puts_attr(_(&quot;\nWARNING: Original file may be lost or damaged\n&quot;),</a>
<a name="ln3568">                    attr | MSG_HIST);</a>
<a name="ln3569">      msg_puts_attr(_(&quot;don't quit the editor until the file is successfully written!&quot;),</a>
<a name="ln3570">                    attr | MSG_HIST);</a>
<a name="ln3571"> </a>
<a name="ln3572">      // Update the timestamp to avoid an &quot;overwrite changed file&quot;</a>
<a name="ln3573">      // prompt when writing again.</a>
<a name="ln3574">      if (os_fileinfo(fname, &amp;file_info_old)) {</a>
<a name="ln3575">        buf_store_file_info(buf, &amp;file_info_old);</a>
<a name="ln3576">        buf-&gt;b_mtime_read = buf-&gt;b_mtime;</a>
<a name="ln3577">        buf-&gt;b_mtime_read_ns = buf-&gt;b_mtime_ns;</a>
<a name="ln3578">      }</a>
<a name="ln3579">    }</a>
<a name="ln3580">  }</a>
<a name="ln3581">  msg_scroll = msg_save;</a>
<a name="ln3582"> </a>
<a name="ln3583">  // When writing the whole file and 'undofile' is set, also write the undo</a>
<a name="ln3584">  // file.</a>
<a name="ln3585">  if (retval == OK &amp;&amp; write_undo_file) {</a>
<a name="ln3586">    char hash[UNDO_HASH_SIZE];</a>
<a name="ln3587"> </a>
<a name="ln3588">    sha256_finish(&amp;sha_ctx, (char_u *)hash);</a>
<a name="ln3589">    u_write_undo(NULL, false, buf, (char_u *)hash);</a>
<a name="ln3590">  }</a>
<a name="ln3591"> </a>
<a name="ln3592">  if (!should_abort(retval)) {</a>
<a name="ln3593">    aco_save_T aco;</a>
<a name="ln3594"> </a>
<a name="ln3595">    curbuf-&gt;b_no_eol_lnum = 0;      // in case it was set by the previous read</a>
<a name="ln3596"> </a>
<a name="ln3597">    // Apply POST autocommands.</a>
<a name="ln3598">    // Careful: The autocommands may call buf_write() recursively!</a>
<a name="ln3599">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln3600"> </a>
<a name="ln3601">    if (append) {</a>
<a name="ln3602">      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,</a>
<a name="ln3603">                           false, curbuf, eap);</a>
<a name="ln3604">    } else if (filtering) {</a>
<a name="ln3605">      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,</a>
<a name="ln3606">                           false, curbuf, eap);</a>
<a name="ln3607">    } else if (reset_changed &amp;&amp; whole) {</a>
<a name="ln3608">      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,</a>
<a name="ln3609">                           false, curbuf, eap);</a>
<a name="ln3610">    } else {</a>
<a name="ln3611">      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,</a>
<a name="ln3612">                           false, curbuf, eap);</a>
<a name="ln3613">    }</a>
<a name="ln3614"> </a>
<a name="ln3615">    // restore curwin/curbuf and a few other things</a>
<a name="ln3616">    aucmd_restbuf(&amp;aco);</a>
<a name="ln3617"> </a>
<a name="ln3618">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln3619">      retval = false;</a>
<a name="ln3620">    }</a>
<a name="ln3621">  }</a>
<a name="ln3622"> </a>
<a name="ln3623">  got_int |= prev_got_int;</a>
<a name="ln3624"> </a>
<a name="ln3625">  return retval;</a>
<a name="ln3626">#undef SET_ERRMSG</a>
<a name="ln3627">#undef SET_ERRMSG_ARG</a>
<a name="ln3628">#undef SET_ERRMSG_NUM</a>
<a name="ln3629">}</a>
<a name="ln3630"> </a>
<a name="ln3631">/// Set the name of the current buffer.  Use when the buffer doesn't have a</a>
<a name="ln3632">/// name and a &quot;:r&quot; or &quot;:w&quot; command with a file name is used.</a>
<a name="ln3633">static int set_rw_fname(char_u *fname, char_u *sfname)</a>
<a name="ln3634">{</a>
<a name="ln3635">  buf_T *buf = curbuf;</a>
<a name="ln3636"> </a>
<a name="ln3637">  // It's like the unnamed buffer is deleted....</a>
<a name="ln3638">  if (curbuf-&gt;b_p_bl) {</a>
<a name="ln3639">    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, false, curbuf);</a>
<a name="ln3640">  }</a>
<a name="ln3641">  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, false, curbuf);</a>
<a name="ln3642">  if (aborting()) {         // autocmds may abort script processing</a>
<a name="ln3643">    return FAIL;</a>
<a name="ln3644">  }</a>
<a name="ln3645">  if (curbuf != buf) {</a>
<a name="ln3646">    // We are in another buffer now, don't do the renaming.</a>
<a name="ln3647">    emsg(_(e_auchangedbuf));</a>
<a name="ln3648">    return FAIL;</a>
<a name="ln3649">  }</a>
<a name="ln3650"> </a>
<a name="ln3651">  if (setfname(curbuf, (char *)fname, (char *)sfname, false) == OK) {</a>
<a name="ln3652">    curbuf-&gt;b_flags |= BF_NOTEDITED;</a>
<a name="ln3653">  }</a>
<a name="ln3654"> </a>
<a name="ln3655">  // ....and a new named one is created</a>
<a name="ln3656">  apply_autocmds(EVENT_BUFNEW, NULL, NULL, false, curbuf);</a>
<a name="ln3657">  if (curbuf-&gt;b_p_bl) {</a>
<a name="ln3658">    apply_autocmds(EVENT_BUFADD, NULL, NULL, false, curbuf);</a>
<a name="ln3659">  }</a>
<a name="ln3660">  if (aborting()) {         // autocmds may abort script processing</a>
<a name="ln3661">    return FAIL;</a>
<a name="ln3662">  }</a>
<a name="ln3663"> </a>
<a name="ln3664">  // Do filetype detection now if 'filetype' is empty.</a>
<a name="ln3665">  if (*curbuf-&gt;b_p_ft == NUL) {</a>
<a name="ln3666">    if (augroup_exists(&quot;filetypedetect&quot;)) {</a>
<a name="ln3667">      (void)do_doautocmd(&quot;filetypedetect BufRead&quot;, false, NULL);</a>
<a name="ln3668">    }</a>
<a name="ln3669">    do_modelines(0);</a>
<a name="ln3670">  }</a>
<a name="ln3671"> </a>
<a name="ln3672">  return OK;</a>
<a name="ln3673">}</a>
<a name="ln3674"> </a>
<a name="ln3675">/// Put file name into the specified buffer with quotes</a>
<a name="ln3676">///</a>
<a name="ln3677">/// Replaces home directory at the start with `~`.</a>
<a name="ln3678">///</a>
<a name="ln3679">/// @param[out]  ret_buf  Buffer to save results to.</a>
<a name="ln3680">/// @param[in]  buf_len  ret_buf length.</a>
<a name="ln3681">/// @param[in]  buf  buf_T file name is coming from.</a>
<a name="ln3682">/// @param[in]  fname  File name to write.</a>
<a name="ln3683">static void add_quoted_fname(char *const ret_buf, const size_t buf_len, const buf_T *const buf,</a>
<a name="ln3684">                             const char *fname)</a>
<a name="ln3685">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3686">{</a>
<a name="ln3687">  if (fname == NULL) {</a>
<a name="ln3688">    fname = &quot;-stdin-&quot;;</a>
<a name="ln3689">  }</a>
<a name="ln3690">  ret_buf[0] = '&quot;';</a>
<a name="ln3691">  home_replace(buf, fname, ret_buf + 1, buf_len - 4, true);</a>
<a name="ln3692">  xstrlcat(ret_buf, &quot;\&quot; &quot;, buf_len);</a>
<a name="ln3693">}</a>
<a name="ln3694"> </a>
<a name="ln3695">/// Append message for text mode to IObuff.</a>
<a name="ln3696">///</a>
<a name="ln3697">/// @param eol_type line ending type</a>
<a name="ln3698">///</a>
<a name="ln3699">/// @return true if something was appended.</a>
<a name="ln3700">static bool msg_add_fileformat(int eol_type)</a>
<a name="ln3701">{</a>
<a name="ln3702">#ifndef USE_CRNL</a>
<a name="ln3703">  if (eol_type == EOL_DOS) {</a>
<a name="ln3704">    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(&quot;[dos]&quot;) : _(&quot;[dos format]&quot;));</a>
<a name="ln3705">    return true;</a>
<a name="ln3706">  }</a>
<a name="ln3707">#endif</a>
<a name="ln3708">  if (eol_type == EOL_MAC) {</a>
<a name="ln3709">    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(&quot;[mac]&quot;) : _(&quot;[mac format]&quot;));</a>
<a name="ln3710">    return true;</a>
<a name="ln3711">  }</a>
<a name="ln3712">#ifdef USE_CRNL</a>
<a name="ln3713">  if (eol_type == EOL_UNIX) {</a>
<a name="ln3714">    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(&quot;[unix]&quot;) : _(&quot;[unix format]&quot;));</a>
<a name="ln3715">    return true;</a>
<a name="ln3716">  }</a>
<a name="ln3717">#endif</a>
<a name="ln3718">  return false;</a>
<a name="ln3719">}</a>
<a name="ln3720"> </a>
<a name="ln3721">/// Append line and character count to IObuff.</a>
<a name="ln3722">void msg_add_lines(int insert_space, long lnum, off_T nchars)</a>
<a name="ln3723">{</a>
<a name="ln3724">  char_u *p;</a>
<a name="ln3725"> </a>
<a name="ln3726">  p = (char_u *)IObuff + STRLEN(IObuff);</a>
<a name="ln3727"> </a>
<a name="ln3728">  if (insert_space) {</a>
<a name="ln3729">    *p++ = ' ';</a>
<a name="ln3730">  }</a>
<a name="ln3731">  if (shortmess(SHM_LINES)) {</a>
<a name="ln3732">    vim_snprintf((char *)p, (size_t)(IOSIZE - (p - (char_u *)IObuff)), &quot;%&quot; PRId64 &quot;L, %&quot; PRId64 &quot;B&quot;,</a>
<a name="ln3733">                 (int64_t)lnum, (int64_t)nchars);</a>
<a name="ln3734">  } else {</a>
<a name="ln3735">    vim_snprintf((char *)p, (size_t)(IOSIZE - (p - (char_u *)IObuff)),</a>
<a name="ln3736">                 NGETTEXT(&quot;%&quot; PRId64 &quot; line, &quot;, &quot;%&quot; PRId64 &quot; lines, &quot;, lnum),</a>
<a name="ln3737">                 (int64_t)lnum);</a>
<a name="ln3738">    p += STRLEN(p);</a>
<a name="ln3739">    vim_snprintf((char *)p, (size_t)(IOSIZE - (p - (char_u *)IObuff)),</a>
<a name="ln3740">                 NGETTEXT(&quot;%&quot; PRId64 &quot; byte&quot;, &quot;%&quot; PRId64 &quot; bytes&quot;, nchars),</a>
<a name="ln3741">                 (int64_t)nchars);</a>
<a name="ln3742">  }</a>
<a name="ln3743">}</a>
<a name="ln3744"> </a>
<a name="ln3745">/// Append message for missing line separator to IObuff.</a>
<a name="ln3746">static void msg_add_eol(void)</a>
<a name="ln3747">{</a>
<a name="ln3748">  STRCAT(IObuff,</a>
<a name="ln3749">         shortmess(SHM_LAST) ? _(&quot;[noeol]&quot;) : _(&quot;[Incomplete last line]&quot;));</a>
<a name="ln3750">}</a>
<a name="ln3751"> </a>
<a name="ln3752">/// Check modification time of file, before writing to it.</a>
<a name="ln3753">/// The size isn't checked, because using a tool like &quot;gzip&quot; takes care of</a>
<a name="ln3754">/// using the same timestamp but can't set the size.</a>
<a name="ln3755">static int check_mtime(buf_T *buf, FileInfo *file_info)</a>
<a name="ln3756">{</a>
<a name="ln3757">  if (buf-&gt;b_mtime_read != 0</a>
<a name="ln3758">      &amp;&amp; time_differs(file_info, buf-&gt;b_mtime_read, buf-&gt;b_mtime_read_ns)) {</a>
<a name="ln3759">    msg_scroll = true;  // Don't overwrite messages here.</a>
<a name="ln3760">    msg_silent = 0;     // Must give this prompt.</a>
<a name="ln3761">    // Don't use emsg() here, don't want to flush the buffers.</a>
<a name="ln3762">    msg_attr(_(&quot;WARNING: The file has been changed since reading it!!!&quot;),</a>
<a name="ln3763">             HL_ATTR(HLF_E));</a>
<a name="ln3764">    if (ask_yesno(_(&quot;Do you really want to write to it&quot;), true) == 'n') {</a>
<a name="ln3765">      return FAIL;</a>
<a name="ln3766">    }</a>
<a name="ln3767">    msg_scroll = false;  // Always overwrite the file message now.</a>
<a name="ln3768">  }</a>
<a name="ln3769">  return OK;</a>
<a name="ln3770">}</a>
<a name="ln3771"> </a>
<a name="ln3772">static bool time_differs(const FileInfo *file_info, long mtime, long mtime_ns) FUNC_ATTR_CONST</a>
<a name="ln3773">{</a>
<a name="ln3774">  return file_info-&gt;stat.st_mtim.tv_nsec != mtime_ns</a>
<a name="ln3775">#if defined(__linux__) || defined(MSWIN)</a>
<a name="ln3776">         // On a FAT filesystem, esp. under Linux, there are only 5 bits to store</a>
<a name="ln3777">         // the seconds.  Since the roundoff is done when flushing the inode, the</a>
<a name="ln3778">         // time may change unexpectedly by one second!!!</a>
<a name="ln3779">         || file_info-&gt;stat.st_mtim.tv_sec - mtime &gt; 1</a>
<a name="ln3780">         || mtime - file_info-&gt;stat.st_mtim.tv_sec &gt; 1;</a>
<a name="ln3781">#else</a>
<a name="ln3782">         || (long)file_info-&gt;stat.st_mtim.tv_sec != mtime;</a>
<a name="ln3783">#endif</a>
<a name="ln3784">}</a>
<a name="ln3785"> </a>
<a name="ln3786">/// Call write() to write a number of bytes to the file.</a>
<a name="ln3787">/// Handles 'encoding' conversion.</a>
<a name="ln3788">///</a>
<a name="ln3789">/// @return  FAIL for failure, OK otherwise.</a>
<a name="ln3790">static int buf_write_bytes(struct bw_info *ip)</a>
<a name="ln3791">{</a>
<a name="ln3792">  int wlen;</a>
<a name="ln3793">  char_u *buf = ip-&gt;bw_buf;        // data to write</a>
<a name="ln3794">  int len = ip-&gt;bw_len;                 // length of data</a>
<a name="ln3795">#ifdef HAS_BW_FLAGS</a>
<a name="ln3796">  int flags = ip-&gt;bw_flags;             // extra flags</a>
<a name="ln3797">#endif</a>
<a name="ln3798"> </a>
<a name="ln3799">  // Skip conversion when writing the BOM.</a>
<a name="ln3800">  if (!(flags &amp; FIO_NOCONVERT)) {</a>
<a name="ln3801">    char_u *p;</a>
<a name="ln3802">    unsigned c;</a>
<a name="ln3803">    int n;</a>
<a name="ln3804"> </a>
<a name="ln3805">    if (flags &amp; FIO_UTF8) {</a>
<a name="ln3806">      // Convert latin1 in the buffer to UTF-8 in the file.</a>
<a name="ln3807">      p = ip-&gt;bw_conv_buf;              // translate to buffer</a>
<a name="ln3808">      for (wlen = 0; wlen &lt; len; wlen++) {</a>
<a name="ln3809">        p += utf_char2bytes(buf[wlen], (char *)p);</a>
<a name="ln3810">      }</a>
<a name="ln3811">      buf = ip-&gt;bw_conv_buf;</a>
<a name="ln3812">      len = (int)(p - ip-&gt;bw_conv_buf);</a>
<a name="ln3813">    } else if (flags &amp; (FIO_UCS4 | FIO_UTF16 | FIO_UCS2 | FIO_LATIN1)) {</a>
<a name="ln3814">      // Convert UTF-8 bytes in the buffer to UCS-2, UCS-4, UTF-16 or</a>
<a name="ln3815">      // Latin1 chars in the file.</a>
<a name="ln3816">      if (flags &amp; FIO_LATIN1) {</a>
<a name="ln3817">        p = buf;                // translate in-place (can only get shorter)</a>
<a name="ln3818">      } else {</a>
<a name="ln3819">        p = ip-&gt;bw_conv_buf;            // translate to buffer</a>
<a name="ln3820">      }</a>
<a name="ln3821">      for (wlen = 0; wlen &lt; len; wlen += n) {</a>
<a name="ln3822">        if (wlen == 0 &amp;&amp; ip-&gt;bw_restlen != 0) {</a>
<a name="ln3823">          int l;</a>
<a name="ln3824"> </a>
<a name="ln3825">          // Use remainder of previous call.  Append the start of</a>
<a name="ln3826">          // buf[] to get a full sequence.  Might still be too</a>
<a name="ln3827">          // short!</a>
<a name="ln3828">          l = CONV_RESTLEN - ip-&gt;bw_restlen;</a>
<a name="ln3829">          if (l &gt; len) {</a>
<a name="ln3830">            l = len;</a>
<a name="ln3831">          }</a>
<a name="ln3832">          memmove(ip-&gt;bw_rest + ip-&gt;bw_restlen, buf, (size_t)l);</a>
<a name="ln3833">          n = utf_ptr2len_len(ip-&gt;bw_rest, ip-&gt;bw_restlen + l);</a>
<a name="ln3834">          if (n &gt; ip-&gt;bw_restlen + len) {</a>
<a name="ln3835">            // We have an incomplete byte sequence at the end to</a>
<a name="ln3836">            // be written.  We can't convert it without the</a>
<a name="ln3837">            // remaining bytes.  Keep them for the next call.</a>
<a name="ln3838">            if (ip-&gt;bw_restlen + len &gt; CONV_RESTLEN) {</a>
<a name="ln3839">              return FAIL;</a>
<a name="ln3840">            }</a>
<a name="ln3841">            ip-&gt;bw_restlen += len;</a>
<a name="ln3842">            break;</a>
<a name="ln3843">          }</a>
<a name="ln3844">          if (n &gt; 1) {</a>
<a name="ln3845">            c = (unsigned)utf_ptr2char((char *)ip-&gt;bw_rest);</a>
<a name="ln3846">          } else {</a>
<a name="ln3847">            c = ip-&gt;bw_rest[0];</a>
<a name="ln3848">          }</a>
<a name="ln3849">          if (n &gt;= ip-&gt;bw_restlen) {</a>
<a name="ln3850">            n -= ip-&gt;bw_restlen;</a>
<a name="ln3851">            ip-&gt;bw_restlen = 0;</a>
<a name="ln3852">          } else {</a>
<a name="ln3853">            ip-&gt;bw_restlen -= n;</a>
<a name="ln3854">            memmove(ip-&gt;bw_rest, ip-&gt;bw_rest + n,</a>
<a name="ln3855">                    (size_t)ip-&gt;bw_restlen);</a>
<a name="ln3856">            n = 0;</a>
<a name="ln3857">          }</a>
<a name="ln3858">        } else {</a>
<a name="ln3859">          n = utf_ptr2len_len(buf + wlen, len - wlen);</a>
<a name="ln3860">          if (n &gt; len - wlen) {</a>
<a name="ln3861">            // We have an incomplete byte sequence at the end to</a>
<a name="ln3862">            // be written.  We can't convert it without the</a>
<a name="ln3863">            // remaining bytes.  Keep them for the next call.</a>
<a name="ln3864">            if (len - wlen &gt; CONV_RESTLEN) {</a>
<a name="ln3865">              return FAIL;</a>
<a name="ln3866">            }</a>
<a name="ln3867">            ip-&gt;bw_restlen = len - wlen;</a>
<a name="ln3868">            memmove(ip-&gt;bw_rest, buf + wlen,</a>
<a name="ln3869">                    (size_t)ip-&gt;bw_restlen);</a>
<a name="ln3870">            break;</a>
<a name="ln3871">          }</a>
<a name="ln3872">          if (n &gt; 1) {</a>
<a name="ln3873">            c = (unsigned)utf_ptr2char((char *)buf + wlen);</a>
<a name="ln3874">          } else {</a>
<a name="ln3875">            c = buf[wlen];</a>
<a name="ln3876">          }</a>
<a name="ln3877">        }</a>
<a name="ln3878"> </a>
<a name="ln3879">        if (ucs2bytes(c, &amp;p, flags) &amp;&amp; !ip-&gt;bw_conv_error) {</a>
<a name="ln3880">          ip-&gt;bw_conv_error = true;</a>
<a name="ln3881">          ip-&gt;bw_conv_error_lnum = ip-&gt;bw_start_lnum;</a>
<a name="ln3882">        }</a>
<a name="ln3883">        if (c == NL) {</a>
<a name="ln3884">          ip-&gt;bw_start_lnum++;</a>
<a name="ln3885">        }</a>
<a name="ln3886">      }</a>
<a name="ln3887">      if (flags &amp; FIO_LATIN1) {</a>
<a name="ln3888">        len = (int)(p - buf);</a>
<a name="ln3889">      } else {</a>
<a name="ln3890">        buf = ip-&gt;bw_conv_buf;</a>
<a name="ln3891">        len = (int)(p - ip-&gt;bw_conv_buf);</a>
<a name="ln3892">      }</a>
<a name="ln3893">    }</a>
<a name="ln3894"> </a>
<a name="ln3895">#ifdef HAVE_ICONV</a>
<a name="ln3896">    if (ip-&gt;bw_iconv_fd != (iconv_t)-1) {</a>
<a name="ln3897">      const char *from;</a>
<a name="ln3898">      size_t fromlen;</a>
<a name="ln3899">      char *to;</a>
<a name="ln3900">      size_t tolen;</a>
<a name="ln3901"> </a>
<a name="ln3902">      // Convert with iconv().</a>
<a name="ln3903">      if (ip-&gt;bw_restlen &gt; 0) {</a>
<a name="ln3904">        char *fp;</a>
<a name="ln3905"> </a>
<a name="ln3906">        // Need to concatenate the remainder of the previous call and</a>
<a name="ln3907">        // the bytes of the current call.  Use the end of the</a>
<a name="ln3908">        // conversion buffer for this.</a>
<a name="ln3909">        fromlen = (size_t)len + (size_t)ip-&gt;bw_restlen;</a>
<a name="ln3910">        fp = (char *)ip-&gt;bw_conv_buf + ip-&gt;bw_conv_buflen - fromlen;</a>
<a name="ln3911">        memmove(fp, ip-&gt;bw_rest, (size_t)ip-&gt;bw_restlen);</a>
<a name="ln3912">        memmove(fp + ip-&gt;bw_restlen, buf, (size_t)len);</a>
<a name="ln3913">        from = fp;</a>
<a name="ln3914">        tolen = ip-&gt;bw_conv_buflen - fromlen;</a>
<a name="ln3915">      } else {</a>
<a name="ln3916">        from = (const char *)buf;</a>
<a name="ln3917">        fromlen = (size_t)len;</a>
<a name="ln3918">        tolen = ip-&gt;bw_conv_buflen;</a>
<a name="ln3919">      }</a>
<a name="ln3920">      to = (char *)ip-&gt;bw_conv_buf;</a>
<a name="ln3921"> </a>
<a name="ln3922">      if (ip-&gt;bw_first) {</a>
<a name="ln3923">        size_t save_len = tolen;</a>
<a name="ln3924"> </a>
<a name="ln3925">        // output the initial shift state sequence</a>
<a name="ln3926">        (void)iconv(ip-&gt;bw_iconv_fd, NULL, NULL, &amp;to, &amp;tolen);</a>
<a name="ln3927"> </a>
<a name="ln3928">        // There is a bug in iconv() on Linux (which appears to be</a>
<a name="ln3929">        // wide-spread) which sets &quot;to&quot; to NULL and messes up &quot;tolen&quot;.</a>
<a name="ln3930">        if (to == NULL) {</a>
<a name="ln3931">          to = (char *)ip-&gt;bw_conv_buf;</a>
<a name="ln3932">          tolen = save_len;</a>
<a name="ln3933">        }</a>
<a name="ln3934">        ip-&gt;bw_first = false;</a>
<a name="ln3935">      }</a>
<a name="ln3936"> </a>
<a name="ln3937">      // If iconv() has an error or there is not enough room, fail.</a>
<a name="ln3938">      if ((iconv(ip-&gt;bw_iconv_fd, (void *)&amp;from, &amp;fromlen, &amp;to, &amp;tolen)</a>
<a name="ln3939">           == (size_t)-1 &amp;&amp; ICONV_ERRNO != ICONV_EINVAL)</a>
<a name="ln3940">          || fromlen &gt; CONV_RESTLEN) {</a>
<a name="ln3941">        ip-&gt;bw_conv_error = true;</a>
<a name="ln3942">        return FAIL;</a>
<a name="ln3943">      }</a>
<a name="ln3944"> </a>
<a name="ln3945">      // copy remainder to ip-&gt;bw_rest[] to be used for the next call.</a>
<a name="ln3946">      if (fromlen &gt; 0) {</a>
<a name="ln3947">        memmove(ip-&gt;bw_rest, (void *)from, fromlen);</a>
<a name="ln3948">      }</a>
<a name="ln3949">      ip-&gt;bw_restlen = (int)fromlen;</a>
<a name="ln3950"> </a>
<a name="ln3951">      buf = ip-&gt;bw_conv_buf;</a>
<a name="ln3952">      len = (int)((char_u *)to - ip-&gt;bw_conv_buf);</a>
<a name="ln3953">    }</a>
<a name="ln3954">#endif</a>
<a name="ln3955">  }</a>
<a name="ln3956"> </a>
<a name="ln3957">  if (ip-&gt;bw_fd &lt; 0) {</a>
<a name="ln3958">    // Only checking conversion, which is OK if we get here.</a>
<a name="ln3959">    return OK;</a>
<a name="ln3960">  }</a>
<a name="ln3961">  wlen = (int)write_eintr(ip-&gt;bw_fd, buf, (size_t)len);</a>
<a name="ln3962">  return (wlen &lt; len) ? FAIL : OK;</a>
<a name="ln3963">}</a>
<a name="ln3964"> </a>
<a name="ln3965">/// Convert a Unicode character to bytes.</a>
<a name="ln3966">///</a>
<a name="ln3967">/// @param c character to convert</a>
<a name="ln3968">/// @param[in,out] pp pointer to store the result at</a>
<a name="ln3969">/// @param flags FIO_ flags that specify which encoding to use</a>
<a name="ln3970">///</a>
<a name="ln3971">/// @return true for an error, false when it's OK.</a>
<a name="ln3972">static bool ucs2bytes(unsigned c, char_u **pp, int flags) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3973">{</a>
<a name="ln3974">  char_u *p = *pp;</a>
<a name="ln3975">  bool error = false;</a>
<a name="ln3976">  int cc;</a>
<a name="ln3977"> </a>
<a name="ln3978">  if (flags &amp; FIO_UCS4) {</a>
<a name="ln3979">    if (flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln3980">      *p++ = (uint8_t)c;</a>
<a name="ln3981">      *p++ = (uint8_t)(c &gt;&gt; 8);</a>
<a name="ln3982">      *p++ = (uint8_t)(c &gt;&gt; 16);</a>
<a name="ln3983">      *p++ = (uint8_t)(c &gt;&gt; 24);</a>
<a name="ln3984">    } else {</a>
<a name="ln3985">      *p++ = (uint8_t)(c &gt;&gt; 24);</a>
<a name="ln3986">      *p++ = (uint8_t)(c &gt;&gt; 16);</a>
<a name="ln3987">      *p++ = (uint8_t)(c &gt;&gt; 8);</a>
<a name="ln3988">      *p++ = (uint8_t)c;</a>
<a name="ln3989">    }</a>
<a name="ln3990">  } else if (flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln3991">    if (c &gt;= 0x10000) {</a>
<a name="ln3992">      if (flags &amp; FIO_UTF16) {</a>
<a name="ln3993">        // Make two words, ten bits of the character in each.  First</a>
<a name="ln3994">        // word is 0xd800 - 0xdbff, second one 0xdc00 - 0xdfff</a>
<a name="ln3995">        c -= 0x10000;</a>
<a name="ln3996">        if (c &gt;= 0x100000) {</a>
<a name="ln3997">          error = true;</a>
<a name="ln3998">        }</a>
<a name="ln3999">        cc = (int)(((c &gt;&gt; 10) &amp; 0x3ff) + 0xd800);</a>
<a name="ln4000">        if (flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln4001">          *p++ = (uint8_t)cc;</a>
<a name="ln4002">          *p++ = (uint8_t)(cc &gt;&gt; 8);</a>
<a name="ln4003">        } else {</a>
<a name="ln4004">          *p++ = (uint8_t)(cc &gt;&gt; 8);</a>
<a name="ln4005">          *p++ = (uint8_t)cc;</a>
<a name="ln4006">        }</a>
<a name="ln4007">        c = (c &amp; 0x3ff) + 0xdc00;</a>
<a name="ln4008">      } else {</a>
<a name="ln4009">        error = true;</a>
<a name="ln4010">      }</a>
<a name="ln4011">    }</a>
<a name="ln4012">    if (flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln4013">      *p++ = (uint8_t)c;</a>
<a name="ln4014">      *p++ = (uint8_t)(c &gt;&gt; 8);</a>
<a name="ln4015">    } else {</a>
<a name="ln4016">      *p++ = (uint8_t)(c &gt;&gt; 8);</a>
<a name="ln4017">      *p++ = (uint8_t)c;</a>
<a name="ln4018">    }</a>
<a name="ln4019">  } else {  // Latin1</a>
<a name="ln4020">    if (c &gt;= 0x100) {</a>
<a name="ln4021">      error = true;</a>
<a name="ln4022">      *p++ = 0xBF;</a>
<a name="ln4023">    } else {</a>
<a name="ln4024">      *p++ = (uint8_t)c;</a>
<a name="ln4025">    }</a>
<a name="ln4026">  }</a>
<a name="ln4027"> </a>
<a name="ln4028">  *pp = p;</a>
<a name="ln4029">  return error;</a>
<a name="ln4030">}</a>
<a name="ln4031"> </a>
<a name="ln4032">/// Return true if file encoding &quot;fenc&quot; requires conversion from or to</a>
<a name="ln4033">/// 'encoding'.</a>
<a name="ln4034">///</a>
<a name="ln4035">/// @param fenc file encoding to check</a>
<a name="ln4036">///</a>
<a name="ln4037">/// @return true if conversion is required</a>
<a name="ln4038">static bool need_conversion(const char *fenc)</a>
<a name="ln4039">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4040">{</a>
<a name="ln4041">  int same_encoding;</a>
<a name="ln4042">  int enc_flags;</a>
<a name="ln4043">  int fenc_flags;</a>
<a name="ln4044"> </a>
<a name="ln4045">  if (*fenc == NUL || strcmp(p_enc, fenc) == 0) {</a>
<a name="ln4046">    same_encoding = true;</a>
<a name="ln4047">    fenc_flags = 0;</a>
<a name="ln4048">  } else {</a>
<a name="ln4049">    // Ignore difference between &quot;ansi&quot; and &quot;latin1&quot;, &quot;ucs-4&quot; and</a>
<a name="ln4050">    // &quot;ucs-4be&quot;, etc.</a>
<a name="ln4051">    enc_flags = get_fio_flags((char_u *)p_enc);</a>
<a name="ln4052">    fenc_flags = get_fio_flags((char_u *)fenc);</a>
<a name="ln4053">    same_encoding = (enc_flags != 0 &amp;&amp; fenc_flags == enc_flags);</a>
<a name="ln4054">  }</a>
<a name="ln4055">  if (same_encoding) {</a>
<a name="ln4056">    // Specified file encoding matches UTF-8.</a>
<a name="ln4057">    return false;</a>
<a name="ln4058">  }</a>
<a name="ln4059"> </a>
<a name="ln4060">  // Encodings differ.  However, conversion is not needed when 'enc' is any</a>
<a name="ln4061">  // Unicode encoding and the file is UTF-8.</a>
<a name="ln4062">  return !(fenc_flags == FIO_UTF8);</a>
<a name="ln4063">}</a>
<a name="ln4064"> </a>
<a name="ln4065">/// Return the FIO_ flags needed for the internal conversion if 'name' was</a>
<a name="ln4066">/// unicode or latin1, otherwise 0. If &quot;name&quot; is an empty string,</a>
<a name="ln4067">/// use 'encoding'.</a>
<a name="ln4068">///</a>
<a name="ln4069">/// @param name string to check for encoding</a>
<a name="ln4070">static int get_fio_flags(const char_u *name)</a>
<a name="ln4071">{</a>
<a name="ln4072">  int prop;</a>
<a name="ln4073"> </a>
<a name="ln4074">  if (*name == NUL) {</a>
<a name="ln4075">    name = (char_u *)p_enc;</a>
<a name="ln4076">  }</a>
<a name="ln4077">  prop = enc_canon_props(name);</a>
<a name="ln4078">  if (prop &amp; ENC_UNICODE) {</a>
<a name="ln4079">    if (prop &amp; ENC_2BYTE) {</a>
<a name="ln4080">      if (prop &amp; ENC_ENDIAN_L) {</a>
<a name="ln4081">        return FIO_UCS2 | FIO_ENDIAN_L;</a>
<a name="ln4082">      }</a>
<a name="ln4083">      return FIO_UCS2;</a>
<a name="ln4084">    }</a>
<a name="ln4085">    if (prop &amp; ENC_4BYTE) {</a>
<a name="ln4086">      if (prop &amp; ENC_ENDIAN_L) {</a>
<a name="ln4087">        return FIO_UCS4 | FIO_ENDIAN_L;</a>
<a name="ln4088">      }</a>
<a name="ln4089">      return FIO_UCS4;</a>
<a name="ln4090">    }</a>
<a name="ln4091">    if (prop &amp; ENC_2WORD) {</a>
<a name="ln4092">      if (prop &amp; ENC_ENDIAN_L) {</a>
<a name="ln4093">        return FIO_UTF16 | FIO_ENDIAN_L;</a>
<a name="ln4094">      }</a>
<a name="ln4095">      return FIO_UTF16;</a>
<a name="ln4096">    }</a>
<a name="ln4097">    return FIO_UTF8;</a>
<a name="ln4098">  }</a>
<a name="ln4099">  if (prop &amp; ENC_LATIN1) {</a>
<a name="ln4100">    return FIO_LATIN1;</a>
<a name="ln4101">  }</a>
<a name="ln4102">  // must be ENC_DBCS, requires iconv()</a>
<a name="ln4103">  return 0;</a>
<a name="ln4104">}</a>
<a name="ln4105"> </a>
<a name="ln4106">/// Check for a Unicode BOM (Byte Order Mark) at the start of p[size].</a>
<a name="ln4107">/// &quot;size&quot; must be at least 2.</a>
<a name="ln4108">///</a>
<a name="ln4109">/// @return  the name of the encoding and set &quot;*lenp&quot; to the length or,</a>
<a name="ln4110">///          NULL when no BOM found.</a>
<a name="ln4111">static char_u *check_for_bom(const char_u *p, long size, int *lenp, int flags)</a>
<a name="ln4112">{</a>
<a name="ln4113">  char *name = NULL;</a>
<a name="ln4114">  int len = 2;</a>
<a name="ln4115"> </a>
<a name="ln4116">  if (p[0] == 0xef &amp;&amp; p[1] == 0xbb &amp;&amp; size &gt;= 3 &amp;&amp; p[2] == 0xbf</a>
<a name="ln4117">      &amp;&amp; (flags == FIO_ALL || flags == FIO_UTF8 || flags == 0)) {</a>
<a name="ln4118">    name = &quot;utf-8&quot;;             // EF BB BF</a>
<a name="ln4119">    len = 3;</a>
<a name="ln4120">  } else if (p[0] == 0xff &amp;&amp; p[1] == 0xfe) {</a>
<a name="ln4121">    if (size &gt;= 4 &amp;&amp; p[2] == 0 &amp;&amp; p[3] == 0</a>
<a name="ln4122">        &amp;&amp; (flags == FIO_ALL || flags == (FIO_UCS4 | FIO_ENDIAN_L))) {</a>
<a name="ln4123">      name = &quot;ucs-4le&quot;;         // FF FE 00 00</a>
<a name="ln4124">      len = 4;</a>
<a name="ln4125">    } else if (flags == (FIO_UCS2 | FIO_ENDIAN_L)) {</a>
<a name="ln4126">      name = &quot;ucs-2le&quot;;         // FF FE</a>
<a name="ln4127">    } else if (flags == FIO_ALL</a>
<a name="ln4128">               || flags == (FIO_UTF16 | FIO_ENDIAN_L)) {</a>
<a name="ln4129">      // utf-16le is preferred, it also works for ucs-2le text</a>
<a name="ln4130">      name = &quot;utf-16le&quot;;        // FF FE</a>
<a name="ln4131">    }</a>
<a name="ln4132">  } else if (p[0] == 0xfe &amp;&amp; p[1] == 0xff</a>
<a name="ln4133">             &amp;&amp; (flags == FIO_ALL || flags == FIO_UCS2 || flags ==</a>
<a name="ln4134">                 FIO_UTF16)) {</a>
<a name="ln4135">    // Default to utf-16, it works also for ucs-2 text.</a>
<a name="ln4136">    if (flags == FIO_UCS2) {</a>
<a name="ln4137">      name = &quot;ucs-2&quot;;           // FE FF</a>
<a name="ln4138">    } else {</a>
<a name="ln4139">      name = &quot;utf-16&quot;;          // FE FF</a>
<a name="ln4140">    }</a>
<a name="ln4141">  } else if (size &gt;= 4 &amp;&amp; p[0] == 0 &amp;&amp; p[1] == 0 &amp;&amp; p[2] == 0xfe</a>
<a name="ln4142">             &amp;&amp; p[3] == 0xff &amp;&amp; (flags == FIO_ALL || flags == FIO_UCS4)) {</a>
<a name="ln4143">    name = &quot;ucs-4&quot;;             // 00 00 FE FF</a>
<a name="ln4144">    len = 4;</a>
<a name="ln4145">  }</a>
<a name="ln4146"> </a>
<a name="ln4147">  *lenp = len;</a>
<a name="ln4148">  return (char_u *)name;</a>
<a name="ln4149">}</a>
<a name="ln4150"> </a>
<a name="ln4151">/// Generate a BOM in &quot;buf[4]&quot; for encoding &quot;name&quot;.</a>
<a name="ln4152">///</a>
<a name="ln4153">/// @return  the length of the BOM (zero when no BOM).</a>
<a name="ln4154">static int make_bom(char_u *buf, char_u *name)</a>
<a name="ln4155">{</a>
<a name="ln4156">  int flags;</a>
<a name="ln4157">  char_u *p;</a>
<a name="ln4158"> </a>
<a name="ln4159">  flags = get_fio_flags(name);</a>
<a name="ln4160"> </a>
<a name="ln4161">  // Can't put a BOM in a non-Unicode file.</a>
<a name="ln4162">  if (flags == FIO_LATIN1 || flags == 0) {</a>
<a name="ln4163">    return 0;</a>
<a name="ln4164">  }</a>
<a name="ln4165"> </a>
<a name="ln4166">  if (flags == FIO_UTF8) {      // UTF-8</a>
<a name="ln4167">    buf[0] = 0xef;</a>
<a name="ln4168">    buf[1] = 0xbb;</a>
<a name="ln4169">    buf[2] = 0xbf;</a>
<a name="ln4170">    return 3;</a>
<a name="ln4171">  }</a>
<a name="ln4172">  p = buf;</a>
<a name="ln4173">  (void)ucs2bytes(0xfeff, &amp;p, flags);</a>
<a name="ln4174">  return (int)(p - buf);</a>
<a name="ln4175">}</a>
<a name="ln4176"> </a>
<a name="ln4177">/// Shorten filename of a buffer.</a>
<a name="ln4178">///</a>
<a name="ln4179">/// @param force  when true: Use full path from now on for files currently being</a>
<a name="ln4180">///               edited, both for file name and swap file name.  Try to shorten the file</a>
<a name="ln4181">///               names a bit, if safe to do so.</a>
<a name="ln4182">///               when false: Only try to shorten absolute file names.</a>
<a name="ln4183">///</a>
<a name="ln4184">/// For buffers that have buftype &quot;nofile&quot; or &quot;scratch&quot;: never change the file</a>
<a name="ln4185">/// name.</a>
<a name="ln4186">void shorten_buf_fname(buf_T *buf, char_u *dirname, int force)</a>
<a name="ln4187">{</a>
<a name="ln4188">  char *p;</a>
<a name="ln4189"> </a>
<a name="ln4190">  if (buf-&gt;b_fname != NULL</a>
<a name="ln4191">      &amp;&amp; !bt_nofilename(buf)</a>
<a name="ln4192">      &amp;&amp; !path_with_url(buf-&gt;b_fname)</a>
<a name="ln4193">      &amp;&amp; (force</a>
<a name="ln4194">          || buf-&gt;b_sfname == NULL</a>
<a name="ln4195">          || path_is_absolute((char_u *)buf-&gt;b_sfname))) {</a>
<a name="ln4196">    if (buf-&gt;b_sfname != buf-&gt;b_ffname) {</a>
<a name="ln4197">      XFREE_CLEAR(buf-&gt;b_sfname);</a>
<a name="ln4198">    }</a>
<a name="ln4199">    p = path_shorten_fname(buf-&gt;b_ffname, (char *)dirname);</a>
<a name="ln4200">    if (p != NULL) {</a>
<a name="ln4201">      buf-&gt;b_sfname = xstrdup(p);</a>
<a name="ln4202">      buf-&gt;b_fname = buf-&gt;b_sfname;</a>
<a name="ln4203">    }</a>
<a name="ln4204">    if (p == NULL) {</a>
<a name="ln4205">      buf-&gt;b_fname = buf-&gt;b_ffname;</a>
<a name="ln4206">    }</a>
<a name="ln4207">  }</a>
<a name="ln4208">}</a>
<a name="ln4209"> </a>
<a name="ln4210">/// Shorten filenames for all buffers.</a>
<a name="ln4211">void shorten_fnames(int force)</a>
<a name="ln4212">{</a>
<a name="ln4213">  char_u dirname[MAXPATHL];</a>
<a name="ln4214"> </a>
<a name="ln4215">  os_dirname(dirname, MAXPATHL);</a>
<a name="ln4216">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln4217">    shorten_buf_fname(buf, dirname, force);</a>
<a name="ln4218"> </a>
<a name="ln4219">    // Always make the swap file name a full path, a &quot;nofile&quot; buffer may</a>
<a name="ln4220">    // also have a swap file.</a>
<a name="ln4221">    mf_fullname(buf-&gt;b_ml.ml_mfp);</a>
<a name="ln4222">  }</a>
<a name="ln4223">  status_redraw_all();</a>
<a name="ln4224">  redraw_tabline = true;</a>
<a name="ln4225">}</a>
<a name="ln4226"> </a>
<a name="ln4227">/// Get new filename ended by given extension.</a>
<a name="ln4228">///</a>
<a name="ln4229">/// @param fname        The original filename.</a>
<a name="ln4230">///                     If NULL, use current directory name and ext to</a>
<a name="ln4231">///                     compute new filename.</a>
<a name="ln4232">/// @param ext          The extension to add to the filename.</a>
<a name="ln4233">///                     4 chars max if prefixed with a dot, 3 otherwise.</a>
<a name="ln4234">/// @param prepend_dot  If true, prefix ext with a dot.</a>
<a name="ln4235">///                     Does nothing if ext already starts with a dot, or</a>
<a name="ln4236">///                     if fname is NULL.</a>
<a name="ln4237">///</a>
<a name="ln4238">/// @return [allocated] - A new filename, made up from:</a>
<a name="ln4239">///                       * fname + ext, if fname not NULL.</a>
<a name="ln4240">///                       * current dir + ext, if fname is NULL.</a>
<a name="ln4241">///                       Result is guaranteed to:</a>
<a name="ln4242">///                       * be ended by &lt;ext&gt;.</a>
<a name="ln4243">///                       * have a basename with at most BASENAMELEN chars:</a>
<a name="ln4244">///                         original basename is truncated if necessary.</a>
<a name="ln4245">///                       * be different than original: basename chars are</a>
<a name="ln4246">///                         replaced by &quot;_&quot; if necessary. If that can't be done</a>
<a name="ln4247">///                         because truncated value of original filename was</a>
<a name="ln4248">///                         made of all underscores, replace first &quot;_&quot; by &quot;v&quot;.</a>
<a name="ln4249">///                     - NULL, if fname is NULL and there was a problem trying</a>
<a name="ln4250">///                       to get current directory.</a>
<a name="ln4251">char *modname(const char *fname, const char *ext, bool prepend_dot)</a>
<a name="ln4252">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln4253">{</a>
<a name="ln4254">  char *retval;</a>
<a name="ln4255">  size_t fnamelen;</a>
<a name="ln4256">  size_t extlen = strlen(ext);</a>
<a name="ln4257"> </a>
<a name="ln4258">  // If there is no file name we must get the name of the current directory</a>
<a name="ln4259">  // (we need the full path in case :cd is used).</a>
<a name="ln4260">  if (fname == NULL || *fname == NUL) {</a>
<a name="ln4261">    retval = xmalloc(MAXPATHL + extlen + 3);  // +3 for PATHSEP, &quot;_&quot; (Win), NUL</a>
<a name="ln4262">    if (os_dirname((char_u *)retval, MAXPATHL) == FAIL</a>
<a name="ln4263">        || strlen(retval) == 0) {</a>
<a name="ln4264">      xfree(retval);</a>
<a name="ln4265">      return NULL;</a>
<a name="ln4266">    }</a>
<a name="ln4267">    add_pathsep(retval);</a>
<a name="ln4268">    fnamelen = strlen(retval);</a>
<a name="ln4269">    prepend_dot = false;  // nothing to prepend a dot to</a>
<a name="ln4270">  } else {</a>
<a name="ln4271">    fnamelen = strlen(fname);</a>
<a name="ln4272">    retval = xmalloc(fnamelen + extlen + 3);</a>
<a name="ln4273">    strcpy(retval, fname);  // NOLINT(runtime/printf)</a>
<a name="ln4274">  }</a>
<a name="ln4275"> </a>
<a name="ln4276">  // Search backwards until we hit a '/', '\' or ':'.</a>
<a name="ln4277">  // Then truncate what is after the '/', '\' or ':' to BASENAMELEN characters.</a>
<a name="ln4278">  char *ptr = NULL;</a>
<a name="ln4279">  for (ptr = retval + fnamelen; ptr &gt; retval; MB_PTR_BACK(retval, ptr)) {</a>
<a name="ln4280">    if (vim_ispathsep(*ptr)) {</a>
<a name="ln4281">      ptr++;</a>
<a name="ln4282">      break;</a>
<a name="ln4283">    }</a>
<a name="ln4284">  }</a>
<a name="ln4285"> </a>
<a name="ln4286">  // the file name has at most BASENAMELEN characters.</a>
<a name="ln4287">  if (strlen(ptr) &gt; BASENAMELEN) {</a>
<a name="ln4288">    ptr[BASENAMELEN] = '\0';</a>
<a name="ln4289">  }</a>
<a name="ln4290"> </a>
<a name="ln4291">  char *s = ptr + strlen(ptr);</a>
<a name="ln4292"> </a>
<a name="ln4293">  // Append the extension.</a>
<a name="ln4294">  // ext can start with '.' and cannot exceed 3 more characters.</a>
<a name="ln4295">  strcpy(s, ext);  // NOLINT(runtime/printf)</a>
<a name="ln4296"> </a>
<a name="ln4297">  char *e;</a>
<a name="ln4298">  // Prepend the dot if needed.</a>
<a name="ln4299">  if (prepend_dot &amp;&amp; *(e = path_tail(retval)) != '.') {</a>
<a name="ln4300">    STRMOVE(e + 1, e);</a>
<a name="ln4301">    *e = '.';</a>
<a name="ln4302">  }</a>
<a name="ln4303"> </a>
<a name="ln4304">  // Check that, after appending the extension, the file name is really</a>
<a name="ln4305">  // different.</a>
<a name="ln4306">  if (fname != NULL &amp;&amp; strcmp(fname, retval) == 0) {</a>
<a name="ln4307">    // we search for a character that can be replaced by '_'</a>
<a name="ln4308">    while (--s &gt;= ptr) {</a>
<a name="ln4309">      if (*s != '_') {</a>
<a name="ln4310">        *s = '_';</a>
<a name="ln4311">        break;</a>
<a name="ln4312">      }</a>
<a name="ln4313">    }</a>
<a name="ln4314">    if (s &lt; ptr) {  // fname was &quot;________.&lt;ext&gt;&quot;, how tricky!</a>
<a name="ln4315">      *ptr = 'v';</a>
<a name="ln4316">    }</a>
<a name="ln4317">  }</a>
<a name="ln4318">  return retval;</a>
<a name="ln4319">}</a>
<a name="ln4320"> </a>
<a name="ln4321">/// Like fgets(), but if the file line is too long, it is truncated and the</a>
<a name="ln4322">/// rest of the line is thrown away.</a>
<a name="ln4323">///</a>
<a name="ln4324">/// @param[out] buf buffer to fill</a>
<a name="ln4325">/// @param size size of the buffer</a>
<a name="ln4326">/// @param fp file to read from</a>
<a name="ln4327">///</a>
<a name="ln4328">/// @return true for EOF or error</a>
<a name="ln4329">bool vim_fgets(char_u *buf, int size, FILE *fp) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4330">{</a>
<a name="ln4331">  char *retval;</a>
<a name="ln4332"> </a>
<a name="ln4333">  assert(size &gt; 0);</a>
<a name="ln4334">  buf[size - 2] = NUL;</a>
<a name="ln4335"> </a>
<a name="ln4336">  do {</a>
<a name="ln4337">    errno = 0;</a>
<a name="ln4338">    retval = fgets((char *)buf, size, fp);</a>
<a name="ln4339">  } while (retval == NULL &amp;&amp; errno == EINTR &amp;&amp; ferror(fp));</a>
<a name="ln4340"> </a>
<a name="ln4341">  if (buf[size - 2] != NUL &amp;&amp; buf[size - 2] != '\n') {</a>
<a name="ln4342">    char tbuf[200];</a>
<a name="ln4343"> </a>
<a name="ln4344">    buf[size - 1] = NUL;  // Truncate the line.</a>
<a name="ln4345"> </a>
<a name="ln4346">    // Now throw away the rest of the line:</a>
<a name="ln4347">    do {</a>
<a name="ln4348">      tbuf[sizeof(tbuf) - 2] = NUL;</a>
<a name="ln4349">      errno = 0;</a>
<a name="ln4350">      retval = fgets((char *)tbuf, sizeof(tbuf), fp);</a>
<a name="ln4351">      if (retval == NULL &amp;&amp; (feof(fp) || errno != EINTR)) {</a>
<a name="ln4352">        break;</a>
<a name="ln4353">      }</a>
<a name="ln4354">    } while (tbuf[sizeof(tbuf) - 2] != NUL &amp;&amp; tbuf[sizeof(tbuf) - 2] != '\n');</a>
<a name="ln4355">  }</a>
<a name="ln4356">  return retval == NULL;</a>
<a name="ln4357">}</a>
<a name="ln4358"> </a>
<a name="ln4359">/// Read 2 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln4360">///</a>
<a name="ln4361">/// @return  -1 when encountering EOF.</a>
<a name="ln4362">int get2c(FILE *fd)</a>
<a name="ln4363">{</a>
<a name="ln4364">  const int n = getc(fd);</a>
<a name="ln4365">  if (n == EOF) {</a>
<a name="ln4366">    return -1;</a>
<a name="ln4367">  }</a>
<a name="ln4368">  const int c = getc(fd);</a>
<a name="ln4369">  if (c == EOF) {</a>
<a name="ln4370">    return -1;</a>
<a name="ln4371">  }</a>
<a name="ln4372">  return (n &lt;&lt; 8) + c;</a>
<a name="ln4373">}</a>
<a name="ln4374"> </a>
<a name="ln4375">/// Read 3 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln4376">///</a>
<a name="ln4377">/// @return  -1 when encountering EOF.</a>
<a name="ln4378">int get3c(FILE *fd)</a>
<a name="ln4379">{</a>
<a name="ln4380">  int n = getc(fd);</a>
<a name="ln4381">  if (n == EOF) {</a>
<a name="ln4382">    return -1;</a>
<a name="ln4383">  }</a>
<a name="ln4384">  int c = getc(fd);</a>
<a name="ln4385">  if (c == EOF) {</a>
<a name="ln4386">    return -1;</a>
<a name="ln4387">  }</a>
<a name="ln4388">  n = (n &lt;&lt; 8) + c;</a>
<a name="ln4389">  c = getc(fd);</a>
<a name="ln4390">  if (c == EOF) {</a>
<a name="ln4391">    return -1;</a>
<a name="ln4392">  }</a>
<a name="ln4393">  return (n &lt;&lt; 8) + c;</a>
<a name="ln4394">}</a>
<a name="ln4395"> </a>
<a name="ln4396">/// Read 4 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln4397">///</a>
<a name="ln4398">/// @return  -1 when encountering EOF.</a>
<a name="ln4399">int get4c(FILE *fd)</a>
<a name="ln4400">{</a>
<a name="ln4401">  // Use unsigned rather than int otherwise result is undefined</a>
<a name="ln4402">  // when left-shift sets the MSB.</a>
<a name="ln4403">  unsigned n;</a>
<a name="ln4404"> </a>
<a name="ln4405">  int c = getc(fd);</a>
<a name="ln4406">  if (c == EOF) {</a>
<a name="ln4407">    return -1;</a>
<a name="ln4408">  }</a>
<a name="ln4409">  n = (unsigned)c;</a>
<a name="ln4410">  c = getc(fd);</a>
<a name="ln4411">  if (c == EOF) {</a>
<a name="ln4412">    return -1;</a>
<a name="ln4413">  }</a>
<a name="ln4414">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln4415">  c = getc(fd);</a>
<a name="ln4416">  if (c == EOF) {</a>
<a name="ln4417">    return -1;</a>
<a name="ln4418">  }</a>
<a name="ln4419">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln4420">  c = getc(fd);</a>
<a name="ln4421">  if (c == EOF) {</a>
<a name="ln4422">    return -1;</a>
<a name="ln4423">  }</a>
<a name="ln4424">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln4425">  return (int)n;</a>
<a name="ln4426">}</a>
<a name="ln4427"> </a>
<a name="ln4428">/// Read 8 bytes from `fd` and turn them into a time_t, MSB first.</a>
<a name="ln4429">///</a>
<a name="ln4430">/// @return  -1 when encountering EOF.</a>
<a name="ln4431">time_t get8ctime(FILE *fd)</a>
<a name="ln4432">{</a>
<a name="ln4433">  time_t n = 0;</a>
<a name="ln4434"> </a>
<a name="ln4435">  for (int i = 0; i &lt; 8; i++) {</a>
<a name="ln4436">    const int c = getc(fd);</a>
<a name="ln4437">    if (c == EOF) {</a>
<a name="ln4438">      return -1;</a>
<a name="ln4439">    }</a>
<a name="ln4440">    n = (n &lt;&lt; 8) + c;</a>
<a name="ln4441">  }</a>
<a name="ln4442">  return n;</a>
<a name="ln4443">}</a>
<a name="ln4444"> </a>
<a name="ln4445">/// Reads a string of length &quot;cnt&quot; from &quot;fd&quot; into allocated memory.</a>
<a name="ln4446">///</a>
<a name="ln4447">/// @return  pointer to the string or NULL when unable to read that many bytes.</a>
<a name="ln4448">char *read_string(FILE *fd, size_t cnt)</a>
<a name="ln4449">{</a>
<a name="ln4450">  char *str = xmallocz(cnt);</a>
<a name="ln4451">  for (size_t i = 0; i &lt; cnt; i++) {</a>
<a name="ln4452">    int c = getc(fd);</a>
<a name="ln4453">    if (c == EOF) {</a>
<a name="ln4454">      xfree(str);</a>
<a name="ln4455">      return NULL;</a>
<a name="ln4456">    }</a>
<a name="ln4457">    str[i] = (char)c;</a>
<a name="ln4458">  }</a>
<a name="ln4459">  return str;</a>
<a name="ln4460">}</a>
<a name="ln4461"> </a>
<a name="ln4462">/// Writes a number to file &quot;fd&quot;, most significant bit first, in &quot;len&quot; bytes.</a>
<a name="ln4463">///</a>
<a name="ln4464">/// @return  false in case of an error.</a>
<a name="ln4465">bool put_bytes(FILE *fd, uintmax_t number, size_t len)</a>
<a name="ln4466">{</a>
<a name="ln4467">  assert(len &gt; 0);</a>
<a name="ln4468">  for (size_t i = len - 1; i &lt; len; i--) {</a>
<a name="ln4469">    if (putc((int)(number &gt;&gt; (i * 8)), fd) == EOF) {</a>
<a name="ln4470">      return false;</a>
<a name="ln4471">    }</a>
<a name="ln4472">  }</a>
<a name="ln4473">  return true;</a>
<a name="ln4474">}</a>
<a name="ln4475"> </a>
<a name="ln4476">/// Writes time_t to file &quot;fd&quot; in 8 bytes.</a>
<a name="ln4477">///</a>
<a name="ln4478">/// @return  FAIL when the write failed.</a>
<a name="ln4479">int put_time(FILE *fd, time_t time_)</a>
<a name="ln4480">{</a>
<a name="ln4481">  uint8_t buf[8];</a>
<a name="ln4482">  time_to_bytes(time_, buf);</a>
<a name="ln4483">  return fwrite(buf, sizeof(uint8_t), ARRAY_SIZE(buf), fd) == 1 ? OK : FAIL;</a>
<a name="ln4484">}</a>
<a name="ln4485"> </a>
<a name="ln4486">/// os_rename() only works if both files are on the same file system, this</a>
<a name="ln4487">/// function will (attempts to?) copy the file across if rename fails -- webb</a>
<a name="ln4488">///</a>
<a name="ln4489">/// @return  -1 for failure, 0 for success</a>
<a name="ln4490">int vim_rename(const char *from, const char *to)</a>
<a name="ln4491">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4492">{</a>
<a name="ln4493">  int fd_in;</a>
<a name="ln4494">  int fd_out;</a>
<a name="ln4495">  int n;</a>
<a name="ln4496">  char *errmsg = NULL;</a>
<a name="ln4497">  char *buffer;</a>
<a name="ln4498">  long perm;</a>
<a name="ln4499">#ifdef HAVE_ACL</a>
<a name="ln4500">  vim_acl_T acl;                // ACL from original file</a>
<a name="ln4501">#endif</a>
<a name="ln4502">  bool use_tmp_file = false;</a>
<a name="ln4503"> </a>
<a name="ln4504">  // When the names are identical, there is nothing to do.  When they refer</a>
<a name="ln4505">  // to the same file (ignoring case and slash/backslash differences) but</a>
<a name="ln4506">  // the file name differs we need to go through a temp file.</a>
<a name="ln4507">  if (path_fnamecmp(from, to) == 0) {</a>
<a name="ln4508">    if (p_fic &amp;&amp; (strcmp(path_tail((char *)from), path_tail((char *)to))</a>
<a name="ln4509">                  != 0)) {</a>
<a name="ln4510">      use_tmp_file = true;</a>
<a name="ln4511">    } else {</a>
<a name="ln4512">      return 0;</a>
<a name="ln4513">    }</a>
<a name="ln4514">  }</a>
<a name="ln4515"> </a>
<a name="ln4516">  // Fail if the &quot;from&quot; file doesn't exist. Avoids that &quot;to&quot; is deleted.</a>
<a name="ln4517">  FileInfo from_info;</a>
<a name="ln4518">  if (!os_fileinfo((char *)from, &amp;from_info)) {</a>
<a name="ln4519">    return -1;</a>
<a name="ln4520">  }</a>
<a name="ln4521"> </a>
<a name="ln4522">  // It's possible for the source and destination to be the same file.</a>
<a name="ln4523">  // This happens when &quot;from&quot; and &quot;to&quot; differ in case and are on a FAT32</a>
<a name="ln4524">  // filesystem. In that case go through a temp file name.</a>
<a name="ln4525">  FileInfo to_info;</a>
<a name="ln4526">  if (os_fileinfo((char *)to, &amp;to_info)</a>
<a name="ln4527">      &amp;&amp; os_fileinfo_id_equal(&amp;from_info,  &amp;to_info)) {</a>
<a name="ln4528">    use_tmp_file = true;</a>
<a name="ln4529">  }</a>
<a name="ln4530"> </a>
<a name="ln4531">  if (use_tmp_file) {</a>
<a name="ln4532">    char_u tempname[MAXPATHL + 1];</a>
<a name="ln4533"> </a>
<a name="ln4534">    // Find a name that doesn't exist and is in the same directory.</a>
<a name="ln4535">    // Rename &quot;from&quot; to &quot;tempname&quot; and then rename &quot;tempname&quot; to &quot;to&quot;.</a>
<a name="ln4536">    if (strlen(from) &gt;= MAXPATHL - 5) {</a>
<a name="ln4537">      return -1;</a>
<a name="ln4538">    }</a>
<a name="ln4539">    STRCPY(tempname, from);</a>
<a name="ln4540">    for (n = 123; n &lt; 99999; n++) {</a>
<a name="ln4541">      char *tail = path_tail((char *)tempname);</a>
<a name="ln4542">      snprintf(tail, (size_t)((MAXPATHL + 1) - (tail - (char *)tempname - 1)), &quot;%d&quot;, n);</a>
<a name="ln4543"> </a>
<a name="ln4544">      if (!os_path_exists((char *)tempname)) {</a>
<a name="ln4545">        if (os_rename((char_u *)from, tempname) == OK) {</a>
<a name="ln4546">          if (os_rename(tempname, (char_u *)to) == OK) {</a>
<a name="ln4547">            return 0;</a>
<a name="ln4548">          }</a>
<a name="ln4549">          // Strange, the second step failed.  Try moving the</a>
<a name="ln4550">          // file back and return failure.</a>
<a name="ln4551">          (void)os_rename(tempname, (char_u *)from);</a>
<a name="ln4552">          return -1;</a>
<a name="ln4553">        }</a>
<a name="ln4554">        // If it fails for one temp name it will most likely fail</a>
<a name="ln4555">        // for any temp name, give up.</a>
<a name="ln4556">        return -1;</a>
<a name="ln4557">      }</a>
<a name="ln4558">    }</a>
<a name="ln4559">    return -1;</a>
<a name="ln4560">  }</a>
<a name="ln4561"> </a>
<a name="ln4562">  // Delete the &quot;to&quot; file, this is required on some systems to make the</a>
<a name="ln4563">  // os_rename() work, on other systems it makes sure that we don't have</a>
<a name="ln4564">  // two files when the os_rename() fails.</a>
<a name="ln4565"> </a>
<a name="ln4566">  os_remove((char *)to);</a>
<a name="ln4567"> </a>
<a name="ln4568">  // First try a normal rename, return if it works.</a>
<a name="ln4569">  if (os_rename((char_u *)from, (char_u *)to) == OK) {</a>
<a name="ln4570">    return 0;</a>
<a name="ln4571">  }</a>
<a name="ln4572"> </a>
<a name="ln4573">  // Rename() failed, try copying the file.</a>
<a name="ln4574">  perm = os_getperm(from);</a>
<a name="ln4575">#ifdef HAVE_ACL</a>
<a name="ln4576">  // For systems that support ACL: get the ACL from the original file.</a>
<a name="ln4577">  acl = mch_get_acl((char_u *)from);</a>
<a name="ln4578">#endif</a>
<a name="ln4579">  fd_in = os_open((char *)from, O_RDONLY, 0);</a>
<a name="ln4580">  if (fd_in &lt; 0) {</a>
<a name="ln4581">#ifdef HAVE_ACL</a>
<a name="ln4582">    mch_free_acl(acl);</a>
<a name="ln4583">#endif</a>
<a name="ln4584">    return -1;</a>
<a name="ln4585">  }</a>
<a name="ln4586"> </a>
<a name="ln4587">  // Create the new file with same permissions as the original.</a>
<a name="ln4588">  fd_out = os_open((char *)to,</a>
<a name="ln4589">                   O_CREAT|O_EXCL|O_WRONLY|O_NOFOLLOW, (int)perm);</a>
<a name="ln4590">  if (fd_out &lt; 0) {</a>
<a name="ln4591">    close(fd_in);</a>
<a name="ln4592">#ifdef HAVE_ACL</a>
<a name="ln4593">    mch_free_acl(acl);</a>
<a name="ln4594">#endif</a>
<a name="ln4595">    return -1;</a>
<a name="ln4596">  }</a>
<a name="ln4597"> </a>
<a name="ln4598">  // Avoid xmalloc() here as vim_rename() is called by buf_write() when nvim</a>
<a name="ln4599">  // is `preserve_exit()`ing.</a>
<a name="ln4600">  buffer = try_malloc(BUFSIZE);</a>
<a name="ln4601">  if (buffer == NULL) {</a>
<a name="ln4602">    close(fd_out);</a>
<a name="ln4603">    close(fd_in);</a>
<a name="ln4604">#ifdef HAVE_ACL</a>
<a name="ln4605">    mch_free_acl(acl);</a>
<a name="ln4606">#endif</a>
<a name="ln4607">    return -1;</a>
<a name="ln4608">  }</a>
<a name="ln4609"> </a>
<a name="ln4610">  while ((n = (int)read_eintr(fd_in, buffer, BUFSIZE)) &gt; 0) {</a>
<a name="ln4611">    if (write_eintr(fd_out, buffer, (size_t)n) != n) {</a>
<a name="ln4612">      errmsg = _(&quot;E208: Error writing to \&quot;%s\&quot;&quot;);</a>
<a name="ln4613">      break;</a>
<a name="ln4614">    }</a>
<a name="ln4615">  }</a>
<a name="ln4616"> </a>
<a name="ln4617">  xfree(buffer);</a>
<a name="ln4618">  close(fd_in);</a>
<a name="ln4619">  if (close(fd_out) &lt; 0) {</a>
<a name="ln4620">    errmsg = _(&quot;E209: Error closing \&quot;%s\&quot;&quot;);</a>
<a name="ln4621">  }</a>
<a name="ln4622">  if (n &lt; 0) {</a>
<a name="ln4623">    errmsg = _(&quot;E210: Error reading \&quot;%s\&quot;&quot;);</a>
<a name="ln4624">    to = from;</a>
<a name="ln4625">  }</a>
<a name="ln4626">#ifndef UNIX  // For Unix os_open() already set the permission.</a>
<a name="ln4627">  os_setperm((const char *)to, perm);</a>
<a name="ln4628">#endif</a>
<a name="ln4629">#ifdef HAVE_ACL</a>
<a name="ln4630">  mch_set_acl((char_u *)to, acl);</a>
<a name="ln4631">  mch_free_acl(acl);</a>
<a name="ln4632">#endif</a>
<a name="ln4633">  if (errmsg != NULL) {</a>
<a name="ln4634">    semsg(errmsg, to);</a>
<a name="ln4635">    return -1;</a>
<a name="ln4636">  }</a>
<a name="ln4637">  os_remove((char *)from);</a>
<a name="ln4638">  return 0;</a>
<a name="ln4639">}</a>
<a name="ln4640"> </a>
<a name="ln4641">static int already_warned = false;</a>
<a name="ln4642"> </a>
<a name="ln4643">/// Check if any not hidden buffer has been changed.</a>
<a name="ln4644">/// Postpone the check if there are characters in the stuff buffer, a global</a>
<a name="ln4645">/// command is being executed, a mapping is being executed or an autocommand is</a>
<a name="ln4646">/// busy.</a>
<a name="ln4647">///</a>
<a name="ln4648">/// @param focus  called for GUI focus event</a>
<a name="ln4649">///</a>
<a name="ln4650">/// @return       true if some message was written (screen should be redrawn and cursor positioned).</a>
<a name="ln4651">int check_timestamps(int focus)</a>
<a name="ln4652">{</a>
<a name="ln4653">  int didit = 0;</a>
<a name="ln4654"> </a>
<a name="ln4655">  // Don't check timestamps while system() or another low-level function may</a>
<a name="ln4656">  // cause us to lose and gain focus.</a>
<a name="ln4657">  if (no_check_timestamps &gt; 0) {</a>
<a name="ln4658">    return false;</a>
<a name="ln4659">  }</a>
<a name="ln4660"> </a>
<a name="ln4661">  // Avoid doing a check twice.  The OK/Reload dialog can cause a focus</a>
<a name="ln4662">  // event and we would keep on checking if the file is steadily growing.</a>
<a name="ln4663">  // Do check again after typing something.</a>
<a name="ln4664">  if (focus &amp;&amp; did_check_timestamps) {</a>
<a name="ln4665">    need_check_timestamps = true;</a>
<a name="ln4666">    return false;</a>
<a name="ln4667">  }</a>
<a name="ln4668"> </a>
<a name="ln4669">  if (!stuff_empty() || global_busy || !typebuf_typed()</a>
<a name="ln4670">      || autocmd_busy || curbuf-&gt;b_ro_locked &gt; 0</a>
<a name="ln4671">      || allbuf_lock &gt; 0) {</a>
<a name="ln4672">    need_check_timestamps = true;               // check later</a>
<a name="ln4673">  } else {</a>
<a name="ln4674">    no_wait_return++;</a>
<a name="ln4675">    did_check_timestamps = true;</a>
<a name="ln4676">    already_warned = false;</a>
<a name="ln4677">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln4678">      // Only check buffers in a window.</a>
<a name="ln4679">      if (buf-&gt;b_nwindows &gt; 0) {</a>
<a name="ln4680">        bufref_T bufref;</a>
<a name="ln4681">        set_bufref(&amp;bufref, buf);</a>
<a name="ln4682">        const int n = buf_check_timestamp(buf);</a>
<a name="ln4683">        if (didit &lt; n) {</a>
<a name="ln4684">          didit = n;</a>
<a name="ln4685">        }</a>
<a name="ln4686">        if (n &gt; 0 &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln4687">          // Autocommands have removed the buffer, start at the first one again.</a>
<a name="ln4688">          buf = firstbuf;</a>
<a name="ln4689">          continue;</a>
<a name="ln4690">        }</a>
<a name="ln4691">      }</a>
<a name="ln4692">    }</a>
<a name="ln4693">    no_wait_return--;</a>
<a name="ln4694">    need_check_timestamps = false;</a>
<a name="ln4695">    if (need_wait_return &amp;&amp; didit == 2) {</a>
<a name="ln4696">      // make sure msg isn't overwritten</a>
<a name="ln4697">      msg_puts(&quot;\n&quot;);</a>
<a name="ln4698">      ui_flush();</a>
<a name="ln4699">    }</a>
<a name="ln4700">  }</a>
<a name="ln4701">  return didit;</a>
<a name="ln4702">}</a>
<a name="ln4703"> </a>
<a name="ln4704">/// Move all the lines from buffer &quot;frombuf&quot; to buffer &quot;tobuf&quot;.</a>
<a name="ln4705">///</a>
<a name="ln4706">/// @return  OK or FAIL.</a>
<a name="ln4707">///          When FAIL &quot;tobuf&quot; is incomplete and/or &quot;frombuf&quot; is not empty.</a>
<a name="ln4708">static int move_lines(buf_T *frombuf, buf_T *tobuf)</a>
<a name="ln4709">{</a>
<a name="ln4710">  buf_T *tbuf = curbuf;</a>
<a name="ln4711">  int retval = OK;</a>
<a name="ln4712">  linenr_T lnum;</a>
<a name="ln4713">  char *p;</a>
<a name="ln4714"> </a>
<a name="ln4715">  // Copy the lines in &quot;frombuf&quot; to &quot;tobuf&quot;.</a>
<a name="ln4716">  curbuf = tobuf;</a>
<a name="ln4717">  for (lnum = 1; lnum &lt;= frombuf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln4718">    p = xstrdup(ml_get_buf(frombuf, lnum, false));</a>
<a name="ln4719">    if (ml_append(lnum - 1, p, 0, false) == FAIL) {</a>
<a name="ln4720">      xfree(p);</a>
<a name="ln4721">      retval = FAIL;</a>
<a name="ln4722">      break;</a>
<a name="ln4723">    }</a>
<a name="ln4724">    xfree(p);</a>
<a name="ln4725">  }</a>
<a name="ln4726"> </a>
<a name="ln4727">  // Delete all the lines in &quot;frombuf&quot;.</a>
<a name="ln4728">  if (retval != FAIL) {</a>
<a name="ln4729">    curbuf = frombuf;</a>
<a name="ln4730">    for (lnum = curbuf-&gt;b_ml.ml_line_count; lnum &gt; 0; lnum--) {</a>
<a name="ln4731">      if (ml_delete(lnum, false) == FAIL) {</a>
<a name="ln4732">        // Oops!  We could try putting back the saved lines, but that</a>
<a name="ln4733">        // might fail again...</a>
<a name="ln4734">        retval = FAIL;</a>
<a name="ln4735">        break;</a>
<a name="ln4736">      }</a>
<a name="ln4737">    }</a>
<a name="ln4738">  }</a>
<a name="ln4739"> </a>
<a name="ln4740">  curbuf = tbuf;</a>
<a name="ln4741">  return retval;</a>
<a name="ln4742">}</a>
<a name="ln4743"> </a>
<a name="ln4744">/// Check if buffer &quot;buf&quot; has been changed.</a>
<a name="ln4745">/// Also check if the file for a new buffer unexpectedly appeared.</a>
<a name="ln4746">///</a>
<a name="ln4747">/// @return  1 if a changed buffer was found or,</a>
<a name="ln4748">///          2 if a message has been displayed or,</a>
<a name="ln4749">///          0 otherwise.</a>
<a name="ln4750">int buf_check_timestamp(buf_T *buf)</a>
<a name="ln4751">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4752">{</a>
<a name="ln4753">  int retval = 0;</a>
<a name="ln4754">  char *path;</a>
<a name="ln4755">  char *mesg = NULL;</a>
<a name="ln4756">  char *mesg2 = &quot;&quot;;</a>
<a name="ln4757">  bool helpmesg = false;</a>
<a name="ln4758"> </a>
<a name="ln4759">  enum {</a>
<a name="ln4760">    RELOAD_NONE,</a>
<a name="ln4761">    RELOAD_NORMAL,</a>
<a name="ln4762">    RELOAD_DETECT,</a>
<a name="ln4763">  } reload = RELOAD_NONE;</a>
<a name="ln4764"> </a>
<a name="ln4765">  bool can_reload = false;</a>
<a name="ln4766">  uint64_t orig_size = buf-&gt;b_orig_size;</a>
<a name="ln4767">  int orig_mode = buf-&gt;b_orig_mode;</a>
<a name="ln4768">  static bool busy = false;</a>
<a name="ln4769">  char *s;</a>
<a name="ln4770">  char *reason;</a>
<a name="ln4771"> </a>
<a name="ln4772">  bufref_T bufref;</a>
<a name="ln4773">  set_bufref(&amp;bufref, buf);</a>
<a name="ln4774"> </a>
<a name="ln4775">  // If its a terminal, there is no file name, the buffer is not loaded,</a>
<a name="ln4776">  // 'buftype' is set, we are in the middle of a save or being called</a>
<a name="ln4777">  // recursively: ignore this buffer.</a>
<a name="ln4778">  if (buf-&gt;terminal</a>
<a name="ln4779">      || buf-&gt;b_ffname == NULL</a>
<a name="ln4780">      || buf-&gt;b_ml.ml_mfp == NULL</a>
<a name="ln4781">      || !bt_normal(buf)</a>
<a name="ln4782">      || buf-&gt;b_saving</a>
<a name="ln4783">      || busy) {</a>
<a name="ln4784">    return 0;</a>
<a name="ln4785">  }</a>
<a name="ln4786"> </a>
<a name="ln4787">  FileInfo file_info;</a>
<a name="ln4788">  bool file_info_ok;</a>
<a name="ln4789">  if (!(buf-&gt;b_flags &amp; BF_NOTEDITED)</a>
<a name="ln4790">      &amp;&amp; buf-&gt;b_mtime != 0</a>
<a name="ln4791">      &amp;&amp; (!(file_info_ok = os_fileinfo(buf-&gt;b_ffname, &amp;file_info))</a>
<a name="ln4792">          || time_differs(&amp;file_info, buf-&gt;b_mtime, buf-&gt;b_mtime_ns)</a>
<a name="ln4793">          || (int)file_info.stat.st_mode != buf-&gt;b_orig_mode)) {</a>
<a name="ln4794">    const long prev_b_mtime = buf-&gt;b_mtime;</a>
<a name="ln4795"> </a>
<a name="ln4796">    retval = 1;</a>
<a name="ln4797"> </a>
<a name="ln4798">    // set b_mtime to stop further warnings (e.g., when executing</a>
<a name="ln4799">    // FileChangedShell autocmd)</a>
<a name="ln4800">    if (!file_info_ok) {</a>
<a name="ln4801">      // Check the file again later to see if it re-appears.</a>
<a name="ln4802">      buf-&gt;b_mtime = -1;</a>
<a name="ln4803">      buf-&gt;b_orig_size = 0;</a>
<a name="ln4804">      buf-&gt;b_orig_mode = 0;</a>
<a name="ln4805">    } else {</a>
<a name="ln4806">      buf_store_file_info(buf, &amp;file_info);</a>
<a name="ln4807">    }</a>
<a name="ln4808"> </a>
<a name="ln4809">    if (os_isdir(buf-&gt;b_fname)) {</a>
<a name="ln4810">      // Don't do anything for a directory.  Might contain the file explorer.</a>
<a name="ln4811">    } else if ((buf-&gt;b_p_ar &gt;= 0 ? buf-&gt;b_p_ar : p_ar)</a>
<a name="ln4812">               &amp;&amp; !bufIsChanged(buf) &amp;&amp; file_info_ok) {</a>
<a name="ln4813">      // If 'autoread' is set, the buffer has no changes and the file still</a>
<a name="ln4814">      // exists, reload the buffer.  Use the buffer-local option value if it</a>
<a name="ln4815">      // was set, the global option value otherwise.</a>
<a name="ln4816">      reload = RELOAD_NORMAL;</a>
<a name="ln4817">    } else {</a>
<a name="ln4818">      if (!file_info_ok) {</a>
<a name="ln4819">        reason = &quot;deleted&quot;;</a>
<a name="ln4820">      } else if (bufIsChanged(buf)) {</a>
<a name="ln4821">        reason = &quot;conflict&quot;;</a>
<a name="ln4822">      } else if (orig_size != buf-&gt;b_orig_size || buf_contents_changed(buf)) {</a>
<a name="ln4823">        reason = &quot;changed&quot;;</a>
<a name="ln4824">      } else if (orig_mode != buf-&gt;b_orig_mode) {</a>
<a name="ln4825">        reason = &quot;mode&quot;;</a>
<a name="ln4826">      } else {</a>
<a name="ln4827">        reason = &quot;time&quot;;</a>
<a name="ln4828">      }</a>
<a name="ln4829"> </a>
<a name="ln4830">      // Only give the warning if there are no FileChangedShell</a>
<a name="ln4831">      // autocommands.</a>
<a name="ln4832">      // Avoid being called recursively by setting &quot;busy&quot;.</a>
<a name="ln4833">      busy = true;</a>
<a name="ln4834">      set_vim_var_string(VV_FCS_REASON, reason, -1);</a>
<a name="ln4835">      set_vim_var_string(VV_FCS_CHOICE, &quot;&quot;, -1);</a>
<a name="ln4836">      allbuf_lock++;</a>
<a name="ln4837">      bool n = apply_autocmds(EVENT_FILECHANGEDSHELL, buf-&gt;b_fname, buf-&gt;b_fname, false, buf);</a>
<a name="ln4838">      allbuf_lock--;</a>
<a name="ln4839">      busy = false;</a>
<a name="ln4840">      if (n) {</a>
<a name="ln4841">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln4842">          emsg(_(&quot;E246: FileChangedShell autocommand deleted buffer&quot;));</a>
<a name="ln4843">        }</a>
<a name="ln4844">        s = get_vim_var_str(VV_FCS_CHOICE);</a>
<a name="ln4845">        if (strcmp(s, &quot;reload&quot;) == 0 &amp;&amp; *reason != 'd') {</a>
<a name="ln4846">          reload = RELOAD_NORMAL;</a>
<a name="ln4847">        } else if (strcmp(s, &quot;edit&quot;) == 0) {</a>
<a name="ln4848">          reload = RELOAD_DETECT;</a>
<a name="ln4849">        } else if (strcmp(s, &quot;ask&quot;) == 0) {</a>
<a name="ln4850">          n = false;</a>
<a name="ln4851">        } else {</a>
<a name="ln4852">          return 2;</a>
<a name="ln4853">        }</a>
<a name="ln4854">      }</a>
<a name="ln4855">      if (!n) {</a>
<a name="ln4856">        if (*reason == 'd') {</a>
<a name="ln4857">          // Only give the message once.</a>
<a name="ln4858">          if (prev_b_mtime != -1) {</a>
<a name="ln4859">            mesg = _(&quot;E211: File \&quot;%s\&quot; no longer available&quot;);</a>
<a name="ln4860">          }</a>
<a name="ln4861">        } else {</a>
<a name="ln4862">          helpmesg = true;</a>
<a name="ln4863">          can_reload = true;</a>
<a name="ln4864"> </a>
<a name="ln4865">          // Check if the file contents really changed to avoid</a>
<a name="ln4866">          // giving a warning when only the timestamp was set (e.g.,</a>
<a name="ln4867">          // checked out of CVS).  Always warn when the buffer was</a>
<a name="ln4868">          // changed.</a>
<a name="ln4869">          if (reason[2] == 'n') {</a>
<a name="ln4870">            mesg = _(</a>
<a name="ln4871">                    &quot;W12: Warning: File \&quot;%s\&quot; has changed and the buffer was changed in Vim as well&quot;);</a>
<a name="ln4872">            mesg2 = _(&quot;See \&quot;:help W12\&quot; for more info.&quot;);</a>
<a name="ln4873">          } else if (reason[1] == 'h') {</a>
<a name="ln4874">            mesg = _(&quot;W11: Warning: File \&quot;%s\&quot; has changed since editing started&quot;);</a>
<a name="ln4875">            mesg2 = _(&quot;See \&quot;:help W11\&quot; for more info.&quot;);</a>
<a name="ln4876">          } else if (*reason == 'm') {</a>
<a name="ln4877">            mesg = _(&quot;W16: Warning: Mode of file \&quot;%s\&quot; has changed since editing started&quot;);</a>
<a name="ln4878">            mesg2 = _(&quot;See \&quot;:help W16\&quot; for more info.&quot;);</a>
<a name="ln4879">          } else {</a>
<a name="ln4880">            // Only timestamp changed, store it to avoid a warning</a>
<a name="ln4881">            // in check_mtime() later.</a>
<a name="ln4882">            buf-&gt;b_mtime_read = buf-&gt;b_mtime;</a>
<a name="ln4883">            buf-&gt;b_mtime_read_ns = buf-&gt;b_mtime_ns;</a>
<a name="ln4884">          }</a>
<a name="ln4885">        }</a>
<a name="ln4886">      }</a>
<a name="ln4887">    }</a>
<a name="ln4888">  } else if ((buf-&gt;b_flags &amp; BF_NEW) &amp;&amp; !(buf-&gt;b_flags &amp; BF_NEW_W)</a>
<a name="ln4889">             &amp;&amp; os_path_exists(buf-&gt;b_ffname)) {</a>
<a name="ln4890">    retval = 1;</a>
<a name="ln4891">    mesg = _(&quot;W13: Warning: File \&quot;%s\&quot; has been created after editing started&quot;);</a>
<a name="ln4892">    buf-&gt;b_flags |= BF_NEW_W;</a>
<a name="ln4893">    can_reload = true;</a>
<a name="ln4894">  }</a>
<a name="ln4895"> </a>
<a name="ln4896">  if (mesg != NULL) {</a>
<a name="ln4897">    path = home_replace_save(buf, buf-&gt;b_fname);</a>
<a name="ln4898">    if (!helpmesg) {</a>
<a name="ln4899">      mesg2 = &quot;&quot;;</a>
<a name="ln4900">    }</a>
<a name="ln4901">    const size_t tbuf_len = strlen(path) + strlen(mesg) + strlen(mesg2) + 2;</a>
<a name="ln4902">    char *const tbuf = xmalloc(tbuf_len);</a>
<a name="ln4903">    snprintf(tbuf, tbuf_len, mesg, path);</a>
<a name="ln4904">    // Set warningmsg here, before the unimportant and output-specific</a>
<a name="ln4905">    // mesg2 has been appended.</a>
<a name="ln4906">    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);</a>
<a name="ln4907">    if (can_reload) {</a>
<a name="ln4908">      if (*mesg2 != NUL) {</a>
<a name="ln4909">        xstrlcat(tbuf, &quot;\n&quot;, tbuf_len - 1);</a>
<a name="ln4910">        xstrlcat(tbuf, mesg2, tbuf_len - 1);</a>
<a name="ln4911">      }</a>
<a name="ln4912">      switch (do_dialog(VIM_WARNING, _(&quot;Warning&quot;), tbuf,</a>
<a name="ln4913">                        _(&quot;&amp;OK\n&amp;Load File\nLoad File &amp;and Options&quot;),</a>
<a name="ln4914">                        1, NULL, true)) {</a>
<a name="ln4915">      case 2:</a>
<a name="ln4916">        reload = RELOAD_NORMAL;</a>
<a name="ln4917">        break;</a>
<a name="ln4918">      case 3:</a>
<a name="ln4919">        reload = RELOAD_DETECT;</a>
<a name="ln4920">        break;</a>
<a name="ln4921">      }</a>
<a name="ln4922">    } else if (State &gt; MODE_NORMAL_BUSY || (State &amp; MODE_CMDLINE) || already_warned) {</a>
<a name="ln4923">      if (*mesg2 != NUL) {</a>
<a name="ln4924">        xstrlcat(tbuf, &quot;; &quot;, tbuf_len - 1);</a>
<a name="ln4925">        xstrlcat(tbuf, mesg2, tbuf_len - 1);</a>
<a name="ln4926">      }</a>
<a name="ln4927">      emsg(tbuf);</a>
<a name="ln4928">      retval = 2;</a>
<a name="ln4929">    } else {</a>
<a name="ln4930">      if (!autocmd_busy) {</a>
<a name="ln4931">        msg_start();</a>
<a name="ln4932">        msg_puts_attr(tbuf, HL_ATTR(HLF_E) + MSG_HIST);</a>
<a name="ln4933">        if (*mesg2 != NUL) {</a>
<a name="ln4934">          msg_puts_attr(mesg2, HL_ATTR(HLF_W) + MSG_HIST);</a>
<a name="ln4935">        }</a>
<a name="ln4936">        msg_clr_eos();</a>
<a name="ln4937">        (void)msg_end();</a>
<a name="ln4938">        if (emsg_silent == 0) {</a>
<a name="ln4939">          ui_flush();</a>
<a name="ln4940">          // give the user some time to think about it</a>
<a name="ln4941">          os_delay(1004L, true);</a>
<a name="ln4942"> </a>
<a name="ln4943">          // don't redraw and erase the message</a>
<a name="ln4944">          redraw_cmdline = false;</a>
<a name="ln4945">        }</a>
<a name="ln4946">      }</a>
<a name="ln4947">      already_warned = true;</a>
<a name="ln4948">    }</a>
<a name="ln4949"> </a>
<a name="ln4950">    xfree(path);</a>
<a name="ln4951">    xfree(tbuf);</a>
<a name="ln4952">  }</a>
<a name="ln4953"> </a>
<a name="ln4954">  if (reload != RELOAD_NONE) {</a>
<a name="ln4955">    // Reload the buffer.</a>
<a name="ln4956">    buf_reload(buf, orig_mode, reload == RELOAD_DETECT);</a>
<a name="ln4957">    if (buf-&gt;b_p_udf &amp;&amp; buf-&gt;b_ffname != NULL) {</a>
<a name="ln4958">      char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln4959"> </a>
<a name="ln4960">      // Any existing undo file is unusable, write it now.</a>
<a name="ln4961">      u_compute_hash(buf, hash);</a>
<a name="ln4962">      u_write_undo(NULL, false, buf, hash);</a>
<a name="ln4963">    }</a>
<a name="ln4964">  }</a>
<a name="ln4965"> </a>
<a name="ln4966">  // Trigger FileChangedShell when the file was changed in any way.</a>
<a name="ln4967">  if (bufref_valid(&amp;bufref) &amp;&amp; retval != 0) {</a>
<a name="ln4968">    (void)apply_autocmds(EVENT_FILECHANGEDSHELLPOST, buf-&gt;b_fname, buf-&gt;b_fname, false, buf);</a>
<a name="ln4969">  }</a>
<a name="ln4970">  return retval;</a>
<a name="ln4971">}</a>
<a name="ln4972"> </a>
<a name="ln4973">/// Reload a buffer that is already loaded.</a>
<a name="ln4974">/// Used when the file was changed outside of Vim.</a>
<a name="ln4975">/// &quot;orig_mode&quot; is buf-&gt;b_orig_mode before the need for reloading was detected.</a>
<a name="ln4976">/// buf-&gt;b_orig_mode may have been reset already.</a>
<a name="ln4977">void buf_reload(buf_T *buf, int orig_mode, bool reload_options)</a>
<a name="ln4978">{</a>
<a name="ln4979">  exarg_T ea;</a>
<a name="ln4980">  pos_T old_cursor;</a>
<a name="ln4981">  linenr_T old_topline;</a>
<a name="ln4982">  int old_ro = buf-&gt;b_p_ro;</a>
<a name="ln4983">  buf_T *savebuf;</a>
<a name="ln4984">  bufref_T bufref;</a>
<a name="ln4985">  int saved = OK;</a>
<a name="ln4986">  aco_save_T aco;</a>
<a name="ln4987">  int flags = READ_NEW;</a>
<a name="ln4988"> </a>
<a name="ln4989">  // set curwin/curbuf for &quot;buf&quot; and save some things</a>
<a name="ln4990">  aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln4991"> </a>
<a name="ln4992">  // Unless reload_options is set, we only want to read the text from the</a>
<a name="ln4993">  // file, not reset the syntax highlighting, clear marks, diff status, etc.</a>
<a name="ln4994">  // Force the fileformat and encoding to be the same.</a>
<a name="ln4995">  if (reload_options) {</a>
<a name="ln4996">    CLEAR_FIELD(ea);</a>
<a name="ln4997">  } else {</a>
<a name="ln4998">    prep_exarg(&amp;ea, buf);</a>
<a name="ln4999">  }</a>
<a name="ln5000"> </a>
<a name="ln5001">  old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln5002">  old_topline = curwin-&gt;w_topline;</a>
<a name="ln5003"> </a>
<a name="ln5004">  if (p_ur &lt; 0 || curbuf-&gt;b_ml.ml_line_count &lt;= p_ur) {</a>
<a name="ln5005">    // Save all the text, so that the reload can be undone.</a>
<a name="ln5006">    // Sync first so that this is a separate undo-able action.</a>
<a name="ln5007">    u_sync(false);</a>
<a name="ln5008">    saved = u_savecommon(curbuf, 0, curbuf-&gt;b_ml.ml_line_count + 1, 0, true);</a>
<a name="ln5009">    flags |= READ_KEEP_UNDO;</a>
<a name="ln5010">  }</a>
<a name="ln5011"> </a>
<a name="ln5012">  // To behave like when a new file is edited (matters for</a>
<a name="ln5013">  // BufReadPost autocommands) we first need to delete the current</a>
<a name="ln5014">  // buffer contents.  But if reading the file fails we should keep</a>
<a name="ln5015">  // the old contents.  Can't use memory only, the file might be</a>
<a name="ln5016">  // too big.  Use a hidden buffer to move the buffer contents to.</a>
<a name="ln5017">  if (buf_is_empty(curbuf) || saved == FAIL) {</a>
<a name="ln5018">    savebuf = NULL;</a>
<a name="ln5019">  } else {</a>
<a name="ln5020">    // Allocate a buffer without putting it in the buffer list.</a>
<a name="ln5021">    savebuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);</a>
<a name="ln5022">    set_bufref(&amp;bufref, savebuf);</a>
<a name="ln5023">    if (savebuf != NULL &amp;&amp; buf == curbuf) {</a>
<a name="ln5024">      // Open the memline.</a>
<a name="ln5025">      curbuf = savebuf;</a>
<a name="ln5026">      curwin-&gt;w_buffer = savebuf;</a>
<a name="ln5027">      saved = ml_open(curbuf);</a>
<a name="ln5028">      curbuf = buf;</a>
<a name="ln5029">      curwin-&gt;w_buffer = buf;</a>
<a name="ln5030">    }</a>
<a name="ln5031">    if (savebuf == NULL || saved == FAIL || buf != curbuf</a>
<a name="ln5032">        || move_lines(buf, savebuf) == FAIL) {</a>
<a name="ln5033">      semsg(_(&quot;E462: Could not prepare for reloading \&quot;%s\&quot;&quot;),</a>
<a name="ln5034">            buf-&gt;b_fname);</a>
<a name="ln5035">      saved = FAIL;</a>
<a name="ln5036">    }</a>
<a name="ln5037">  }</a>
<a name="ln5038"> </a>
<a name="ln5039">  if (saved == OK) {</a>
<a name="ln5040">    curbuf-&gt;b_flags |= BF_CHECK_RO;           // check for RO again</a>
<a name="ln5041">    keep_filetype = true;                     // don't detect 'filetype'</a>
<a name="ln5042">    if (readfile(buf-&gt;b_ffname, buf-&gt;b_fname, (linenr_T)0, (linenr_T)0,</a>
<a name="ln5043">                 (linenr_T)MAXLNUM, &amp;ea, flags, false) != OK) {</a>
<a name="ln5044">      if (!aborting()) {</a>
<a name="ln5045">        semsg(_(&quot;E321: Could not reload \&quot;%s\&quot;&quot;), buf-&gt;b_fname);</a>
<a name="ln5046">      }</a>
<a name="ln5047">      if (savebuf != NULL &amp;&amp; bufref_valid(&amp;bufref) &amp;&amp; buf == curbuf) {</a>
<a name="ln5048">        // Put the text back from the save buffer.  First</a>
<a name="ln5049">        // delete any lines that readfile() added.</a>
<a name="ln5050">        while (!buf_is_empty(curbuf)) {</a>
<a name="ln5051">          if (ml_delete(buf-&gt;b_ml.ml_line_count, false) == FAIL) {</a>
<a name="ln5052">            break;</a>
<a name="ln5053">          }</a>
<a name="ln5054">        }</a>
<a name="ln5055">        (void)move_lines(savebuf, buf);</a>
<a name="ln5056">      }</a>
<a name="ln5057">    } else if (buf == curbuf) {  // &quot;buf&quot; still valid.</a>
<a name="ln5058">      // Mark the buffer as unmodified and free undo info.</a>
<a name="ln5059">      unchanged(buf, true, true);</a>
<a name="ln5060">      if ((flags &amp; READ_KEEP_UNDO) == 0) {</a>
<a name="ln5061">        u_blockfree(buf);</a>
<a name="ln5062">        u_clearall(buf);</a>
<a name="ln5063">      } else {</a>
<a name="ln5064">        // Mark all undo states as changed.</a>
<a name="ln5065">        u_unchanged(curbuf);</a>
<a name="ln5066">      }</a>
<a name="ln5067">      buf_updates_unload(curbuf, true);</a>
<a name="ln5068">      curbuf-&gt;b_mod_set = true;</a>
<a name="ln5069">    }</a>
<a name="ln5070">  }</a>
<a name="ln5071">  xfree(ea.cmd);</a>
<a name="ln5072"> </a>
<a name="ln5073">  if (savebuf != NULL &amp;&amp; bufref_valid(&amp;bufref)) {</a>
<a name="ln5074">    wipe_buffer(savebuf, false);</a>
<a name="ln5075">  }</a>
<a name="ln5076"> </a>
<a name="ln5077">  // Invalidate diff info if necessary.</a>
<a name="ln5078">  diff_invalidate(curbuf);</a>
<a name="ln5079"> </a>
<a name="ln5080">  // Restore the topline and cursor position and check it (lines may</a>
<a name="ln5081">  // have been removed).</a>
<a name="ln5082">  if (old_topline &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5083">    curwin-&gt;w_topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln5084">  } else {</a>
<a name="ln5085">    curwin-&gt;w_topline = old_topline;</a>
<a name="ln5086">  }</a>
<a name="ln5087">  curwin-&gt;w_cursor = old_cursor;</a>
<a name="ln5088">  check_cursor();</a>
<a name="ln5089">  update_topline(curwin);</a>
<a name="ln5090">  keep_filetype = false;</a>
<a name="ln5091"> </a>
<a name="ln5092">  // Update folds unless they are defined manually.</a>
<a name="ln5093">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln5094">    if (wp-&gt;w_buffer == curwin-&gt;w_buffer</a>
<a name="ln5095">        &amp;&amp; !foldmethodIsManual(wp)) {</a>
<a name="ln5096">      foldUpdateAll(wp);</a>
<a name="ln5097">    }</a>
<a name="ln5098">  }</a>
<a name="ln5099"> </a>
<a name="ln5100">  // If the mode didn't change and 'readonly' was set, keep the old</a>
<a name="ln5101">  // value; the user probably used the &quot;:view&quot; command.  But don't</a>
<a name="ln5102">  // reset it, might have had a read error.</a>
<a name="ln5103">  if (orig_mode == curbuf-&gt;b_orig_mode) {</a>
<a name="ln5104">    curbuf-&gt;b_p_ro |= old_ro;</a>
<a name="ln5105">  }</a>
<a name="ln5106"> </a>
<a name="ln5107">  // Modelines must override settings done by autocommands.</a>
<a name="ln5108">  do_modelines(0);</a>
<a name="ln5109"> </a>
<a name="ln5110">  // restore curwin/curbuf and a few other things</a>
<a name="ln5111">  aucmd_restbuf(&amp;aco);</a>
<a name="ln5112">  // Careful: autocommands may have made &quot;buf&quot; invalid!</a>
<a name="ln5113">}</a>
<a name="ln5114"> </a>
<a name="ln5115">void buf_store_file_info(buf_T *buf, FileInfo *file_info)</a>
<a name="ln5116">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5117">{</a>
<a name="ln5118">  buf-&gt;b_mtime = file_info-&gt;stat.st_mtim.tv_sec;</a>
<a name="ln5119">  buf-&gt;b_mtime_ns = file_info-&gt;stat.st_mtim.tv_nsec;</a>
<a name="ln5120">  buf-&gt;b_orig_size = os_fileinfo_size(file_info);</a>
<a name="ln5121">  buf-&gt;b_orig_mode = (int)file_info-&gt;stat.st_mode;</a>
<a name="ln5122">}</a>
<a name="ln5123"> </a>
<a name="ln5124">/// Adjust the line with missing eol, used for the next write.</a>
<a name="ln5125">/// Used for do_filter(), when the input lines for the filter are deleted.</a>
<a name="ln5126">void write_lnum_adjust(linenr_T offset)</a>
<a name="ln5127">{</a>
<a name="ln5128">  if (curbuf-&gt;b_no_eol_lnum != 0) {     // only if there is a missing eol</a>
<a name="ln5129">    curbuf-&gt;b_no_eol_lnum += offset;</a>
<a name="ln5130">  }</a>
<a name="ln5131">}</a>
<a name="ln5132"> </a>
<a name="ln5133">#if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln5134">/// Convert all backslashes in fname to forward slashes in-place,</a>
<a name="ln5135">/// unless when it looks like a URL.</a>
<a name="ln5136">void forward_slash(char_u *fname)</a>
<a name="ln5137">{</a>
<a name="ln5138">  char_u *p;</a>
<a name="ln5139"> </a>
<a name="ln5140">  if (path_with_url((const char *)fname)) {</a>
<a name="ln5141">    return;</a>
<a name="ln5142">  }</a>
<a name="ln5143">  for (p = fname; *p != NUL; p++) {</a>
<a name="ln5144">    if (*p == '\\') {</a>
<a name="ln5145">      *p = '/';</a>
<a name="ln5146">    }</a>
<a name="ln5147">  }</a>
<a name="ln5148">}</a>
<a name="ln5149">#endif</a>
<a name="ln5150"> </a>
<a name="ln5151">/// Path to Nvim's own temp dir. Ends in a slash.</a>
<a name="ln5152">static char *vim_tempdir = NULL;</a>
<a name="ln5153"> </a>
<a name="ln5154">/// Creates a directory for private use by this instance of Nvim, trying each of</a>
<a name="ln5155">/// `TEMP_DIR_NAMES` until one succeeds.</a>
<a name="ln5156">///</a>
<a name="ln5157">/// Only done once, the same directory is used for all temp files.</a>
<a name="ln5158">/// This method avoids security problems because of symlink attacks et al.</a>
<a name="ln5159">/// It's also a bit faster, because we only need to check for an existing</a>
<a name="ln5160">/// file when creating the directory and not for each temp file.</a>
<a name="ln5161">static void vim_mktempdir(void)</a>
<a name="ln5162">{</a>
<a name="ln5163">  static const char *temp_dirs[] = TEMP_DIR_NAMES;  // Try each of these until one succeeds.</a>
<a name="ln5164">  char tmp[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln5165">  char path[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln5166">  char user[40] = { 0 };</a>
<a name="ln5167"> </a>
<a name="ln5168">  (void)os_get_username(user, sizeof(user));</a>
<a name="ln5169">  // Usernames may contain slashes! #19240</a>
<a name="ln5170">  memchrsub(user, '/', '_', sizeof(user));</a>
<a name="ln5171">  memchrsub(user, '\\', '_', sizeof(user));</a>
<a name="ln5172"> </a>
<a name="ln5173">  // Make sure the umask doesn't remove the executable bit.</a>
<a name="ln5174">  // &quot;repl&quot; has been reported to use &quot;0177&quot;.</a>
<a name="ln5175">  mode_t umask_save = umask(0077);</a>
<a name="ln5176">  for (size_t i = 0; i &lt; ARRAY_SIZE(temp_dirs); i++) {</a>
<a name="ln5177">    // Expand environment variables, leave room for &quot;/tmp/nvim.&lt;user&gt;/XXXXXX/999999999&quot;.</a>
<a name="ln5178">    expand_env((char *)temp_dirs[i], tmp, TEMP_FILE_PATH_MAXLEN - 64);</a>
<a name="ln5179">    if (!os_isdir(tmp)) {</a>
<a name="ln5180">      continue;</a>
<a name="ln5181">    }</a>
<a name="ln5182"> </a>
<a name="ln5183">    // &quot;/tmp/&quot; exists, now try to create &quot;/tmp/nvim.&lt;user&gt;/&quot;.</a>
<a name="ln5184">    add_pathsep(tmp);</a>
<a name="ln5185">    xstrlcat(tmp, &quot;nvim.&quot;, sizeof(tmp));</a>
<a name="ln5186">    xstrlcat(tmp, user, sizeof(tmp));</a>
<a name="ln5187">    (void)os_mkdir(tmp, 0700);  // Always create, to avoid a race.</a>
<a name="ln5188">    bool owned = os_file_owned(tmp);</a>
<a name="ln5189">    bool isdir = os_isdir(tmp);</a>
<a name="ln5190">#ifdef UNIX</a>
<a name="ln5191">    int perm = os_getperm(tmp);  // XDG_RUNTIME_DIR must be owned by the user, mode 0700.</a>
<a name="ln5192">    bool valid = isdir &amp;&amp; owned &amp;&amp; 0700 == (perm &amp; 0777);</a>
<a name="ln5193">#else</a>
<a name="ln5194">    bool valid = isdir &amp;&amp; owned;  // TODO(justinmk): Windows ACL?</a>
<a name="ln5195">#endif</a>
<a name="ln5196">    if (valid) {</a>
<a name="ln5197">      add_pathsep(tmp);</a>
<a name="ln5198">    } else {</a>
<a name="ln5199">      if (!owned) {</a>
<a name="ln5200">        ELOG(&quot;tempdir root not owned by current user (%s): %s&quot;, user, tmp);</a>
<a name="ln5201">      } else if (!isdir) {</a>
<a name="ln5202">        ELOG(&quot;tempdir root not a directory: %s&quot;, tmp);</a>
<a name="ln5203">      }</a>
<a name="ln5204">#ifdef UNIX</a>
<a name="ln5205">      if (0700 != (perm &amp; 0777)) {</a>
<a name="ln5206">        ELOG(&quot;tempdir root has invalid permissions (%o): %s&quot;, perm, tmp);</a>
<a name="ln5207">      }</a>
<a name="ln5208">#endif</a>
<a name="ln5209">      // If our &quot;root&quot; tempdir is invalid or fails, proceed without &quot;&lt;user&gt;/&quot;.</a>
<a name="ln5210">      // Else user1 could break user2 by creating &quot;/tmp/nvim.user2/&quot;.</a>
<a name="ln5211">      tmp[strlen(tmp) - strlen(user)] = '\0';</a>
<a name="ln5212">    }</a>
<a name="ln5213"> </a>
<a name="ln5214">    // Now try to create &quot;/tmp/nvim.&lt;user&gt;/XXXXXX&quot;.</a>
<a name="ln5215">    xstrlcat(tmp, &quot;XXXXXX&quot;, sizeof(tmp));  // mkdtemp &quot;template&quot;, will be replaced with random alphanumeric chars.</a>
<a name="ln5216">    int r = os_mkdtemp(tmp, path);</a>
<a name="ln5217">    if (r != 0) {</a>
<a name="ln5218">      WLOG(&quot;tempdir create failed: %s: %s&quot;, os_strerror(r), tmp);</a>
<a name="ln5219">      continue;</a>
<a name="ln5220">    }</a>
<a name="ln5221"> </a>
<a name="ln5222">    if (vim_settempdir(path)) {</a>
<a name="ln5223">      // Successfully created and set temporary directory so stop trying.</a>
<a name="ln5224">      break;</a>
<a name="ln5225">    } else {</a>
<a name="ln5226">      // Couldn't set `vim_tempdir` to `path` so remove created directory.</a>
<a name="ln5227">      os_rmdir(path);</a>
<a name="ln5228">    }</a>
<a name="ln5229">  }</a>
<a name="ln5230">  (void)umask(umask_save);</a>
<a name="ln5231">}</a>
<a name="ln5232"> </a>
<a name="ln5233">/// Core part of &quot;readdir()&quot; function.</a>
<a name="ln5234">/// Retrieve the list of files/directories of &quot;path&quot; into &quot;gap&quot;.</a>
<a name="ln5235">///</a>
<a name="ln5236">/// @return  OK for success, FAIL for failure.</a>
<a name="ln5237">int readdir_core(garray_T *gap, const char *path, void *context, CheckItem checkitem)</a>
<a name="ln5238">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln5239">{</a>
<a name="ln5240">  ga_init(gap, (int)sizeof(char *), 20);</a>
<a name="ln5241"> </a>
<a name="ln5242">  Directory dir;</a>
<a name="ln5243">  if (!os_scandir(&amp;dir, path)) {</a>
<a name="ln5244">    smsg(_(e_notopen), path);</a>
<a name="ln5245">    return FAIL;</a>
<a name="ln5246">  }</a>
<a name="ln5247"> </a>
<a name="ln5248">  for (;;) {</a>
<a name="ln5249">    const char *p = os_scandir_next(&amp;dir);</a>
<a name="ln5250">    if (p == NULL) {</a>
<a name="ln5251">      break;</a>
<a name="ln5252">    }</a>
<a name="ln5253"> </a>
<a name="ln5254">    bool ignore = (p[0] == '.' &amp;&amp; (p[1] == NUL || (p[1] == '.' &amp;&amp; p[2] == NUL)));</a>
<a name="ln5255">    if (!ignore &amp;&amp; checkitem != NULL) {</a>
<a name="ln5256">      varnumber_T r = checkitem(context, p);</a>
<a name="ln5257">      if (r &lt; 0) {</a>
<a name="ln5258">        break;</a>
<a name="ln5259">      }</a>
<a name="ln5260">      if (r == 0) {</a>
<a name="ln5261">        ignore = true;</a>
<a name="ln5262">      }</a>
<a name="ln5263">    }</a>
<a name="ln5264"> </a>
<a name="ln5265">    if (!ignore) {</a>
<a name="ln5266">      ga_grow(gap, 1);</a>
<a name="ln5267">      ((char **)gap-&gt;ga_data)[gap-&gt;ga_len++] = xstrdup(p);</a>
<a name="ln5268">    }</a>
<a name="ln5269">  }</a>
<a name="ln5270"> </a>
<a name="ln5271">  os_closedir(&amp;dir);</a>
<a name="ln5272"> </a>
<a name="ln5273">  if (gap-&gt;ga_len &gt; 0) {</a>
<a name="ln5274">    sort_strings(gap-&gt;ga_data, gap-&gt;ga_len);</a>
<a name="ln5275">  }</a>
<a name="ln5276"> </a>
<a name="ln5277">  return OK;</a>
<a name="ln5278">}</a>
<a name="ln5279"> </a>
<a name="ln5280">/// Delete &quot;name&quot; and everything in it, recursively.</a>
<a name="ln5281">///</a>
<a name="ln5282">/// @param name  The path which should be deleted.</a>
<a name="ln5283">///</a>
<a name="ln5284">/// @return  0 for success, -1 if some file was not deleted.</a>
<a name="ln5285">int delete_recursive(const char *name)</a>
<a name="ln5286">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5287">{</a>
<a name="ln5288">  int result = 0;</a>
<a name="ln5289"> </a>
<a name="ln5290">  if (os_isrealdir(name)) {</a>
<a name="ln5291">    char *exp = xstrdup(name);</a>
<a name="ln5292">    garray_T ga;</a>
<a name="ln5293">    if (readdir_core(&amp;ga, exp, NULL, NULL) == OK) {</a>
<a name="ln5294">      for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln5295">        vim_snprintf((char *)NameBuff, MAXPATHL, &quot;%s/%s&quot;, exp, ((char_u **)ga.ga_data)[i]);</a>
<a name="ln5296">        if (delete_recursive((const char *)NameBuff) != 0) {</a>
<a name="ln5297">          // Remember the failure but continue deleting any further</a>
<a name="ln5298">          // entries.</a>
<a name="ln5299">          result = -1;</a>
<a name="ln5300">        }</a>
<a name="ln5301">      }</a>
<a name="ln5302">      ga_clear_strings(&amp;ga);</a>
<a name="ln5303">      if (os_rmdir(exp) != 0) {</a>
<a name="ln5304">        result = -1;</a>
<a name="ln5305">      }</a>
<a name="ln5306">    } else {</a>
<a name="ln5307">      result = -1;</a>
<a name="ln5308">    }</a>
<a name="ln5309">    xfree(exp);</a>
<a name="ln5310">  } else {</a>
<a name="ln5311">    // Delete symlink only.</a>
<a name="ln5312">    result = os_remove(name) == 0 ? 0 : -1;</a>
<a name="ln5313">  }</a>
<a name="ln5314"> </a>
<a name="ln5315">  return result;</a>
<a name="ln5316">}</a>
<a name="ln5317"> </a>
<a name="ln5318">/// Delete the temp directory and all files it contains.</a>
<a name="ln5319">void vim_deltempdir(void)</a>
<a name="ln5320">{</a>
<a name="ln5321">  if (vim_tempdir != NULL) {</a>
<a name="ln5322">    // remove the trailing path separator</a>
<a name="ln5323">    path_tail(vim_tempdir)[-1] = NUL;</a>
<a name="ln5324">    delete_recursive(vim_tempdir);</a>
<a name="ln5325">    XFREE_CLEAR(vim_tempdir);</a>
<a name="ln5326">  }</a>
<a name="ln5327">}</a>
<a name="ln5328"> </a>
<a name="ln5329">/// Gets path to Nvim's own temp dir (ending with slash).</a>
<a name="ln5330">///</a>
<a name="ln5331">/// Creates the directory on the first call.</a>
<a name="ln5332">char *vim_gettempdir(void)</a>
<a name="ln5333">{</a>
<a name="ln5334">  if (vim_tempdir == NULL) {</a>
<a name="ln5335">    vim_mktempdir();</a>
<a name="ln5336">  }</a>
<a name="ln5337"> </a>
<a name="ln5338">  return vim_tempdir;</a>
<a name="ln5339">}</a>
<a name="ln5340"> </a>
<a name="ln5341">/// Sets Nvim's own temporary directory name to `tempdir`. This directory must</a>
<a name="ln5342">/// already exist. Expands the name to a full path and put it in `vim_tempdir`.</a>
<a name="ln5343">/// This avoids that using `:cd` would confuse us.</a>
<a name="ln5344">///</a>
<a name="ln5345">/// @param tempdir must be no longer than MAXPATHL.</a>
<a name="ln5346">///</a>
<a name="ln5347">/// @return false if we run out of memory.</a>
<a name="ln5348">static bool vim_settempdir(char *tempdir)</a>
<a name="ln5349">{</a>
<a name="ln5350">  char *buf = verbose_try_malloc(MAXPATHL + 2);</a>
<a name="ln5351">  if (!buf) {</a>
<a name="ln5352">    return false;</a>
<a name="ln5353">  }</a>
<a name="ln5354">  vim_FullName(tempdir, buf, MAXPATHL, false);</a>
<a name="ln5355">  add_pathsep(buf);</a>
<a name="ln5356">  vim_tempdir = xstrdup(buf);</a>
<a name="ln5357">  xfree(buf);</a>
<a name="ln5358">  return true;</a>
<a name="ln5359">}</a>
<a name="ln5360"> </a>
<a name="ln5361">/// Return a unique name that can be used for a temp file.</a>
<a name="ln5362">///</a>
<a name="ln5363">/// @note The temp file is NOT created.</a>
<a name="ln5364">///</a>
<a name="ln5365">/// @return  pointer to the temp file name or NULL if Nvim can't create</a>
<a name="ln5366">///          temporary directory for its own temporary files.</a>
<a name="ln5367">char *vim_tempname(void)</a>
<a name="ln5368">{</a>
<a name="ln5369">  // Temp filename counter.</a>
<a name="ln5370">  static uint64_t temp_count;</a>
<a name="ln5371"> </a>
<a name="ln5372">  char *tempdir = vim_gettempdir();</a>
<a name="ln5373">  if (!tempdir) {</a>
<a name="ln5374">    return NULL;</a>
<a name="ln5375">  }</a>
<a name="ln5376"> </a>
<a name="ln5377">  // There is no need to check if the file exists, because we own the directory</a>
<a name="ln5378">  // and nobody else creates a file in it.</a>
<a name="ln5379">  char template[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln5380">  snprintf(template, TEMP_FILE_PATH_MAXLEN,</a>
<a name="ln5381">           &quot;%s%&quot; PRIu64, tempdir, temp_count++);</a>
<a name="ln5382">  return xstrdup(template);</a>
<a name="ln5383">}</a>
<a name="ln5384"> </a>
<a name="ln5385">/// Tries matching a filename with a &quot;pattern&quot; (&quot;prog&quot; is NULL), or use the</a>
<a name="ln5386">/// precompiled regprog &quot;prog&quot; (&quot;pattern&quot; is NULL).  That avoids calling</a>
<a name="ln5387">/// vim_regcomp() often.</a>
<a name="ln5388">///</a>
<a name="ln5389">/// Used for autocommands and 'wildignore'.</a>
<a name="ln5390">///</a>
<a name="ln5391">/// @param pattern pattern to match with</a>
<a name="ln5392">/// @param prog pre-compiled regprog or NULL</a>
<a name="ln5393">/// @param fname full path of the file name</a>
<a name="ln5394">/// @param sfname short file name or NULL</a>
<a name="ln5395">/// @param tail tail of the path</a>
<a name="ln5396">/// @param allow_dirs Allow matching with dir</a>
<a name="ln5397">///</a>
<a name="ln5398">/// @return true if there is a match, false otherwise</a>
<a name="ln5399">bool match_file_pat(char *pattern, regprog_T **prog, char *fname, char *sfname, char *tail,</a>
<a name="ln5400">                    int allow_dirs)</a>
<a name="ln5401">{</a>
<a name="ln5402">  regmatch_T regmatch;</a>
<a name="ln5403">  bool result = false;</a>
<a name="ln5404"> </a>
<a name="ln5405">  regmatch.rm_ic = p_fic;   // ignore case if 'fileignorecase' is set</a>
<a name="ln5406">  {</a>
<a name="ln5407">    if (prog != NULL) {</a>
<a name="ln5408">      regmatch.regprog = *prog;</a>
<a name="ln5409">    } else {</a>
<a name="ln5410">      regmatch.regprog = vim_regcomp(pattern, RE_MAGIC);</a>
<a name="ln5411">    }</a>
<a name="ln5412">  }</a>
<a name="ln5413"> </a>
<a name="ln5414">  // Try for a match with the pattern with:</a>
<a name="ln5415">  // 1. the full file name, when the pattern has a '/'.</a>
<a name="ln5416">  // 2. the short file name, when the pattern has a '/'.</a>
<a name="ln5417">  // 3. the tail of the file name, when the pattern has no '/'.</a>
<a name="ln5418">  if (regmatch.regprog != NULL</a>
<a name="ln5419">      &amp;&amp; ((allow_dirs</a>
<a name="ln5420">           &amp;&amp; (vim_regexec(&amp;regmatch, fname, (colnr_T)0)</a>
<a name="ln5421">               || (sfname != NULL</a>
<a name="ln5422">                   &amp;&amp; vim_regexec(&amp;regmatch, sfname, (colnr_T)0))))</a>
<a name="ln5423">          || (!allow_dirs &amp;&amp; vim_regexec(&amp;regmatch, tail, (colnr_T)0)))) {</a>
<a name="ln5424">    result = true;</a>
<a name="ln5425">  }</a>
<a name="ln5426"> </a>
<a name="ln5427">  if (prog != NULL) {</a>
<a name="ln5428">    *prog = regmatch.regprog;</a>
<a name="ln5429">  } else {</a>
<a name="ln5430">    vim_regfree(regmatch.regprog);</a>
<a name="ln5431">  }</a>
<a name="ln5432">  return result;</a>
<a name="ln5433">}</a>
<a name="ln5434"> </a>
<a name="ln5435">/// Check if a file matches with a pattern in &quot;list&quot;.</a>
<a name="ln5436">/// &quot;list&quot; is a comma-separated list of patterns, like 'wildignore'.</a>
<a name="ln5437">/// &quot;sfname&quot; is the short file name or NULL, &quot;ffname&quot; the long file name.</a>
<a name="ln5438">///</a>
<a name="ln5439">/// @param list list of patterns to match</a>
<a name="ln5440">/// @param sfname short file name</a>
<a name="ln5441">/// @param ffname full file name</a>
<a name="ln5442">///</a>
<a name="ln5443">/// @return true if there was a match</a>
<a name="ln5444">bool match_file_list(char_u *list, char_u *sfname, char_u *ffname)</a>
<a name="ln5445">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1, 3)</a>
<a name="ln5446">{</a>
<a name="ln5447">  char_u buf[100];</a>
<a name="ln5448">  char_u *tail;</a>
<a name="ln5449">  char_u *regpat;</a>
<a name="ln5450">  char allow_dirs;</a>
<a name="ln5451">  bool match;</a>
<a name="ln5452">  char *p;</a>
<a name="ln5453"> </a>
<a name="ln5454">  tail = (char_u *)path_tail((char *)sfname);</a>
<a name="ln5455"> </a>
<a name="ln5456">  // try all patterns in 'wildignore'</a>
<a name="ln5457">  p = (char *)list;</a>
<a name="ln5458">  while (*p) {</a>
<a name="ln5459">    copy_option_part(&amp;p, (char *)buf, ARRAY_SIZE(buf), &quot;,&quot;);</a>
<a name="ln5460">    regpat = (char_u *)file_pat_to_reg_pat((char *)buf, NULL, &amp;allow_dirs, false);</a>
<a name="ln5461">    if (regpat == NULL) {</a>
<a name="ln5462">      break;</a>
<a name="ln5463">    }</a>
<a name="ln5464">    match = match_file_pat((char *)regpat, NULL, (char *)ffname, (char *)sfname, (char *)tail,</a>
<a name="ln5465">                           (int)allow_dirs);</a>
<a name="ln5466">    xfree(regpat);</a>
<a name="ln5467">    if (match) {</a>
<a name="ln5468">      return true;</a>
<a name="ln5469">    }</a>
<a name="ln5470">  }</a>
<a name="ln5471">  return false;</a>
<a name="ln5472">}</a>
<a name="ln5473"> </a>
<a name="ln5474">/// Convert the given pattern &quot;pat&quot; which has shell style wildcards in it, into</a>
<a name="ln5475">/// a regular expression, and return the result in allocated memory.  If there</a>
<a name="ln5476">/// is a directory path separator to be matched, then true is put in</a>
<a name="ln5477">/// allow_dirs, otherwise false is put there -- webb.</a>
<a name="ln5478">/// Handle backslashes before special characters, like &quot;\*&quot; and &quot;\ &quot;.</a>
<a name="ln5479">///</a>
<a name="ln5480">/// @param pat_end     first char after pattern or NULL</a>
<a name="ln5481">/// @param allow_dirs  Result passed back out in here</a>
<a name="ln5482">/// @param no_bslash   Don't use a backward slash as pathsep</a>
<a name="ln5483">///</a>
<a name="ln5484">/// @return            NULL on failure.</a>
<a name="ln5485">char *file_pat_to_reg_pat(const char *pat, const char *pat_end, char *allow_dirs, int no_bslash)</a>
<a name="ln5486">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln5487">{</a>
<a name="ln5488">  const char *endp;</a>
<a name="ln5489">  char *reg_pat;</a>
<a name="ln5490">  const char *p;</a>
<a name="ln5491">  int nested = 0;</a>
<a name="ln5492">  bool add_dollar = true;</a>
<a name="ln5493"> </a>
<a name="ln5494">  if (allow_dirs != NULL) {</a>
<a name="ln5495">    *allow_dirs = false;</a>
<a name="ln5496">  }</a>
<a name="ln5497">  if (pat_end == NULL) {</a>
<a name="ln5498">    pat_end = pat + strlen(pat);</a>
<a name="ln5499">  }</a>
<a name="ln5500"> </a>
<a name="ln5501">  if (pat_end == pat) {</a>
<a name="ln5502">    return xstrdup(&quot;^$&quot;);</a>
<a name="ln5503">  }</a>
<a name="ln5504"> </a>
<a name="ln5505">  size_t size = 2;  // '^' at start, '$' at end.</a>
<a name="ln5506"> </a>
<a name="ln5507">  for (p = pat; p &lt; pat_end; p++) {</a>
<a name="ln5508">    switch (*p) {</a>
<a name="ln5509">    case '*':</a>
<a name="ln5510">    case '.':</a>
<a name="ln5511">    case ',':</a>
<a name="ln5512">    case '{':</a>
<a name="ln5513">    case '}':</a>
<a name="ln5514">    case '~':</a>
<a name="ln5515">      size += 2;                // extra backslash</a>
<a name="ln5516">      break;</a>
<a name="ln5517">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5518">    case '\\':</a>
<a name="ln5519">    case '/':</a>
<a name="ln5520">      size += 4;                // could become &quot;[\/]&quot;</a>
<a name="ln5521">      break;</a>
<a name="ln5522">#endif</a>
<a name="ln5523">    default:</a>
<a name="ln5524">      size++;</a>
<a name="ln5525">      break;</a>
<a name="ln5526">    }</a>
<a name="ln5527">  }</a>
<a name="ln5528">  reg_pat = xmalloc(size + 1);</a>
<a name="ln5529"> </a>
<a name="ln5530">  size_t i = 0;</a>
<a name="ln5531"> </a>
<a name="ln5532">  if (pat[0] == '*') {</a>
<a name="ln5533">    while (pat[0] == '*' &amp;&amp; pat &lt; pat_end - 1) {</a>
<a name="ln5534">      pat++;</a>
<a name="ln5535">    }</a>
<a name="ln5536">  } else {</a>
<a name="ln5537">    reg_pat[i++] = '^';</a>
<a name="ln5538">  }</a>
<a name="ln5539">  endp = pat_end - 1;</a>
<a name="ln5540">  if (endp &gt;= pat &amp;&amp; *endp == '*') {</a>
<a name="ln5541">    while (endp - pat &gt; 0 &amp;&amp; *endp == '*') {</a>
<a name="ln5542">      endp--;</a>
<a name="ln5543">    }</a>
<a name="ln5544">    add_dollar = false;</a>
<a name="ln5545">  }</a>
<a name="ln5546">  for (p = pat; *p &amp;&amp; nested &gt;= 0 &amp;&amp; p &lt;= endp; p++) {</a>
<a name="ln5547">    switch (*p) {</a>
<a name="ln5548">    case '*':</a>
<a name="ln5549">      reg_pat[i++] = '.';</a>
<a name="ln5550">      reg_pat[i++] = '*';</a>
<a name="ln5551">      while (p[1] == '*') {  // &quot;**&quot; matches like &quot;*&quot;</a>
<a name="ln5552">        p++;</a>
<a name="ln5553">      }</a>
<a name="ln5554">      break;</a>
<a name="ln5555">    case '.':</a>
<a name="ln5556">    case '~':</a>
<a name="ln5557">      reg_pat[i++] = '\\';</a>
<a name="ln5558">      reg_pat[i++] = *p;</a>
<a name="ln5559">      break;</a>
<a name="ln5560">    case '?':</a>
<a name="ln5561">      reg_pat[i++] = '.';</a>
<a name="ln5562">      break;</a>
<a name="ln5563">    case '\\':</a>
<a name="ln5564">      if (p[1] == NUL) {</a>
<a name="ln5565">        break;</a>
<a name="ln5566">      }</a>
<a name="ln5567">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5568">      if (!no_bslash) {</a>
<a name="ln5569">        // translate:</a>
<a name="ln5570">        // &quot;\x&quot; to &quot;\\x&quot;  e.g., &quot;dir\file&quot;</a>
<a name="ln5571">        // &quot;\*&quot; to &quot;\\.*&quot; e.g., &quot;dir\*.c&quot;</a>
<a name="ln5572">        // &quot;\?&quot; to &quot;\\.&quot;  e.g., &quot;dir\??.c&quot;</a>
<a name="ln5573">        // &quot;\+&quot; to &quot;\+&quot;   e.g., &quot;fileX\+.c&quot;</a>
<a name="ln5574">        if ((vim_isfilec(p[1]) || p[1] == '*' || p[1] == '?')</a>
<a name="ln5575">            &amp;&amp; p[1] != '+') {</a>
<a name="ln5576">          reg_pat[i++] = '[';</a>
<a name="ln5577">          reg_pat[i++] = '\\';</a>
<a name="ln5578">          reg_pat[i++] = '/';</a>
<a name="ln5579">          reg_pat[i++] = ']';</a>
<a name="ln5580">          if (allow_dirs != NULL) {</a>
<a name="ln5581">            *allow_dirs = true;</a>
<a name="ln5582">          }</a>
<a name="ln5583">          break;</a>
<a name="ln5584">        }</a>
<a name="ln5585">      }</a>
<a name="ln5586">#endif</a>
<a name="ln5587">      // Undo escaping from ExpandEscape():</a>
<a name="ln5588">      // foo\?bar -&gt; foo?bar</a>
<a name="ln5589">      // foo\%bar -&gt; foo%bar</a>
<a name="ln5590">      // foo\,bar -&gt; foo,bar</a>
<a name="ln5591">      // foo\ bar -&gt; foo bar</a>
<a name="ln5592">      // Don't unescape \, * and others that are also special in a</a>
<a name="ln5593">      // regexp.</a>
<a name="ln5594">      // An escaped { must be unescaped since we use magic not</a>
<a name="ln5595">      // verymagic.  Use &quot;\\\{n,m\}&quot;&quot; to get &quot;\{n,m}&quot;.</a>
<a name="ln5596">      if (*++p == '?'</a>
<a name="ln5597">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5598">          &amp;&amp; no_bslash</a>
<a name="ln5599">#endif</a>
<a name="ln5600">          ) {</a>
<a name="ln5601">        reg_pat[i++] = '?';</a>
<a name="ln5602">      } else if (*p == ',' || *p == '%' || *p == '#'</a>
<a name="ln5603">                 || ascii_isspace(*p) || *p == '{' || *p == '}') {</a>
<a name="ln5604">        reg_pat[i++] = *p;</a>
<a name="ln5605">      } else if (*p == '\\' &amp;&amp; p[1] == '\\' &amp;&amp; p[2] == '{') {</a>
<a name="ln5606">        reg_pat[i++] = '\\';</a>
<a name="ln5607">        reg_pat[i++] = '{';</a>
<a name="ln5608">        p += 2;</a>
<a name="ln5609">      } else {</a>
<a name="ln5610">        if (allow_dirs != NULL &amp;&amp; vim_ispathsep(*p)</a>
<a name="ln5611">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5612">            &amp;&amp; (!no_bslash || *p != '\\')</a>
<a name="ln5613">#endif</a>
<a name="ln5614">            ) {</a>
<a name="ln5615">          *allow_dirs = true;</a>
<a name="ln5616">        }</a>
<a name="ln5617">        reg_pat[i++] = '\\';</a>
<a name="ln5618">        reg_pat[i++] = *p;</a>
<a name="ln5619">      }</a>
<a name="ln5620">      break;</a>
<a name="ln5621">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5622">    case '/':</a>
<a name="ln5623">      reg_pat[i++] = '[';</a>
<a name="ln5624">      reg_pat[i++] = '\\';</a>
<a name="ln5625">      reg_pat[i++] = '/';</a>
<a name="ln5626">      reg_pat[i++] = ']';</a>
<a name="ln5627">      if (allow_dirs != NULL) {</a>
<a name="ln5628">        *allow_dirs = true;</a>
<a name="ln5629">      }</a>
<a name="ln5630">      break;</a>
<a name="ln5631">#endif</a>
<a name="ln5632">    case '{':</a>
<a name="ln5633">      reg_pat[i++] = '\\';</a>
<a name="ln5634">      reg_pat[i++] = '(';</a>
<a name="ln5635">      nested++;</a>
<a name="ln5636">      break;</a>
<a name="ln5637">    case '}':</a>
<a name="ln5638">      reg_pat[i++] = '\\';</a>
<a name="ln5639">      reg_pat[i++] = ')';</a>
<a name="ln5640">      nested--;</a>
<a name="ln5641">      break;</a>
<a name="ln5642">    case ',':</a>
<a name="ln5643">      if (nested) {</a>
<a name="ln5644">        reg_pat[i++] = '\\';</a>
<a name="ln5645">        reg_pat[i++] = '|';</a>
<a name="ln5646">      } else {</a>
<a name="ln5647">        reg_pat[i++] = ',';</a>
<a name="ln5648">      }</a>
<a name="ln5649">      break;</a>
<a name="ln5650">    default:</a>
<a name="ln5651">      if (allow_dirs != NULL &amp;&amp; vim_ispathsep(*p)) {</a>
<a name="ln5652">        *allow_dirs = true;</a>
<a name="ln5653">      }</a>
<a name="ln5654">      reg_pat[i++] = *p;</a>
<a name="ln5655">      break;</a>
<a name="ln5656">    }</a>
<a name="ln5657">  }</a>
<a name="ln5658">  if (add_dollar) {</a>
<a name="ln5659">    reg_pat[i++] = '$';</a>
<a name="ln5660">  }</a>
<a name="ln5661">  reg_pat[i] = NUL;</a>
<a name="ln5662">  if (nested != 0) {</a>
<a name="ln5663">    if (nested &lt; 0) {</a>
<a name="ln5664">      emsg(_(&quot;E219: Missing {.&quot;));</a>
<a name="ln5665">    } else {</a>
<a name="ln5666">      emsg(_(&quot;E220: Missing }.&quot;));</a>
<a name="ln5667">    }</a>
<a name="ln5668">    XFREE_CLEAR(reg_pat);</a>
<a name="ln5669">  }</a>
<a name="ln5670">  return reg_pat;</a>
<a name="ln5671">}</a>
<a name="ln5672"> </a>
<a name="ln5673">#if defined(EINTR)</a>
<a name="ln5674"> </a>
<a name="ln5675">/// Version of read() that retries when interrupted by EINTR (possibly</a>
<a name="ln5676">/// by a SIGWINCH).</a>
<a name="ln5677">long read_eintr(int fd, void *buf, size_t bufsize)</a>
<a name="ln5678">{</a>
<a name="ln5679">  long ret;</a>
<a name="ln5680"> </a>
<a name="ln5681">  for (;;) {</a>
<a name="ln5682">    ret = read(fd, buf, bufsize);</a>
<a name="ln5683">    if (ret &gt;= 0 || errno != EINTR) {</a>
<a name="ln5684">      break;</a>
<a name="ln5685">    }</a>
<a name="ln5686">  }</a>
<a name="ln5687">  return ret;</a>
<a name="ln5688">}</a>
<a name="ln5689"> </a>
<a name="ln5690">/// Version of write() that retries when interrupted by EINTR (possibly</a>
<a name="ln5691">/// by a SIGWINCH).</a>
<a name="ln5692">long write_eintr(int fd, void *buf, size_t bufsize)</a>
<a name="ln5693">{</a>
<a name="ln5694">  long ret = 0;</a>
<a name="ln5695"> </a>
<a name="ln5696">  // Repeat the write() so long it didn't fail, other than being interrupted</a>
<a name="ln5697">  // by a signal.</a>
<a name="ln5698">  while (ret &lt; (long)bufsize) {</a>
<a name="ln5699">    long wlen = write(fd, (char *)buf + ret, bufsize - (size_t)ret);</a>
<a name="ln5700">    if (wlen &lt; 0) {</a>
<a name="ln5701">      if (errno != EINTR) {</a>
<a name="ln5702">        break;</a>
<a name="ln5703">      }</a>
<a name="ln5704">    } else {</a>
<a name="ln5705">      ret += wlen;</a>
<a name="ln5706">    }</a>
<a name="ln5707">  }</a>
<a name="ln5708">  return ret;</a>
<a name="ln5709">}</a>
<a name="ln5710">#endif</a>
</code></pre>
<div class="balloon" rel="5211"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'strlen(tmp) - strlen(user)' index could reach 18446744073709551615.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>