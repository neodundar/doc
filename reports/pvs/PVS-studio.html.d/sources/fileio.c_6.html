<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fileio.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// fileio.c: read from and write to a file</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;errno.h&gt;</a>
<a name="ln8">#include &lt;fcntl.h&gt;</a>
<a name="ln9">#include &lt;inttypes.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln14">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln15">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln16">#include &quot;nvim/buffer_updates.h&quot;</a>
<a name="ln17">#include &quot;nvim/change.h&quot;</a>
<a name="ln18">#include &quot;nvim/charset.h&quot;</a>
<a name="ln19">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln20">#include &quot;nvim/diff.h&quot;</a>
<a name="ln21">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln22">#include &quot;nvim/edit.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln25">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln28">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln29">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln30">#include &quot;nvim/fold.h&quot;</a>
<a name="ln31">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln32">#include &quot;nvim/garray.h&quot;</a>
<a name="ln33">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln34">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln35">#include &quot;nvim/iconv.h&quot;</a>
<a name="ln36">#include &quot;nvim/input.h&quot;</a>
<a name="ln37">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln38">#include &quot;nvim/memfile.h&quot;</a>
<a name="ln39">#include &quot;nvim/memline.h&quot;</a>
<a name="ln40">#include &quot;nvim/memory.h&quot;</a>
<a name="ln41">#include &quot;nvim/message.h&quot;</a>
<a name="ln42">#include &quot;nvim/move.h&quot;</a>
<a name="ln43">#include &quot;nvim/normal.h&quot;</a>
<a name="ln44">#include &quot;nvim/option.h&quot;</a>
<a name="ln45">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln46">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln48">#include &quot;nvim/os/os_defs.h&quot;</a>
<a name="ln49">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln50">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln51">#include &quot;nvim/path.h&quot;</a>
<a name="ln52">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln53">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln54">#include &quot;nvim/search.h&quot;</a>
<a name="ln55">#include &quot;nvim/sha256.h&quot;</a>
<a name="ln56">#include &quot;nvim/shada.h&quot;</a>
<a name="ln57">#include &quot;nvim/state.h&quot;</a>
<a name="ln58">#include &quot;nvim/strings.h&quot;</a>
<a name="ln59">#include &quot;nvim/types.h&quot;</a>
<a name="ln60">#include &quot;nvim/ui.h&quot;</a>
<a name="ln61">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln62">#include &quot;nvim/undo.h&quot;</a>
<a name="ln63">#include &quot;nvim/vim.h&quot;</a>
<a name="ln64">#include &quot;nvim/window.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">#define BUFSIZE         8192    // size of normal write buffer</a>
<a name="ln67">#define SMBUFSIZE       256     // size of emergency write buffer</a>
<a name="ln68"> </a>
<a name="ln69">// For compatibility with libuv &lt; 1.20.0 (tested on 1.18.0)</a>
<a name="ln70">#ifndef UV_FS_COPYFILE_FICLONE</a>
<a name="ln71"># define UV_FS_COPYFILE_FICLONE 0</a>
<a name="ln72">#endif</a>
<a name="ln73"> </a>
<a name="ln74">#define HAS_BW_FLAGS</a>
<a name="ln75">#define FIO_LATIN1     0x01    // convert Latin1</a>
<a name="ln76">#define FIO_UTF8       0x02    // convert UTF-8</a>
<a name="ln77">#define FIO_UCS2       0x04    // convert UCS-2</a>
<a name="ln78">#define FIO_UCS4       0x08    // convert UCS-4</a>
<a name="ln79">#define FIO_UTF16      0x10    // convert UTF-16</a>
<a name="ln80">#define FIO_ENDIAN_L   0x80    // little endian</a>
<a name="ln81">#define FIO_NOCONVERT  0x2000  // skip encoding conversion</a>
<a name="ln82">#define FIO_UCSBOM     0x4000  // check for BOM at start of file</a>
<a name="ln83">#define FIO_ALL        (-1)    // allow all formats</a>
<a name="ln84"> </a>
<a name="ln85">// When converting, a read() or write() may leave some bytes to be converted</a>
<a name="ln86">// for the next call.  The value is guessed...</a>
<a name="ln87">#define CONV_RESTLEN 30</a>
<a name="ln88"> </a>
<a name="ln89">// We have to guess how much a sequence of bytes may expand when converting</a>
<a name="ln90">// with iconv() to be able to allocate a buffer.</a>
<a name="ln91">#define ICONV_MULT 8</a>
<a name="ln92"> </a>
<a name="ln93">// Structure to pass arguments from buf_write() to buf_write_bytes().</a>
<a name="ln94">struct bw_info {</a>
<a name="ln95">  int bw_fd;                     // file descriptor</a>
<a name="ln96">  char_u *bw_buf;           // buffer with data to be written</a>
<a name="ln97">  int bw_len;                    // length of data</a>
<a name="ln98">#ifdef HAS_BW_FLAGS</a>
<a name="ln99">  int bw_flags;                  // FIO_ flags</a>
<a name="ln100">#endif</a>
<a name="ln101">  char_u bw_rest[CONV_RESTLEN];  // not converted bytes</a>
<a name="ln102">  int bw_restlen;                // nr of bytes in bw_rest[]</a>
<a name="ln103">  int bw_first;                  // first write call</a>
<a name="ln104">  char_u *bw_conv_buf;           // buffer for writing converted chars</a>
<a name="ln105">  size_t bw_conv_buflen;         // size of bw_conv_buf</a>
<a name="ln106">  int bw_conv_error;             // set for conversion error</a>
<a name="ln107">  linenr_T bw_conv_error_lnum;   // first line with error or zero</a>
<a name="ln108">  linenr_T bw_start_lnum;        // line number at start of buffer</a>
<a name="ln109">#ifdef HAVE_ICONV</a>
<a name="ln110">  iconv_t bw_iconv_fd;           // descriptor for iconv() or -1</a>
<a name="ln111">#endif</a>
<a name="ln112">};</a>
<a name="ln113"> </a>
<a name="ln114">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln115"># include &quot;fileio.c.generated.h&quot;</a>
<a name="ln116">#endif</a>
<a name="ln117"> </a>
<a name="ln118">static char *e_auchangedbuf = N_(&quot;E812: Autocommands changed buffer or buffer name&quot;);</a>
<a name="ln119">static char e_no_matching_autocommands_for_buftype_str_buffer[]</a>
<a name="ln120">  = N_(&quot;E676: No matching autocommands for buftype=%s buffer&quot;);</a>
<a name="ln121"> </a>
<a name="ln122">void filemess(buf_T *buf, char *name, char *s, int attr)</a>
<a name="ln123">{</a>
<a name="ln124">  int msg_scroll_save;</a>
<a name="ln125"> </a>
<a name="ln126">  if (msg_silent != 0) {</a>
<a name="ln127">    return;</a>
<a name="ln128">  }</a>
<a name="ln129">  add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)name);</a>
<a name="ln130">  // Avoid an over-long translation to cause trouble.</a>
<a name="ln131">  xstrlcat(IObuff, s, IOSIZE);</a>
<a name="ln132">  // For the first message may have to start a new line.</a>
<a name="ln133">  // For further ones overwrite the previous one, reset msg_scroll before</a>
<a name="ln134">  // calling filemess().</a>
<a name="ln135">  msg_scroll_save = msg_scroll;</a>
<a name="ln136">  if (shortmess(SHM_OVERALL) &amp;&amp; !exiting &amp;&amp; p_verbose == 0) {</a>
<a name="ln137">    msg_scroll = false;</a>
<a name="ln138">  }</a>
<a name="ln139">  if (!msg_scroll) {    // wait a bit when overwriting an error msg</a>
<a name="ln140">    check_for_delay(false);</a>
<a name="ln141">  }</a>
<a name="ln142">  msg_start();</a>
<a name="ln143">  msg_scroll = msg_scroll_save;</a>
<a name="ln144">  msg_scrolled_ign = true;</a>
<a name="ln145">  // may truncate the message to avoid a hit-return prompt</a>
<a name="ln146">  msg_outtrans_attr(msg_may_trunc(false, (char *)IObuff), attr);</a>
<a name="ln147">  msg_clr_eos();</a>
<a name="ln148">  ui_flush();</a>
<a name="ln149">  msg_scrolled_ign = false;</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">/// Read lines from file &quot;fname&quot; into the buffer after line &quot;from&quot;.</a>
<a name="ln153">///</a>
<a name="ln154">/// 1. We allocate blocks with try_malloc, as big as possible.</a>
<a name="ln155">/// 2. Each block is filled with characters from the file with a single read().</a>
<a name="ln156">/// 3. The lines are inserted in the buffer with ml_append().</a>
<a name="ln157">///</a>
<a name="ln158">/// (caller must check that fname != NULL, unless READ_STDIN is used)</a>
<a name="ln159">///</a>
<a name="ln160">/// &quot;lines_to_skip&quot; is the number of lines that must be skipped</a>
<a name="ln161">/// &quot;lines_to_read&quot; is the number of lines that are appended</a>
<a name="ln162">/// When not recovering lines_to_skip is 0 and lines_to_read MAXLNUM.</a>
<a name="ln163">///</a>
<a name="ln164">/// flags:</a>
<a name="ln165">/// READ_NEW     starting to edit a new buffer</a>
<a name="ln166">/// READ_FILTER  reading filter output</a>
<a name="ln167">/// READ_STDIN   read from stdin instead of a file</a>
<a name="ln168">/// READ_BUFFER  read from curbuf instead of a file (converting after reading</a>
<a name="ln169">///              stdin)</a>
<a name="ln170">/// READ_NOFILE  do not read a file, only trigger BufReadCmd</a>
<a name="ln171">/// READ_DUMMY   read into a dummy buffer (to check if file contents changed)</a>
<a name="ln172">/// READ_KEEP_UNDO  don't clear undo info or read it from a file</a>
<a name="ln173">/// READ_FIFO    read from fifo/socket instead of a file</a>
<a name="ln174">///</a>
<a name="ln175">/// @param eap  can be NULL!</a>
<a name="ln176">///</a>
<a name="ln177">/// @return     FAIL for failure, NOTDONE for directory (failure), or OK</a>
<a name="ln178">int readfile(char *fname, char *sfname, linenr_T from, linenr_T lines_to_skip,</a>
<a name="ln179">             linenr_T lines_to_read, exarg_T *eap, int flags, bool silent)</a>
<a name="ln180">{</a>
<a name="ln181">  int fd = stdin_fd &gt;= 0 ? stdin_fd : 0;</a>
<a name="ln182">  int newfile = (flags &amp; READ_NEW);</a>
<a name="ln183">  int check_readonly;</a>
<a name="ln184">  int filtering = (flags &amp; READ_FILTER);</a>
<a name="ln185">  int read_stdin = (flags &amp; READ_STDIN);</a>
<a name="ln186">  int read_buffer = (flags &amp; READ_BUFFER);</a>
<a name="ln187">  int read_fifo = (flags &amp; READ_FIFO);</a>
<a name="ln188">  int set_options = newfile || read_buffer</a>
<a name="ln189">                    || (eap != NULL &amp;&amp; eap-&gt;read_edit);</a>
<a name="ln190">  linenr_T read_buf_lnum = 1;           // next line to read from curbuf</a>
<a name="ln191">  colnr_T read_buf_col = 0;             // next char to read from this line</a>
<a name="ln192">  char c;</a>
<a name="ln193">  linenr_T lnum = from;</a>
<a name="ln194">  char *ptr = NULL;              // pointer into read buffer</a>
<a name="ln195">  char *buffer = NULL;           // read buffer</a>
<a name="ln196">  char *new_buffer = NULL;       // init to shut up gcc</a>
<a name="ln197">  char *line_start = NULL;       // init to shut up gcc</a>
<a name="ln198">  int wasempty;                         // buffer was empty before reading</a>
<a name="ln199">  colnr_T len;</a>
<a name="ln200">  long size = 0;</a>
<a name="ln201">  uint8_t *p = NULL;</a>
<a name="ln202">  off_T filesize = 0;</a>
<a name="ln203">  bool skip_read = false;</a>
<a name="ln204">  context_sha256_T sha_ctx;</a>
<a name="ln205">  int read_undo_file = false;</a>
<a name="ln206">  int split = 0;  // number of split lines</a>
<a name="ln207">  linenr_T linecnt;</a>
<a name="ln208">  bool error = false;                   // errors encountered</a>
<a name="ln209">  int ff_error = EOL_UNKNOWN;           // file format with errors</a>
<a name="ln210">  long linerest = 0;                    // remaining chars in line</a>
<a name="ln211">  int perm = 0;</a>
<a name="ln212">#ifdef UNIX</a>
<a name="ln213">  int swap_mode = -1;                   // protection bits for swap file</a>
<a name="ln214">#endif</a>
<a name="ln215">  int fileformat = 0;                   // end-of-line format</a>
<a name="ln216">  bool keep_fileformat = false;</a>
<a name="ln217">  FileInfo file_info;</a>
<a name="ln218">  linenr_T skip_count = 0;</a>
<a name="ln219">  linenr_T read_count = 0;</a>
<a name="ln220">  int msg_save = msg_scroll;</a>
<a name="ln221">  linenr_T read_no_eol_lnum = 0;        // non-zero lnum when last line of</a>
<a name="ln222">                                        // last read was missing the eol</a>
<a name="ln223">  bool file_rewind = false;</a>
<a name="ln224">  int can_retry;</a>
<a name="ln225">  linenr_T conv_error = 0;              // line nr with conversion error</a>
<a name="ln226">  linenr_T illegal_byte = 0;            // line nr with illegal byte</a>
<a name="ln227">  bool keep_dest_enc = false;           // don't retry when char doesn't fit</a>
<a name="ln228">                                        // in destination encoding</a>
<a name="ln229">  int bad_char_behavior = BAD_REPLACE;</a>
<a name="ln230">  // BAD_KEEP, BAD_DROP or character to</a>
<a name="ln231">  // replace with</a>
<a name="ln232">  char *tmpname = NULL;          // name of 'charconvert' output file</a>
<a name="ln233">  int fio_flags = 0;</a>
<a name="ln234">  char *fenc;                    // fileencoding to use</a>
<a name="ln235">  bool fenc_alloced;                    // fenc_next is in allocated memory</a>
<a name="ln236">  char *fenc_next = NULL;        // next item in 'fencs' or NULL</a>
<a name="ln237">  bool advance_fenc = false;</a>
<a name="ln238">  long real_size = 0;</a>
<a name="ln239">#ifdef HAVE_ICONV</a>
<a name="ln240">  iconv_t iconv_fd = (iconv_t)-1;       // descriptor for iconv() or -1</a>
<a name="ln241">  bool did_iconv = false;               // true when iconv() failed and trying</a>
<a name="ln242">                                        // 'charconvert' next</a>
<a name="ln243">#endif</a>
<a name="ln244">  bool converted = false;                // true if conversion done</a>
<a name="ln245">  bool notconverted = false;             // true if conversion wanted but it wasn't possible</a>
<a name="ln246">  char conv_rest[CONV_RESTLEN];</a>
<a name="ln247">  int conv_restlen = 0;                 // nr of bytes in conv_rest[]</a>
<a name="ln248">  pos_T orig_start;</a>
<a name="ln249">  buf_T *old_curbuf;</a>
<a name="ln250">  char *old_b_ffname;</a>
<a name="ln251">  char *old_b_fname;</a>
<a name="ln252">  int using_b_ffname;</a>
<a name="ln253">  int using_b_fname;</a>
<a name="ln254">  static char *msg_is_a_directory = N_(&quot;is a directory&quot;);</a>
<a name="ln255"> </a>
<a name="ln256">  au_did_filetype = false;  // reset before triggering any autocommands</a>
<a name="ln257"> </a>
<a name="ln258">  curbuf-&gt;b_no_eol_lnum = 0;    // in case it was set by the previous read</a>
<a name="ln259"> </a>
<a name="ln260">  // If there is no file name yet, use the one for the read file.</a>
<a name="ln261">  // BF_NOTEDITED is set to reflect this.</a>
<a name="ln262">  // Don't do this for a read from a filter.</a>
<a name="ln263">  // Only do this when 'cpoptions' contains the 'f' flag.</a>
<a name="ln264">  if (curbuf-&gt;b_ffname == NULL</a>
<a name="ln265">      &amp;&amp; !filtering</a>
<a name="ln266">      &amp;&amp; fname != NULL</a>
<a name="ln267">      &amp;&amp; vim_strchr(p_cpo, CPO_FNAMER) != NULL</a>
<a name="ln268">      &amp;&amp; !(flags &amp; READ_DUMMY)) {</a>
<a name="ln269">    if (set_rw_fname((char_u *)fname, (char_u *)sfname) == FAIL) {</a>
<a name="ln270">      return FAIL;</a>
<a name="ln271">    }</a>
<a name="ln272">  }</a>
<a name="ln273"> </a>
<a name="ln274">  // Remember the initial values of curbuf, curbuf-&gt;b_ffname and</a>
<a name="ln275">  // curbuf-&gt;b_fname to detect whether they are altered as a result of</a>
<a name="ln276">  // executing nasty autocommands.  Also check if &quot;fname&quot; and &quot;sfname&quot;</a>
<a name="ln277">  // point to one of these values.</a>
<a name="ln278">  old_curbuf = curbuf;</a>
<a name="ln279">  old_b_ffname = curbuf-&gt;b_ffname;</a>
<a name="ln280">  old_b_fname = curbuf-&gt;b_fname;</a>
<a name="ln281">  using_b_ffname = (fname == curbuf-&gt;b_ffname) || (sfname == curbuf-&gt;b_ffname);</a>
<a name="ln282">  using_b_fname = (fname == curbuf-&gt;b_fname) || (sfname == curbuf-&gt;b_fname);</a>
<a name="ln283"> </a>
<a name="ln284">  // After reading a file the cursor line changes but we don't want to</a>
<a name="ln285">  // display the line.</a>
<a name="ln286">  ex_no_reprint = true;</a>
<a name="ln287"> </a>
<a name="ln288">  // don't display the file info for another buffer now</a>
<a name="ln289">  need_fileinfo = false;</a>
<a name="ln290"> </a>
<a name="ln291">  // For Unix: Use the short file name whenever possible.</a>
<a name="ln292">  // Avoids problems with networks and when directory names are changed.</a>
<a name="ln293">  // Don't do this for Windows, a &quot;cd&quot; in a sub-shell may have moved us to</a>
<a name="ln294">  // another directory, which we don't detect.</a>
<a name="ln295">  if (sfname == NULL) {</a>
<a name="ln296">    sfname = fname;</a>
<a name="ln297">  }</a>
<a name="ln298">#if defined(UNIX)</a>
<a name="ln299">  fname = sfname;</a>
<a name="ln300">#endif</a>
<a name="ln301"> </a>
<a name="ln302">  // The BufReadCmd and FileReadCmd events intercept the reading process by</a>
<a name="ln303">  // executing the associated commands instead.</a>
<a name="ln304">  if (!filtering &amp;&amp; !read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln305">    orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln306"> </a>
<a name="ln307">    // Set '[ mark to the line above where the lines go (line 1 if zero).</a>
<a name="ln308">    curbuf-&gt;b_op_start.lnum = ((from == 0) ? 1 : from);</a>
<a name="ln309">    curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln310"> </a>
<a name="ln311">    if (newfile) {</a>
<a name="ln312">      if (apply_autocmds_exarg(EVENT_BUFREADCMD, NULL, sfname,</a>
<a name="ln313">                               false, curbuf, eap)) {</a>
<a name="ln314">        int status = OK;</a>
<a name="ln315"> </a>
<a name="ln316">        if (aborting()) {</a>
<a name="ln317">          status = FAIL;</a>
<a name="ln318">        }</a>
<a name="ln319"> </a>
<a name="ln320">        // The BufReadCmd code usually uses &quot;:read&quot; to get the text and</a>
<a name="ln321">        // perhaps &quot;:file&quot; to change the buffer name. But we should</a>
<a name="ln322">        // consider this to work like &quot;:edit&quot;, thus reset the</a>
<a name="ln323">        // BF_NOTEDITED flag.  Then &quot;:write&quot; will work to overwrite the</a>
<a name="ln324">        // same file.</a>
<a name="ln325">        if (status == OK) {</a>
<a name="ln326">          curbuf-&gt;b_flags &amp;= ~BF_NOTEDITED;</a>
<a name="ln327">        }</a>
<a name="ln328">        return status;</a>
<a name="ln329">      }</a>
<a name="ln330">    } else if (apply_autocmds_exarg(EVENT_FILEREADCMD, sfname, sfname,</a>
<a name="ln331">                                    false, NULL, eap)) {</a>
<a name="ln332">      return aborting() ? FAIL : OK;</a>
<a name="ln333">    }</a>
<a name="ln334"> </a>
<a name="ln335">    curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln336"> </a>
<a name="ln337">    if (flags &amp; READ_NOFILE) {</a>
<a name="ln338">      // Return NOTDONE instead of FAIL so that BufEnter can be triggered</a>
<a name="ln339">      // and other operations don't fail.</a>
<a name="ln340">      return NOTDONE;</a>
<a name="ln341">    }</a>
<a name="ln342">  }</a>
<a name="ln343"> </a>
<a name="ln344">  if ((shortmess(SHM_OVER) || curbuf-&gt;b_help) &amp;&amp; p_verbose == 0) {</a>
<a name="ln345">    msg_scroll = false;         // overwrite previous file message</a>
<a name="ln346">  } else {</a>
<a name="ln347">    msg_scroll = true;          // don't overwrite previous file message</a>
<a name="ln348">  }</a>
<a name="ln349">  // If the name is too long we might crash further on, quit here.</a>
<a name="ln350">  if (fname != NULL &amp;&amp; *fname != NUL) {</a>
<a name="ln351">    size_t namelen = strlen(fname);</a>
<a name="ln352"> </a>
<a name="ln353">    // If the name is too long we might crash further on, quit here.</a>
<a name="ln354">    if (namelen &gt;= MAXPATHL) {</a>
<a name="ln355">      filemess(curbuf, fname, _(&quot;Illegal file name&quot;), 0);</a>
<a name="ln356">      msg_end();</a>
<a name="ln357">      msg_scroll = msg_save;</a>
<a name="ln358">      return FAIL;</a>
<a name="ln359">    }</a>
<a name="ln360"> </a>
<a name="ln361">    // If the name ends in a path separator, we can't open it.  Check here,</a>
<a name="ln362">    // because reading the file may actually work, but then creating the</a>
<a name="ln363">    // swap file may destroy it!  Reported on MS-DOS and Win 95.</a>
<a name="ln364">    if (after_pathsep(fname, fname + namelen)) {</a>
<a name="ln365">      if (!silent) {</a>
<a name="ln366">        filemess(curbuf, fname, _(msg_is_a_directory), 0);</a>
<a name="ln367">      }</a>
<a name="ln368">      msg_end();</a>
<a name="ln369">      msg_scroll = msg_save;</a>
<a name="ln370">      return NOTDONE;</a>
<a name="ln371">    }</a>
<a name="ln372">  }</a>
<a name="ln373"> </a>
<a name="ln374">  if (!read_buffer &amp;&amp; !read_stdin &amp;&amp; !read_fifo) {</a>
<a name="ln375">    perm = os_getperm(fname);</a>
<a name="ln376">    // On Unix it is possible to read a directory, so we have to</a>
<a name="ln377">    // check for it before os_open().</a>
<a name="ln378">    if (perm &gt;= 0 &amp;&amp; !S_ISREG(perm)                 // not a regular file ...</a>
<a name="ln379">        &amp;&amp; !S_ISFIFO(perm)                          // ... or fifo</a>
<a name="ln380">        &amp;&amp; !S_ISSOCK(perm)                          // ... or socket</a>
<a name="ln381">#ifdef OPEN_CHR_FILES</a>
<a name="ln382">        &amp;&amp; !(S_ISCHR(perm) &amp;&amp; is_dev_fd_file(fname))</a>
<a name="ln383">        // ... or a character special file named /dev/fd/&lt;n&gt;</a>
<a name="ln384">#endif</a>
<a name="ln385">        ) {</a>
<a name="ln386">      if (S_ISDIR(perm)) {</a>
<a name="ln387">        if (!silent) {</a>
<a name="ln388">          filemess(curbuf, fname, _(msg_is_a_directory), 0);</a>
<a name="ln389">        }</a>
<a name="ln390">      } else {</a>
<a name="ln391">        filemess(curbuf, fname, _(&quot;is not a file&quot;), 0);</a>
<a name="ln392">      }</a>
<a name="ln393">      msg_end();</a>
<a name="ln394">      msg_scroll = msg_save;</a>
<a name="ln395">      return S_ISDIR(perm) ? NOTDONE : FAIL;</a>
<a name="ln396">    }</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">  // Set default or forced 'fileformat' and 'binary'.</a>
<a name="ln400">  set_file_options(set_options, eap);</a>
<a name="ln401"> </a>
<a name="ln402">  // When opening a new file we take the readonly flag from the file.</a>
<a name="ln403">  // Default is r/w, can be set to r/o below.</a>
<a name="ln404">  // Don't reset it when in readonly mode</a>
<a name="ln405">  // Only set/reset b_p_ro when BF_CHECK_RO is set.</a>
<a name="ln406">  check_readonly = (newfile &amp;&amp; (curbuf-&gt;b_flags &amp; BF_CHECK_RO));</a>
<a name="ln407">  if (check_readonly &amp;&amp; !readonlymode) {</a>
<a name="ln408">    curbuf-&gt;b_p_ro = false;</a>
<a name="ln409">  }</a>
<a name="ln410"> </a>
<a name="ln411">  if (newfile &amp;&amp; !read_stdin &amp;&amp; !read_buffer &amp;&amp; !read_fifo) {</a>
<a name="ln412">    // Remember time of file.</a>
<a name="ln413">    if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln414">      buf_store_file_info(curbuf, &amp;file_info);</a>
<a name="ln415">      curbuf-&gt;b_mtime_read = curbuf-&gt;b_mtime;</a>
<a name="ln416">      curbuf-&gt;b_mtime_read_ns = curbuf-&gt;b_mtime_ns;</a>
<a name="ln417">#ifdef UNIX</a>
<a name="ln418">      // Use the protection bits of the original file for the swap file.</a>
<a name="ln419">      // This makes it possible for others to read the name of the</a>
<a name="ln420">      // edited file from the swapfile, but only if they can read the</a>
<a name="ln421">      // edited file.</a>
<a name="ln422">      // Remove the &quot;write&quot; and &quot;execute&quot; bits for group and others</a>
<a name="ln423">      // (they must not write the swapfile).</a>
<a name="ln424">      // Add the &quot;read&quot; and &quot;write&quot; bits for the user, otherwise we may</a>
<a name="ln425">      // not be able to write to the file ourselves.</a>
<a name="ln426">      // Setting the bits is done below, after creating the swap file.</a>
<a name="ln427">      swap_mode = ((int)file_info.stat.st_mode &amp; 0644) | 0600;</a>
<a name="ln428">#endif</a>
<a name="ln429">    } else {</a>
<a name="ln430">      curbuf-&gt;b_mtime = 0;</a>
<a name="ln431">      curbuf-&gt;b_mtime_ns = 0;</a>
<a name="ln432">      curbuf-&gt;b_mtime_read = 0;</a>
<a name="ln433">      curbuf-&gt;b_mtime_read_ns = 0;</a>
<a name="ln434">      curbuf-&gt;b_orig_size = 0;</a>
<a name="ln435">      curbuf-&gt;b_orig_mode = 0;</a>
<a name="ln436">    }</a>
<a name="ln437"> </a>
<a name="ln438">    // Reset the &quot;new file&quot; flag.  It will be set again below when the</a>
<a name="ln439">    // file doesn't exist.</a>
<a name="ln440">    curbuf-&gt;b_flags &amp;= ~(BF_NEW | BF_NEW_W);</a>
<a name="ln441">  }</a>
<a name="ln442"> </a>
<a name="ln443">  // Check readonly.</a>
<a name="ln444">  bool file_readonly = false;</a>
<a name="ln445">  if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln446">    if (!newfile || readonlymode || !(perm &amp; 0222)</a>
<a name="ln447">        || !os_file_is_writable(fname)) {</a>
<a name="ln448">      file_readonly = true;</a>
<a name="ln449">    }</a>
<a name="ln450">    fd = os_open(fname, O_RDONLY, 0);</a>
<a name="ln451">  }</a>
<a name="ln452"> </a>
<a name="ln453">  if (fd &lt; 0) {                     // cannot open at all</a>
<a name="ln454">    msg_scroll = msg_save;</a>
<a name="ln455">    if (!newfile) {</a>
<a name="ln456">      return FAIL;</a>
<a name="ln457">    }</a>
<a name="ln458">    if (perm == UV_ENOENT) {  // check if the file exists</a>
<a name="ln459">      // Set the 'new-file' flag, so that when the file has</a>
<a name="ln460">      // been created by someone else, a &quot;:w&quot; will complain.</a>
<a name="ln461">      curbuf-&gt;b_flags |= BF_NEW;</a>
<a name="ln462"> </a>
<a name="ln463">      // Create a swap file now, so that other Vims are warned</a>
<a name="ln464">      // that we are editing this file.  Don't do this for a</a>
<a name="ln465">      // &quot;nofile&quot; or &quot;nowrite&quot; buffer type.</a>
<a name="ln466">      if (!bt_dontwrite(curbuf)) {</a>
<a name="ln467">        check_need_swap(newfile);</a>
<a name="ln468">        // SwapExists autocommand may mess things up</a>
<a name="ln469">        if (curbuf != old_curbuf</a>
<a name="ln470">            || (using_b_ffname</a>
<a name="ln471">                &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln472">            || (using_b_fname</a>
<a name="ln473">                &amp;&amp; (old_b_fname != curbuf-&gt;b_fname))) {</a>
<a name="ln474">          emsg(_(e_auchangedbuf));</a>
<a name="ln475">          return FAIL;</a>
<a name="ln476">        }</a>
<a name="ln477">      }</a>
<a name="ln478">      if (!silent) {</a>
<a name="ln479">        if (dir_of_file_exists((char_u *)fname)) {</a>
<a name="ln480">          filemess(curbuf, sfname, new_file_message(), 0);</a>
<a name="ln481">        } else {</a>
<a name="ln482">          filemess(curbuf, sfname, _(&quot;[New DIRECTORY]&quot;), 0);</a>
<a name="ln483">        }</a>
<a name="ln484">      }</a>
<a name="ln485">      // Even though this is a new file, it might have been</a>
<a name="ln486">      // edited before and deleted.  Get the old marks.</a>
<a name="ln487">      check_marks_read();</a>
<a name="ln488">      // Set forced 'fileencoding'.</a>
<a name="ln489">      if (eap != NULL) {</a>
<a name="ln490">        set_forced_fenc(eap);</a>
<a name="ln491">      }</a>
<a name="ln492">      apply_autocmds_exarg(EVENT_BUFNEWFILE, sfname, sfname,</a>
<a name="ln493">                           false, curbuf, eap);</a>
<a name="ln494">      // remember the current fileformat</a>
<a name="ln495">      save_file_ff(curbuf);</a>
<a name="ln496"> </a>
<a name="ln497">      if (aborting()) {             // autocmds may abort script processing</a>
<a name="ln498">        return FAIL;</a>
<a name="ln499">      }</a>
<a name="ln500">      return OK;                  // a new file is not an error</a>
<a name="ln501">    } else {</a>
<a name="ln502">      filemess(curbuf, sfname, ((fd == UV_EFBIG) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln503">#if defined(UNIX) &amp;&amp; defined(EOVERFLOW)</a>
<a name="ln504">                                // libuv only returns -errno</a>
<a name="ln505">                                // in Unix and in Windows</a>
<a name="ln506">                                // open() does not set</a>
<a name="ln507">                                // EOVERFLOW</a>
<a name="ln508">                                (fd == -EOVERFLOW) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln509">#endif</a>
<a name="ln510">                                _(&quot;[Permission Denied]&quot;)), 0);</a>
<a name="ln511">      curbuf-&gt;b_p_ro = true;                  // must use &quot;w!&quot; now</a>
<a name="ln512">    }</a>
<a name="ln513"> </a>
<a name="ln514">    return FAIL;</a>
<a name="ln515">  }</a>
<a name="ln516"> </a>
<a name="ln517">  // Only set the 'ro' flag for readonly files the first time they are</a>
<a name="ln518">  // loaded.    Help files always get readonly mode</a>
<a name="ln519">  if ((check_readonly &amp;&amp; file_readonly) || curbuf-&gt;b_help) {</a>
<a name="ln520">    curbuf-&gt;b_p_ro = true;</a>
<a name="ln521">  }</a>
<a name="ln522"> </a>
<a name="ln523">  if (set_options) {</a>
<a name="ln524">    // Don't change 'eol' if reading from buffer as it will already be</a>
<a name="ln525">    // correctly set when reading stdin.</a>
<a name="ln526">    if (!read_buffer) {</a>
<a name="ln527">      curbuf-&gt;b_p_eol = true;</a>
<a name="ln528">      curbuf-&gt;b_start_eol = true;</a>
<a name="ln529">    }</a>
<a name="ln530">    curbuf-&gt;b_p_bomb = false;</a>
<a name="ln531">    curbuf-&gt;b_start_bomb = false;</a>
<a name="ln532">  }</a>
<a name="ln533"> </a>
<a name="ln534">  // Create a swap file now, so that other Vims are warned that we are</a>
<a name="ln535">  // editing this file.</a>
<a name="ln536">  // Don't do this for a &quot;nofile&quot; or &quot;nowrite&quot; buffer type.</a>
<a name="ln537">  if (!bt_dontwrite(curbuf)) {</a>
<a name="ln538">    check_need_swap(newfile);</a>
<a name="ln539">    if (!read_stdin</a>
<a name="ln540">        &amp;&amp; (curbuf != old_curbuf</a>
<a name="ln541">            || (using_b_ffname &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln542">            || (using_b_fname &amp;&amp; (old_b_fname != curbuf-&gt;b_fname)))) {</a>
<a name="ln543">      emsg(_(e_auchangedbuf));</a>
<a name="ln544">      if (!read_buffer) {</a>
<a name="ln545">        close(fd);</a>
<a name="ln546">      }</a>
<a name="ln547">      return FAIL;</a>
<a name="ln548">    }</a>
<a name="ln549">#ifdef UNIX</a>
<a name="ln550">    // Set swap file protection bits after creating it.</a>
<a name="ln551">    if (swap_mode &gt; 0 &amp;&amp; curbuf-&gt;b_ml.ml_mfp != NULL</a>
<a name="ln552">        &amp;&amp; curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname != NULL) {</a>
<a name="ln553">      const char *swap_fname = (const char *)curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname;</a>
<a name="ln554"> </a>
<a name="ln555">      // If the group-read bit is set but not the world-read bit, then</a>
<a name="ln556">      // the group must be equal to the group of the original file.  If</a>
<a name="ln557">      // we can't make that happen then reset the group-read bit.  This</a>
<a name="ln558">      // avoids making the swap file readable to more users when the</a>
<a name="ln559">      // primary group of the user is too permissive.</a>
<a name="ln560">      if ((swap_mode &amp; 044) == 040) {</a>
<a name="ln561">        FileInfo swap_info;</a>
<a name="ln562"> </a>
<a name="ln563">        if (os_fileinfo(swap_fname, &amp;swap_info)</a>
<a name="ln564">            &amp;&amp; file_info.stat.st_gid != swap_info.stat.st_gid</a>
<a name="ln565">            &amp;&amp; os_fchown(curbuf-&gt;b_ml.ml_mfp-&gt;mf_fd, (uv_uid_t)(-1),</a>
<a name="ln566">                         (uv_gid_t)file_info.stat.st_gid)</a>
<a name="ln567">            == -1) {</a>
<a name="ln568">          swap_mode &amp;= 0600;</a>
<a name="ln569">        }</a>
<a name="ln570">      }</a>
<a name="ln571"> </a>
<a name="ln572">      (void)os_setperm(swap_fname, swap_mode);</a>
<a name="ln573">    }</a>
<a name="ln574">#endif</a>
<a name="ln575">  }</a>
<a name="ln576"> </a>
<a name="ln577">  // If &quot;Quit&quot; selected at ATTENTION dialog, don't load the file.</a>
<a name="ln578">  if (swap_exists_action == SEA_QUIT) {</a>
<a name="ln579">    if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln580">      close(fd);</a>
<a name="ln581">    }</a>
<a name="ln582">    return FAIL;</a>
<a name="ln583">  }</a>
<a name="ln584"> </a>
<a name="ln585">  no_wait_return++;         // don't wait for return yet</a>
<a name="ln586"> </a>
<a name="ln587">  // Set '[ mark to the line above where the lines go (line 1 if zero).</a>
<a name="ln588">  orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln589">  curbuf-&gt;b_op_start.lnum = ((from == 0) ? 1 : from);</a>
<a name="ln590">  curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln591"> </a>
<a name="ln592">  int try_mac = (vim_strchr(p_ffs, 'm') != NULL);</a>
<a name="ln593">  int try_dos = (vim_strchr(p_ffs, 'd') != NULL);</a>
<a name="ln594">  int try_unix = (vim_strchr(p_ffs, 'x') != NULL);</a>
<a name="ln595"> </a>
<a name="ln596">  if (!read_buffer) {</a>
<a name="ln597">    int m = msg_scroll;</a>
<a name="ln598">    int n = msg_scrolled;</a>
<a name="ln599"> </a>
<a name="ln600">    // The file must be closed again, the autocommands may want to change</a>
<a name="ln601">    // the file before reading it.</a>
<a name="ln602">    if (!read_stdin) {</a>
<a name="ln603">      close(fd);                // ignore errors</a>
<a name="ln604">    }</a>
<a name="ln605"> </a>
<a name="ln606">    // The output from the autocommands should not overwrite anything and</a>
<a name="ln607">    // should not be overwritten: Set msg_scroll, restore its value if no</a>
<a name="ln608">    // output was done.</a>
<a name="ln609">    msg_scroll = true;</a>
<a name="ln610">    if (filtering) {</a>
<a name="ln611">      apply_autocmds_exarg(EVENT_FILTERREADPRE, NULL, sfname,</a>
<a name="ln612">                           false, curbuf, eap);</a>
<a name="ln613">    } else if (read_stdin) {</a>
<a name="ln614">      apply_autocmds_exarg(EVENT_STDINREADPRE, NULL, sfname,</a>
<a name="ln615">                           false, curbuf, eap);</a>
<a name="ln616">    } else if (newfile) {</a>
<a name="ln617">      apply_autocmds_exarg(EVENT_BUFREADPRE, NULL, sfname,</a>
<a name="ln618">                           false, curbuf, eap);</a>
<a name="ln619">    } else {</a>
<a name="ln620">      apply_autocmds_exarg(EVENT_FILEREADPRE, sfname, sfname,</a>
<a name="ln621">                           false, NULL, eap);</a>
<a name="ln622">    }</a>
<a name="ln623"> </a>
<a name="ln624">    // autocommands may have changed it</a>
<a name="ln625">    try_mac = (vim_strchr(p_ffs, 'm') != NULL);</a>
<a name="ln626">    try_dos = (vim_strchr(p_ffs, 'd') != NULL);</a>
<a name="ln627">    try_unix = (vim_strchr(p_ffs, 'x') != NULL);</a>
<a name="ln628">    curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln629"> </a>
<a name="ln630">    if (msg_scrolled == n) {</a>
<a name="ln631">      msg_scroll = m;</a>
<a name="ln632">    }</a>
<a name="ln633"> </a>
<a name="ln634">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln635">      no_wait_return--;</a>
<a name="ln636">      msg_scroll = msg_save;</a>
<a name="ln637">      curbuf-&gt;b_p_ro = true;            // must use &quot;w!&quot; now</a>
<a name="ln638">      return FAIL;</a>
<a name="ln639">    }</a>
<a name="ln640">    // Don't allow the autocommands to change the current buffer.</a>
<a name="ln641">    // Try to re-open the file.</a>
<a name="ln642">    //</a>
<a name="ln643">    // Don't allow the autocommands to change the buffer name either</a>
<a name="ln644">    // (cd for example) if it invalidates fname or sfname.</a>
<a name="ln645">    if (!read_stdin &amp;&amp; (curbuf != old_curbuf</a>
<a name="ln646">                        || (using_b_ffname &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln647">                        || (using_b_fname &amp;&amp; (old_b_fname != curbuf-&gt;b_fname))</a>
<a name="ln648">                        || (fd = os_open(fname, O_RDONLY, 0)) &lt; 0)) {</a>
<a name="ln649">      no_wait_return--;</a>
<a name="ln650">      msg_scroll = msg_save;</a>
<a name="ln651">      if (fd &lt; 0) {</a>
<a name="ln652">        emsg(_(&quot;E200: *ReadPre autocommands made the file unreadable&quot;));</a>
<a name="ln653">      } else {</a>
<a name="ln654">        emsg(_(&quot;E201: *ReadPre autocommands must not change current buffer&quot;));</a>
<a name="ln655">      }</a>
<a name="ln656">      curbuf-&gt;b_p_ro = true;            // must use &quot;w!&quot; now</a>
<a name="ln657">      return FAIL;</a>
<a name="ln658">    }</a>
<a name="ln659">  }</a>
<a name="ln660"> </a>
<a name="ln661">  // Autocommands may add lines to the file, need to check if it is empty</a>
<a name="ln662">  wasempty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln663"> </a>
<a name="ln664">  if (!recoverymode &amp;&amp; !filtering &amp;&amp; !(flags &amp; READ_DUMMY) &amp;&amp; !silent) {</a>
<a name="ln665">    if (!read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln666">      filemess(curbuf, sfname, &quot;&quot;, 0);</a>
<a name="ln667">    }</a>
<a name="ln668">  }</a>
<a name="ln669"> </a>
<a name="ln670">  msg_scroll = false;                   // overwrite the file message</a>
<a name="ln671"> </a>
<a name="ln672">  // Set linecnt now, before the &quot;retry&quot; caused by a wrong guess for</a>
<a name="ln673">  // fileformat, and after the autocommands, which may change them.</a>
<a name="ln674">  linecnt = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln675"> </a>
<a name="ln676">  // &quot;++bad=&quot; argument.</a>
<a name="ln677">  if (eap != NULL &amp;&amp; eap-&gt;bad_char != 0) {</a>
<a name="ln678">    bad_char_behavior = eap-&gt;bad_char;</a>
<a name="ln679">    if (set_options) {</a>
<a name="ln680">      curbuf-&gt;b_bad_char = eap-&gt;bad_char;</a>
<a name="ln681">    }</a>
<a name="ln682">  } else {</a>
<a name="ln683">    curbuf-&gt;b_bad_char = 0;</a>
<a name="ln684">  }</a>
<a name="ln685"> </a>
<a name="ln686">  // Decide which 'encoding' to use or use first.</a>
<a name="ln687">  if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln688">    fenc = enc_canonize(eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln689">    fenc_alloced = true;</a>
<a name="ln690">    keep_dest_enc = true;</a>
<a name="ln691">  } else if (curbuf-&gt;b_p_bin) {</a>
<a name="ln692">    fenc = &quot;&quot;;                // binary: don't convert</a>
<a name="ln693">    fenc_alloced = false;</a>
<a name="ln694">  } else if (curbuf-&gt;b_help) {</a>
<a name="ln695">    // Help files are either utf-8 or latin1.  Try utf-8 first, if this</a>
<a name="ln696">    // fails it must be latin1.</a>
<a name="ln697">    // It is needed when the first line contains non-ASCII characters.</a>
<a name="ln698">    // That is only in *.??x files.</a>
<a name="ln699">    fenc_next = &quot;latin1&quot;;</a>
<a name="ln700">    fenc = &quot;utf-8&quot;;</a>
<a name="ln701"> </a>
<a name="ln702">    fenc_alloced = false;</a>
<a name="ln703">  } else if (*p_fencs == NUL) {</a>
<a name="ln704">    fenc = curbuf-&gt;b_p_fenc;            // use format from buffer</a>
<a name="ln705">    fenc_alloced = false;</a>
<a name="ln706">  } else {</a>
<a name="ln707">    fenc_next = p_fencs;                // try items in 'fileencodings'</a>
<a name="ln708">    fenc = next_fenc(&amp;fenc_next, &amp;fenc_alloced);</a>
<a name="ln709">  }</a>
<a name="ln710"> </a>
<a name="ln711">  // Jump back here to retry reading the file in different ways.</a>
<a name="ln712">  // Reasons to retry:</a>
<a name="ln713">  // - encoding conversion failed: try another one from &quot;fenc_next&quot;</a>
<a name="ln714">  // - BOM detected and fenc was set, need to setup conversion</a>
<a name="ln715">  // - &quot;fileformat&quot; check failed: try another</a>
<a name="ln716">  //</a>
<a name="ln717">  // Variables set for special retry actions:</a>
<a name="ln718">  // &quot;file_rewind&quot;      Rewind the file to start reading it again.</a>
<a name="ln719">  // &quot;advance_fenc&quot;     Advance &quot;fenc&quot; using &quot;fenc_next&quot;.</a>
<a name="ln720">  // &quot;skip_read&quot;        Re-use already read bytes (BOM detected).</a>
<a name="ln721">  // &quot;did_iconv&quot;        iconv() conversion failed, try 'charconvert'.</a>
<a name="ln722">  // &quot;keep_fileformat&quot; Don't reset &quot;fileformat&quot;.</a>
<a name="ln723">  //</a>
<a name="ln724">  // Other status indicators:</a>
<a name="ln725">  // &quot;tmpname&quot;  When != NULL did conversion with 'charconvert'.</a>
<a name="ln726">  //                    Output file has to be deleted afterwards.</a>
<a name="ln727">  // &quot;iconv_fd&quot; When != -1 did conversion with iconv().</a>
<a name="ln728">retry:</a>
<a name="ln729"> </a>
<a name="ln730">  if (file_rewind) {</a>
<a name="ln731">    if (read_buffer) {</a>
<a name="ln732">      read_buf_lnum = 1;</a>
<a name="ln733">      read_buf_col = 0;</a>
<a name="ln734">    } else if (read_stdin || vim_lseek(fd, (off_T)0L, SEEK_SET) != 0) {</a>
<a name="ln735">      // Can't rewind the file, give up.</a>
<a name="ln736">      error = true;</a>
<a name="ln737">      goto failed;</a>
<a name="ln738">    }</a>
<a name="ln739">    // Delete the previously read lines.</a>
<a name="ln740">    while (lnum &gt; from) {</a>
<a name="ln741">      ml_delete(lnum--, false);</a>
<a name="ln742">    }</a>
<a name="ln743">    file_rewind = false;</a>
<a name="ln744">    if (set_options) {</a>
<a name="ln745">      curbuf-&gt;b_p_bomb = false;</a>
<a name="ln746">      curbuf-&gt;b_start_bomb = false;</a>
<a name="ln747">    }</a>
<a name="ln748">    conv_error = 0;</a>
<a name="ln749">  }</a>
<a name="ln750"> </a>
<a name="ln751">  // When retrying with another &quot;fenc&quot; and the first time &quot;fileformat&quot;</a>
<a name="ln752">  // will be reset.</a>
<a name="ln753">  if (keep_fileformat) {</a>
<a name="ln754">    keep_fileformat = false;</a>
<a name="ln755">  } else {</a>
<a name="ln756">    if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln757">      fileformat = get_fileformat_force(curbuf, eap);</a>
<a name="ln758">      try_unix = try_dos = try_mac = false;</a>
<a name="ln759">    } else if (curbuf-&gt;b_p_bin) {</a>
<a name="ln760">      fileformat = EOL_UNIX;                    // binary: use Unix format</a>
<a name="ln761">    } else if (*p_ffs ==</a>
<a name="ln762">               NUL) {</a>
<a name="ln763">      fileformat = get_fileformat(curbuf);      // use format from buffer</a>
<a name="ln764">    } else {</a>
<a name="ln765">      fileformat = EOL_UNKNOWN;                 // detect from file</a>
<a name="ln766">    }</a>
<a name="ln767">  }</a>
<a name="ln768"> </a>
<a name="ln769">#ifdef HAVE_ICONV</a>
<a name="ln770">  if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln771">    // aborted conversion with iconv(), close the descriptor</a>
<a name="ln772">    iconv_close(iconv_fd);</a>
<a name="ln773">    iconv_fd = (iconv_t)-1;</a>
<a name="ln774">  }</a>
<a name="ln775">#endif</a>
<a name="ln776"> </a>
<a name="ln777">  if (advance_fenc) {</a>
<a name="ln778">    // Try the next entry in 'fileencodings'.</a>
<a name="ln779">    advance_fenc = false;</a>
<a name="ln780"> </a>
<a name="ln781">    if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln782">      // Conversion given with &quot;++cc=&quot; wasn't possible, read</a>
<a name="ln783">      // without conversion.</a>
<a name="ln784">      notconverted = true;</a>
<a name="ln785">      conv_error = 0;</a>
<a name="ln786">      if (fenc_alloced) {</a>
<a name="ln787">        xfree(fenc);</a>
<a name="ln788">      }</a>
<a name="ln789">      fenc = &quot;&quot;;</a>
<a name="ln790">      fenc_alloced = false;</a>
<a name="ln791">    } else {</a>
<a name="ln792">      if (fenc_alloced) {</a>
<a name="ln793">        xfree(fenc);</a>
<a name="ln794">      }</a>
<a name="ln795">      if (fenc_next != NULL) {</a>
<a name="ln796">        fenc = next_fenc(&amp;fenc_next, &amp;fenc_alloced);</a>
<a name="ln797">      } else {</a>
<a name="ln798">        fenc = &quot;&quot;;</a>
<a name="ln799">        fenc_alloced = false;</a>
<a name="ln800">      }</a>
<a name="ln801">    }</a>
<a name="ln802">    if (tmpname != NULL) {</a>
<a name="ln803">      os_remove(tmpname);  // delete converted file</a>
<a name="ln804">      XFREE_CLEAR(tmpname);</a>
<a name="ln805">    }</a>
<a name="ln806">  }</a>
<a name="ln807"> </a>
<a name="ln808">  // Conversion may be required when the encoding of the file is different</a>
<a name="ln809">  // from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4.</a>
<a name="ln810">  fio_flags = 0;</a>
<a name="ln811">  converted = need_conversion(fenc);</a>
<a name="ln812">  if (converted) {</a>
<a name="ln813">    // &quot;ucs-bom&quot; means we need to check the first bytes of the file</a>
<a name="ln814">    // for a BOM.</a>
<a name="ln815">    if (strcmp(fenc, ENC_UCSBOM) == 0) {</a>
<a name="ln816">      fio_flags = FIO_UCSBOM;</a>
<a name="ln817">    } else {</a>
<a name="ln818">      // Check if UCS-2/4 or Latin1 to UTF-8 conversion needs to be</a>
<a name="ln819">      // done.  This is handled below after read().  Prepare the</a>
<a name="ln820">      // fio_flags to avoid having to parse the string each time.</a>
<a name="ln821">      // Also check for Unicode to Latin1 conversion, because iconv()</a>
<a name="ln822">      // appears not to handle this correctly.  This works just like</a>
<a name="ln823">      // conversion to UTF-8 except how the resulting character is put in</a>
<a name="ln824">      // the buffer.</a>
<a name="ln825">      fio_flags = get_fio_flags((char_u *)fenc);</a>
<a name="ln826">    }</a>
<a name="ln827"> </a>
<a name="ln828">#ifdef HAVE_ICONV</a>
<a name="ln829">    // Try using iconv() if we can't convert internally.</a>
<a name="ln830">    if (fio_flags == 0</a>
<a name="ln831">        &amp;&amp; !did_iconv) {</a>
<a name="ln832">      iconv_fd = (iconv_t)my_iconv_open((char_u *)&quot;utf-8&quot;, (char_u *)fenc);</a>
<a name="ln833">    }</a>
<a name="ln834">#endif</a>
<a name="ln835"> </a>
<a name="ln836">    // Use the 'charconvert' expression when conversion is required</a>
<a name="ln837">    // and we can't do it internally or with iconv().</a>
<a name="ln838">    if (fio_flags == 0 &amp;&amp; !read_stdin &amp;&amp; !read_buffer &amp;&amp; *p_ccv != NUL</a>
<a name="ln839">        &amp;&amp; !read_fifo</a>
<a name="ln840">#ifdef HAVE_ICONV</a>
<a name="ln841">        &amp;&amp; iconv_fd == (iconv_t)-1</a>
<a name="ln842">#endif</a>
<a name="ln843">        ) {</a>
<a name="ln844">#ifdef HAVE_ICONV</a>
<a name="ln845">      did_iconv = false;</a>
<a name="ln846">#endif</a>
<a name="ln847">      // Skip conversion when it's already done (retry for wrong</a>
<a name="ln848">      // &quot;fileformat&quot;).</a>
<a name="ln849">      if (tmpname == NULL) {</a>
<a name="ln850">        tmpname = (char *)readfile_charconvert((char_u *)fname, (char_u *)fenc, &amp;fd);</a>
<a name="ln851">        if (tmpname == NULL) {</a>
<a name="ln852">          // Conversion failed.  Try another one.</a>
<a name="ln853">          advance_fenc = true;</a>
<a name="ln854">          if (fd &lt; 0) {</a>
<a name="ln855">            // Re-opening the original file failed!</a>
<a name="ln856">            emsg(_(&quot;E202: Conversion made file unreadable!&quot;));</a>
<a name="ln857">            error = true;</a>
<a name="ln858">            goto failed;</a>
<a name="ln859">          }</a>
<a name="ln860">          goto retry;</a>
<a name="ln861">        }</a>
<a name="ln862">      }</a>
<a name="ln863">    } else {</a>
<a name="ln864">      if (fio_flags == 0</a>
<a name="ln865">#ifdef HAVE_ICONV</a>
<a name="ln866">          &amp;&amp; iconv_fd == (iconv_t)-1</a>
<a name="ln867">#endif</a>
<a name="ln868">          ) {</a>
<a name="ln869">        // Conversion wanted but we can't.</a>
<a name="ln870">        // Try the next conversion in 'fileencodings'</a>
<a name="ln871">        advance_fenc = true;</a>
<a name="ln872">        goto retry;</a>
<a name="ln873">      }</a>
<a name="ln874">    }</a>
<a name="ln875">  }</a>
<a name="ln876"> </a>
<a name="ln877">  // Set &quot;can_retry&quot; when it's possible to rewind the file and try with</a>
<a name="ln878">  // another &quot;fenc&quot; value.  It's false when no other &quot;fenc&quot; to try, reading</a>
<a name="ln879">  // stdin or fixed at a specific encoding.</a>
<a name="ln880">  can_retry = (*fenc != NUL &amp;&amp; !read_stdin &amp;&amp; !keep_dest_enc &amp;&amp; !read_fifo);</a>
<a name="ln881"> </a>
<a name="ln882">  if (!skip_read) {</a>
<a name="ln883">    linerest = 0;</a>
<a name="ln884">    filesize = 0;</a>
<a name="ln885">    skip_count = lines_to_skip;</a>
<a name="ln886">    read_count = lines_to_read;</a>
<a name="ln887">    conv_restlen = 0;</a>
<a name="ln888">    read_undo_file = (newfile &amp;&amp; (flags &amp; READ_KEEP_UNDO) == 0</a>
<a name="ln889">                      &amp;&amp; curbuf-&gt;b_ffname != NULL</a>
<a name="ln890">                      &amp;&amp; curbuf-&gt;b_p_udf</a>
<a name="ln891">                      &amp;&amp; !filtering</a>
<a name="ln892">                      &amp;&amp; !read_fifo</a>
<a name="ln893">                      &amp;&amp; !read_stdin</a>
<a name="ln894">                      &amp;&amp; !read_buffer);</a>
<a name="ln895">    if (read_undo_file) {</a>
<a name="ln896">      sha256_start(&amp;sha_ctx);</a>
<a name="ln897">    }</a>
<a name="ln898">  }</a>
<a name="ln899"> </a>
<a name="ln900">  while (!error &amp;&amp; !got_int) {</a>
<a name="ln901">    // We allocate as much space for the file as we can get, plus</a>
<a name="ln902">    // space for the old line plus room for one terminating NUL.</a>
<a name="ln903">    // The amount is limited by the fact that read() only can read</a>
<a name="ln904">    // up to max_unsigned characters (and other things).</a>
<a name="ln905">    {</a>
<a name="ln906">      if (!skip_read) {</a>
<a name="ln907">        // Use buffer &gt;= 64K.  Add linerest to double the size if the</a>
<a name="ln908">        // line gets very long, to avoid a lot of copying. But don't</a>
<a name="ln909">        // read more than 1 Mbyte at a time, so we can be interrupted.</a>
<a name="ln910">        size = 0x10000L + linerest;</a>
<a name="ln911">        if (size &gt; 0x100000L) {</a>
<a name="ln912">          size = 0x100000L;</a>
<a name="ln913">        }</a>
<a name="ln914">      }</a>
<a name="ln915"> </a>
<a name="ln916">      // Protect against the argument of lalloc() going negative.</a>
<a name="ln917">      if (size &lt; 0 || size + linerest + 1 &lt; 0 || linerest &gt;= MAXCOL) {</a>
<a name="ln918">        split++;</a>
<a name="ln919">        *ptr = NL;  // split line by inserting a NL</a>
<a name="ln920">        size = 1;</a>
<a name="ln921">      } else if (!skip_read) {</a>
<a name="ln922">        for (; size &gt;= 10; size /= 2) {</a>
<a name="ln923">          new_buffer = verbose_try_malloc((size_t)size + (size_t)linerest + 1);</a>
<a name="ln924">          if (new_buffer) {</a>
<a name="ln925">            break;</a>
<a name="ln926">          }</a>
<a name="ln927">        }</a>
<a name="ln928">        if (new_buffer == NULL) {</a>
<a name="ln929">          error = true;</a>
<a name="ln930">          break;</a>
<a name="ln931">        }</a>
<a name="ln932">        if (linerest) {         // copy characters from the previous buffer</a>
<a name="ln933">          memmove(new_buffer, ptr - linerest, (size_t)linerest);</a>
<a name="ln934">        }</a>
<a name="ln935">        xfree(buffer);</a>
<a name="ln936">        buffer = new_buffer;</a>
<a name="ln937">        ptr = buffer + linerest;</a>
<a name="ln938">        line_start = buffer;</a>
<a name="ln939"> </a>
<a name="ln940">        // May need room to translate into.</a>
<a name="ln941">        // For iconv() we don't really know the required space, use a</a>
<a name="ln942">        // factor ICONV_MULT.</a>
<a name="ln943">        // latin1 to utf-8: 1 byte becomes up to 2 bytes</a>
<a name="ln944">        // utf-16 to utf-8: 2 bytes become up to 3 bytes, 4 bytes</a>
<a name="ln945">        // become up to 4 bytes, size must be multiple of 2</a>
<a name="ln946">        // ucs-2 to utf-8: 2 bytes become up to 3 bytes, size must be</a>
<a name="ln947">        // multiple of 2</a>
<a name="ln948">        // ucs-4 to utf-8: 4 bytes become up to 6 bytes, size must be</a>
<a name="ln949">        // multiple of 4</a>
<a name="ln950">        real_size = (int)size;</a>
<a name="ln951">#ifdef HAVE_ICONV</a>
<a name="ln952">        if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln953">          size = size / ICONV_MULT;</a>
<a name="ln954">        } else {</a>
<a name="ln955">#endif</a>
<a name="ln956">        if (fio_flags &amp; FIO_LATIN1) {</a>
<a name="ln957">          size = size / 2;</a>
<a name="ln958">        } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln959">          size = (size * 2 / 3) &amp; ~1;</a>
<a name="ln960">        } else if (fio_flags &amp; FIO_UCS4) {</a>
<a name="ln961">          size = (size * 2 / 3) &amp; ~3;</a>
<a name="ln962">        } else if (fio_flags == FIO_UCSBOM) {</a>
<a name="ln963">          size = size / ICONV_MULT;  // worst case</a>
<a name="ln964">        }</a>
<a name="ln965">#ifdef HAVE_ICONV</a>
<a name="ln966">      }</a>
<a name="ln967">#endif</a>
<a name="ln968">        if (conv_restlen &gt; 0) {</a>
<a name="ln969">          // Insert unconverted bytes from previous line.</a>
<a name="ln970">          memmove(ptr, conv_rest, (size_t)conv_restlen);  // -V614</a>
<a name="ln971">          ptr += conv_restlen;</a>
<a name="ln972">          size -= conv_restlen;</a>
<a name="ln973">        }</a>
<a name="ln974"> </a>
<a name="ln975">        if (read_buffer) {</a>
<a name="ln976">          // Read bytes from curbuf.  Used for converting text read</a>
<a name="ln977">          // from stdin.</a>
<a name="ln978">          if (read_buf_lnum &gt; from) {</a>
<a name="ln979">            size = 0;</a>
<a name="ln980">          } else {</a>
<a name="ln981">            int n, ni;</a>
<a name="ln982">            long tlen;</a>
<a name="ln983"> </a>
<a name="ln984">            tlen = 0;</a>
<a name="ln985">            for (;;) {</a>
<a name="ln986">              p = (char_u *)ml_get(read_buf_lnum) + read_buf_col;</a>
<a name="ln987">              n = (int)STRLEN(p);</a>
<a name="ln988">              if ((int)tlen + n + 1 &gt; size) {</a>
<a name="ln989">                // Filled up to &quot;size&quot;, append partial line.</a>
<a name="ln990">                // Change NL to NUL to reverse the effect done</a>
<a name="ln991">                // below.</a>
<a name="ln992">                n = (int)(size - tlen);</a>
<a name="ln993">                for (ni = 0; ni &lt; n; ni++) {</a>
<a name="ln994">                  if (p[ni] == NL) {</a>
<a name="ln995">                    ptr[tlen++] = NUL;</a>
<a name="ln996">                  } else {</a>
<a name="ln997">                    ptr[tlen++] = (char)p[ni];</a>
<a name="ln998">                  }</a>
<a name="ln999">                }</a>
<a name="ln1000">                read_buf_col += n;</a>
<a name="ln1001">                break;</a>
<a name="ln1002">              }</a>
<a name="ln1003"> </a>
<a name="ln1004">              // Append whole line and new-line.  Change NL</a>
<a name="ln1005">              // to NUL to reverse the effect done below.</a>
<a name="ln1006">              for (ni = 0; ni &lt; n; ni++) {</a>
<a name="ln1007">                if (p[ni] == NL) {</a>
<a name="ln1008">                  ptr[tlen++] = NUL;</a>
<a name="ln1009">                } else {</a>
<a name="ln1010">                  ptr[tlen++] = (char)p[ni];</a>
<a name="ln1011">                }</a>
<a name="ln1012">              }</a>
<a name="ln1013">              ptr[tlen++] = NL;</a>
<a name="ln1014">              read_buf_col = 0;</a>
<a name="ln1015">              if (++read_buf_lnum &gt; from) {</a>
<a name="ln1016">                // When the last line didn't have an</a>
<a name="ln1017">                // end-of-line don't add it now either.</a>
<a name="ln1018">                if (!curbuf-&gt;b_p_eol) {</a>
<a name="ln1019">                  tlen--;</a>
<a name="ln1020">                }</a>
<a name="ln1021">                size = tlen;</a>
<a name="ln1022">                break;</a>
<a name="ln1023">              }</a>
<a name="ln1024">            }</a>
<a name="ln1025">          }</a>
<a name="ln1026">        } else {</a>
<a name="ln1027">          // Read bytes from the file.</a>
<a name="ln1028">          size = read_eintr(fd, ptr, (size_t)size);</a>
<a name="ln1029">        }</a>
<a name="ln1030"> </a>
<a name="ln1031">        if (size &lt;= 0) {</a>
<a name="ln1032">          if (size &lt; 0) {                           // read error</a>
<a name="ln1033">            error = true;</a>
<a name="ln1034">          } else if (conv_restlen &gt; 0) {</a>
<a name="ln1035">            // Reached end-of-file but some trailing bytes could</a>
<a name="ln1036">            // not be converted.  Truncated file?</a>
<a name="ln1037"> </a>
<a name="ln1038">            // When we did a conversion report an error.</a>
<a name="ln1039">            if (fio_flags != 0</a>
<a name="ln1040">#ifdef HAVE_ICONV</a>
<a name="ln1041">                || iconv_fd != (iconv_t)-1</a>
<a name="ln1042">#endif</a>
<a name="ln1043">                ) {</a>
<a name="ln1044">              if (can_retry) {</a>
<a name="ln1045">                goto rewind_retry;</a>
<a name="ln1046">              }</a>
<a name="ln1047">              if (conv_error == 0) {</a>
<a name="ln1048">                conv_error = curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln1049">                             - linecnt + 1;</a>
<a name="ln1050">              }</a>
<a name="ln1051">            } else if (illegal_byte == 0) {</a>
<a name="ln1052">              // Remember the first linenr with an illegal byte</a>
<a name="ln1053">              illegal_byte = curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln1054">                             - linecnt + 1;</a>
<a name="ln1055">            }</a>
<a name="ln1056">            if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1057">              *(ptr - conv_restlen) = NUL;</a>
<a name="ln1058">              conv_restlen = 0;</a>
<a name="ln1059">            } else {</a>
<a name="ln1060">              // Replace the trailing bytes with the replacement</a>
<a name="ln1061">              // character if we were converting; if we weren't,</a>
<a name="ln1062">              // leave the UTF8 checking code to do it, as it</a>
<a name="ln1063">              // works slightly differently.</a>
<a name="ln1064">              if (bad_char_behavior != BAD_KEEP &amp;&amp; (fio_flags != 0</a>
<a name="ln1065">#ifdef HAVE_ICONV</a>
<a name="ln1066">                                                    || iconv_fd != (iconv_t)-1</a>
<a name="ln1067">#endif</a>
<a name="ln1068">                                                    )) {  // NOLINT(whitespace/parens)</a>
<a name="ln1069">                while (conv_restlen &gt; 0) {</a>
<a name="ln1070">                  *(--ptr) = (char)bad_char_behavior;</a>
<a name="ln1071">                  conv_restlen--;</a>
<a name="ln1072">                }</a>
<a name="ln1073">              }</a>
<a name="ln1074">              fio_flags = 0;  // don't convert this</a>
<a name="ln1075">#ifdef HAVE_ICONV</a>
<a name="ln1076">              if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1077">                iconv_close(iconv_fd);</a>
<a name="ln1078">                iconv_fd = (iconv_t)-1;</a>
<a name="ln1079">              }</a>
<a name="ln1080">#endif</a>
<a name="ln1081">            }</a>
<a name="ln1082">          }</a>
<a name="ln1083">        }</a>
<a name="ln1084">      }</a>
<a name="ln1085"> </a>
<a name="ln1086">      skip_read = false;</a>
<a name="ln1087"> </a>
<a name="ln1088">      // At start of file: Check for BOM.</a>
<a name="ln1089">      // Also check for a BOM for other Unicode encodings, but not after</a>
<a name="ln1090">      // converting with 'charconvert' or when a BOM has already been</a>
<a name="ln1091">      // found.</a>
<a name="ln1092">      if ((filesize == 0)</a>
<a name="ln1093">          &amp;&amp; (fio_flags == FIO_UCSBOM</a>
<a name="ln1094">              || (!curbuf-&gt;b_p_bomb</a>
<a name="ln1095">                  &amp;&amp; tmpname == NULL</a>
<a name="ln1096">                  &amp;&amp; (*fenc == 'u' || *fenc == NUL)))) {</a>
<a name="ln1097">        char_u *ccname;</a>
<a name="ln1098">        int blen = 0;</a>
<a name="ln1099"> </a>
<a name="ln1100">        // no BOM detection in a short file or in binary mode</a>
<a name="ln1101">        if (size &lt; 2 || curbuf-&gt;b_p_bin) {</a>
<a name="ln1102">          ccname = NULL;</a>
<a name="ln1103">        } else {</a>
<a name="ln1104">          ccname = check_for_bom((char_u *)ptr, size, &amp;blen,</a>
<a name="ln1105">                                 fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags((char_u *)fenc));</a>
<a name="ln1106">        }</a>
<a name="ln1107">        if (ccname != NULL) {</a>
<a name="ln1108">          // Remove BOM from the text</a>
<a name="ln1109">          filesize += blen;</a>
<a name="ln1110">          size -= blen;</a>
<a name="ln1111">          memmove(ptr, ptr + blen, (size_t)size);</a>
<a name="ln1112">          if (set_options) {</a>
<a name="ln1113">            curbuf-&gt;b_p_bomb = true;</a>
<a name="ln1114">            curbuf-&gt;b_start_bomb = true;</a>
<a name="ln1115">          }</a>
<a name="ln1116">        }</a>
<a name="ln1117"> </a>
<a name="ln1118">        if (fio_flags == FIO_UCSBOM) {</a>
<a name="ln1119">          if (ccname == NULL) {</a>
<a name="ln1120">            // No BOM detected: retry with next encoding.</a>
<a name="ln1121">            advance_fenc = true;</a>
<a name="ln1122">          } else {</a>
<a name="ln1123">            // BOM detected: set &quot;fenc&quot; and jump back</a>
<a name="ln1124">            if (fenc_alloced) {</a>
<a name="ln1125">              xfree(fenc);</a>
<a name="ln1126">            }</a>
<a name="ln1127">            fenc = (char *)ccname;</a>
<a name="ln1128">            fenc_alloced = false;</a>
<a name="ln1129">          }</a>
<a name="ln1130">          // retry reading without getting new bytes or rewinding</a>
<a name="ln1131">          skip_read = true;</a>
<a name="ln1132">          goto retry;</a>
<a name="ln1133">        }</a>
<a name="ln1134">      }</a>
<a name="ln1135"> </a>
<a name="ln1136">      // Include not converted bytes.</a>
<a name="ln1137">      ptr -= conv_restlen;</a>
<a name="ln1138">      size += conv_restlen;</a>
<a name="ln1139">      conv_restlen = 0;</a>
<a name="ln1140">      // Break here for a read error or end-of-file.</a>
<a name="ln1141">      if (size &lt;= 0) {</a>
<a name="ln1142">        break;</a>
<a name="ln1143">      }</a>
<a name="ln1144"> </a>
<a name="ln1145">#ifdef HAVE_ICONV</a>
<a name="ln1146">      if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1147">        // Attempt conversion of the read bytes to 'encoding' using iconv().</a>
<a name="ln1148">        const char *fromp = ptr;</a>
<a name="ln1149">        size_t from_size = (size_t)size;</a>
<a name="ln1150">        ptr += size;</a>
<a name="ln1151">        char *top = ptr;</a>
<a name="ln1152">        size_t to_size = (size_t)(real_size - size);</a>
<a name="ln1153"> </a>
<a name="ln1154">        // If there is conversion error or not enough room try using</a>
<a name="ln1155">        // another conversion.  Except for when there is no</a>
<a name="ln1156">        // alternative (help files).</a>
<a name="ln1157">        while ((iconv(iconv_fd, (void *)&amp;fromp, &amp;from_size,</a>
<a name="ln1158">                      &amp;top, &amp;to_size)</a>
<a name="ln1159">                == (size_t)-1 &amp;&amp; ICONV_ERRNO != ICONV_EINVAL)</a>
<a name="ln1160">               || from_size &gt; CONV_RESTLEN) {</a>
<a name="ln1161">          if (can_retry) {</a>
<a name="ln1162">            goto rewind_retry;</a>
<a name="ln1163">          }</a>
<a name="ln1164">          if (conv_error == 0) {</a>
<a name="ln1165">            conv_error = readfile_linenr(linecnt, (char_u *)ptr, (char_u *)top);</a>
<a name="ln1166">          }</a>
<a name="ln1167"> </a>
<a name="ln1168">          // Deal with a bad byte and continue with the next.</a>
<a name="ln1169">          fromp++;</a>
<a name="ln1170">          from_size--;</a>
<a name="ln1171">          if (bad_char_behavior == BAD_KEEP) {</a>
<a name="ln1172">            *top++ = *(fromp - 1);</a>
<a name="ln1173">            to_size--;</a>
<a name="ln1174">          } else if (bad_char_behavior != BAD_DROP) {</a>
<a name="ln1175">            *top++ = (char)bad_char_behavior;</a>
<a name="ln1176">            to_size--;</a>
<a name="ln1177">          }</a>
<a name="ln1178">        }</a>
<a name="ln1179"> </a>
<a name="ln1180">        if (from_size &gt; 0) {</a>
<a name="ln1181">          // Some remaining characters, keep them for the next</a>
<a name="ln1182">          // round.</a>
<a name="ln1183">          memmove(conv_rest, (char_u *)fromp, from_size);</a>
<a name="ln1184">          conv_restlen = (int)from_size;</a>
<a name="ln1185">        }</a>
<a name="ln1186"> </a>
<a name="ln1187">        // move the linerest to before the converted characters</a>
<a name="ln1188">        line_start = ptr - linerest;</a>
<a name="ln1189">        memmove(line_start, buffer, (size_t)linerest);</a>
<a name="ln1190">        size = (top - ptr);</a>
<a name="ln1191">      }</a>
<a name="ln1192">#endif</a>
<a name="ln1193"> </a>
<a name="ln1194">      if (fio_flags != 0) {</a>
<a name="ln1195">        unsigned int u8c;</a>
<a name="ln1196">        char *dest;</a>
<a name="ln1197">        char *tail = NULL;</a>
<a name="ln1198"> </a>
<a name="ln1199">        // Convert Unicode or Latin1 to UTF-8.</a>
<a name="ln1200">        // Go from end to start through the buffer, because the number</a>
<a name="ln1201">        // of bytes may increase.</a>
<a name="ln1202">        // &quot;dest&quot; points to after where the UTF-8 bytes go, &quot;p&quot; points</a>
<a name="ln1203">        // to after the next character to convert.</a>
<a name="ln1204">        dest = ptr + real_size;</a>
<a name="ln1205">        if (fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8) {</a>
<a name="ln1206">          p = (uint8_t *)ptr + size;</a>
<a name="ln1207">          if (fio_flags == FIO_UTF8) {</a>
<a name="ln1208">            // Check for a trailing incomplete UTF-8 sequence</a>
<a name="ln1209">            tail = ptr + size - 1;</a>
<a name="ln1210">            while (tail &gt; ptr &amp;&amp; (*tail &amp; 0xc0) == 0x80) {</a>
<a name="ln1211">              tail--;</a>
<a name="ln1212">            }</a>
<a name="ln1213">            if (tail + utf_byte2len(*tail) &lt;= ptr + size) {</a>
<a name="ln1214">              tail = NULL;</a>
<a name="ln1215">            } else {</a>
<a name="ln1216">              p = (uint8_t *)tail;</a>
<a name="ln1217">            }</a>
<a name="ln1218">          }</a>
<a name="ln1219">        } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln1220">          // Check for a trailing byte</a>
<a name="ln1221">          p = (uint8_t *)ptr + (size &amp; ~1);</a>
<a name="ln1222">          if (size &amp; 1) {</a>
<a name="ln1223">            tail = (char *)p;</a>
<a name="ln1224">          }</a>
<a name="ln1225">          if ((fio_flags &amp; FIO_UTF16) &amp;&amp; p &gt; (uint8_t *)ptr) {</a>
<a name="ln1226">            // Check for a trailing leading word</a>
<a name="ln1227">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1228">              u8c = (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1229">              u8c += *--p;</a>
<a name="ln1230">            } else {</a>
<a name="ln1231">              u8c = *--p;</a>
<a name="ln1232">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1233">            }</a>
<a name="ln1234">            if (u8c &gt;= 0xd800 &amp;&amp; u8c &lt;= 0xdbff) {</a>
<a name="ln1235">              tail = (char *)p;</a>
<a name="ln1236">            } else {</a>
<a name="ln1237">              p += 2;</a>
<a name="ln1238">            }</a>
<a name="ln1239">          }</a>
<a name="ln1240">        } else {   //  FIO_UCS4</a>
<a name="ln1241">                   // Check for trailing 1, 2 or 3 bytes</a>
<a name="ln1242">          p = (uint8_t *)ptr + (size &amp; ~3);</a>
<a name="ln1243">          if (size &amp; 3) {</a>
<a name="ln1244">            tail = (char *)p;</a>
<a name="ln1245">          }</a>
<a name="ln1246">        }</a>
<a name="ln1247"> </a>
<a name="ln1248">        // If there is a trailing incomplete sequence move it to</a>
<a name="ln1249">        // conv_rest[].</a>
<a name="ln1250">        if (tail != NULL) {</a>
<a name="ln1251">          conv_restlen = (int)((ptr + size) - tail);</a>
<a name="ln1252">          memmove(conv_rest, tail, (size_t)conv_restlen);</a>
<a name="ln1253">          size -= conv_restlen;</a>
<a name="ln1254">        }</a>
<a name="ln1255"> </a>
<a name="ln1256">        while (p &gt; (uint8_t *)ptr) {</a>
<a name="ln1257">          if (fio_flags &amp; FIO_LATIN1) {</a>
<a name="ln1258">            u8c = *--p;</a>
<a name="ln1259">          } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln1260">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1261">              u8c = (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1262">              u8c += *--p;</a>
<a name="ln1263">            } else {</a>
<a name="ln1264">              u8c = *--p;</a>
<a name="ln1265">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1266">            }</a>
<a name="ln1267">            if ((fio_flags &amp; FIO_UTF16)</a>
<a name="ln1268">                &amp;&amp; u8c &gt;= 0xdc00 &amp;&amp; u8c &lt;= 0xdfff) {</a>
<a name="ln1269">              int u16c;</a>
<a name="ln1270"> </a>
<a name="ln1271">              if (p == (uint8_t *)ptr) {</a>
<a name="ln1272">                // Missing leading word.</a>
<a name="ln1273">                if (can_retry) {</a>
<a name="ln1274">                  goto rewind_retry;</a>
<a name="ln1275">                }</a>
<a name="ln1276">                if (conv_error == 0) {</a>
<a name="ln1277">                  conv_error = readfile_linenr(linecnt, (char_u *)ptr, p);</a>
<a name="ln1278">                }</a>
<a name="ln1279">                if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1280">                  continue;</a>
<a name="ln1281">                }</a>
<a name="ln1282">                if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1283">                  u8c = (unsigned)bad_char_behavior;</a>
<a name="ln1284">                }</a>
<a name="ln1285">              }</a>
<a name="ln1286"> </a>
<a name="ln1287">              // found second word of double-word, get the first</a>
<a name="ln1288">              // word and compute the resulting character</a>
<a name="ln1289">              if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1290">                u16c = (*--p &lt;&lt; 8);</a>
<a name="ln1291">                u16c += *--p;</a>
<a name="ln1292">              } else {</a>
<a name="ln1293">                u16c = *--p;</a>
<a name="ln1294">                u16c += (*--p &lt;&lt; 8);</a>
<a name="ln1295">              }</a>
<a name="ln1296">              u8c = 0x10000 + (((unsigned)u16c &amp; 0x3ff) &lt;&lt; 10)</a>
<a name="ln1297">                    + (u8c &amp; 0x3ff);</a>
<a name="ln1298"> </a>
<a name="ln1299">              // Check if the word is indeed a leading word.</a>
<a name="ln1300">              if (u16c &lt; 0xd800 || u16c &gt; 0xdbff) {</a>
<a name="ln1301">                if (can_retry) {</a>
<a name="ln1302">                  goto rewind_retry;</a>
<a name="ln1303">                }</a>
<a name="ln1304">                if (conv_error == 0) {</a>
<a name="ln1305">                  conv_error = readfile_linenr(linecnt, (char_u *)ptr, p);</a>
<a name="ln1306">                }</a>
<a name="ln1307">                if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1308">                  continue;</a>
<a name="ln1309">                }</a>
<a name="ln1310">                if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1311">                  u8c = (unsigned)bad_char_behavior;</a>
<a name="ln1312">                }</a>
<a name="ln1313">              }</a>
<a name="ln1314">            }</a>
<a name="ln1315">          } else if (fio_flags &amp; FIO_UCS4) {</a>
<a name="ln1316">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1317">              u8c = (unsigned)(*--p) &lt;&lt; 24;</a>
<a name="ln1318">              u8c += (unsigned)(*--p) &lt;&lt; 16;</a>
<a name="ln1319">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1320">              u8c += *--p;</a>
<a name="ln1321">            } else {          // big endian</a>
<a name="ln1322">              u8c = *--p;</a>
<a name="ln1323">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1324">              u8c += (unsigned)(*--p) &lt;&lt; 16;</a>
<a name="ln1325">              u8c += (unsigned)(*--p) &lt;&lt; 24;</a>
<a name="ln1326">            }</a>
<a name="ln1327">            // Replace characters over INT_MAX with Unicode replacement character</a>
<a name="ln1328">            if (u8c &gt; INT_MAX) {</a>
<a name="ln1329">              u8c = 0xfffd;</a>
<a name="ln1330">            }</a>
<a name="ln1331">          } else {        // UTF-8</a>
<a name="ln1332">            if (*--p &lt; 0x80) {</a>
<a name="ln1333">              u8c = *p;</a>
<a name="ln1334">            } else {</a>
<a name="ln1335">              len = utf_head_off(ptr, (char *)p);</a>
<a name="ln1336">              p -= len;</a>
<a name="ln1337">              u8c = (unsigned)utf_ptr2char((char *)p);</a>
<a name="ln1338">              if (len == 0) {</a>
<a name="ln1339">                // Not a valid UTF-8 character, retry with</a>
<a name="ln1340">                // another fenc when possible, otherwise just</a>
<a name="ln1341">                // report the error.</a>
<a name="ln1342">                if (can_retry) {</a>
<a name="ln1343">                  goto rewind_retry;</a>
<a name="ln1344">                }</a>
<a name="ln1345">                if (conv_error == 0) {</a>
<a name="ln1346">                  conv_error = readfile_linenr(linecnt, (char_u *)ptr, p);</a>
<a name="ln1347">                }</a>
<a name="ln1348">                if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1349">                  continue;</a>
<a name="ln1350">                }</a>
<a name="ln1351">                if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1352">                  u8c = (unsigned)bad_char_behavior;</a>
<a name="ln1353">                }</a>
<a name="ln1354">              }</a>
<a name="ln1355">            }</a>
<a name="ln1356">          }</a>
<a name="ln1357">          assert(u8c &lt;= INT_MAX);</a>
<a name="ln1358">          // produce UTF-8</a>
<a name="ln1359">          dest -= utf_char2len((int)u8c);</a>
<a name="ln1360">          (void)utf_char2bytes((int)u8c, dest);</a>
<a name="ln1361">        }</a>
<a name="ln1362"> </a>
<a name="ln1363">        // move the linerest to before the converted characters</a>
<a name="ln1364">        line_start = dest - linerest;</a>
<a name="ln1365">        memmove(line_start, buffer, (size_t)linerest);</a>
<a name="ln1366">        size = ((ptr + real_size) - dest);</a>
<a name="ln1367">        ptr = dest;</a>
<a name="ln1368">      } else if (!curbuf-&gt;b_p_bin) {</a>
<a name="ln1369">        bool incomplete_tail = false;</a>
<a name="ln1370"> </a>
<a name="ln1371">        // Reading UTF-8: Check if the bytes are valid UTF-8.</a>
<a name="ln1372">        for (p = (uint8_t *)ptr;; p++) {</a>
<a name="ln1373">          int todo = (int)(((uint8_t *)ptr + size) - p);</a>
<a name="ln1374">          int l;</a>
<a name="ln1375"> </a>
<a name="ln1376">          if (todo &lt;= 0) {</a>
<a name="ln1377">            break;</a>
<a name="ln1378">          }</a>
<a name="ln1379">          if (*p &gt;= 0x80) {</a>
<a name="ln1380">            // A length of 1 means it's an illegal byte.  Accept</a>
<a name="ln1381">            // an incomplete character at the end though, the next</a>
<a name="ln1382">            // read() will get the next bytes, we'll check it</a>
<a name="ln1383">            // then.</a>
<a name="ln1384">            l = utf_ptr2len_len(p, todo);</a>
<a name="ln1385">            if (l &gt; todo &amp;&amp; !incomplete_tail) {</a>
<a name="ln1386">              // Avoid retrying with a different encoding when</a>
<a name="ln1387">              // a truncated file is more likely, or attempting</a>
<a name="ln1388">              // to read the rest of an incomplete sequence when</a>
<a name="ln1389">              // we have already done so.</a>
<a name="ln1390">              if (p &gt; (uint8_t *)ptr || filesize &gt; 0) {</a>
<a name="ln1391">                incomplete_tail = true;</a>
<a name="ln1392">              }</a>
<a name="ln1393">              // Incomplete byte sequence, move it to conv_rest[]</a>
<a name="ln1394">              // and try to read the rest of it, unless we've</a>
<a name="ln1395">              // already done so.</a>
<a name="ln1396">              if (p &gt; (uint8_t *)ptr) {</a>
<a name="ln1397">                conv_restlen = todo;</a>
<a name="ln1398">                memmove(conv_rest, p, (size_t)conv_restlen);</a>
<a name="ln1399">                size -= conv_restlen;</a>
<a name="ln1400">                break;</a>
<a name="ln1401">              }</a>
<a name="ln1402">            }</a>
<a name="ln1403">            if (l == 1 || l &gt; todo) {</a>
<a name="ln1404">              // Illegal byte.  If we can try another encoding</a>
<a name="ln1405">              // do that, unless at EOF where a truncated</a>
<a name="ln1406">              // file is more likely than a conversion error.</a>
<a name="ln1407">              if (can_retry &amp;&amp; !incomplete_tail) {</a>
<a name="ln1408">                break;</a>
<a name="ln1409">              }</a>
<a name="ln1410">#ifdef HAVE_ICONV</a>
<a name="ln1411">              // When we did a conversion report an error.</a>
<a name="ln1412">              if (iconv_fd != (iconv_t)-1 &amp;&amp; conv_error == 0) {</a>
<a name="ln1413">                conv_error = readfile_linenr(linecnt, (char_u *)ptr, p);</a>
<a name="ln1414">              }</a>
<a name="ln1415">#endif</a>
<a name="ln1416">              // Remember the first linenr with an illegal byte</a>
<a name="ln1417">              if (conv_error == 0 &amp;&amp; illegal_byte == 0) {</a>
<a name="ln1418">                illegal_byte = readfile_linenr(linecnt, (char_u *)ptr, p);</a>
<a name="ln1419">              }</a>
<a name="ln1420"> </a>
<a name="ln1421">              // Drop, keep or replace the bad byte.</a>
<a name="ln1422">              if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1423">                memmove(p, p + 1, (size_t)(todo - 1));</a>
<a name="ln1424">                p--;</a>
<a name="ln1425">                size--;</a>
<a name="ln1426">              } else if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1427">                *p = (uint8_t)bad_char_behavior;</a>
<a name="ln1428">              }</a>
<a name="ln1429">            } else {</a>
<a name="ln1430">              p += l - 1;</a>
<a name="ln1431">            }</a>
<a name="ln1432">          }</a>
<a name="ln1433">        }</a>
<a name="ln1434">        if (p &lt; (uint8_t *)ptr + size &amp;&amp; !incomplete_tail) {</a>
<a name="ln1435">          // Detected a UTF-8 error.</a>
<a name="ln1436">rewind_retry:</a>
<a name="ln1437">          // Retry reading with another conversion.</a>
<a name="ln1438">#ifdef HAVE_ICONV</a>
<a name="ln1439">          if (*p_ccv != NUL &amp;&amp; iconv_fd != (iconv_t)-1) {</a>
<a name="ln1440">            // iconv() failed, try 'charconvert'</a>
<a name="ln1441">            did_iconv = true;</a>
<a name="ln1442">          } else {</a>
<a name="ln1443">#endif</a>
<a name="ln1444">          // use next item from 'fileencodings'</a>
<a name="ln1445">          advance_fenc = true;</a>
<a name="ln1446">#ifdef HAVE_ICONV</a>
<a name="ln1447">        }</a>
<a name="ln1448">#endif</a>
<a name="ln1449">          file_rewind = true;</a>
<a name="ln1450">          goto retry;</a>
<a name="ln1451">        }</a>
<a name="ln1452">      }</a>
<a name="ln1453"> </a>
<a name="ln1454">      // count the number of characters (after conversion!)</a>
<a name="ln1455">      filesize += size;</a>
<a name="ln1456"> </a>
<a name="ln1457">      // when reading the first part of a file: guess EOL type</a>
<a name="ln1458">      if (fileformat == EOL_UNKNOWN) {</a>
<a name="ln1459">        // First try finding a NL, for Dos and Unix</a>
<a name="ln1460">        if (try_dos || try_unix) {</a>
<a name="ln1461">          // Reset the carriage return counter.</a>
<a name="ln1462">          if (try_mac) {</a>
<a name="ln1463">            try_mac = 1;</a>
<a name="ln1464">          }</a>
<a name="ln1465"> </a>
<a name="ln1466">          for (p = (uint8_t *)ptr; p &lt; (uint8_t *)ptr + size; p++) {</a>
<a name="ln1467">            if (*p == NL) {</a>
<a name="ln1468">              if (!try_unix</a>
<a name="ln1469">                  || (try_dos &amp;&amp; p &gt; (uint8_t *)ptr &amp;&amp; p[-1] == CAR)) {</a>
<a name="ln1470">                fileformat = EOL_DOS;</a>
<a name="ln1471">              } else {</a>
<a name="ln1472">                fileformat = EOL_UNIX;</a>
<a name="ln1473">              }</a>
<a name="ln1474">              break;</a>
<a name="ln1475">            } else if (*p == CAR &amp;&amp; try_mac) {</a>
<a name="ln1476">              try_mac++;</a>
<a name="ln1477">            }</a>
<a name="ln1478">          }</a>
<a name="ln1479"> </a>
<a name="ln1480">          // Don't give in to EOL_UNIX if EOL_MAC is more likely</a>
<a name="ln1481">          if (fileformat == EOL_UNIX &amp;&amp; try_mac) {</a>
<a name="ln1482">            // Need to reset the counters when retrying fenc.</a>
<a name="ln1483">            try_mac = 1;</a>
<a name="ln1484">            try_unix = 1;</a>
<a name="ln1485">            for (; p &gt;= (uint8_t *)ptr &amp;&amp; *p != CAR; p--) {}</a>
<a name="ln1486">            if (p &gt;= (uint8_t *)ptr) {</a>
<a name="ln1487">              for (p = (uint8_t *)ptr; p &lt; (uint8_t *)ptr + size; p++) {</a>
<a name="ln1488">                if (*p == NL) {</a>
<a name="ln1489">                  try_unix++;</a>
<a name="ln1490">                } else if (*p == CAR) {</a>
<a name="ln1491">                  try_mac++;</a>
<a name="ln1492">                }</a>
<a name="ln1493">              }</a>
<a name="ln1494">              if (try_mac &gt; try_unix) {</a>
<a name="ln1495">                fileformat = EOL_MAC;</a>
<a name="ln1496">              }</a>
<a name="ln1497">            }</a>
<a name="ln1498">          } else if (fileformat == EOL_UNKNOWN &amp;&amp; try_mac == 1) {</a>
<a name="ln1499">            // Looking for CR but found no end-of-line markers at all:</a>
<a name="ln1500">            // use the default format.</a>
<a name="ln1501">            fileformat = default_fileformat();</a>
<a name="ln1502">          }</a>
<a name="ln1503">        }</a>
<a name="ln1504"> </a>
<a name="ln1505">        // No NL found: may use Mac format</a>
<a name="ln1506">        if (fileformat == EOL_UNKNOWN &amp;&amp; try_mac) {</a>
<a name="ln1507">          fileformat = EOL_MAC;</a>
<a name="ln1508">        }</a>
<a name="ln1509"> </a>
<a name="ln1510">        // Still nothing found?  Use first format in 'ffs'</a>
<a name="ln1511">        if (fileformat == EOL_UNKNOWN) {</a>
<a name="ln1512">          fileformat = default_fileformat();</a>
<a name="ln1513">        }</a>
<a name="ln1514"> </a>
<a name="ln1515">        // May set 'p_ff' if editing a new file.</a>
<a name="ln1516">        if (set_options) {</a>
<a name="ln1517">          set_fileformat(fileformat, OPT_LOCAL);</a>
<a name="ln1518">        }</a>
<a name="ln1519">      }</a>
<a name="ln1520">    }</a>
<a name="ln1521"> </a>
<a name="ln1522">    // This loop is executed once for every character read.</a>
<a name="ln1523">    // Keep it fast!</a>
<a name="ln1524">    if (fileformat == EOL_MAC) {</a>
<a name="ln1525">      ptr--;</a>
<a name="ln1526">      while (++ptr, --size &gt;= 0) {</a>
<a name="ln1527">        // catch most common case first</a>
<a name="ln1528">        if ((c = *ptr) != NUL &amp;&amp; c != CAR &amp;&amp; c != NL) {</a>
<a name="ln1529">          continue;</a>
<a name="ln1530">        }</a>
<a name="ln1531">        if (c == NUL) {</a>
<a name="ln1532">          *ptr = NL;            // NULs are replaced by newlines!</a>
<a name="ln1533">        } else if (c == NL) {</a>
<a name="ln1534">          *ptr = CAR;           // NLs are replaced by CRs!</a>
<a name="ln1535">        } else {</a>
<a name="ln1536">          if (skip_count == 0) {</a>
<a name="ln1537">            *ptr = NUL;                     // end of line</a>
<a name="ln1538">            len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1539">            if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1540">              error = true;</a>
<a name="ln1541">              break;</a>
<a name="ln1542">            }</a>
<a name="ln1543">            if (read_undo_file) {</a>
<a name="ln1544">              sha256_update(&amp;sha_ctx, (char_u *)line_start, (size_t)len);</a>
<a name="ln1545">            }</a>
<a name="ln1546">            lnum++;</a>
<a name="ln1547">            if (--read_count == 0) {</a>
<a name="ln1548">              error = true;                     // break loop</a>
<a name="ln1549">              line_start = ptr;                 // nothing left to write</a>
<a name="ln1550">              break;</a>
<a name="ln1551">            }</a>
<a name="ln1552">          } else {</a>
<a name="ln1553">            skip_count--;</a>
<a name="ln1554">          }</a>
<a name="ln1555">          line_start = ptr + 1;</a>
<a name="ln1556">        }</a>
<a name="ln1557">      }</a>
<a name="ln1558">    } else {</a>
<a name="ln1559">      ptr--;</a>
<a name="ln1560">      while (++ptr, --size &gt;= 0) {</a>
<a name="ln1561">        if ((c = *ptr) != NUL &amp;&amp; c != NL) {        // catch most common case</a>
<a name="ln1562">          continue;</a>
<a name="ln1563">        }</a>
<a name="ln1564">        if (c == NUL) {</a>
<a name="ln1565">          *ptr = NL;            // NULs are replaced by newlines!</a>
<a name="ln1566">        } else {</a>
<a name="ln1567">          if (skip_count == 0) {</a>
<a name="ln1568">            *ptr = NUL;                         // end of line</a>
<a name="ln1569">            len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1570">            if (fileformat == EOL_DOS) {</a>
<a name="ln1571">              if (ptr &gt; line_start &amp;&amp; ptr[-1] == CAR) {</a>
<a name="ln1572">                // remove CR before NL</a>
<a name="ln1573">                ptr[-1] = NUL;</a>
<a name="ln1574">                len--;</a>
<a name="ln1575">              } else if (ff_error != EOL_DOS) {</a>
<a name="ln1576">                // Reading in Dos format, but no CR-LF found!</a>
<a name="ln1577">                // When 'fileformats' includes &quot;unix&quot;, delete all</a>
<a name="ln1578">                // the lines read so far and start all over again.</a>
<a name="ln1579">                // Otherwise give an error message later.</a>
<a name="ln1580">                if (try_unix</a>
<a name="ln1581">                    &amp;&amp; !read_stdin</a>
<a name="ln1582">                    &amp;&amp; (read_buffer</a>
<a name="ln1583">                        || vim_lseek(fd, (off_T)0L, SEEK_SET) == 0)) {</a>
<a name="ln1584">                  fileformat = EOL_UNIX;</a>
<a name="ln1585">                  if (set_options) {</a>
<a name="ln1586">                    set_fileformat(EOL_UNIX, OPT_LOCAL);</a>
<a name="ln1587">                  }</a>
<a name="ln1588">                  file_rewind = true;</a>
<a name="ln1589">                  keep_fileformat = true;</a>
<a name="ln1590">                  goto retry;</a>
<a name="ln1591">                }</a>
<a name="ln1592">                ff_error = EOL_DOS;</a>
<a name="ln1593">              }</a>
<a name="ln1594">            }</a>
<a name="ln1595">            if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1596">              error = true;</a>
<a name="ln1597">              break;</a>
<a name="ln1598">            }</a>
<a name="ln1599">            if (read_undo_file) {</a>
<a name="ln1600">              sha256_update(&amp;sha_ctx, (char_u *)line_start, (size_t)len);</a>
<a name="ln1601">            }</a>
<a name="ln1602">            lnum++;</a>
<a name="ln1603">            if (--read_count == 0) {</a>
<a name="ln1604">              error = true;                         // break loop</a>
<a name="ln1605">              line_start = ptr;                 // nothing left to write</a>
<a name="ln1606">              break;</a>
<a name="ln1607">            }</a>
<a name="ln1608">          } else {</a>
<a name="ln1609">            skip_count--;</a>
<a name="ln1610">          }</a>
<a name="ln1611">          line_start = ptr + 1;</a>
<a name="ln1612">        }</a>
<a name="ln1613">      }</a>
<a name="ln1614">    }</a>
<a name="ln1615">    linerest = (ptr - line_start);</a>
<a name="ln1616">    os_breakcheck();</a>
<a name="ln1617">  }</a>
<a name="ln1618"> </a>
<a name="ln1619">failed:</a>
<a name="ln1620">  // not an error, max. number of lines reached</a>
<a name="ln1621">  if (error &amp;&amp; read_count == 0) {</a>
<a name="ln1622">    error = false;</a>
<a name="ln1623">  }</a>
<a name="ln1624"> </a>
<a name="ln1625">  // If we get EOF in the middle of a line, note the fact and</a>
<a name="ln1626">  // complete the line ourselves.</a>
<a name="ln1627">  // In Dos format ignore a trailing CTRL-Z, unless 'binary' set.</a>
<a name="ln1628">  if (!error</a>
<a name="ln1629">      &amp;&amp; !got_int</a>
<a name="ln1630">      &amp;&amp; linerest != 0</a>
<a name="ln1631">      &amp;&amp; !(!curbuf-&gt;b_p_bin</a>
<a name="ln1632">           &amp;&amp; fileformat == EOL_DOS</a>
<a name="ln1633">           &amp;&amp; *line_start == Ctrl_Z</a>
<a name="ln1634">           &amp;&amp; ptr == line_start + 1)) {</a>
<a name="ln1635">    // remember for when writing</a>
<a name="ln1636">    if (set_options) {</a>
<a name="ln1637">      curbuf-&gt;b_p_eol = false;</a>
<a name="ln1638">    }</a>
<a name="ln1639">    *ptr = NUL;</a>
<a name="ln1640">    len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1641">    if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1642">      error = true;</a>
<a name="ln1643">    } else {</a>
<a name="ln1644">      if (read_undo_file) {</a>
<a name="ln1645">        sha256_update(&amp;sha_ctx, (char_u *)line_start, (size_t)len);</a>
<a name="ln1646">      }</a>
<a name="ln1647">      read_no_eol_lnum = ++lnum;</a>
<a name="ln1648">    }</a>
<a name="ln1649">  }</a>
<a name="ln1650"> </a>
<a name="ln1651">  if (set_options) {</a>
<a name="ln1652">    // Remember the current file format.</a>
<a name="ln1653">    save_file_ff(curbuf);</a>
<a name="ln1654">    // If editing a new file: set 'fenc' for the current buffer.</a>
<a name="ln1655">    // Also for &quot;:read ++edit file&quot;.</a>
<a name="ln1656">    set_string_option_direct(&quot;fenc&quot;, -1, fenc, OPT_FREE | OPT_LOCAL, 0);</a>
<a name="ln1657">  }</a>
<a name="ln1658">  if (fenc_alloced) {</a>
<a name="ln1659">    xfree(fenc);</a>
<a name="ln1660">  }</a>
<a name="ln1661">#ifdef HAVE_ICONV</a>
<a name="ln1662">  if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1663">    iconv_close(iconv_fd);</a>
<a name="ln1664">  }</a>
<a name="ln1665">#endif</a>
<a name="ln1666"> </a>
<a name="ln1667">  if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln1668">    close(fd);  // errors are ignored</a>
<a name="ln1669">  } else {</a>
<a name="ln1670">    (void)os_set_cloexec(fd);</a>
<a name="ln1671">  }</a>
<a name="ln1672">  xfree(buffer);</a>
<a name="ln1673"> </a>
<a name="ln1674">  if (read_stdin) {</a>
<a name="ln1675">    close(fd);</a>
<a name="ln1676">    if (stdin_fd &lt; 0) {</a>
<a name="ln1677">#ifndef MSWIN</a>
<a name="ln1678">      // On Unix, use stderr for stdin, makes shell commands work.</a>
<a name="ln1679">      vim_ignored = dup(2);</a>
<a name="ln1680">#else</a>
<a name="ln1681">      // On Windows, use the console input handle for stdin.</a>
<a name="ln1682">      HANDLE conin = CreateFile(&quot;CONIN$&quot;, GENERIC_READ | GENERIC_WRITE,</a>
<a name="ln1683">                                FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)NULL,</a>
<a name="ln1684">                                OPEN_EXISTING, 0, (HANDLE)NULL);</a>
<a name="ln1685">      vim_ignored = _open_osfhandle((intptr_t)conin, _O_RDONLY);</a>
<a name="ln1686">#endif</a>
<a name="ln1687">    }</a>
<a name="ln1688">  }</a>
<a name="ln1689"> </a>
<a name="ln1690">  if (tmpname != NULL) {</a>
<a name="ln1691">    os_remove(tmpname);  // delete converted file</a>
<a name="ln1692">    xfree(tmpname);</a>
<a name="ln1693">  }</a>
<a name="ln1694">  no_wait_return--;                     // may wait for return now</a>
<a name="ln1695"> </a>
<a name="ln1696">  // In recovery mode everything but autocommands is skipped.</a>
<a name="ln1697">  if (!recoverymode) {</a>
<a name="ln1698">    // need to delete the last line, which comes from the empty buffer</a>
<a name="ln1699">    if (newfile &amp;&amp; wasempty &amp;&amp; !(curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)) {</a>
<a name="ln1700">      ml_delete(curbuf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln1701">      linecnt--;</a>
<a name="ln1702">    }</a>
<a name="ln1703">    curbuf-&gt;deleted_bytes = 0;</a>
<a name="ln1704">    curbuf-&gt;deleted_bytes2 = 0;</a>
<a name="ln1705">    curbuf-&gt;deleted_codepoints = 0;</a>
<a name="ln1706">    curbuf-&gt;deleted_codeunits = 0;</a>
<a name="ln1707">    linecnt = curbuf-&gt;b_ml.ml_line_count - linecnt;</a>
<a name="ln1708">    if (filesize == 0) {</a>
<a name="ln1709">      linecnt = 0;</a>
<a name="ln1710">    }</a>
<a name="ln1711">    if (newfile || read_buffer) {</a>
<a name="ln1712">      redraw_curbuf_later(UPD_NOT_VALID);</a>
<a name="ln1713">      // After reading the text into the buffer the diff info needs to</a>
<a name="ln1714">      // be updated.</a>
<a name="ln1715">      diff_invalidate(curbuf);</a>
<a name="ln1716">      // All folds in the window are invalid now.  Mark them for update</a>
<a name="ln1717">      // before triggering autocommands.</a>
<a name="ln1718">      foldUpdateAll(curwin);</a>
<a name="ln1719">    } else if (linecnt) {               // appended at least one line</a>
<a name="ln1720">      appended_lines_mark(from, linecnt);</a>
<a name="ln1721">    }</a>
<a name="ln1722"> </a>
<a name="ln1723">    if (got_int) {</a>
<a name="ln1724">      if (!(flags &amp; READ_DUMMY)) {</a>
<a name="ln1725">        filemess(curbuf, sfname, _(e_interr), 0);</a>
<a name="ln1726">        if (newfile) {</a>
<a name="ln1727">          curbuf-&gt;b_p_ro = true;                // must use &quot;w!&quot; now</a>
<a name="ln1728">        }</a>
<a name="ln1729">      }</a>
<a name="ln1730">      msg_scroll = msg_save;</a>
<a name="ln1731">      check_marks_read();</a>
<a name="ln1732">      return OK;                // an interrupt isn't really an error</a>
<a name="ln1733">    }</a>
<a name="ln1734"> </a>
<a name="ln1735">    if (!filtering &amp;&amp; !(flags &amp; READ_DUMMY) &amp;&amp; !silent) {</a>
<a name="ln1736">      add_quoted_fname((char *)IObuff, IOSIZE, curbuf, (const char *)sfname);</a>
<a name="ln1737">      c = false;</a>
<a name="ln1738"> </a>
<a name="ln1739">#ifdef UNIX</a>
<a name="ln1740">      if (S_ISFIFO(perm)) {             // fifo</a>
<a name="ln1741">        STRCAT(IObuff, _(&quot;[fifo]&quot;));</a>
<a name="ln1742">        c = true;</a>
<a name="ln1743">      }</a>
<a name="ln1744">      if (S_ISSOCK(perm)) {            // or socket</a>
<a name="ln1745">        STRCAT(IObuff, _(&quot;[socket]&quot;));</a>
<a name="ln1746">        c = true;</a>
<a name="ln1747">      }</a>
<a name="ln1748"># ifdef OPEN_CHR_FILES</a>
<a name="ln1749">      if (S_ISCHR(perm)) {                          // or character special</a>
<a name="ln1750">        STRCAT(IObuff, _(&quot;[character special]&quot;));</a>
<a name="ln1751">        c = true;</a>
<a name="ln1752">      }</a>
<a name="ln1753"># endif</a>
<a name="ln1754">#endif</a>
<a name="ln1755">      if (curbuf-&gt;b_p_ro) {</a>
<a name="ln1756">        STRCAT(IObuff, shortmess(SHM_RO) ? _(&quot;[RO]&quot;) : _(&quot;[readonly]&quot;));</a>
<a name="ln1757">        c = true;</a>
<a name="ln1758">      }</a>
<a name="ln1759">      if (read_no_eol_lnum) {</a>
<a name="ln1760">        msg_add_eol();</a>
<a name="ln1761">        c = true;</a>
<a name="ln1762">      }</a>
<a name="ln1763">      if (ff_error == EOL_DOS) {</a>
<a name="ln1764">        STRCAT(IObuff, _(&quot;[CR missing]&quot;));</a>
<a name="ln1765">        c = true;</a>
<a name="ln1766">      }</a>
<a name="ln1767">      if (split) {</a>
<a name="ln1768">        STRCAT(IObuff, _(&quot;[long lines split]&quot;));</a>
<a name="ln1769">        c = true;</a>
<a name="ln1770">      }</a>
<a name="ln1771">      if (notconverted) {</a>
<a name="ln1772">        STRCAT(IObuff, _(&quot;[NOT converted]&quot;));</a>
<a name="ln1773">        c = true;</a>
<a name="ln1774">      } else if (converted) {</a>
<a name="ln1775">        STRCAT(IObuff, _(&quot;[converted]&quot;));</a>
<a name="ln1776">        c = true;</a>
<a name="ln1777">      }</a>
<a name="ln1778">      if (conv_error != 0) {</a>
<a name="ln1779">        snprintf(IObuff + strlen(IObuff), IOSIZE - strlen(IObuff),</a>
<a name="ln1780">                 _(&quot;[CONVERSION ERROR in line %&quot; PRId64 &quot;]&quot;), (int64_t)conv_error);</a>
<a name="ln1781">        c = true;</a>
<a name="ln1782">      } else if (illegal_byte &gt; 0) {</a>
<a name="ln1783">        snprintf(IObuff + strlen(IObuff), IOSIZE - strlen(IObuff),</a>
<a name="ln1784">                 _(&quot;[ILLEGAL BYTE in line %&quot; PRId64 &quot;]&quot;), (int64_t)illegal_byte);</a>
<a name="ln1785">        c = true;</a>
<a name="ln1786">      } else if (error) {</a>
<a name="ln1787">        STRCAT(IObuff, _(&quot;[READ ERRORS]&quot;));</a>
<a name="ln1788">        c = true;</a>
<a name="ln1789">      }</a>
<a name="ln1790">      if (msg_add_fileformat(fileformat)) {</a>
<a name="ln1791">        c = true;</a>
<a name="ln1792">      }</a>
<a name="ln1793"> </a>
<a name="ln1794">      msg_add_lines(c, (long)linecnt, filesize);</a>
<a name="ln1795"> </a>
<a name="ln1796">      XFREE_CLEAR(keep_msg);</a>
<a name="ln1797">      p = NULL;</a>
<a name="ln1798">      msg_scrolled_ign = true;</a>
<a name="ln1799"> </a>
<a name="ln1800">      if (!read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln1801">        p = (char_u *)msg_trunc_attr((char *)IObuff, false, 0);</a>
<a name="ln1802">      }</a>
<a name="ln1803"> </a>
<a name="ln1804">      if (read_stdin || read_buffer || restart_edit != 0</a>
<a name="ln1805">          || (msg_scrolled != 0 &amp;&amp; !need_wait_return)) {</a>
<a name="ln1806">        // Need to repeat the message after redrawing when:</a>
<a name="ln1807">        // - When reading from stdin (the screen will be cleared next).</a>
<a name="ln1808">        // - When restart_edit is set (otherwise there will be a delay before</a>
<a name="ln1809">        //   redrawing).</a>
<a name="ln1810">        // - When the screen was scrolled but there is no wait-return prompt.</a>
<a name="ln1811">        set_keep_msg((char *)p, 0);</a>
<a name="ln1812">      }</a>
<a name="ln1813">      msg_scrolled_ign = false;</a>
<a name="ln1814">    }</a>
<a name="ln1815"> </a>
<a name="ln1816">    // with errors writing the file requires &quot;:w!&quot;</a>
<a name="ln1817">    if (newfile &amp;&amp; (error</a>
<a name="ln1818">                    || conv_error != 0</a>
<a name="ln1819">                    || (illegal_byte &gt; 0 &amp;&amp; bad_char_behavior != BAD_KEEP))) {</a>
<a name="ln1820">      curbuf-&gt;b_p_ro = true;</a>
<a name="ln1821">    }</a>
<a name="ln1822"> </a>
<a name="ln1823">    u_clearline();          // cannot use &quot;U&quot; command after adding lines</a>
<a name="ln1824"> </a>
<a name="ln1825">    // In Ex mode: cursor at last new line.</a>
<a name="ln1826">    // Otherwise: cursor at first new line.</a>
<a name="ln1827">    if (exmode_active) {</a>
<a name="ln1828">      curwin-&gt;w_cursor.lnum = from + linecnt;</a>
<a name="ln1829">    } else {</a>
<a name="ln1830">      curwin-&gt;w_cursor.lnum = from + 1;</a>
<a name="ln1831">    }</a>
<a name="ln1832">    check_cursor_lnum();</a>
<a name="ln1833">    beginline(BL_WHITE | BL_FIX);           // on first non-blank</a>
<a name="ln1834"> </a>
<a name="ln1835">    if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln1836">      // Set '[ and '] marks to the newly read lines.</a>
<a name="ln1837">      curbuf-&gt;b_op_start.lnum = from + 1;</a>
<a name="ln1838">      curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln1839">      curbuf-&gt;b_op_end.lnum = from + linecnt;</a>
<a name="ln1840">      curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln1841">    }</a>
<a name="ln1842">  }</a>
<a name="ln1843">  msg_scroll = msg_save;</a>
<a name="ln1844"> </a>
<a name="ln1845">  // Get the marks before executing autocommands, so they can be used there.</a>
<a name="ln1846">  check_marks_read();</a>
<a name="ln1847"> </a>
<a name="ln1848">  // We remember if the last line of the read didn't have</a>
<a name="ln1849">  // an eol even when 'binary' is off, to support turning 'fixeol' off,</a>
<a name="ln1850">  // or writing the read again with 'binary' on.  The latter is required</a>
<a name="ln1851">  // for &quot;:autocmd FileReadPost *.gz set bin|'[,']!gunzip&quot; to work.</a>
<a name="ln1852">  curbuf-&gt;b_no_eol_lnum = read_no_eol_lnum;</a>
<a name="ln1853"> </a>
<a name="ln1854">  // When reloading a buffer put the cursor at the first line that is</a>
<a name="ln1855">  // different.</a>
<a name="ln1856">  if (flags &amp; READ_KEEP_UNDO) {</a>
<a name="ln1857">    u_find_first_changed();</a>
<a name="ln1858">  }</a>
<a name="ln1859"> </a>
<a name="ln1860">  // When opening a new file locate undo info and read it.</a>
<a name="ln1861">  if (read_undo_file) {</a>
<a name="ln1862">    char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln1863"> </a>
<a name="ln1864">    sha256_finish(&amp;sha_ctx, hash);</a>
<a name="ln1865">    u_read_undo(NULL, hash, (char_u *)fname);</a>
<a name="ln1866">  }</a>
<a name="ln1867"> </a>
<a name="ln1868">  if (!read_stdin &amp;&amp; !read_fifo &amp;&amp; (!read_buffer || sfname != NULL)) {</a>
<a name="ln1869">    int m = msg_scroll;</a>
<a name="ln1870">    int n = msg_scrolled;</a>
<a name="ln1871"> </a>
<a name="ln1872">    // Save the fileformat now, otherwise the buffer will be considered</a>
<a name="ln1873">    // modified if the format/encoding was automatically detected.</a>
<a name="ln1874">    if (set_options) {</a>
<a name="ln1875">      save_file_ff(curbuf);</a>
<a name="ln1876">    }</a>
<a name="ln1877"> </a>
<a name="ln1878">    // The output from the autocommands should not overwrite anything and</a>
<a name="ln1879">    // should not be overwritten: Set msg_scroll, restore its value if no</a>
<a name="ln1880">    // output was done.</a>
<a name="ln1881">    msg_scroll = true;</a>
<a name="ln1882">    if (filtering) {</a>
<a name="ln1883">      apply_autocmds_exarg(EVENT_FILTERREADPOST, NULL, sfname,</a>
<a name="ln1884">                           false, curbuf, eap);</a>
<a name="ln1885">    } else if (newfile || (read_buffer &amp;&amp; sfname != NULL)) {</a>
<a name="ln1886">      apply_autocmds_exarg(EVENT_BUFREADPOST, NULL, sfname,</a>
<a name="ln1887">                           false, curbuf, eap);</a>
<a name="ln1888">      if (!au_did_filetype &amp;&amp; *curbuf-&gt;b_p_ft != NUL) {</a>
<a name="ln1889">        // EVENT_FILETYPE was not triggered but the buffer already has a</a>
<a name="ln1890">        // filetype.  Trigger EVENT_FILETYPE using the existing filetype.</a>
<a name="ln1891">        apply_autocmds(EVENT_FILETYPE, curbuf-&gt;b_p_ft, curbuf-&gt;b_fname, true, curbuf);</a>
<a name="ln1892">      }</a>
<a name="ln1893">    } else {</a>
<a name="ln1894">      apply_autocmds_exarg(EVENT_FILEREADPOST, sfname, sfname,</a>
<a name="ln1895">                           false, NULL, eap);</a>
<a name="ln1896">    }</a>
<a name="ln1897">    if (msg_scrolled == n) {</a>
<a name="ln1898">      msg_scroll = m;</a>
<a name="ln1899">    }</a>
<a name="ln1900">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln1901">      return FAIL;</a>
<a name="ln1902">    }</a>
<a name="ln1903">  }</a>
<a name="ln1904"> </a>
<a name="ln1905">  if (recoverymode &amp;&amp; error) {</a>
<a name="ln1906">    return FAIL;</a>
<a name="ln1907">  }</a>
<a name="ln1908">  return OK;</a>
<a name="ln1909">}</a>
<a name="ln1910"> </a>
<a name="ln1911">#ifdef OPEN_CHR_FILES</a>
<a name="ln1912">/// Returns true if the file name argument is of the form &quot;/dev/fd/\d\+&quot;,</a>
<a name="ln1913">/// which is the name of files used for process substitution output by</a>
<a name="ln1914">/// some shells on some operating systems, e.g., bash on SunOS.</a>
<a name="ln1915">/// Do not accept &quot;/dev/fd/[012]&quot;, opening these may hang Vim.</a>
<a name="ln1916">///</a>
<a name="ln1917">/// @param fname file name to check</a>
<a name="ln1918">bool is_dev_fd_file(char *fname)</a>
<a name="ln1919">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1920">{</a>
<a name="ln1921">  return STRNCMP(fname, &quot;/dev/fd/&quot;, 8) == 0</a>
<a name="ln1922">         &amp;&amp; ascii_isdigit((uint8_t)fname[8])</a>
<a name="ln1923">         &amp;&amp; *skipdigits(fname + 9) == NUL</a>
<a name="ln1924">         &amp;&amp; (fname[9] != NUL</a>
<a name="ln1925">             || (fname[8] != '0' &amp;&amp; fname[8] != '1' &amp;&amp; fname[8] != '2'));</a>
<a name="ln1926">}</a>
<a name="ln1927">#endif</a>
<a name="ln1928"> </a>
<a name="ln1929">/// From the current line count and characters read after that, estimate the</a>
<a name="ln1930">/// line number where we are now.</a>
<a name="ln1931">/// Used for error messages that include a line number.</a>
<a name="ln1932">///</a>
<a name="ln1933">/// @param linecnt  line count before reading more bytes</a>
<a name="ln1934">/// @param p        start of more bytes read</a>
<a name="ln1935">/// @param endp     end of more bytes read</a>
<a name="ln1936">static linenr_T readfile_linenr(linenr_T linecnt, char_u *p, char_u *endp)</a>
<a name="ln1937">{</a>
<a name="ln1938">  char_u *s;</a>
<a name="ln1939">  linenr_T lnum;</a>
<a name="ln1940"> </a>
<a name="ln1941">  lnum = curbuf-&gt;b_ml.ml_line_count - linecnt + 1;</a>
<a name="ln1942">  for (s = p; s &lt; endp; s++) {</a>
<a name="ln1943">    if (*s == '\n') {</a>
<a name="ln1944">      lnum++;</a>
<a name="ln1945">    }</a>
<a name="ln1946">  }</a>
<a name="ln1947">  return lnum;</a>
<a name="ln1948">}</a>
<a name="ln1949"> </a>
<a name="ln1950">/// Fill &quot;*eap&quot; to force the 'fileencoding', 'fileformat' and 'binary' to be</a>
<a name="ln1951">/// equal to the buffer &quot;buf&quot;.  Used for calling readfile().</a>
<a name="ln1952">void prep_exarg(exarg_T *eap, const buf_T *buf)</a>
<a name="ln1953">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1954">{</a>
<a name="ln1955">  const size_t cmd_len = 15 + strlen(buf-&gt;b_p_fenc);</a>
<a name="ln1956">  eap-&gt;cmd = xmalloc(cmd_len);</a>
<a name="ln1957"> </a>
<a name="ln1958">  snprintf(eap-&gt;cmd, cmd_len, &quot;e ++enc=%s&quot;, buf-&gt;b_p_fenc);</a>
<a name="ln1959">  eap-&gt;force_enc = 8;</a>
<a name="ln1960">  eap-&gt;bad_char = buf-&gt;b_bad_char;</a>
<a name="ln1961">  eap-&gt;force_ff = (unsigned char)(*buf-&gt;b_p_ff);</a>
<a name="ln1962"> </a>
<a name="ln1963">  eap-&gt;force_bin = buf-&gt;b_p_bin ? FORCE_BIN : FORCE_NOBIN;</a>
<a name="ln1964">  eap-&gt;read_edit = false;</a>
<a name="ln1965">  eap-&gt;forceit = false;</a>
<a name="ln1966">}</a>
<a name="ln1967"> </a>
<a name="ln1968">/// Set default or forced 'fileformat' and 'binary'.</a>
<a name="ln1969">void set_file_options(int set_options, exarg_T *eap)</a>
<a name="ln1970">{</a>
<a name="ln1971">  // set default 'fileformat'</a>
<a name="ln1972">  if (set_options) {</a>
<a name="ln1973">    if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln1974">      set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);</a>
<a name="ln1975">    } else if (*p_ffs != NUL) {</a>
<a name="ln1976">      set_fileformat(default_fileformat(), OPT_LOCAL);</a>
<a name="ln1977">    }</a>
<a name="ln1978">  }</a>
<a name="ln1979"> </a>
<a name="ln1980">  // set or reset 'binary'</a>
<a name="ln1981">  if (eap != NULL &amp;&amp; eap-&gt;force_bin != 0) {</a>
<a name="ln1982">    int oldval = curbuf-&gt;b_p_bin;</a>
<a name="ln1983"> </a>
<a name="ln1984">    curbuf-&gt;b_p_bin = (eap-&gt;force_bin == FORCE_BIN);</a>
<a name="ln1985">    set_options_bin(oldval, curbuf-&gt;b_p_bin, OPT_LOCAL);</a>
<a name="ln1986">  }</a>
<a name="ln1987">}</a>
<a name="ln1988"> </a>
<a name="ln1989">/// Set forced 'fileencoding'.</a>
<a name="ln1990">void set_forced_fenc(exarg_T *eap)</a>
<a name="ln1991">{</a>
<a name="ln1992">  if (eap-&gt;force_enc != 0) {</a>
<a name="ln1993">    char *fenc = enc_canonize(eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln1994">    set_string_option_direct(&quot;fenc&quot;, -1, fenc, OPT_FREE|OPT_LOCAL, 0);</a>
<a name="ln1995">    xfree(fenc);</a>
<a name="ln1996">  }</a>
<a name="ln1997">}</a>
<a name="ln1998"> </a>
<a name="ln1999">/// Find next fileencoding to use from 'fileencodings'.</a>
<a name="ln2000">/// &quot;pp&quot; points to fenc_next.  It's advanced to the next item.</a>
<a name="ln2001">/// When there are no more items, an empty string is returned and *pp is set to</a>
<a name="ln2002">/// NULL.</a>
<a name="ln2003">/// When *pp is not set to NULL, the result is in allocated memory and &quot;alloced&quot;</a>
<a name="ln2004">/// is set to true.</a>
<a name="ln2005">static char *next_fenc(char **pp, bool *alloced)</a>
<a name="ln2006">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln2007">{</a>
<a name="ln2008">  char *p;</a>
<a name="ln2009">  char *r;</a>
<a name="ln2010"> </a>
<a name="ln2011">  *alloced = false;</a>
<a name="ln2012">  if (**pp == NUL) {</a>
<a name="ln2013">    *pp = NULL;</a>
<a name="ln2014">    return &quot;&quot;;</a>
<a name="ln2015">  }</a>
<a name="ln2016">  p = vim_strchr((*pp), ',');</a>
<a name="ln2017">  if (p == NULL) {</a>
<a name="ln2018">    r = enc_canonize(*pp);</a>
<a name="ln2019">    *pp += strlen(*pp);</a>
<a name="ln2020">  } else {</a>
<a name="ln2021">    r = xstrnsave(*pp, (size_t)(p - *pp));</a>
<a name="ln2022">    *pp = p + 1;</a>
<a name="ln2023">    p = enc_canonize(r);</a>
<a name="ln2024">    xfree(r);</a>
<a name="ln2025">    r = p;</a>
<a name="ln2026">  }</a>
<a name="ln2027">  *alloced = true;</a>
<a name="ln2028">  return r;</a>
<a name="ln2029">}</a>
<a name="ln2030"> </a>
<a name="ln2031">/// Convert a file with the 'charconvert' expression.</a>
<a name="ln2032">/// This closes the file which is to be read, converts it and opens the</a>
<a name="ln2033">/// resulting file for reading.</a>
<a name="ln2034">///</a>
<a name="ln2035">/// @param fname  name of input file</a>
<a name="ln2036">/// @param fenc   converted from</a>
<a name="ln2037">/// @param fdp    in/out: file descriptor of file</a>
<a name="ln2038">///</a>
<a name="ln2039">/// @return       name of the resulting converted file (the caller should delete it after reading it).</a>
<a name="ln2040">///               Returns NULL if the conversion failed (&quot;*fdp&quot; is not set) .</a>
<a name="ln2041">static char_u *readfile_charconvert(char_u *fname, char_u *fenc, int *fdp)</a>
<a name="ln2042">{</a>
<a name="ln2043">  char_u *tmpname;</a>
<a name="ln2044">  char *errmsg = NULL;</a>
<a name="ln2045"> </a>
<a name="ln2046">  tmpname = (char_u *)vim_tempname();</a>
<a name="ln2047">  if (tmpname == NULL) {</a>
<a name="ln2048">    errmsg = _(&quot;Can't find temp file for conversion&quot;);</a>
<a name="ln2049">  } else {</a>
<a name="ln2050">    close(*fdp);                // close the input file, ignore errors</a>
<a name="ln2051">    *fdp = -1;</a>
<a name="ln2052">    if (eval_charconvert((char *)fenc, &quot;utf-8&quot;,</a>
<a name="ln2053">                         (char *)fname, (char *)tmpname) == FAIL) {</a>
<a name="ln2054">      errmsg = _(&quot;Conversion with 'charconvert' failed&quot;);</a>
<a name="ln2055">    }</a>
<a name="ln2056">    if (errmsg == NULL &amp;&amp; (*fdp = os_open((char *)tmpname, O_RDONLY, 0)) &lt; 0) {</a>
<a name="ln2057">      errmsg = _(&quot;can't read output of 'charconvert'&quot;);</a>
<a name="ln2058">    }</a>
<a name="ln2059">  }</a>
<a name="ln2060"> </a>
<a name="ln2061">  if (errmsg != NULL) {</a>
<a name="ln2062">    // Don't use emsg(), it breaks mappings, the retry with</a>
<a name="ln2063">    // another type of conversion might still work.</a>
<a name="ln2064">    msg(errmsg);</a>
<a name="ln2065">    if (tmpname != NULL) {</a>
<a name="ln2066">      os_remove((char *)tmpname);  // delete converted file</a>
<a name="ln2067">      XFREE_CLEAR(tmpname);</a>
<a name="ln2068">    }</a>
<a name="ln2069">  }</a>
<a name="ln2070"> </a>
<a name="ln2071">  // If the input file is closed, open it (caller should check for error).</a>
<a name="ln2072">  if (*fdp &lt; 0) {</a>
<a name="ln2073">    *fdp = os_open((char *)fname, O_RDONLY, 0);</a>
<a name="ln2074">  }</a>
<a name="ln2075"> </a>
<a name="ln2076">  return tmpname;</a>
<a name="ln2077">}</a>
<a name="ln2078"> </a>
<a name="ln2079">/// Read marks for the current buffer from the ShaDa file, when we support</a>
<a name="ln2080">/// buffer marks and the buffer has a name.</a>
<a name="ln2081">static void check_marks_read(void)</a>
<a name="ln2082">{</a>
<a name="ln2083">  if (!curbuf-&gt;b_marks_read &amp;&amp; get_shada_parameter('\'') &gt; 0</a>
<a name="ln2084">      &amp;&amp; curbuf-&gt;b_ffname != NULL) {</a>
<a name="ln2085">    shada_read_marks();</a>
<a name="ln2086">  }</a>
<a name="ln2087"> </a>
<a name="ln2088">  // Always set b_marks_read; needed when 'shada' is changed to include</a>
<a name="ln2089">  // the ' parameter after opening a buffer.</a>
<a name="ln2090">  curbuf-&gt;b_marks_read = true;</a>
<a name="ln2091">}</a>
<a name="ln2092"> </a>
<a name="ln2093">char *new_file_message(void)</a>
<a name="ln2094">{</a>
<a name="ln2095">  return shortmess(SHM_NEW) ? _(&quot;[New]&quot;) : _(&quot;[New File]&quot;);</a>
<a name="ln2096">}</a>
<a name="ln2097"> </a>
<a name="ln2098">/// buf_write() - write to file &quot;fname&quot; lines &quot;start&quot; through &quot;end&quot;</a>
<a name="ln2099">///</a>
<a name="ln2100">/// We do our own buffering here because fwrite() is so slow.</a>
<a name="ln2101">///</a>
<a name="ln2102">/// If &quot;forceit&quot; is true, we don't care for errors when attempting backups.</a>
<a name="ln2103">/// In case of an error everything possible is done to restore the original</a>
<a name="ln2104">/// file.  But when &quot;forceit&quot; is true, we risk losing it.</a>
<a name="ln2105">///</a>
<a name="ln2106">/// When &quot;reset_changed&quot; is true and &quot;append&quot; == false and &quot;start&quot; == 1 and</a>
<a name="ln2107">/// &quot;end&quot; == curbuf-&gt;b_ml.ml_line_count, reset curbuf-&gt;b_changed.</a>
<a name="ln2108">///</a>
<a name="ln2109">/// This function must NOT use NameBuff (because it's called by autowrite()).</a>
<a name="ln2110">///</a>
<a name="ln2111">///</a>
<a name="ln2112">/// @param eap     for forced 'ff' and 'fenc', can be NULL!</a>
<a name="ln2113">/// @param append  append to the file</a>
<a name="ln2114">///</a>
<a name="ln2115">/// @return        FAIL for failure, OK otherwise</a>
<a name="ln2116">int buf_write(buf_T *buf, char *fname, char *sfname, linenr_T start, linenr_T end, exarg_T *eap,</a>
<a name="ln2117">              int append, int forceit, int reset_changed, int filtering)</a>
<a name="ln2118">{</a>
<a name="ln2119">  int fd;</a>
<a name="ln2120">  char *backup = NULL;</a>
<a name="ln2121">  int backup_copy = false;               // copy the original file?</a>
<a name="ln2122">  int dobackup;</a>
<a name="ln2123">  char *ffname;</a>
<a name="ln2124">  char *wfname = NULL;       // name of file to write to</a>
<a name="ln2125">  char *s;</a>
<a name="ln2126">  char *ptr;</a>
<a name="ln2127">  char c;</a>
<a name="ln2128">  int len;</a>
<a name="ln2129">  linenr_T lnum;</a>
<a name="ln2130">  long nchars;</a>
<a name="ln2131">#define SET_ERRMSG_NUM(num, msg) \</a>
<a name="ln2132">  errnum = (num), errmsg = (msg), errmsgarg = 0</a>
<a name="ln2133">#define SET_ERRMSG_ARG(msg, error) \</a>
<a name="ln2134">  errnum = NULL, errmsg = (msg), errmsgarg = error</a>
<a name="ln2135">#define SET_ERRMSG(msg) \</a>
<a name="ln2136">  errnum = NULL, errmsg = (msg), errmsgarg = 0</a>
<a name="ln2137">  const char *errnum = NULL;</a>
<a name="ln2138">  char *errmsg = NULL;</a>
<a name="ln2139">  int errmsgarg = 0;</a>
<a name="ln2140">  bool errmsg_allocated = false;</a>
<a name="ln2141">  char *buffer;</a>
<a name="ln2142">  char smallbuf[SMBUFSIZE];</a>
<a name="ln2143">  char *backup_ext;</a>
<a name="ln2144">  int bufsize;</a>
<a name="ln2145">  long perm;                                // file permissions</a>
<a name="ln2146">  int retval = OK;</a>
<a name="ln2147">  int newfile = false;                      // true if file doesn't exist yet</a>
<a name="ln2148">  int msg_save = msg_scroll;</a>
<a name="ln2149">  int overwriting;                          // true if writing over original</a>
<a name="ln2150">  int no_eol = false;                       // no end-of-line written</a>
<a name="ln2151">  int device = false;                       // writing to a device</a>
<a name="ln2152">  int prev_got_int = got_int;</a>
<a name="ln2153">  int checking_conversion;</a>
<a name="ln2154">  bool file_readonly = false;               // overwritten file is read-only</a>
<a name="ln2155">  static char *err_readonly =</a>
<a name="ln2156">    &quot;is read-only (cannot override: \&quot;W\&quot; in 'cpoptions')&quot;;</a>
<a name="ln2157">#if defined(UNIX)</a>
<a name="ln2158">  int made_writable = false;                // 'w' bit has been set</a>
<a name="ln2159">#endif</a>
<a name="ln2160">  // writing everything</a>
<a name="ln2161">  int whole = (start == 1 &amp;&amp; end == buf-&gt;b_ml.ml_line_count);</a>
<a name="ln2162">  linenr_T old_line_count = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2163">  int fileformat;</a>
<a name="ln2164">  int write_bin;</a>
<a name="ln2165">  struct bw_info write_info;            // info for buf_write_bytes()</a>
<a name="ln2166">  int converted = false;</a>
<a name="ln2167">  int notconverted = false;</a>
<a name="ln2168">  char *fenc;                // effective 'fileencoding'</a>
<a name="ln2169">  char *fenc_tofree = NULL;   // allocated &quot;fenc&quot;</a>
<a name="ln2170">#ifdef HAS_BW_FLAGS</a>
<a name="ln2171">  int wb_flags = 0;</a>
<a name="ln2172">#endif</a>
<a name="ln2173">#ifdef HAVE_ACL</a>
<a name="ln2174">  vim_acl_T acl = NULL;                 // ACL copied from original file to</a>
<a name="ln2175">                                        // backup or new file</a>
<a name="ln2176">#endif</a>
<a name="ln2177">  int write_undo_file = false;</a>
<a name="ln2178">  context_sha256_T sha_ctx;</a>
<a name="ln2179">  unsigned int bkc = get_bkc_value(buf);</a>
<a name="ln2180">  const pos_T orig_start = buf-&gt;b_op_start;</a>
<a name="ln2181">  const pos_T orig_end = buf-&gt;b_op_end;</a>
<a name="ln2182"> </a>
<a name="ln2183">  if (fname == NULL || *fname == NUL) {  // safety check</a>
<a name="ln2184">    return FAIL;</a>
<a name="ln2185">  }</a>
<a name="ln2186">  if (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2187">    // This can happen during startup when there is a stray &quot;w&quot; in the</a>
<a name="ln2188">    // vimrc file.</a>
<a name="ln2189">    emsg(_(e_emptybuf));</a>
<a name="ln2190">    return FAIL;</a>
<a name="ln2191">  }</a>
<a name="ln2192"> </a>
<a name="ln2193">  // Disallow writing from .exrc and .vimrc in current directory for</a>
<a name="ln2194">  // security reasons.</a>
<a name="ln2195">  if (check_secure()) {</a>
<a name="ln2196">    return FAIL;</a>
<a name="ln2197">  }</a>
<a name="ln2198"> </a>
<a name="ln2199">  // Avoid a crash for a long name.</a>
<a name="ln2200">  if (strlen(fname) &gt;= MAXPATHL) {</a>
<a name="ln2201">    emsg(_(e_longname));</a>
<a name="ln2202">    return FAIL;</a>
<a name="ln2203">  }</a>
<a name="ln2204"> </a>
<a name="ln2205">  // must init bw_conv_buf and bw_iconv_fd before jumping to &quot;fail&quot;</a>
<a name="ln2206">  write_info.bw_conv_buf = NULL;</a>
<a name="ln2207">  write_info.bw_conv_error = false;</a>
<a name="ln2208">  write_info.bw_conv_error_lnum = 0;</a>
<a name="ln2209">  write_info.bw_restlen = 0;</a>
<a name="ln2210">#ifdef HAVE_ICONV</a>
<a name="ln2211">  write_info.bw_iconv_fd = (iconv_t)-1;</a>
<a name="ln2212">#endif</a>
<a name="ln2213"> </a>
<a name="ln2214">  // After writing a file changedtick changes but we don't want to display</a>
<a name="ln2215">  // the line.</a>
<a name="ln2216">  ex_no_reprint = true;</a>
<a name="ln2217"> </a>
<a name="ln2218">  // If there is no file name yet, use the one for the written file.</a>
<a name="ln2219">  // BF_NOTEDITED is set to reflect this (in case the write fails).</a>
<a name="ln2220">  // Don't do this when the write is for a filter command.</a>
<a name="ln2221">  // Don't do this when appending.</a>
<a name="ln2222">  // Only do this when 'cpoptions' contains the 'F' flag.</a>
<a name="ln2223">  if (buf-&gt;b_ffname == NULL</a>
<a name="ln2224">      &amp;&amp; reset_changed</a>
<a name="ln2225">      &amp;&amp; whole</a>
<a name="ln2226">      &amp;&amp; buf == curbuf</a>
<a name="ln2227">      &amp;&amp; !bt_nofilename(buf)</a>
<a name="ln2228">      &amp;&amp; !filtering</a>
<a name="ln2229">      &amp;&amp; (!append || vim_strchr(p_cpo, CPO_FNAMEAPP) != NULL)</a>
<a name="ln2230">      &amp;&amp; vim_strchr(p_cpo, CPO_FNAMEW) != NULL) {</a>
<a name="ln2231">    if (set_rw_fname((char_u *)fname, (char_u *)sfname) == FAIL) {</a>
<a name="ln2232">      return FAIL;</a>
<a name="ln2233">    }</a>
<a name="ln2234">    buf = curbuf;           // just in case autocmds made &quot;buf&quot; invalid</a>
<a name="ln2235">  }</a>
<a name="ln2236"> </a>
<a name="ln2237">  if (sfname == NULL) {</a>
<a name="ln2238">    sfname = fname;</a>
<a name="ln2239">  }</a>
<a name="ln2240"> </a>
<a name="ln2241">  // For Unix: Use the short file name whenever possible.</a>
<a name="ln2242">  // Avoids problems with networks and when directory names are changed.</a>
<a name="ln2243">  // Don't do this for Windows, a &quot;cd&quot; in a sub-shell may have moved us to</a>
<a name="ln2244">  // another directory, which we don't detect.</a>
<a name="ln2245">  ffname = fname;                           // remember full fname</a>
<a name="ln2246">#ifdef UNIX</a>
<a name="ln2247">  fname = sfname;</a>
<a name="ln2248">#endif</a>
<a name="ln2249"> </a>
<a name="ln2250">  if (buf-&gt;b_ffname != NULL &amp;&amp; path_fnamecmp(ffname, buf-&gt;b_ffname) == 0) {</a>
<a name="ln2251">    overwriting = true;</a>
<a name="ln2252">  } else {</a>
<a name="ln2253">    overwriting = false;</a>
<a name="ln2254">  }</a>
<a name="ln2255"> </a>
<a name="ln2256">  no_wait_return++;                 // don't wait for return yet</a>
<a name="ln2257"> </a>
<a name="ln2258">  // Set '[ and '] marks to the lines to be written.</a>
<a name="ln2259">  buf-&gt;b_op_start.lnum = start;</a>
<a name="ln2260">  buf-&gt;b_op_start.col = 0;</a>
<a name="ln2261">  buf-&gt;b_op_end.lnum = end;</a>
<a name="ln2262">  buf-&gt;b_op_end.col = 0;</a>
<a name="ln2263"> </a>
<a name="ln2264">  {</a>
<a name="ln2265">    aco_save_T aco;</a>
<a name="ln2266">    int buf_ffname = false;</a>
<a name="ln2267">    int buf_sfname = false;</a>
<a name="ln2268">    int buf_fname_f = false;</a>
<a name="ln2269">    int buf_fname_s = false;</a>
<a name="ln2270">    int did_cmd = false;</a>
<a name="ln2271">    int nofile_err = false;</a>
<a name="ln2272">    int empty_memline = (buf-&gt;b_ml.ml_mfp == NULL);</a>
<a name="ln2273">    bufref_T bufref;</a>
<a name="ln2274"> </a>
<a name="ln2275">    // Apply PRE autocommands.</a>
<a name="ln2276">    // Set curbuf to the buffer to be written.</a>
<a name="ln2277">    // Careful: The autocommands may call buf_write() recursively!</a>
<a name="ln2278">    if (ffname == buf-&gt;b_ffname) {</a>
<a name="ln2279">      buf_ffname = true;</a>
<a name="ln2280">    }</a>
<a name="ln2281">    if (sfname == buf-&gt;b_sfname) {</a>
<a name="ln2282">      buf_sfname = true;</a>
<a name="ln2283">    }</a>
<a name="ln2284">    if (fname == buf-&gt;b_ffname) {</a>
<a name="ln2285">      buf_fname_f = true;</a>
<a name="ln2286">    }</a>
<a name="ln2287">    if (fname == buf-&gt;b_sfname) {</a>
<a name="ln2288">      buf_fname_s = true;</a>
<a name="ln2289">    }</a>
<a name="ln2290"> </a>
<a name="ln2291">    // Set curwin/curbuf to buf and save a few things.</a>
<a name="ln2292">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln2293">    set_bufref(&amp;bufref, buf);</a>
<a name="ln2294"> </a>
<a name="ln2295">    if (append) {</a>
<a name="ln2296">      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,</a>
<a name="ln2297">                                           sfname, sfname, false, curbuf, eap))) {</a>
<a name="ln2298">        if (overwriting &amp;&amp; bt_nofilename(curbuf)) {</a>
<a name="ln2299">          nofile_err = true;</a>
<a name="ln2300">        } else {</a>
<a name="ln2301">          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,</a>
<a name="ln2302">                               sfname, sfname, false, curbuf, eap);</a>
<a name="ln2303">        }</a>
<a name="ln2304">      }</a>
<a name="ln2305">    } else if (filtering) {</a>
<a name="ln2306">      apply_autocmds_exarg(EVENT_FILTERWRITEPRE,</a>
<a name="ln2307">                           NULL, sfname, false, curbuf, eap);</a>
<a name="ln2308">    } else if (reset_changed &amp;&amp; whole) {</a>
<a name="ln2309">      int was_changed = curbufIsChanged();</a>
<a name="ln2310"> </a>
<a name="ln2311">      did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,</a>
<a name="ln2312">                                     sfname, sfname, false, curbuf, eap);</a>
<a name="ln2313">      if (did_cmd) {</a>
<a name="ln2314">        if (was_changed &amp;&amp; !curbufIsChanged()) {</a>
<a name="ln2315">          // Written everything correctly and BufWriteCmd has reset</a>
<a name="ln2316">          // 'modified': Correct the undo information so that an</a>
<a name="ln2317">          // undo now sets 'modified'.</a>
<a name="ln2318">          u_unchanged(curbuf);</a>
<a name="ln2319">          u_update_save_nr(curbuf);</a>
<a name="ln2320">        }</a>
<a name="ln2321">      } else {</a>
<a name="ln2322">        if (overwriting &amp;&amp; bt_nofilename(curbuf)) {</a>
<a name="ln2323">          nofile_err = true;</a>
<a name="ln2324">        } else {</a>
<a name="ln2325">          apply_autocmds_exarg(EVENT_BUFWRITEPRE,</a>
<a name="ln2326">                               sfname, sfname, false, curbuf, eap);</a>
<a name="ln2327">        }</a>
<a name="ln2328">      }</a>
<a name="ln2329">    } else {</a>
<a name="ln2330">      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,</a>
<a name="ln2331">                                           sfname, sfname, false, curbuf, eap))) {</a>
<a name="ln2332">        if (overwriting &amp;&amp; bt_nofilename(curbuf)) {</a>
<a name="ln2333">          nofile_err = true;</a>
<a name="ln2334">        } else {</a>
<a name="ln2335">          apply_autocmds_exarg(EVENT_FILEWRITEPRE,</a>
<a name="ln2336">                               sfname, sfname, false, curbuf, eap);</a>
<a name="ln2337">        }</a>
<a name="ln2338">      }</a>
<a name="ln2339">    }</a>
<a name="ln2340"> </a>
<a name="ln2341">    // restore curwin/curbuf and a few other things</a>
<a name="ln2342">    aucmd_restbuf(&amp;aco);</a>
<a name="ln2343"> </a>
<a name="ln2344">    // In three situations we return here and don't write the file:</a>
<a name="ln2345">    // 1. the autocommands deleted or unloaded the buffer.</a>
<a name="ln2346">    // 2. The autocommands abort script processing.</a>
<a name="ln2347">    // 3. If one of the &quot;Cmd&quot; autocommands was executed.</a>
<a name="ln2348">    if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2349">      buf = NULL;</a>
<a name="ln2350">    }</a>
<a name="ln2351">    if (buf == NULL || (buf-&gt;b_ml.ml_mfp == NULL &amp;&amp; !empty_memline)</a>
<a name="ln2352">        || did_cmd || nofile_err</a>
<a name="ln2353">        || aborting()) {</a>
<a name="ln2354">      if (buf != NULL &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS)) {</a>
<a name="ln2355">        // restore the original '[ and '] positions</a>
<a name="ln2356">        buf-&gt;b_op_start = orig_start;</a>
<a name="ln2357">        buf-&gt;b_op_end = orig_end;</a>
<a name="ln2358">      }</a>
<a name="ln2359"> </a>
<a name="ln2360">      no_wait_return--;</a>
<a name="ln2361">      msg_scroll = msg_save;</a>
<a name="ln2362">      if (nofile_err) {</a>
<a name="ln2363">        semsg(_(e_no_matching_autocommands_for_buftype_str_buffer), curbuf-&gt;b_p_bt);</a>
<a name="ln2364">      }</a>
<a name="ln2365"> </a>
<a name="ln2366">      if (nofile_err</a>
<a name="ln2367">          || aborting()) {</a>
<a name="ln2368">        // An aborting error, interrupt or exception in the</a>
<a name="ln2369">        // autocommands.</a>
<a name="ln2370">        return FAIL;</a>
<a name="ln2371">      }</a>
<a name="ln2372">      if (did_cmd) {</a>
<a name="ln2373">        if (buf == NULL) {</a>
<a name="ln2374">          // The buffer was deleted.  We assume it was written</a>
<a name="ln2375">          // (can't retry anyway).</a>
<a name="ln2376">          return OK;</a>
<a name="ln2377">        }</a>
<a name="ln2378">        if (overwriting) {</a>
<a name="ln2379">          // Assume the buffer was written, update the timestamp.</a>
<a name="ln2380">          ml_timestamp(buf);</a>
<a name="ln2381">          if (append) {</a>
<a name="ln2382">            buf-&gt;b_flags &amp;= ~BF_NEW;</a>
<a name="ln2383">          } else {</a>
<a name="ln2384">            buf-&gt;b_flags &amp;= ~BF_WRITE_MASK;</a>
<a name="ln2385">          }</a>
<a name="ln2386">        }</a>
<a name="ln2387">        if (reset_changed &amp;&amp; buf-&gt;b_changed &amp;&amp; !append</a>
<a name="ln2388">            &amp;&amp; (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL)) {</a>
<a name="ln2389">          // Buffer still changed, the autocommands didn't work properly.</a>
<a name="ln2390">          return FAIL;</a>
<a name="ln2391">        }</a>
<a name="ln2392">        return OK;</a>
<a name="ln2393">      }</a>
<a name="ln2394">      if (!aborting()) {</a>
<a name="ln2395">        emsg(_(&quot;E203: Autocommands deleted or unloaded buffer to be written&quot;));</a>
<a name="ln2396">      }</a>
<a name="ln2397">      return FAIL;</a>
<a name="ln2398">    }</a>
<a name="ln2399"> </a>
<a name="ln2400">    // The autocommands may have changed the number of lines in the file.</a>
<a name="ln2401">    // When writing the whole file, adjust the end.</a>
<a name="ln2402">    // When writing part of the file, assume that the autocommands only</a>
<a name="ln2403">    // changed the number of lines that are to be written (tricky!).</a>
<a name="ln2404">    if (buf-&gt;b_ml.ml_line_count != old_line_count) {</a>
<a name="ln2405">      if (whole) {                                              // write all</a>
<a name="ln2406">        end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2407">      } else if (buf-&gt;b_ml.ml_line_count &gt; old_line_count) {           // more lines</a>
<a name="ln2408">        end += buf-&gt;b_ml.ml_line_count - old_line_count;</a>
<a name="ln2409">      } else {                                                    // less lines</a>
<a name="ln2410">        end -= old_line_count - buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2411">        if (end &lt; start) {</a>
<a name="ln2412">          no_wait_return--;</a>
<a name="ln2413">          msg_scroll = msg_save;</a>
<a name="ln2414">          emsg(_(&quot;E204: Autocommand changed number of lines in unexpected way&quot;));</a>
<a name="ln2415">          return FAIL;</a>
<a name="ln2416">        }</a>
<a name="ln2417">      }</a>
<a name="ln2418">    }</a>
<a name="ln2419"> </a>
<a name="ln2420">    // The autocommands may have changed the name of the buffer, which may</a>
<a name="ln2421">    // be kept in fname, ffname and sfname.</a>
<a name="ln2422">    if (buf_ffname) {</a>
<a name="ln2423">      ffname = buf-&gt;b_ffname;</a>
<a name="ln2424">    }</a>
<a name="ln2425">    if (buf_sfname) {</a>
<a name="ln2426">      sfname = buf-&gt;b_sfname;</a>
<a name="ln2427">    }</a>
<a name="ln2428">    if (buf_fname_f) {</a>
<a name="ln2429">      fname = buf-&gt;b_ffname;</a>
<a name="ln2430">    }</a>
<a name="ln2431">    if (buf_fname_s) {</a>
<a name="ln2432">      fname = buf-&gt;b_sfname;</a>
<a name="ln2433">    }</a>
<a name="ln2434">  }</a>
<a name="ln2435"> </a>
<a name="ln2436">  if (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) {</a>
<a name="ln2437">    // restore the original '[ and '] positions</a>
<a name="ln2438">    buf-&gt;b_op_start = orig_start;</a>
<a name="ln2439">    buf-&gt;b_op_end = orig_end;</a>
<a name="ln2440">  }</a>
<a name="ln2441"> </a>
<a name="ln2442">  if (shortmess(SHM_OVER) &amp;&amp; !exiting) {</a>
<a name="ln2443">    msg_scroll = false;             // overwrite previous file message</a>
<a name="ln2444">  } else {</a>
<a name="ln2445">    msg_scroll = true;              // don't overwrite previous file message</a>
<a name="ln2446">  }</a>
<a name="ln2447">  if (!filtering) {</a>
<a name="ln2448">    filemess(buf,</a>
<a name="ln2449">#ifndef UNIX</a>
<a name="ln2450">             (char_u *)sfname,</a>
<a name="ln2451">#else</a>
<a name="ln2452">             fname,</a>
<a name="ln2453">#endif</a>
<a name="ln2454">             &quot;&quot;, 0);               // show that we are busy</a>
<a name="ln2455">  }</a>
<a name="ln2456">  msg_scroll = false;               // always overwrite the file message now</a>
<a name="ln2457"> </a>
<a name="ln2458">  buffer = verbose_try_malloc(BUFSIZE);</a>
<a name="ln2459">  // can't allocate big buffer, use small one (to be able to write when out of</a>
<a name="ln2460">  // memory)</a>
<a name="ln2461">  if (buffer == NULL) {</a>
<a name="ln2462">    buffer = smallbuf;</a>
<a name="ln2463">    bufsize = SMBUFSIZE;</a>
<a name="ln2464">  } else {</a>
<a name="ln2465">    bufsize = BUFSIZE;</a>
<a name="ln2466">  }</a>
<a name="ln2467"> </a>
<a name="ln2468">  // Get information about original file (if there is one).</a>
<a name="ln2469">  FileInfo file_info_old;</a>
<a name="ln2470">#if defined(UNIX)</a>
<a name="ln2471">  perm = -1;</a>
<a name="ln2472">  if (!os_fileinfo(fname, &amp;file_info_old)) {</a>
<a name="ln2473">    newfile = true;</a>
<a name="ln2474">  } else {</a>
<a name="ln2475">    perm = (long)file_info_old.stat.st_mode;</a>
<a name="ln2476">    if (!S_ISREG(file_info_old.stat.st_mode)) {             // not a file</a>
<a name="ln2477">      if (S_ISDIR(file_info_old.stat.st_mode)) {</a>
<a name="ln2478">        SET_ERRMSG_NUM(&quot;E502&quot;, _(&quot;is a directory&quot;));</a>
<a name="ln2479">        goto fail;</a>
<a name="ln2480">      }</a>
<a name="ln2481">      if (os_nodetype(fname) != NODE_WRITABLE) {</a>
<a name="ln2482">        SET_ERRMSG_NUM(&quot;E503&quot;, _(&quot;is not a file or writable device&quot;));</a>
<a name="ln2483">        goto fail;</a>
<a name="ln2484">      }</a>
<a name="ln2485">      // It's a device of some kind (or a fifo) which we can write to</a>
<a name="ln2486">      // but for which we can't make a backup.</a>
<a name="ln2487">      device = true;</a>
<a name="ln2488">      newfile = true;</a>
<a name="ln2489">      perm = -1;</a>
<a name="ln2490">    }</a>
<a name="ln2491">  }</a>
<a name="ln2492">#else  // win32</a>
<a name="ln2493">  // Check for a writable device name.</a>
<a name="ln2494">  c = fname == NULL ? NODE_OTHER : os_nodetype((char *)fname);</a>
<a name="ln2495">  if (c == NODE_OTHER) {</a>
<a name="ln2496">    SET_ERRMSG_NUM(&quot;E503&quot;, _(&quot;is not a file or writable device&quot;));</a>
<a name="ln2497">    goto fail;</a>
<a name="ln2498">  }</a>
<a name="ln2499">  if (c == NODE_WRITABLE) {</a>
<a name="ln2500">    device = true;</a>
<a name="ln2501">    newfile = true;</a>
<a name="ln2502">    perm = -1;</a>
<a name="ln2503">  } else {</a>
<a name="ln2504">    perm = os_getperm((const char *)fname);</a>
<a name="ln2505">    if (perm &lt; 0) {</a>
<a name="ln2506">      newfile = true;</a>
<a name="ln2507">    } else if (os_isdir(fname)) {</a>
<a name="ln2508">      SET_ERRMSG_NUM(&quot;E502&quot;, _(&quot;is a directory&quot;));</a>
<a name="ln2509">      goto fail;</a>
<a name="ln2510">    }</a>
<a name="ln2511">    if (overwriting) {</a>
<a name="ln2512">      os_fileinfo((char *)fname, &amp;file_info_old);</a>
<a name="ln2513">    }</a>
<a name="ln2514">  }</a>
<a name="ln2515">#endif  // !UNIX</a>
<a name="ln2516"> </a>
<a name="ln2517">  if (!device &amp;&amp; !newfile) {</a>
<a name="ln2518">    // Check if the file is really writable (when renaming the file to</a>
<a name="ln2519">    // make a backup we won't discover it later).</a>
<a name="ln2520">    file_readonly = !os_file_is_writable(fname);</a>
<a name="ln2521"> </a>
<a name="ln2522">    if (!forceit &amp;&amp; file_readonly) {</a>
<a name="ln2523">      if (vim_strchr(p_cpo, CPO_FWRITE) != NULL) {</a>
<a name="ln2524">        SET_ERRMSG_NUM(&quot;E504&quot;, _(err_readonly));</a>
<a name="ln2525">      } else {</a>
<a name="ln2526">        SET_ERRMSG_NUM(&quot;E505&quot;, _(&quot;is read-only (add ! to override)&quot;));</a>
<a name="ln2527">      }</a>
<a name="ln2528">      goto fail;</a>
<a name="ln2529">    }</a>
<a name="ln2530"> </a>
<a name="ln2531">    // If 'forceit' is false, check if the timestamp hasn't changed since reading the file.</a>
<a name="ln2532">    if (overwriting &amp;&amp; !forceit) {</a>
<a name="ln2533">      retval = check_mtime(buf, &amp;file_info_old);</a>
<a name="ln2534">      if (retval == FAIL) {</a>
<a name="ln2535">        goto fail;</a>
<a name="ln2536">      }</a>
<a name="ln2537">    }</a>
<a name="ln2538">  }</a>
<a name="ln2539"> </a>
<a name="ln2540">#ifdef HAVE_ACL</a>
<a name="ln2541">  // For systems that support ACL: get the ACL from the original file.</a>
<a name="ln2542">  if (!newfile) {</a>
<a name="ln2543">    acl = mch_get_acl((char_u *)fname);</a>
<a name="ln2544">  }</a>
<a name="ln2545">#endif</a>
<a name="ln2546"> </a>
<a name="ln2547">  // If 'backupskip' is not empty, don't make a backup for some files.</a>
<a name="ln2548">  dobackup = (p_wb || p_bk || *p_pm != NUL);</a>
<a name="ln2549">  if (dobackup &amp;&amp; *p_bsk != NUL &amp;&amp; match_file_list(p_bsk, (char_u *)sfname, (char_u *)ffname)) {</a>
<a name="ln2550">    dobackup = false;</a>
<a name="ln2551">  }</a>
<a name="ln2552"> </a>
<a name="ln2553">  // Save the value of got_int and reset it.  We don't want a previous</a>
<a name="ln2554">  // interruption cancel writing, only hitting CTRL-C while writing should</a>
<a name="ln2555">  // abort it.</a>
<a name="ln2556">  prev_got_int = got_int;</a>
<a name="ln2557">  got_int = false;</a>
<a name="ln2558"> </a>
<a name="ln2559">  // Mark the buffer as 'being saved' to prevent changed buffer warnings</a>
<a name="ln2560">  buf-&gt;b_saving = true;</a>
<a name="ln2561"> </a>
<a name="ln2562">  // If we are not appending or filtering, the file exists, and the</a>
<a name="ln2563">  // 'writebackup', 'backup' or 'patchmode' option is set, need a backup.</a>
<a name="ln2564">  // When 'patchmode' is set also make a backup when appending.</a>
<a name="ln2565">  //</a>
<a name="ln2566">  // Do not make any backup, if 'writebackup' and 'backup' are both switched</a>
<a name="ln2567">  // off.  This helps when editing large files on almost-full disks.</a>
<a name="ln2568">  if (!(append &amp;&amp; *p_pm == NUL) &amp;&amp; !filtering &amp;&amp; perm &gt;= 0 &amp;&amp; dobackup) {</a>
<a name="ln2569">    FileInfo file_info;</a>
<a name="ln2570">    const bool no_prepend_dot = false;</a>
<a name="ln2571"> </a>
<a name="ln2572">    if ((bkc &amp; BKC_YES) || append) {       // &quot;yes&quot;</a>
<a name="ln2573">      backup_copy = true;</a>
<a name="ln2574">    } else if ((bkc &amp; BKC_AUTO)) {          // &quot;auto&quot;</a>
<a name="ln2575">      int i;</a>
<a name="ln2576"> </a>
<a name="ln2577">      // Don't rename the file when:</a>
<a name="ln2578">      // - it's a hard link</a>
<a name="ln2579">      // - it's a symbolic link</a>
<a name="ln2580">      // - we don't have write permission in the directory</a>
<a name="ln2581">      if (os_fileinfo_hardlinks(&amp;file_info_old) &gt; 1</a>
<a name="ln2582">          || !os_fileinfo_link(fname, &amp;file_info)</a>
<a name="ln2583">          || !os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old)) {</a>
<a name="ln2584">        backup_copy = true;</a>
<a name="ln2585">      } else {</a>
<a name="ln2586">        // Check if we can create a file and set the owner/group to</a>
<a name="ln2587">        // the ones from the original file.</a>
<a name="ln2588">        // First find a file name that doesn't exist yet (use some</a>
<a name="ln2589">        // arbitrary numbers).</a>
<a name="ln2590">        STRCPY(IObuff, fname);</a>
<a name="ln2591">        for (i = 4913;; i += 123) {</a>
<a name="ln2592">          char *tail = path_tail((char *)IObuff);</a>
<a name="ln2593">          size_t size = (size_t)(tail - IObuff);</a>
<a name="ln2594">          snprintf(tail, IOSIZE - size, &quot;%d&quot;, i);</a>
<a name="ln2595">          if (!os_fileinfo_link((char *)IObuff, &amp;file_info)) {</a>
<a name="ln2596">            break;</a>
<a name="ln2597">          }</a>
<a name="ln2598">        }</a>
<a name="ln2599">        fd = os_open((char *)IObuff,</a>
<a name="ln2600">                     O_CREAT|O_WRONLY|O_EXCL|O_NOFOLLOW, (int)perm);</a>
<a name="ln2601">        if (fd &lt; 0) {           // can't write in directory</a>
<a name="ln2602">          backup_copy = true;</a>
<a name="ln2603">        } else {</a>
<a name="ln2604">#ifdef UNIX</a>
<a name="ln2605">          os_fchown(fd, (uv_uid_t)file_info_old.stat.st_uid, (uv_gid_t)file_info_old.stat.st_gid);</a>
<a name="ln2606">          if (!os_fileinfo((char *)IObuff, &amp;file_info)</a>
<a name="ln2607">              || file_info.stat.st_uid != file_info_old.stat.st_uid</a>
<a name="ln2608">              || file_info.stat.st_gid != file_info_old.stat.st_gid</a>
<a name="ln2609">              || (long)file_info.stat.st_mode != perm) {</a>
<a name="ln2610">            backup_copy = true;</a>
<a name="ln2611">          }</a>
<a name="ln2612">#endif</a>
<a name="ln2613">          // Close the file before removing it, on MS-Windows we</a>
<a name="ln2614">          // can't delete an open file.</a>
<a name="ln2615">          close(fd);</a>
<a name="ln2616">          os_remove((char *)IObuff);</a>
<a name="ln2617">        }</a>
<a name="ln2618">      }</a>
<a name="ln2619">    }</a>
<a name="ln2620"> </a>
<a name="ln2621">    // Break symlinks and/or hardlinks if we've been asked to.</a>
<a name="ln2622">    if ((bkc &amp; BKC_BREAKSYMLINK) || (bkc &amp; BKC_BREAKHARDLINK)) {</a>
<a name="ln2623">#ifdef UNIX</a>
<a name="ln2624">      bool file_info_link_ok = os_fileinfo_link(fname, &amp;file_info);</a>
<a name="ln2625"> </a>
<a name="ln2626">      // Symlinks.</a>
<a name="ln2627">      if ((bkc &amp; BKC_BREAKSYMLINK)</a>
<a name="ln2628">          &amp;&amp; file_info_link_ok</a>
<a name="ln2629">          &amp;&amp; !os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old)) {</a>
<a name="ln2630">        backup_copy = false;</a>
<a name="ln2631">      }</a>
<a name="ln2632"> </a>
<a name="ln2633">      // Hardlinks.</a>
<a name="ln2634">      if ((bkc &amp; BKC_BREAKHARDLINK)</a>
<a name="ln2635">          &amp;&amp; os_fileinfo_hardlinks(&amp;file_info_old) &gt; 1</a>
<a name="ln2636">          &amp;&amp; (!file_info_link_ok</a>
<a name="ln2637">              || os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old))) {</a>
<a name="ln2638">        backup_copy = false;</a>
<a name="ln2639">      }</a>
<a name="ln2640">#endif</a>
<a name="ln2641">    }</a>
<a name="ln2642"> </a>
<a name="ln2643">    // make sure we have a valid backup extension to use</a>
<a name="ln2644">    if (*p_bex == NUL) {</a>
<a name="ln2645">      backup_ext = &quot;.bak&quot;;</a>
<a name="ln2646">    } else {</a>
<a name="ln2647">      backup_ext = p_bex;</a>
<a name="ln2648">    }</a>
<a name="ln2649"> </a>
<a name="ln2650">    if (backup_copy) {</a>
<a name="ln2651">      char *wp;</a>
<a name="ln2652">      int some_error = false;</a>
<a name="ln2653">      char *dirp;</a>
<a name="ln2654">      char *rootname;</a>
<a name="ln2655">      char *p;</a>
<a name="ln2656"> </a>
<a name="ln2657">      // Try to make the backup in each directory in the 'bdir' option.</a>
<a name="ln2658">      //</a>
<a name="ln2659">      // Unix semantics has it, that we may have a writable file,</a>
<a name="ln2660">      // that cannot be recreated with a simple open(..., O_CREAT, ) e.g:</a>
<a name="ln2661">      //  - the directory is not writable,</a>
<a name="ln2662">      //  - the file may be a symbolic link,</a>
<a name="ln2663">      //  - the file may belong to another user/group, etc.</a>
<a name="ln2664">      //</a>
<a name="ln2665">      // For these reasons, the existing writable file must be truncated</a>
<a name="ln2666">      // and reused. Creation of a backup COPY will be attempted.</a>
<a name="ln2667">      dirp = p_bdir;</a>
<a name="ln2668">      while (*dirp) {</a>
<a name="ln2669">        // Isolate one directory name, using an entry in 'bdir'.</a>
<a name="ln2670">        size_t dir_len = copy_option_part(&amp;dirp, (char *)IObuff, IOSIZE, &quot;,&quot;);</a>
<a name="ln2671">        p = (char *)IObuff + dir_len;</a>
<a name="ln2672">        bool trailing_pathseps = after_pathsep((char *)IObuff, p) &amp;&amp; p[-1] == p[-2];</a>
<a name="ln2673">        if (trailing_pathseps) {</a>
<a name="ln2674">          IObuff[dir_len - 2] = NUL;</a>
<a name="ln2675">        }</a>
<a name="ln2676">        if (*dirp == NUL &amp;&amp; !os_isdir((char *)IObuff)) {</a>
<a name="ln2677">          int ret;</a>
<a name="ln2678">          char *failed_dir;</a>
<a name="ln2679">          if ((ret = os_mkdir_recurse((char *)IObuff, 0755, &amp;failed_dir)) != 0) {</a>
<a name="ln2680">            semsg(_(&quot;E303: Unable to create directory \&quot;%s\&quot; for backup file: %s&quot;),</a>
<a name="ln2681">                  failed_dir, os_strerror(ret));</a>
<a name="ln2682">            xfree(failed_dir);</a>
<a name="ln2683">          }</a>
<a name="ln2684">        }</a>
<a name="ln2685">        if (trailing_pathseps) {</a>
<a name="ln2686">          // Ends with '//', Use Full path</a>
<a name="ln2687">          if ((p = make_percent_swname((char *)IObuff, fname))</a>
<a name="ln2688">              != NULL) {</a>
<a name="ln2689">            backup = modname(p, backup_ext, no_prepend_dot);</a>
<a name="ln2690">            xfree(p);</a>
<a name="ln2691">          }</a>
<a name="ln2692">        }</a>
<a name="ln2693"> </a>
<a name="ln2694">        rootname = get_file_in_dir(fname, (char *)IObuff);</a>
<a name="ln2695">        if (rootname == NULL) {</a>
<a name="ln2696">          some_error = true;                // out of memory</a>
<a name="ln2697">          goto nobackup;</a>
<a name="ln2698">        }</a>
<a name="ln2699"> </a>
<a name="ln2700">        FileInfo file_info_new;</a>
<a name="ln2701">        {</a>
<a name="ln2702">          //</a>
<a name="ln2703">          // Make the backup file name.</a>
<a name="ln2704">          //</a>
<a name="ln2705">          if (backup == NULL) {</a>
<a name="ln2706">            backup = modname(rootname, backup_ext, no_prepend_dot);</a>
<a name="ln2707">          }</a>
<a name="ln2708"> </a>
<a name="ln2709">          if (backup == NULL) {</a>
<a name="ln2710">            xfree(rootname);</a>
<a name="ln2711">            some_error = true;                          // out of memory</a>
<a name="ln2712">            goto nobackup;</a>
<a name="ln2713">          }</a>
<a name="ln2714"> </a>
<a name="ln2715">          // Check if backup file already exists.</a>
<a name="ln2716">          if (os_fileinfo(backup, &amp;file_info_new)) {</a>
<a name="ln2717">            if (os_fileinfo_id_equal(&amp;file_info_new, &amp;file_info_old)) {</a>
<a name="ln2718">              //</a>
<a name="ln2719">              // Backup file is same as original file.</a>
<a name="ln2720">              // May happen when modname() gave the same file back (e.g. silly</a>
<a name="ln2721">              // link). If we don't check here, we either ruin the file when</a>
<a name="ln2722">              // copying or erase it after writing.</a>
<a name="ln2723">              //</a>
<a name="ln2724">              XFREE_CLEAR(backup);              // no backup file to delete</a>
<a name="ln2725">            } else if (!p_bk) {</a>
<a name="ln2726">              // We are not going to keep the backup file, so don't</a>
<a name="ln2727">              // delete an existing one, and try to use another name instead.</a>
<a name="ln2728">              // Change one character, just before the extension.</a>
<a name="ln2729">              //</a>
<a name="ln2730">              wp = backup + strlen(backup) - 1 - strlen(backup_ext);</a>
<a name="ln2731">              if (wp &lt; backup) {                // empty file name ???</a>
<a name="ln2732">                wp = backup;</a>
<a name="ln2733">              }</a>
<a name="ln2734">              *wp = 'z';</a>
<a name="ln2735">              while (*wp &gt; 'a' &amp;&amp; os_fileinfo(backup, &amp;file_info_new)) {</a>
<a name="ln2736">                (*wp)--;</a>
<a name="ln2737">              }</a>
<a name="ln2738">              // They all exist??? Must be something wrong.</a>
<a name="ln2739">              if (*wp == 'a') {</a>
<a name="ln2740">                XFREE_CLEAR(backup);</a>
<a name="ln2741">              }</a>
<a name="ln2742">            }</a>
<a name="ln2743">          }</a>
<a name="ln2744">        }</a>
<a name="ln2745">        xfree(rootname);</a>
<a name="ln2746"> </a>
<a name="ln2747">        // Try to create the backup file</a>
<a name="ln2748">        if (backup != NULL) {</a>
<a name="ln2749">          // remove old backup, if present</a>
<a name="ln2750">          os_remove(backup);</a>
<a name="ln2751"> </a>
<a name="ln2752">          // set file protection same as original file, but</a>
<a name="ln2753">          // strip s-bit.</a>
<a name="ln2754">          (void)os_setperm((const char *)backup, perm &amp; 0777);</a>
<a name="ln2755"> </a>
<a name="ln2756">#ifdef UNIX</a>
<a name="ln2757">          //</a>
<a name="ln2758">          // Try to set the group of the backup same as the original file. If</a>
<a name="ln2759">          // this fails, set the protection bits for the group same as the</a>
<a name="ln2760">          // protection bits for others.</a>
<a name="ln2761">          //</a>
<a name="ln2762">          if (file_info_new.stat.st_gid != file_info_old.stat.st_gid</a>
<a name="ln2763">              &amp;&amp; os_chown(backup, (uv_uid_t)-1, (uv_gid_t)file_info_old.stat.st_gid) != 0) {</a>
<a name="ln2764">            os_setperm((const char *)backup,</a>
<a name="ln2765">                       ((int)perm &amp; 0707) | (((int)perm &amp; 07) &lt;&lt; 3));</a>
<a name="ln2766">          }</a>
<a name="ln2767">#endif</a>
<a name="ln2768"> </a>
<a name="ln2769">          // copy the file</a>
<a name="ln2770">          if (os_copy(fname, backup, UV_FS_COPYFILE_FICLONE)</a>
<a name="ln2771">              != 0) {</a>
<a name="ln2772">            SET_ERRMSG(_(&quot;E506: Can't write to backup file &quot;</a>
<a name="ln2773">                         &quot;(add ! to override)&quot;));</a>
<a name="ln2774">          }</a>
<a name="ln2775"> </a>
<a name="ln2776">#ifdef UNIX</a>
<a name="ln2777">          os_file_settime(backup,</a>
<a name="ln2778">                          (double)file_info_old.stat.st_atim.tv_sec,</a>
<a name="ln2779">                          (double)file_info_old.stat.st_mtim.tv_sec);</a>
<a name="ln2780">#endif</a>
<a name="ln2781">#ifdef HAVE_ACL</a>
<a name="ln2782">          mch_set_acl((char_u *)backup, acl);</a>
<a name="ln2783">#endif</a>
<a name="ln2784">          break;</a>
<a name="ln2785">        }</a>
<a name="ln2786">      }</a>
<a name="ln2787"> </a>
<a name="ln2788">nobackup:</a>
<a name="ln2789">      if (backup == NULL &amp;&amp; errmsg == NULL) {</a>
<a name="ln2790">        SET_ERRMSG(_(&quot;E509: Cannot create backup file (add ! to override)&quot;));</a>
<a name="ln2791">      }</a>
<a name="ln2792">      // Ignore errors when forceit is true.</a>
<a name="ln2793">      if ((some_error || errmsg != NULL) &amp;&amp; !forceit) {</a>
<a name="ln2794">        retval = FAIL;</a>
<a name="ln2795">        goto fail;</a>
<a name="ln2796">      }</a>
<a name="ln2797">      SET_ERRMSG(NULL);</a>
<a name="ln2798">    } else {</a>
<a name="ln2799">      char *dirp;</a>
<a name="ln2800">      char *p;</a>
<a name="ln2801">      char *rootname;</a>
<a name="ln2802"> </a>
<a name="ln2803">      // Make a backup by renaming the original file.</a>
<a name="ln2804"> </a>
<a name="ln2805">      // If 'cpoptions' includes the &quot;W&quot; flag, we don't want to</a>
<a name="ln2806">      // overwrite a read-only file.  But rename may be possible</a>
<a name="ln2807">      // anyway, thus we need an extra check here.</a>
<a name="ln2808">      if (file_readonly &amp;&amp; vim_strchr(p_cpo, CPO_FWRITE) != NULL) {</a>
<a name="ln2809">        SET_ERRMSG_NUM(&quot;E504&quot;, _(err_readonly));</a>
<a name="ln2810">        goto fail;</a>
<a name="ln2811">      }</a>
<a name="ln2812"> </a>
<a name="ln2813">      // Form the backup file name - change path/fo.o.h to</a>
<a name="ln2814">      // path/fo.o.h.bak Try all directories in 'backupdir', first one</a>
<a name="ln2815">      // that works is used.</a>
<a name="ln2816">      dirp = p_bdir;</a>
<a name="ln2817">      while (*dirp) {</a>
<a name="ln2818">        // Isolate one directory name and make the backup file name.</a>
<a name="ln2819">        size_t dir_len = copy_option_part(&amp;dirp, (char *)IObuff, IOSIZE, &quot;,&quot;);</a>
<a name="ln2820">        p = (char *)IObuff + dir_len;</a>
<a name="ln2821">        bool trailing_pathseps = after_pathsep((char *)IObuff, p) &amp;&amp; p[-1] == p[-2];</a>
<a name="ln2822">        if (trailing_pathseps) {</a>
<a name="ln2823">          IObuff[dir_len - 2] = NUL;</a>
<a name="ln2824">        }</a>
<a name="ln2825">        if (*dirp == NUL &amp;&amp; !os_isdir((char *)IObuff)) {</a>
<a name="ln2826">          int ret;</a>
<a name="ln2827">          char *failed_dir;</a>
<a name="ln2828">          if ((ret = os_mkdir_recurse((char *)IObuff, 0755, &amp;failed_dir)) != 0) {</a>
<a name="ln2829">            semsg(_(&quot;E303: Unable to create directory \&quot;%s\&quot; for backup file: %s&quot;),</a>
<a name="ln2830">                  failed_dir, os_strerror(ret));</a>
<a name="ln2831">            xfree(failed_dir);</a>
<a name="ln2832">          }</a>
<a name="ln2833">        }</a>
<a name="ln2834">        if (trailing_pathseps) {</a>
<a name="ln2835">          // path ends with '//', use full path</a>
<a name="ln2836">          if ((p = make_percent_swname((char *)IObuff, fname))</a>
<a name="ln2837">              != NULL) {</a>
<a name="ln2838">            backup = modname(p, backup_ext, no_prepend_dot);</a>
<a name="ln2839">            xfree(p);</a>
<a name="ln2840">          }</a>
<a name="ln2841">        }</a>
<a name="ln2842"> </a>
<a name="ln2843">        if (backup == NULL) {</a>
<a name="ln2844">          rootname = get_file_in_dir(fname, (char *)IObuff);</a>
<a name="ln2845">          if (rootname == NULL) {</a>
<a name="ln2846">            backup = NULL;</a>
<a name="ln2847">          } else {</a>
<a name="ln2848">            backup = modname(rootname, backup_ext, no_prepend_dot);</a>
<a name="ln2849">            xfree(rootname);</a>
<a name="ln2850">          }</a>
<a name="ln2851">        }</a>
<a name="ln2852"> </a>
<a name="ln2853">        if (backup != NULL) {</a>
<a name="ln2854">          // If we are not going to keep the backup file, don't</a>
<a name="ln2855">          // delete an existing one, try to use another name.</a>
<a name="ln2856">          // Change one character, just before the extension.</a>
<a name="ln2857">          if (!p_bk &amp;&amp; os_path_exists(backup)) {</a>
<a name="ln2858">            p = backup + strlen(backup) - 1 - strlen(backup_ext);</a>
<a name="ln2859">            if (p &lt; backup) {           // empty file name ???</a>
<a name="ln2860">              p = backup;</a>
<a name="ln2861">            }</a>
<a name="ln2862">            *p = 'z';</a>
<a name="ln2863">            while (*p &gt; 'a' &amp;&amp; os_path_exists(backup)) {</a>
<a name="ln2864">              (*p)--;</a>
<a name="ln2865">            }</a>
<a name="ln2866">            // They all exist??? Must be something wrong!</a>
<a name="ln2867">            if (*p == 'a') {</a>
<a name="ln2868">              XFREE_CLEAR(backup);</a>
<a name="ln2869">            }</a>
<a name="ln2870">          }</a>
<a name="ln2871">        }</a>
<a name="ln2872">        if (backup != NULL) {</a>
<a name="ln2873">          // Delete any existing backup and move the current version</a>
<a name="ln2874">          // to the backup. For safety, we don't remove the backup</a>
<a name="ln2875">          // until the write has finished successfully. And if the</a>
<a name="ln2876">          // 'backup' option is set, leave it around.</a>
<a name="ln2877"> </a>
<a name="ln2878">          // If the renaming of the original file to the backup file</a>
<a name="ln2879">          // works, quit here.</a>
<a name="ln2880">          ///</a>
<a name="ln2881">          if (vim_rename(fname, backup) == 0) {</a>
<a name="ln2882">            break;</a>
<a name="ln2883">          }</a>
<a name="ln2884"> </a>
<a name="ln2885">          XFREE_CLEAR(backup);             // don't do the rename below</a>
<a name="ln2886">        }</a>
<a name="ln2887">      }</a>
<a name="ln2888">      if (backup == NULL &amp;&amp; !forceit) {</a>
<a name="ln2889">        SET_ERRMSG(_(&quot;E510: Can't make backup file (add ! to override)&quot;));</a>
<a name="ln2890">        goto fail;</a>
<a name="ln2891">      }</a>
<a name="ln2892">    }</a>
<a name="ln2893">  }</a>
<a name="ln2894"> </a>
<a name="ln2895">#if defined(UNIX)</a>
<a name="ln2896">  // When using &quot;:w!&quot; and the file was read-only: make it writable</a>
<a name="ln2897">  if (forceit &amp;&amp; perm &gt;= 0 &amp;&amp; !(perm &amp; 0200)</a>
<a name="ln2898">      &amp;&amp; file_info_old.stat.st_uid == getuid()</a>
<a name="ln2899">      &amp;&amp; vim_strchr(p_cpo, CPO_FWRITE) == NULL) {</a>
<a name="ln2900">    perm |= 0200;</a>
<a name="ln2901">    (void)os_setperm((const char *)fname, (int)perm);</a>
<a name="ln2902">    made_writable = true;</a>
<a name="ln2903">  }</a>
<a name="ln2904">#endif</a>
<a name="ln2905"> </a>
<a name="ln2906">  // When using &quot;:w!&quot; and writing to the current file, 'readonly' makes no</a>
<a name="ln2907">  // sense, reset it, unless 'Z' appears in 'cpoptions'.</a>
<a name="ln2908">  if (forceit &amp;&amp; overwriting &amp;&amp; vim_strchr(p_cpo, CPO_KEEPRO) == NULL) {</a>
<a name="ln2909">    buf-&gt;b_p_ro = false;</a>
<a name="ln2910">    need_maketitle = true;          // set window title later</a>
<a name="ln2911">    status_redraw_all();            // redraw status lines later</a>
<a name="ln2912">  }</a>
<a name="ln2913"> </a>
<a name="ln2914">  if (end &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2915">    end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2916">  }</a>
<a name="ln2917">  if (buf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln2918">    start = end + 1;</a>
<a name="ln2919">  }</a>
<a name="ln2920"> </a>
<a name="ln2921">  // If the original file is being overwritten, there is a small chance that</a>
<a name="ln2922">  // we crash in the middle of writing. Therefore the file is preserved now.</a>
<a name="ln2923">  // This makes all block numbers positive so that recovery does not need</a>
<a name="ln2924">  // the original file.</a>
<a name="ln2925">  // Don't do this if there is a backup file and we are exiting.</a>
<a name="ln2926">  if (reset_changed &amp;&amp; !newfile &amp;&amp; overwriting</a>
<a name="ln2927">      &amp;&amp; !(exiting &amp;&amp; backup != NULL)) {</a>
<a name="ln2928">    ml_preserve(buf, false, !!p_fs);</a>
<a name="ln2929">    if (got_int) {</a>
<a name="ln2930">      SET_ERRMSG(_(e_interr));</a>
<a name="ln2931">      goto restore_backup;</a>
<a name="ln2932">    }</a>
<a name="ln2933">  }</a>
<a name="ln2934"> </a>
<a name="ln2935">  // Default: write the file directly.  May write to a temp file for</a>
<a name="ln2936">  // multi-byte conversion.</a>
<a name="ln2937">  wfname = fname;</a>
<a name="ln2938"> </a>
<a name="ln2939">  // Check for forced 'fileencoding' from &quot;++opt=val&quot; argument.</a>
<a name="ln2940">  if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln2941">    fenc = eap-&gt;cmd + eap-&gt;force_enc;</a>
<a name="ln2942">    fenc = enc_canonize(fenc);</a>
<a name="ln2943">    fenc_tofree = fenc;</a>
<a name="ln2944">  } else {</a>
<a name="ln2945">    fenc = buf-&gt;b_p_fenc;</a>
<a name="ln2946">  }</a>
<a name="ln2947"> </a>
<a name="ln2948">  // Check if the file needs to be converted.</a>
<a name="ln2949">  converted = need_conversion(fenc);</a>
<a name="ln2950"> </a>
<a name="ln2951">  // Check if UTF-8 to UCS-2/4 or Latin1 conversion needs to be done.  Or</a>
<a name="ln2952">  // Latin1 to Unicode conversion.  This is handled in buf_write_bytes().</a>
<a name="ln2953">  // Prepare the flags for it and allocate bw_conv_buf when needed.</a>
<a name="ln2954">  if (converted) {</a>
<a name="ln2955">    wb_flags = get_fio_flags((char_u *)fenc);</a>
<a name="ln2956">    if (wb_flags &amp; (FIO_UCS2 | FIO_UCS4 | FIO_UTF16 | FIO_UTF8)) {</a>
<a name="ln2957">      // Need to allocate a buffer to translate into.</a>
<a name="ln2958">      if (wb_flags &amp; (FIO_UCS2 | FIO_UTF16 | FIO_UTF8)) {</a>
<a name="ln2959">        write_info.bw_conv_buflen = (size_t)bufsize * 2;</a>
<a name="ln2960">      } else {       // FIO_UCS4</a>
<a name="ln2961">        write_info.bw_conv_buflen = (size_t)bufsize * 4;</a>
<a name="ln2962">      }</a>
<a name="ln2963">      write_info.bw_conv_buf = verbose_try_malloc(write_info.bw_conv_buflen);</a>
<a name="ln2964">      if (!write_info.bw_conv_buf) {</a>
<a name="ln2965">        end = 0;</a>
<a name="ln2966">      }</a>
<a name="ln2967">    }</a>
<a name="ln2968">  }</a>
<a name="ln2969"> </a>
<a name="ln2970">  if (converted &amp;&amp; wb_flags == 0) {</a>
<a name="ln2971">#ifdef HAVE_ICONV</a>
<a name="ln2972">    // Use iconv() conversion when conversion is needed and it's not done</a>
<a name="ln2973">    // internally.</a>
<a name="ln2974">    write_info.bw_iconv_fd = (iconv_t)my_iconv_open((char_u *)fenc, (char_u *)&quot;utf-8&quot;);</a>
<a name="ln2975">    if (write_info.bw_iconv_fd != (iconv_t)-1) {</a>
<a name="ln2976">      // We're going to use iconv(), allocate a buffer to convert in.</a>
<a name="ln2977">      write_info.bw_conv_buflen = (size_t)bufsize * ICONV_MULT;</a>
<a name="ln2978">      write_info.bw_conv_buf = verbose_try_malloc(write_info.bw_conv_buflen);</a>
<a name="ln2979">      if (!write_info.bw_conv_buf) {</a>
<a name="ln2980">        end = 0;</a>
<a name="ln2981">      }</a>
<a name="ln2982">      write_info.bw_first = true;</a>
<a name="ln2983">    } else {</a>
<a name="ln2984">#endif</a>
<a name="ln2985"> </a>
<a name="ln2986">    // When the file needs to be converted with 'charconvert' after</a>
<a name="ln2987">    // writing, write to a temp file instead and let the conversion</a>
<a name="ln2988">    // overwrite the original file.</a>
<a name="ln2989">    if (*p_ccv != NUL) {</a>
<a name="ln2990">      wfname = vim_tempname();</a>
<a name="ln2991">      if (wfname == NULL) {  // Can't write without a tempfile!</a>
<a name="ln2992">        SET_ERRMSG(_(&quot;E214: Can't find temp file for writing&quot;));</a>
<a name="ln2993">        goto restore_backup;</a>
<a name="ln2994">      }</a>
<a name="ln2995">    }</a>
<a name="ln2996">  }</a>
<a name="ln2997"> </a>
<a name="ln2998">#ifdef HAVE_ICONV</a>
<a name="ln2999">}</a>
<a name="ln3000">#endif</a>
<a name="ln3001"> </a>
<a name="ln3002">  if (converted &amp;&amp; wb_flags == 0</a>
<a name="ln3003">#ifdef HAVE_ICONV</a>
<a name="ln3004">      &amp;&amp; write_info.bw_iconv_fd == (iconv_t)-1</a>
<a name="ln3005">#endif</a>
<a name="ln3006">      &amp;&amp; wfname == fname) {</a>
<a name="ln3007">    if (!forceit) {</a>
<a name="ln3008">      SET_ERRMSG(_(&quot;E213: Cannot convert (add ! to write without conversion)&quot;));</a>
<a name="ln3009">      goto restore_backup;</a>
<a name="ln3010">    }</a>
<a name="ln3011">    notconverted = true;</a>
<a name="ln3012">  }</a>
<a name="ln3013"> </a>
<a name="ln3014">  // If conversion is taking place, we may first pretend to write and check</a>
<a name="ln3015">  // for conversion errors.  Then loop again to write for real.</a>
<a name="ln3016">  // When not doing conversion this writes for real right away.</a>
<a name="ln3017">  for (checking_conversion = true;; checking_conversion = false) {</a>
<a name="ln3018">    // There is no need to check conversion when:</a>
<a name="ln3019">    // - there is no conversion</a>
<a name="ln3020">    // - we make a backup file, that can be restored in case of conversion</a>
<a name="ln3021">    // failure.</a>
<a name="ln3022">    if (!converted || dobackup) {</a>
<a name="ln3023">      checking_conversion = false;</a>
<a name="ln3024">    }</a>
<a name="ln3025"> </a>
<a name="ln3026">    if (checking_conversion) {</a>
<a name="ln3027">      // Make sure we don't write anything.</a>
<a name="ln3028">      fd = -1;</a>
<a name="ln3029">      write_info.bw_fd = fd;</a>
<a name="ln3030">    } else {</a>
<a name="ln3031">      // Open the file &quot;wfname&quot; for writing.</a>
<a name="ln3032">      // We may try to open the file twice: If we can't write to the file</a>
<a name="ln3033">      // and forceit is true we delete the existing file and try to</a>
<a name="ln3034">      // create a new one. If this still fails we may have lost the</a>
<a name="ln3035">      // original file!  (this may happen when the user reached his</a>
<a name="ln3036">      // quotum for number of files).</a>
<a name="ln3037">      // Appending will fail if the file does not exist and forceit is</a>
<a name="ln3038">      // false.</a>
<a name="ln3039">      while ((fd = os_open(wfname,</a>
<a name="ln3040">                           O_WRONLY |</a>
<a name="ln3041">                           (append</a>
<a name="ln3042">                            ? (forceit</a>
<a name="ln3043">                               ? (O_APPEND | O_CREAT)</a>
<a name="ln3044">                               : O_APPEND)</a>
<a name="ln3045">                            : (O_CREAT | O_TRUNC)),</a>
<a name="ln3046">                           perm &lt; 0 ? 0666 : (perm &amp; 0777))) &lt; 0) {</a>
<a name="ln3047">        // A forced write will try to create a new file if the old one</a>
<a name="ln3048">        // is still readonly. This may also happen when the directory</a>
<a name="ln3049">        // is read-only. In that case the mch_remove() will fail.</a>
<a name="ln3050">        if (errmsg == NULL) {</a>
<a name="ln3051">#ifdef UNIX</a>
<a name="ln3052">          FileInfo file_info;</a>
<a name="ln3053"> </a>
<a name="ln3054">          // Don't delete the file when it's a hard or symbolic link.</a>
<a name="ln3055">          if ((!newfile &amp;&amp; os_fileinfo_hardlinks(&amp;file_info_old) &gt; 1)</a>
<a name="ln3056">              || (os_fileinfo_link(fname, &amp;file_info)</a>
<a name="ln3057">                  &amp;&amp; !os_fileinfo_id_equal(&amp;file_info, &amp;file_info_old))) {</a>
<a name="ln3058">            SET_ERRMSG(_(&quot;E166: Can't open linked file for writing&quot;));</a>
<a name="ln3059">          } else {</a>
<a name="ln3060">#endif</a>
<a name="ln3061">          SET_ERRMSG_ARG(_(&quot;E212: Can't open file for writing: %s&quot;), fd);</a>
<a name="ln3062">          if (forceit &amp;&amp; vim_strchr(p_cpo, CPO_FWRITE) == NULL</a>
<a name="ln3063">              &amp;&amp; perm &gt;= 0) {</a>
<a name="ln3064">#ifdef UNIX</a>
<a name="ln3065">            // we write to the file, thus it should be marked</a>
<a name="ln3066">            // writable after all</a>
<a name="ln3067">            if (!(perm &amp; 0200)) {</a>
<a name="ln3068">              made_writable = true;</a>
<a name="ln3069">            }</a>
<a name="ln3070">            perm |= 0200;</a>
<a name="ln3071">            if (file_info_old.stat.st_uid != getuid()</a>
<a name="ln3072">                || file_info_old.stat.st_gid != getgid()) {</a>
<a name="ln3073">              perm &amp;= 0777;</a>
<a name="ln3074">            }</a>
<a name="ln3075">#endif</a>
<a name="ln3076">            if (!append) {                    // don't remove when appending</a>
<a name="ln3077">              os_remove(wfname);</a>
<a name="ln3078">            }</a>
<a name="ln3079">            continue;</a>
<a name="ln3080">          }</a>
<a name="ln3081">#ifdef UNIX</a>
<a name="ln3082">        }</a>
<a name="ln3083">#endif</a>
<a name="ln3084">        }</a>
<a name="ln3085"> </a>
<a name="ln3086">restore_backup:</a>
<a name="ln3087">        {</a>
<a name="ln3088">          // If we failed to open the file, we don't need a backup. Throw it</a>
<a name="ln3089">          // away.  If we moved or removed the original file try to put the</a>
<a name="ln3090">          // backup in its place.</a>
<a name="ln3091">          if (backup != NULL &amp;&amp; wfname == fname) {</a>
<a name="ln3092">            if (backup_copy) {</a>
<a name="ln3093">              // There is a small chance that we removed the original,</a>
<a name="ln3094">              // try to move the copy in its place.</a>
<a name="ln3095">              // This may not work if the vim_rename() fails.</a>
<a name="ln3096">              // In that case we leave the copy around.</a>
<a name="ln3097">              // If file does not exist, put the copy in its place</a>
<a name="ln3098">              if (!os_path_exists(fname)) {</a>
<a name="ln3099">                vim_rename(backup, fname);</a>
<a name="ln3100">              }</a>
<a name="ln3101">              // if original file does exist throw away the copy</a>
<a name="ln3102">              if (os_path_exists(fname)) {</a>
<a name="ln3103">                os_remove(backup);</a>
<a name="ln3104">              }</a>
<a name="ln3105">            } else {</a>
<a name="ln3106">              // try to put the original file back</a>
<a name="ln3107">              vim_rename(backup, fname);</a>
<a name="ln3108">            }</a>
<a name="ln3109">          }</a>
<a name="ln3110"> </a>
<a name="ln3111">          // if original file no longer exists give an extra warning</a>
<a name="ln3112">          if (!newfile &amp;&amp; !os_path_exists(fname)) {</a>
<a name="ln3113">            end = 0;</a>
<a name="ln3114">          }</a>
<a name="ln3115">        }</a>
<a name="ln3116"> </a>
<a name="ln3117">        if (wfname != fname) {</a>
<a name="ln3118">          xfree(wfname);</a>
<a name="ln3119">        }</a>
<a name="ln3120">        goto fail;</a>
<a name="ln3121">      }</a>
<a name="ln3122">      write_info.bw_fd = fd;</a>
<a name="ln3123">    }</a>
<a name="ln3124">    SET_ERRMSG(NULL);</a>
<a name="ln3125"> </a>
<a name="ln3126">    write_info.bw_buf = (char_u *)buffer;</a>
<a name="ln3127">    nchars = 0;</a>
<a name="ln3128"> </a>
<a name="ln3129">    // use &quot;++bin&quot;, &quot;++nobin&quot; or 'binary'</a>
<a name="ln3130">    if (eap != NULL &amp;&amp; eap-&gt;force_bin != 0) {</a>
<a name="ln3131">      write_bin = (eap-&gt;force_bin == FORCE_BIN);</a>
<a name="ln3132">    } else {</a>
<a name="ln3133">      write_bin = buf-&gt;b_p_bin;</a>
<a name="ln3134">    }</a>
<a name="ln3135"> </a>
<a name="ln3136">    // Skip the BOM when appending and the file already existed, the BOM</a>
<a name="ln3137">    // only makes sense at the start of the file.</a>
<a name="ln3138">    if (buf-&gt;b_p_bomb &amp;&amp; !write_bin &amp;&amp; (!append || perm &lt; 0)) {</a>
<a name="ln3139">      write_info.bw_len = make_bom((char_u *)buffer, (char_u *)fenc);</a>
<a name="ln3140">      if (write_info.bw_len &gt; 0) {</a>
<a name="ln3141">        // don't convert</a>
<a name="ln3142">        write_info.bw_flags = FIO_NOCONVERT | wb_flags;</a>
<a name="ln3143">        if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3144">          end = 0;</a>
<a name="ln3145">        } else {</a>
<a name="ln3146">          nchars += write_info.bw_len;</a>
<a name="ln3147">        }</a>
<a name="ln3148">      }</a>
<a name="ln3149">    }</a>
<a name="ln3150">    write_info.bw_start_lnum = start;</a>
<a name="ln3151"> </a>
<a name="ln3152">    write_undo_file = (buf-&gt;b_p_udf &amp;&amp; overwriting &amp;&amp; !append</a>
<a name="ln3153">                       &amp;&amp; !filtering &amp;&amp; reset_changed &amp;&amp; !checking_conversion);</a>
<a name="ln3154">    if (write_undo_file) {</a>
<a name="ln3155">      // Prepare for computing the hash value of the text.</a>
<a name="ln3156">      sha256_start(&amp;sha_ctx);</a>
<a name="ln3157">    }</a>
<a name="ln3158"> </a>
<a name="ln3159">    write_info.bw_len = bufsize;</a>
<a name="ln3160">#ifdef HAS_BW_FLAGS</a>
<a name="ln3161">    write_info.bw_flags = wb_flags;</a>
<a name="ln3162">#endif</a>
<a name="ln3163">    fileformat = get_fileformat_force(buf, eap);</a>
<a name="ln3164">    s = buffer;</a>
<a name="ln3165">    len = 0;</a>
<a name="ln3166">    for (lnum = start; lnum &lt;= end; lnum++) {</a>
<a name="ln3167">      // The next while loop is done once for each character written.</a>
<a name="ln3168">      // Keep it fast!</a>
<a name="ln3169">      ptr = ml_get_buf(buf, lnum, false) - 1;</a>
<a name="ln3170">      if (write_undo_file) {</a>
<a name="ln3171">        sha256_update(&amp;sha_ctx, (char_u *)ptr + 1, (uint32_t)(strlen(ptr + 1) + 1));</a>
<a name="ln3172">      }</a>
<a name="ln3173">      while ((c = *++ptr) != NUL) {</a>
<a name="ln3174">        if (c == NL) {</a>
<a name="ln3175">          *s = NUL;                       // replace newlines with NULs</a>
<a name="ln3176">        } else if (c == CAR &amp;&amp; fileformat == EOL_MAC) {</a>
<a name="ln3177">          *s = NL;                        // Mac: replace CRs with NLs</a>
<a name="ln3178">        } else {</a>
<a name="ln3179">          *s = c;</a>
<a name="ln3180">        }</a>
<a name="ln3181">        s++;</a>
<a name="ln3182">        if (++len != bufsize) {</a>
<a name="ln3183">          continue;</a>
<a name="ln3184">        }</a>
<a name="ln3185">        if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3186">          end = 0;                        // write error: break loop</a>
<a name="ln3187">          break;</a>
<a name="ln3188">        }</a>
<a name="ln3189">        nchars += bufsize;</a>
<a name="ln3190">        s = buffer;</a>
<a name="ln3191">        len = 0;</a>
<a name="ln3192">        write_info.bw_start_lnum = lnum;</a>
<a name="ln3193">      }</a>
<a name="ln3194">      // write failed or last line has no EOL: stop here</a>
<a name="ln3195">      if (end == 0</a>
<a name="ln3196">          || (lnum == end</a>
<a name="ln3197">              &amp;&amp; (write_bin || !buf-&gt;b_p_fixeol)</a>
<a name="ln3198">              &amp;&amp; ((write_bin &amp;&amp; lnum == buf-&gt;b_no_eol_lnum)</a>
<a name="ln3199">                  || (lnum == buf-&gt;b_ml.ml_line_count &amp;&amp; !buf-&gt;b_p_eol)))) {</a>
<a name="ln3200">        lnum++;                           // written the line, count it</a>
<a name="ln3201">        no_eol = true;</a>
<a name="ln3202">        break;</a>
<a name="ln3203">      }</a>
<a name="ln3204">      if (fileformat == EOL_UNIX) {</a>
<a name="ln3205">        *s++ = NL;</a>
<a name="ln3206">      } else {</a>
<a name="ln3207">        *s++ = CAR;                       // EOL_MAC or EOL_DOS: write CR</a>
<a name="ln3208">        if (fileformat == EOL_DOS) {      // write CR-NL</a>
<a name="ln3209">          if (++len == bufsize) {</a>
<a name="ln3210">            if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3211">              end = 0;                    // write error: break loop</a>
<a name="ln3212">              break;</a>
<a name="ln3213">            }</a>
<a name="ln3214">            nchars += bufsize;</a>
<a name="ln3215">            s = buffer;</a>
<a name="ln3216">            len = 0;</a>
<a name="ln3217">          }</a>
<a name="ln3218">          *s++ = NL;</a>
<a name="ln3219">        }</a>
<a name="ln3220">      }</a>
<a name="ln3221">      if (++len == bufsize) {</a>
<a name="ln3222">        if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3223">          end = 0;  // Write error: break loop.</a>
<a name="ln3224">          break;</a>
<a name="ln3225">        }</a>
<a name="ln3226">        nchars += bufsize;</a>
<a name="ln3227">        s = buffer;</a>
<a name="ln3228">        len = 0;</a>
<a name="ln3229"> </a>
<a name="ln3230">        os_breakcheck();</a>
<a name="ln3231">        if (got_int) {</a>
<a name="ln3232">          end = 0;  // Interrupted, break loop.</a>
<a name="ln3233">          break;</a>
<a name="ln3234">        }</a>
<a name="ln3235">      }</a>
<a name="ln3236">    }</a>
<a name="ln3237">    if (len &gt; 0 &amp;&amp; end &gt; 0) {</a>
<a name="ln3238">      write_info.bw_len = len;</a>
<a name="ln3239">      if (buf_write_bytes(&amp;write_info) == FAIL) {</a>
<a name="ln3240">        end = 0;                      // write error</a>
<a name="ln3241">      }</a>
<a name="ln3242">      nchars += len;</a>
<a name="ln3243">    }</a>
<a name="ln3244"> </a>
<a name="ln3245">    // Stop when writing done or an error was encountered.</a>
<a name="ln3246">    if (!checking_conversion || end == 0) {</a>
<a name="ln3247">      break;</a>
<a name="ln3248">    }</a>
<a name="ln3249"> </a>
<a name="ln3250">    // If no error happened until now, writing should be ok, so loop to</a>
<a name="ln3251">    // really write the buffer.</a>
<a name="ln3252">  }</a>
<a name="ln3253"> </a>
<a name="ln3254">  // If we started writing, finish writing. Also when an error was</a>
<a name="ln3255">  // encountered.</a>
<a name="ln3256">  if (!checking_conversion) {</a>
<a name="ln3257">    // On many journalling file systems there is a bug that causes both the</a>
<a name="ln3258">    // original and the backup file to be lost when halting the system right</a>
<a name="ln3259">    // after writing the file.  That's because only the meta-data is</a>
<a name="ln3260">    // journalled.  Syncing the file slows down the system, but assures it has</a>
<a name="ln3261">    // been written to disk and we don't lose it.</a>
<a name="ln3262">    // For a device do try the fsync() but don't complain if it does not work</a>
<a name="ln3263">    // (could be a pipe).</a>
<a name="ln3264">    // If the 'fsync' option is false, don't fsync().  Useful for laptops.</a>
<a name="ln3265">    int error;</a>
<a name="ln3266">    if (p_fs &amp;&amp; (error = os_fsync(fd)) != 0 &amp;&amp; !device</a>
<a name="ln3267">        // fsync not supported on this storage.</a>
<a name="ln3268">        &amp;&amp; error != UV_ENOTSUP) {</a>
<a name="ln3269">      SET_ERRMSG_ARG(e_fsync, error);</a>
<a name="ln3270">      end = 0;</a>
<a name="ln3271">    }</a>
<a name="ln3272"> </a>
<a name="ln3273">#ifdef UNIX</a>
<a name="ln3274">    // When creating a new file, set its owner/group to that of the original</a>
<a name="ln3275">    // file.  Get the new device and inode number.</a>
<a name="ln3276">    if (backup != NULL &amp;&amp; !backup_copy) {</a>
<a name="ln3277">      // don't change the owner when it's already OK, some systems remove</a>
<a name="ln3278">      // permission or ACL stuff</a>
<a name="ln3279">      FileInfo file_info;</a>
<a name="ln3280">      if (!os_fileinfo(wfname, &amp;file_info)</a>
<a name="ln3281">          || file_info.stat.st_uid != file_info_old.stat.st_uid</a>
<a name="ln3282">          || file_info.stat.st_gid != file_info_old.stat.st_gid) {</a>
<a name="ln3283">        os_fchown(fd, (uv_uid_t)file_info_old.stat.st_uid, (uv_gid_t)file_info_old.stat.st_gid);</a>
<a name="ln3284">        if (perm &gt;= 0) {  // Set permission again, may have changed.</a>
<a name="ln3285">          (void)os_setperm(wfname, (int)perm);</a>
<a name="ln3286">        }</a>
<a name="ln3287">      }</a>
<a name="ln3288">      buf_set_file_id(buf);</a>
<a name="ln3289">    } else if (!buf-&gt;file_id_valid) {</a>
<a name="ln3290">      // Set the file_id when creating a new file.</a>
<a name="ln3291">      buf_set_file_id(buf);</a>
<a name="ln3292">    }</a>
<a name="ln3293">#endif</a>
<a name="ln3294"> </a>
<a name="ln3295">    if ((error = os_close(fd)) != 0) {</a>
<a name="ln3296">      SET_ERRMSG_ARG(_(&quot;E512: Close failed: %s&quot;), error);</a>
<a name="ln3297">      end = 0;</a>
<a name="ln3298">    }</a>
<a name="ln3299"> </a>
<a name="ln3300">#ifdef UNIX</a>
<a name="ln3301">    if (made_writable) {</a>
<a name="ln3302">      perm &amp;= ~0200;              // reset 'w' bit for security reasons</a>
<a name="ln3303">    }</a>
<a name="ln3304">#endif</a>
<a name="ln3305">    if (perm &gt;= 0) {  // Set perm. of new file same as old file.</a>
<a name="ln3306">      (void)os_setperm((const char *)wfname, (int)perm);</a>
<a name="ln3307">    }</a>
<a name="ln3308">#ifdef HAVE_ACL</a>
<a name="ln3309">    // Probably need to set the ACL before changing the user (can't set the</a>
<a name="ln3310">    // ACL on a file the user doesn't own).</a>
<a name="ln3311">    if (!backup_copy) {</a>
<a name="ln3312">      mch_set_acl((char_u *)wfname, acl);</a>
<a name="ln3313">    }</a>
<a name="ln3314">#endif</a>
<a name="ln3315"> </a>
<a name="ln3316">    if (wfname != fname) {</a>
<a name="ln3317">      // The file was written to a temp file, now it needs to be converted</a>
<a name="ln3318">      // with 'charconvert' to (overwrite) the output file.</a>
<a name="ln3319">      if (end != 0) {</a>
<a name="ln3320">        if (eval_charconvert(&quot;utf-8&quot;, fenc, wfname, fname) == FAIL) {</a>
<a name="ln3321">          write_info.bw_conv_error = true;</a>
<a name="ln3322">          end = 0;</a>
<a name="ln3323">        }</a>
<a name="ln3324">      }</a>
<a name="ln3325">      os_remove(wfname);</a>
<a name="ln3326">      xfree(wfname);</a>
<a name="ln3327">    }</a>
<a name="ln3328">  }</a>
<a name="ln3329"> </a>
<a name="ln3330">  if (end == 0) {</a>
<a name="ln3331">    // Error encountered.</a>
<a name="ln3332">    if (errmsg == NULL) {</a>
<a name="ln3333">      if (write_info.bw_conv_error) {</a>
<a name="ln3334">        if (write_info.bw_conv_error_lnum == 0) {</a>
<a name="ln3335">          SET_ERRMSG(_(&quot;E513: write error, conversion failed &quot;</a>
<a name="ln3336">                       &quot;(make 'fenc' empty to override)&quot;));</a>
<a name="ln3337">        } else {</a>
<a name="ln3338">          errmsg_allocated = true;</a>
<a name="ln3339">          SET_ERRMSG(xmalloc(300));</a>
<a name="ln3340">          vim_snprintf(errmsg, 300,  // NOLINT(runtime/printf)</a>
<a name="ln3341">                       _(&quot;E513: write error, conversion failed in line %&quot; PRIdLINENR</a>
<a name="ln3342">                         &quot; (make 'fenc' empty to override)&quot;),</a>
<a name="ln3343">                       write_info.bw_conv_error_lnum);</a>
<a name="ln3344">        }</a>
<a name="ln3345">      } else if (got_int) {</a>
<a name="ln3346">        SET_ERRMSG(_(e_interr));</a>
<a name="ln3347">      } else {</a>
<a name="ln3348">        SET_ERRMSG(_(&quot;E514: write error (file system full?)&quot;));</a>
<a name="ln3349">      }</a>
<a name="ln3350">    }</a>
<a name="ln3351"> </a>
<a name="ln3352">    // If we have a backup file, try to put it in place of the new file,</a>
<a name="ln3353">    // because the new file is probably corrupt.  This avoids losing the</a>
<a name="ln3354">    // original file when trying to make a backup when writing the file a</a>
<a name="ln3355">    // second time.</a>
<a name="ln3356">    // When &quot;backup_copy&quot; is set we need to copy the backup over the new</a>
<a name="ln3357">    // file.  Otherwise rename the backup file.</a>
<a name="ln3358">    // If this is OK, don't give the extra warning message.</a>
<a name="ln3359">    if (backup != NULL) {</a>
<a name="ln3360">      if (backup_copy) {</a>
<a name="ln3361">        // This may take a while, if we were interrupted let the user</a>
<a name="ln3362">        // know we got the message.</a>
<a name="ln3363">        if (got_int) {</a>
<a name="ln3364">          msg(_(e_interr));</a>
<a name="ln3365">          ui_flush();</a>
<a name="ln3366">        }</a>
<a name="ln3367"> </a>
<a name="ln3368">        // copy the file.</a>
<a name="ln3369">        if (os_copy(backup, fname, UV_FS_COPYFILE_FICLONE)</a>
<a name="ln3370">            == 0) {</a>
<a name="ln3371">          end = 1;  // success</a>
<a name="ln3372">        }</a>
<a name="ln3373">      } else {</a>
<a name="ln3374">        if (vim_rename(backup, fname) == 0) {</a>
<a name="ln3375">          end = 1;</a>
<a name="ln3376">        }</a>
<a name="ln3377">      }</a>
<a name="ln3378">    }</a>
<a name="ln3379">    goto fail;</a>
<a name="ln3380">  }</a>
<a name="ln3381"> </a>
<a name="ln3382">  lnum -= start;            // compute number of written lines</a>
<a name="ln3383">  no_wait_return--;         // may wait for return now</a>
<a name="ln3384"> </a>
<a name="ln3385">#if !defined(UNIX)</a>
<a name="ln3386">  fname = sfname;           // use shortname now, for the messages</a>
<a name="ln3387">#endif</a>
<a name="ln3388">  if (!filtering) {</a>
<a name="ln3389">    add_quoted_fname((char *)IObuff, IOSIZE, buf, (const char *)fname);</a>
<a name="ln3390">    c = false;</a>
<a name="ln3391">    if (write_info.bw_conv_error) {</a>
<a name="ln3392">      STRCAT(IObuff, _(&quot; CONVERSION ERROR&quot;));</a>
<a name="ln3393">      c = true;</a>
<a name="ln3394">      if (write_info.bw_conv_error_lnum != 0) {</a>
<a name="ln3395">        vim_snprintf_add((char *)IObuff, IOSIZE, _(&quot; in line %&quot; PRId64 &quot;;&quot;),</a>
<a name="ln3396">                         (int64_t)write_info.bw_conv_error_lnum);</a>
<a name="ln3397">      }</a>
<a name="ln3398">    } else if (notconverted) {</a>
<a name="ln3399">      STRCAT(IObuff, _(&quot;[NOT converted]&quot;));</a>
<a name="ln3400">      c = true;</a>
<a name="ln3401">    } else if (converted) {</a>
<a name="ln3402">      STRCAT(IObuff, _(&quot;[converted]&quot;));</a>
<a name="ln3403">      c = true;</a>
<a name="ln3404">    }</a>
<a name="ln3405">    if (device) {</a>
<a name="ln3406">      STRCAT(IObuff, _(&quot;[Device]&quot;));</a>
<a name="ln3407">      c = true;</a>
<a name="ln3408">    } else if (newfile) {</a>
<a name="ln3409">      STRCAT(IObuff, new_file_message());</a>
<a name="ln3410">      c = true;</a>
<a name="ln3411">    }</a>
<a name="ln3412">    if (no_eol) {</a>
<a name="ln3413">      msg_add_eol();</a>
<a name="ln3414">      c = true;</a>
<a name="ln3415">    }</a>
<a name="ln3416">    // may add [unix/dos/mac]</a>
<a name="ln3417">    if (msg_add_fileformat(fileformat)) {</a>
<a name="ln3418">      c = true;</a>
<a name="ln3419">    }</a>
<a name="ln3420">    msg_add_lines(c, (long)lnum, nchars);       // add line/char count</a>
<a name="ln3421">    if (!shortmess(SHM_WRITE)) {</a>
<a name="ln3422">      if (append) {</a>
<a name="ln3423">        STRCAT(IObuff, shortmess(SHM_WRI) ? _(&quot; [a]&quot;) : _(&quot; appended&quot;));</a>
<a name="ln3424">      } else {</a>
<a name="ln3425">        STRCAT(IObuff, shortmess(SHM_WRI) ? _(&quot; [w]&quot;) : _(&quot; written&quot;));</a>
<a name="ln3426">      }</a>
<a name="ln3427">    }</a>
<a name="ln3428"> </a>
<a name="ln3429">    set_keep_msg(msg_trunc_attr((char *)IObuff, false, 0), 0);</a>
<a name="ln3430">  }</a>
<a name="ln3431"> </a>
<a name="ln3432">  // When written everything correctly: reset 'modified'.  Unless not</a>
<a name="ln3433">  // writing to the original file and '+' is not in 'cpoptions'.</a>
<a name="ln3434">  if (reset_changed &amp;&amp; whole &amp;&amp; !append</a>
<a name="ln3435">      &amp;&amp; !write_info.bw_conv_error</a>
<a name="ln3436">      &amp;&amp; (overwriting || vim_strchr(p_cpo, CPO_PLUS) != NULL)) {</a>
<a name="ln3437">    unchanged(buf, true, false);</a>
<a name="ln3438">    const varnumber_T changedtick = buf_get_changedtick(buf);</a>
<a name="ln3439">    if (buf-&gt;b_last_changedtick + 1 == changedtick) {</a>
<a name="ln3440">      // b:changedtick may be incremented in unchanged() but that</a>
<a name="ln3441">      // should not trigger a TextChanged event.</a>
<a name="ln3442">      buf-&gt;b_last_changedtick = changedtick;</a>
<a name="ln3443">    }</a>
<a name="ln3444">    u_unchanged(buf);</a>
<a name="ln3445">    u_update_save_nr(buf);</a>
<a name="ln3446">  }</a>
<a name="ln3447"> </a>
<a name="ln3448">  // If written to the current file, update the timestamp of the swap file</a>
<a name="ln3449">  // and reset the BF_WRITE_MASK flags. Also sets buf-&gt;b_mtime.</a>
<a name="ln3450">  if (overwriting) {</a>
<a name="ln3451">    ml_timestamp(buf);</a>
<a name="ln3452">    if (append) {</a>
<a name="ln3453">      buf-&gt;b_flags &amp;= ~BF_NEW;</a>
<a name="ln3454">    } else {</a>
<a name="ln3455">      buf-&gt;b_flags &amp;= ~BF_WRITE_MASK;</a>
<a name="ln3456">    }</a>
<a name="ln3457">  }</a>
<a name="ln3458"> </a>
<a name="ln3459">  // If we kept a backup until now, and we are in patch mode, then we make</a>
<a name="ln3460">  // the backup file our 'original' file.</a>
<a name="ln3461">  if (*p_pm &amp;&amp; dobackup) {</a>
<a name="ln3462">    char *const org = modname(fname, p_pm, false);</a>
<a name="ln3463"> </a>
<a name="ln3464">    if (backup != NULL) {</a>
<a name="ln3465">      // If the original file does not exist yet</a>
<a name="ln3466">      // the current backup file becomes the original file</a>
<a name="ln3467">      if (org == NULL) {</a>
<a name="ln3468">        emsg(_(&quot;E205: Patchmode: can't save original file&quot;));</a>
<a name="ln3469">      } else if (!os_path_exists(org)) {</a>
<a name="ln3470">        vim_rename(backup, org);</a>
<a name="ln3471">        XFREE_CLEAR(backup);                   // don't delete the file</a>
<a name="ln3472">#ifdef UNIX</a>
<a name="ln3473">        os_file_settime(org,</a>
<a name="ln3474">                        (double)file_info_old.stat.st_atim.tv_sec,</a>
<a name="ln3475">                        (double)file_info_old.stat.st_mtim.tv_sec);</a>
<a name="ln3476">#endif</a>
<a name="ln3477">      }</a>
<a name="ln3478">    } else {</a>
<a name="ln3479">      // If there is no backup file, remember that a (new) file was</a>
<a name="ln3480">      // created.</a>
<a name="ln3481">      int empty_fd;</a>
<a name="ln3482"> </a>
<a name="ln3483">      if (org == NULL</a>
<a name="ln3484">          || (empty_fd = os_open(org,</a>
<a name="ln3485">                                 O_CREAT | O_EXCL | O_NOFOLLOW,</a>
<a name="ln3486">                                 perm &lt; 0 ? 0666 : (perm &amp; 0777))) &lt; 0) {</a>
<a name="ln3487">        emsg(_(&quot;E206: patchmode: can't touch empty original file&quot;));</a>
<a name="ln3488">      } else {</a>
<a name="ln3489">        close(empty_fd);</a>
<a name="ln3490">      }</a>
<a name="ln3491">    }</a>
<a name="ln3492">    if (org != NULL) {</a>
<a name="ln3493">      os_setperm(org, os_getperm((const char *)fname) &amp; 0777);</a>
<a name="ln3494">      xfree(org);</a>
<a name="ln3495">    }</a>
<a name="ln3496">  }</a>
<a name="ln3497"> </a>
<a name="ln3498">  // Remove the backup unless 'backup' option is set</a>
<a name="ln3499">  if (!p_bk &amp;&amp; backup != NULL</a>
<a name="ln3500">      &amp;&amp; !write_info.bw_conv_error</a>
<a name="ln3501">      &amp;&amp; os_remove(backup) != 0) {</a>
<a name="ln3502">    emsg(_(&quot;E207: Can't delete backup file&quot;));</a>
<a name="ln3503">  }</a>
<a name="ln3504"> </a>
<a name="ln3505">  goto nofail;</a>
<a name="ln3506"> </a>
<a name="ln3507">  // Finish up.  We get here either after failure or success.</a>
<a name="ln3508">fail:</a>
<a name="ln3509">  no_wait_return--;             // may wait for return now</a>
<a name="ln3510">nofail:</a>
<a name="ln3511"> </a>
<a name="ln3512">  // Done saving, we accept changed buffer warnings again</a>
<a name="ln3513">  buf-&gt;b_saving = false;</a>
<a name="ln3514"> </a>
<a name="ln3515">  xfree(backup);</a>
<a name="ln3516">  if (buffer != smallbuf) {</a>
<a name="ln3517">    xfree(buffer);</a>
<a name="ln3518">  }</a>
<a name="ln3519">  xfree(fenc_tofree);</a>
<a name="ln3520">  xfree(write_info.bw_conv_buf);</a>
<a name="ln3521">#ifdef HAVE_ICONV</a>
<a name="ln3522">  if (write_info.bw_iconv_fd != (iconv_t)-1) {</a>
<a name="ln3523">    iconv_close(write_info.bw_iconv_fd);</a>
<a name="ln3524">    write_info.bw_iconv_fd = (iconv_t)-1;</a>
<a name="ln3525">  }</a>
<a name="ln3526">#endif</a>
<a name="ln3527">#ifdef HAVE_ACL</a>
<a name="ln3528">  mch_free_acl(acl);</a>
<a name="ln3529">#endif</a>
<a name="ln3530"> </a>
<a name="ln3531">  if (errmsg != NULL) {</a>
<a name="ln3532">    // - 100 to save some space for further error message</a>
<a name="ln3533">#ifndef UNIX</a>
<a name="ln3534">    add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)sfname);</a>
<a name="ln3535">#else</a>
<a name="ln3536">    add_quoted_fname((char *)IObuff, IOSIZE - 100, buf, (const char *)fname);</a>
<a name="ln3537">#endif</a>
<a name="ln3538">    if (errnum != NULL) {</a>
<a name="ln3539">      if (errmsgarg != 0) {</a>
<a name="ln3540">        semsg(&quot;%s: %s%s: %s&quot;, errnum, IObuff, errmsg, os_strerror(errmsgarg));</a>
<a name="ln3541">      } else {</a>
<a name="ln3542">        semsg(&quot;%s: %s%s&quot;, errnum, IObuff, errmsg);</a>
<a name="ln3543">      }</a>
<a name="ln3544">    } else if (errmsgarg != 0) {</a>
<a name="ln3545">      semsg(errmsg, os_strerror(errmsgarg));</a>
<a name="ln3546">    } else {</a>
<a name="ln3547">      emsg(errmsg);</a>
<a name="ln3548">    }</a>
<a name="ln3549">    if (errmsg_allocated) {</a>
<a name="ln3550">      xfree(errmsg);</a>
<a name="ln3551">    }</a>
<a name="ln3552"> </a>
<a name="ln3553">    retval = FAIL;</a>
<a name="ln3554">    if (end == 0) {</a>
<a name="ln3555">      const int attr = HL_ATTR(HLF_E);  // Set highlight for error messages.</a>
<a name="ln3556">      msg_puts_attr(_(&quot;\nWARNING: Original file may be lost or damaged\n&quot;),</a>
<a name="ln3557">                    attr | MSG_HIST);</a>
<a name="ln3558">      msg_puts_attr(_(&quot;don't quit the editor until the file is successfully written!&quot;),</a>
<a name="ln3559">                    attr | MSG_HIST);</a>
<a name="ln3560"> </a>
<a name="ln3561">      // Update the timestamp to avoid an &quot;overwrite changed file&quot;</a>
<a name="ln3562">      // prompt when writing again.</a>
<a name="ln3563">      if (os_fileinfo(fname, &amp;file_info_old)) {</a>
<a name="ln3564">        buf_store_file_info(buf, &amp;file_info_old);</a>
<a name="ln3565">        buf-&gt;b_mtime_read = buf-&gt;b_mtime;</a>
<a name="ln3566">        buf-&gt;b_mtime_read_ns = buf-&gt;b_mtime_ns;</a>
<a name="ln3567">      }</a>
<a name="ln3568">    }</a>
<a name="ln3569">  }</a>
<a name="ln3570">  msg_scroll = msg_save;</a>
<a name="ln3571"> </a>
<a name="ln3572">  // When writing the whole file and 'undofile' is set, also write the undo</a>
<a name="ln3573">  // file.</a>
<a name="ln3574">  if (retval == OK &amp;&amp; write_undo_file) {</a>
<a name="ln3575">    char hash[UNDO_HASH_SIZE];</a>
<a name="ln3576"> </a>
<a name="ln3577">    sha256_finish(&amp;sha_ctx, (char_u *)hash);</a>
<a name="ln3578">    u_write_undo(NULL, false, buf, (char_u *)hash);</a>
<a name="ln3579">  }</a>
<a name="ln3580"> </a>
<a name="ln3581">  if (!should_abort(retval)) {</a>
<a name="ln3582">    aco_save_T aco;</a>
<a name="ln3583"> </a>
<a name="ln3584">    curbuf-&gt;b_no_eol_lnum = 0;      // in case it was set by the previous read</a>
<a name="ln3585"> </a>
<a name="ln3586">    // Apply POST autocommands.</a>
<a name="ln3587">    // Careful: The autocommands may call buf_write() recursively!</a>
<a name="ln3588">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln3589"> </a>
<a name="ln3590">    if (append) {</a>
<a name="ln3591">      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,</a>
<a name="ln3592">                           false, curbuf, eap);</a>
<a name="ln3593">    } else if (filtering) {</a>
<a name="ln3594">      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,</a>
<a name="ln3595">                           false, curbuf, eap);</a>
<a name="ln3596">    } else if (reset_changed &amp;&amp; whole) {</a>
<a name="ln3597">      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,</a>
<a name="ln3598">                           false, curbuf, eap);</a>
<a name="ln3599">    } else {</a>
<a name="ln3600">      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,</a>
<a name="ln3601">                           false, curbuf, eap);</a>
<a name="ln3602">    }</a>
<a name="ln3603"> </a>
<a name="ln3604">    // restore curwin/curbuf and a few other things</a>
<a name="ln3605">    aucmd_restbuf(&amp;aco);</a>
<a name="ln3606"> </a>
<a name="ln3607">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln3608">      retval = false;</a>
<a name="ln3609">    }</a>
<a name="ln3610">  }</a>
<a name="ln3611"> </a>
<a name="ln3612">  got_int |= prev_got_int;</a>
<a name="ln3613"> </a>
<a name="ln3614">  return retval;</a>
<a name="ln3615">#undef SET_ERRMSG</a>
<a name="ln3616">#undef SET_ERRMSG_ARG</a>
<a name="ln3617">#undef SET_ERRMSG_NUM</a>
<a name="ln3618">}</a>
<a name="ln3619"> </a>
<a name="ln3620">/// Set the name of the current buffer.  Use when the buffer doesn't have a</a>
<a name="ln3621">/// name and a &quot;:r&quot; or &quot;:w&quot; command with a file name is used.</a>
<a name="ln3622">static int set_rw_fname(char_u *fname, char_u *sfname)</a>
<a name="ln3623">{</a>
<a name="ln3624">  buf_T *buf = curbuf;</a>
<a name="ln3625"> </a>
<a name="ln3626">  // It's like the unnamed buffer is deleted....</a>
<a name="ln3627">  if (curbuf-&gt;b_p_bl) {</a>
<a name="ln3628">    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, false, curbuf);</a>
<a name="ln3629">  }</a>
<a name="ln3630">  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, false, curbuf);</a>
<a name="ln3631">  if (aborting()) {         // autocmds may abort script processing</a>
<a name="ln3632">    return FAIL;</a>
<a name="ln3633">  }</a>
<a name="ln3634">  if (curbuf != buf) {</a>
<a name="ln3635">    // We are in another buffer now, don't do the renaming.</a>
<a name="ln3636">    emsg(_(e_auchangedbuf));</a>
<a name="ln3637">    return FAIL;</a>
<a name="ln3638">  }</a>
<a name="ln3639"> </a>
<a name="ln3640">  if (setfname(curbuf, (char *)fname, (char *)sfname, false) == OK) {</a>
<a name="ln3641">    curbuf-&gt;b_flags |= BF_NOTEDITED;</a>
<a name="ln3642">  }</a>
<a name="ln3643"> </a>
<a name="ln3644">  // ....and a new named one is created</a>
<a name="ln3645">  apply_autocmds(EVENT_BUFNEW, NULL, NULL, false, curbuf);</a>
<a name="ln3646">  if (curbuf-&gt;b_p_bl) {</a>
<a name="ln3647">    apply_autocmds(EVENT_BUFADD, NULL, NULL, false, curbuf);</a>
<a name="ln3648">  }</a>
<a name="ln3649">  if (aborting()) {         // autocmds may abort script processing</a>
<a name="ln3650">    return FAIL;</a>
<a name="ln3651">  }</a>
<a name="ln3652"> </a>
<a name="ln3653">  // Do filetype detection now if 'filetype' is empty.</a>
<a name="ln3654">  if (*curbuf-&gt;b_p_ft == NUL) {</a>
<a name="ln3655">    if (augroup_exists(&quot;filetypedetect&quot;)) {</a>
<a name="ln3656">      (void)do_doautocmd(&quot;filetypedetect BufRead&quot;, false, NULL);</a>
<a name="ln3657">    }</a>
<a name="ln3658">    do_modelines(0);</a>
<a name="ln3659">  }</a>
<a name="ln3660"> </a>
<a name="ln3661">  return OK;</a>
<a name="ln3662">}</a>
<a name="ln3663"> </a>
<a name="ln3664">/// Put file name into the specified buffer with quotes</a>
<a name="ln3665">///</a>
<a name="ln3666">/// Replaces home directory at the start with `~`.</a>
<a name="ln3667">///</a>
<a name="ln3668">/// @param[out]  ret_buf  Buffer to save results to.</a>
<a name="ln3669">/// @param[in]  buf_len  ret_buf length.</a>
<a name="ln3670">/// @param[in]  buf  buf_T file name is coming from.</a>
<a name="ln3671">/// @param[in]  fname  File name to write.</a>
<a name="ln3672">static void add_quoted_fname(char *const ret_buf, const size_t buf_len, const buf_T *const buf,</a>
<a name="ln3673">                             const char *fname)</a>
<a name="ln3674">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3675">{</a>
<a name="ln3676">  if (fname == NULL) {</a>
<a name="ln3677">    fname = &quot;-stdin-&quot;;</a>
<a name="ln3678">  }</a>
<a name="ln3679">  ret_buf[0] = '&quot;';</a>
<a name="ln3680">  home_replace(buf, fname, ret_buf + 1, buf_len - 4, true);</a>
<a name="ln3681">  xstrlcat(ret_buf, &quot;\&quot; &quot;, buf_len);</a>
<a name="ln3682">}</a>
<a name="ln3683"> </a>
<a name="ln3684">/// Append message for text mode to IObuff.</a>
<a name="ln3685">///</a>
<a name="ln3686">/// @param eol_type line ending type</a>
<a name="ln3687">///</a>
<a name="ln3688">/// @return true if something was appended.</a>
<a name="ln3689">static bool msg_add_fileformat(int eol_type)</a>
<a name="ln3690">{</a>
<a name="ln3691">#ifndef USE_CRNL</a>
<a name="ln3692">  if (eol_type == EOL_DOS) {</a>
<a name="ln3693">    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(&quot;[dos]&quot;) : _(&quot;[dos format]&quot;));</a>
<a name="ln3694">    return true;</a>
<a name="ln3695">  }</a>
<a name="ln3696">#endif</a>
<a name="ln3697">  if (eol_type == EOL_MAC) {</a>
<a name="ln3698">    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(&quot;[mac]&quot;) : _(&quot;[mac format]&quot;));</a>
<a name="ln3699">    return true;</a>
<a name="ln3700">  }</a>
<a name="ln3701">#ifdef USE_CRNL</a>
<a name="ln3702">  if (eol_type == EOL_UNIX) {</a>
<a name="ln3703">    STRCAT(IObuff, shortmess(SHM_TEXT) ? _(&quot;[unix]&quot;) : _(&quot;[unix format]&quot;));</a>
<a name="ln3704">    return true;</a>
<a name="ln3705">  }</a>
<a name="ln3706">#endif</a>
<a name="ln3707">  return false;</a>
<a name="ln3708">}</a>
<a name="ln3709"> </a>
<a name="ln3710">/// Append line and character count to IObuff.</a>
<a name="ln3711">void msg_add_lines(int insert_space, long lnum, off_T nchars)</a>
<a name="ln3712">{</a>
<a name="ln3713">  char_u *p;</a>
<a name="ln3714"> </a>
<a name="ln3715">  p = (char_u *)IObuff + STRLEN(IObuff);</a>
<a name="ln3716"> </a>
<a name="ln3717">  if (insert_space) {</a>
<a name="ln3718">    *p++ = ' ';</a>
<a name="ln3719">  }</a>
<a name="ln3720">  if (shortmess(SHM_LINES)) {</a>
<a name="ln3721">    vim_snprintf((char *)p, (size_t)(IOSIZE - (p - (char_u *)IObuff)), &quot;%&quot; PRId64 &quot;L, %&quot; PRId64 &quot;B&quot;,</a>
<a name="ln3722">                 (int64_t)lnum, (int64_t)nchars);</a>
<a name="ln3723">  } else {</a>
<a name="ln3724">    vim_snprintf((char *)p, (size_t)(IOSIZE - (p - (char_u *)IObuff)),</a>
<a name="ln3725">                 NGETTEXT(&quot;%&quot; PRId64 &quot; line, &quot;, &quot;%&quot; PRId64 &quot; lines, &quot;, lnum),</a>
<a name="ln3726">                 (int64_t)lnum);</a>
<a name="ln3727">    p += STRLEN(p);</a>
<a name="ln3728">    vim_snprintf((char *)p, (size_t)(IOSIZE - (p - (char_u *)IObuff)),</a>
<a name="ln3729">                 NGETTEXT(&quot;%&quot; PRId64 &quot; byte&quot;, &quot;%&quot; PRId64 &quot; bytes&quot;, nchars),</a>
<a name="ln3730">                 (int64_t)nchars);</a>
<a name="ln3731">  }</a>
<a name="ln3732">}</a>
<a name="ln3733"> </a>
<a name="ln3734">/// Append message for missing line separator to IObuff.</a>
<a name="ln3735">static void msg_add_eol(void)</a>
<a name="ln3736">{</a>
<a name="ln3737">  STRCAT(IObuff,</a>
<a name="ln3738">         shortmess(SHM_LAST) ? _(&quot;[noeol]&quot;) : _(&quot;[Incomplete last line]&quot;));</a>
<a name="ln3739">}</a>
<a name="ln3740"> </a>
<a name="ln3741">/// Check modification time of file, before writing to it.</a>
<a name="ln3742">/// The size isn't checked, because using a tool like &quot;gzip&quot; takes care of</a>
<a name="ln3743">/// using the same timestamp but can't set the size.</a>
<a name="ln3744">static int check_mtime(buf_T *buf, FileInfo *file_info)</a>
<a name="ln3745">{</a>
<a name="ln3746">  if (buf-&gt;b_mtime_read != 0</a>
<a name="ln3747">      &amp;&amp; time_differs(file_info, buf-&gt;b_mtime_read, buf-&gt;b_mtime_read_ns)) {</a>
<a name="ln3748">    msg_scroll = true;  // Don't overwrite messages here.</a>
<a name="ln3749">    msg_silent = 0;     // Must give this prompt.</a>
<a name="ln3750">    // Don't use emsg() here, don't want to flush the buffers.</a>
<a name="ln3751">    msg_attr(_(&quot;WARNING: The file has been changed since reading it!!!&quot;),</a>
<a name="ln3752">             HL_ATTR(HLF_E));</a>
<a name="ln3753">    if (ask_yesno(_(&quot;Do you really want to write to it&quot;), true) == 'n') {</a>
<a name="ln3754">      return FAIL;</a>
<a name="ln3755">    }</a>
<a name="ln3756">    msg_scroll = false;  // Always overwrite the file message now.</a>
<a name="ln3757">  }</a>
<a name="ln3758">  return OK;</a>
<a name="ln3759">}</a>
<a name="ln3760"> </a>
<a name="ln3761">static bool time_differs(const FileInfo *file_info, long mtime, long mtime_ns) FUNC_ATTR_CONST</a>
<a name="ln3762">{</a>
<a name="ln3763">  return file_info-&gt;stat.st_mtim.tv_nsec != mtime_ns</a>
<a name="ln3764">#if defined(__linux__) || defined(MSWIN)</a>
<a name="ln3765">         // On a FAT filesystem, esp. under Linux, there are only 5 bits to store</a>
<a name="ln3766">         // the seconds.  Since the roundoff is done when flushing the inode, the</a>
<a name="ln3767">         // time may change unexpectedly by one second!!!</a>
<a name="ln3768">         || file_info-&gt;stat.st_mtim.tv_sec - mtime &gt; 1</a>
<a name="ln3769">         || mtime - file_info-&gt;stat.st_mtim.tv_sec &gt; 1;</a>
<a name="ln3770">#else</a>
<a name="ln3771">         || (long)file_info-&gt;stat.st_mtim.tv_sec != mtime;</a>
<a name="ln3772">#endif</a>
<a name="ln3773">}</a>
<a name="ln3774"> </a>
<a name="ln3775">/// Call write() to write a number of bytes to the file.</a>
<a name="ln3776">/// Handles 'encoding' conversion.</a>
<a name="ln3777">///</a>
<a name="ln3778">/// @return  FAIL for failure, OK otherwise.</a>
<a name="ln3779">static int buf_write_bytes(struct bw_info *ip)</a>
<a name="ln3780">{</a>
<a name="ln3781">  int wlen;</a>
<a name="ln3782">  char_u *buf = ip-&gt;bw_buf;        // data to write</a>
<a name="ln3783">  int len = ip-&gt;bw_len;                 // length of data</a>
<a name="ln3784">#ifdef HAS_BW_FLAGS</a>
<a name="ln3785">  int flags = ip-&gt;bw_flags;             // extra flags</a>
<a name="ln3786">#endif</a>
<a name="ln3787"> </a>
<a name="ln3788">  // Skip conversion when writing the BOM.</a>
<a name="ln3789">  if (!(flags &amp; FIO_NOCONVERT)) {</a>
<a name="ln3790">    char_u *p;</a>
<a name="ln3791">    unsigned c;</a>
<a name="ln3792">    int n;</a>
<a name="ln3793"> </a>
<a name="ln3794">    if (flags &amp; FIO_UTF8) {</a>
<a name="ln3795">      // Convert latin1 in the buffer to UTF-8 in the file.</a>
<a name="ln3796">      p = ip-&gt;bw_conv_buf;              // translate to buffer</a>
<a name="ln3797">      for (wlen = 0; wlen &lt; len; wlen++) {</a>
<a name="ln3798">        p += utf_char2bytes(buf[wlen], (char *)p);</a>
<a name="ln3799">      }</a>
<a name="ln3800">      buf = ip-&gt;bw_conv_buf;</a>
<a name="ln3801">      len = (int)(p - ip-&gt;bw_conv_buf);</a>
<a name="ln3802">    } else if (flags &amp; (FIO_UCS4 | FIO_UTF16 | FIO_UCS2 | FIO_LATIN1)) {</a>
<a name="ln3803">      // Convert UTF-8 bytes in the buffer to UCS-2, UCS-4, UTF-16 or</a>
<a name="ln3804">      // Latin1 chars in the file.</a>
<a name="ln3805">      if (flags &amp; FIO_LATIN1) {</a>
<a name="ln3806">        p = buf;                // translate in-place (can only get shorter)</a>
<a name="ln3807">      } else {</a>
<a name="ln3808">        p = ip-&gt;bw_conv_buf;            // translate to buffer</a>
<a name="ln3809">      }</a>
<a name="ln3810">      for (wlen = 0; wlen &lt; len; wlen += n) {</a>
<a name="ln3811">        if (wlen == 0 &amp;&amp; ip-&gt;bw_restlen != 0) {</a>
<a name="ln3812">          int l;</a>
<a name="ln3813"> </a>
<a name="ln3814">          // Use remainder of previous call.  Append the start of</a>
<a name="ln3815">          // buf[] to get a full sequence.  Might still be too</a>
<a name="ln3816">          // short!</a>
<a name="ln3817">          l = CONV_RESTLEN - ip-&gt;bw_restlen;</a>
<a name="ln3818">          if (l &gt; len) {</a>
<a name="ln3819">            l = len;</a>
<a name="ln3820">          }</a>
<a name="ln3821">          memmove(ip-&gt;bw_rest + ip-&gt;bw_restlen, buf, (size_t)l);</a>
<a name="ln3822">          n = utf_ptr2len_len(ip-&gt;bw_rest, ip-&gt;bw_restlen + l);</a>
<a name="ln3823">          if (n &gt; ip-&gt;bw_restlen + len) {</a>
<a name="ln3824">            // We have an incomplete byte sequence at the end to</a>
<a name="ln3825">            // be written.  We can't convert it without the</a>
<a name="ln3826">            // remaining bytes.  Keep them for the next call.</a>
<a name="ln3827">            if (ip-&gt;bw_restlen + len &gt; CONV_RESTLEN) {</a>
<a name="ln3828">              return FAIL;</a>
<a name="ln3829">            }</a>
<a name="ln3830">            ip-&gt;bw_restlen += len;</a>
<a name="ln3831">            break;</a>
<a name="ln3832">          }</a>
<a name="ln3833">          if (n &gt; 1) {</a>
<a name="ln3834">            c = (unsigned)utf_ptr2char((char *)ip-&gt;bw_rest);</a>
<a name="ln3835">          } else {</a>
<a name="ln3836">            c = ip-&gt;bw_rest[0];</a>
<a name="ln3837">          }</a>
<a name="ln3838">          if (n &gt;= ip-&gt;bw_restlen) {</a>
<a name="ln3839">            n -= ip-&gt;bw_restlen;</a>
<a name="ln3840">            ip-&gt;bw_restlen = 0;</a>
<a name="ln3841">          } else {</a>
<a name="ln3842">            ip-&gt;bw_restlen -= n;</a>
<a name="ln3843">            memmove(ip-&gt;bw_rest, ip-&gt;bw_rest + n,</a>
<a name="ln3844">                    (size_t)ip-&gt;bw_restlen);</a>
<a name="ln3845">            n = 0;</a>
<a name="ln3846">          }</a>
<a name="ln3847">        } else {</a>
<a name="ln3848">          n = utf_ptr2len_len(buf + wlen, len - wlen);</a>
<a name="ln3849">          if (n &gt; len - wlen) {</a>
<a name="ln3850">            // We have an incomplete byte sequence at the end to</a>
<a name="ln3851">            // be written.  We can't convert it without the</a>
<a name="ln3852">            // remaining bytes.  Keep them for the next call.</a>
<a name="ln3853">            if (len - wlen &gt; CONV_RESTLEN) {</a>
<a name="ln3854">              return FAIL;</a>
<a name="ln3855">            }</a>
<a name="ln3856">            ip-&gt;bw_restlen = len - wlen;</a>
<a name="ln3857">            memmove(ip-&gt;bw_rest, buf + wlen,</a>
<a name="ln3858">                    (size_t)ip-&gt;bw_restlen);</a>
<a name="ln3859">            break;</a>
<a name="ln3860">          }</a>
<a name="ln3861">          if (n &gt; 1) {</a>
<a name="ln3862">            c = (unsigned)utf_ptr2char((char *)buf + wlen);</a>
<a name="ln3863">          } else {</a>
<a name="ln3864">            c = buf[wlen];</a>
<a name="ln3865">          }</a>
<a name="ln3866">        }</a>
<a name="ln3867"> </a>
<a name="ln3868">        if (ucs2bytes(c, &amp;p, flags) &amp;&amp; !ip-&gt;bw_conv_error) {</a>
<a name="ln3869">          ip-&gt;bw_conv_error = true;</a>
<a name="ln3870">          ip-&gt;bw_conv_error_lnum = ip-&gt;bw_start_lnum;</a>
<a name="ln3871">        }</a>
<a name="ln3872">        if (c == NL) {</a>
<a name="ln3873">          ip-&gt;bw_start_lnum++;</a>
<a name="ln3874">        }</a>
<a name="ln3875">      }</a>
<a name="ln3876">      if (flags &amp; FIO_LATIN1) {</a>
<a name="ln3877">        len = (int)(p - buf);</a>
<a name="ln3878">      } else {</a>
<a name="ln3879">        buf = ip-&gt;bw_conv_buf;</a>
<a name="ln3880">        len = (int)(p - ip-&gt;bw_conv_buf);</a>
<a name="ln3881">      }</a>
<a name="ln3882">    }</a>
<a name="ln3883"> </a>
<a name="ln3884">#ifdef HAVE_ICONV</a>
<a name="ln3885">    if (ip-&gt;bw_iconv_fd != (iconv_t)-1) {</a>
<a name="ln3886">      const char *from;</a>
<a name="ln3887">      size_t fromlen;</a>
<a name="ln3888">      char *to;</a>
<a name="ln3889">      size_t tolen;</a>
<a name="ln3890"> </a>
<a name="ln3891">      // Convert with iconv().</a>
<a name="ln3892">      if (ip-&gt;bw_restlen &gt; 0) {</a>
<a name="ln3893">        char *fp;</a>
<a name="ln3894"> </a>
<a name="ln3895">        // Need to concatenate the remainder of the previous call and</a>
<a name="ln3896">        // the bytes of the current call.  Use the end of the</a>
<a name="ln3897">        // conversion buffer for this.</a>
<a name="ln3898">        fromlen = (size_t)len + (size_t)ip-&gt;bw_restlen;</a>
<a name="ln3899">        fp = (char *)ip-&gt;bw_conv_buf + ip-&gt;bw_conv_buflen - fromlen;</a>
<a name="ln3900">        memmove(fp, ip-&gt;bw_rest, (size_t)ip-&gt;bw_restlen);</a>
<a name="ln3901">        memmove(fp + ip-&gt;bw_restlen, buf, (size_t)len);</a>
<a name="ln3902">        from = fp;</a>
<a name="ln3903">        tolen = ip-&gt;bw_conv_buflen - fromlen;</a>
<a name="ln3904">      } else {</a>
<a name="ln3905">        from = (const char *)buf;</a>
<a name="ln3906">        fromlen = (size_t)len;</a>
<a name="ln3907">        tolen = ip-&gt;bw_conv_buflen;</a>
<a name="ln3908">      }</a>
<a name="ln3909">      to = (char *)ip-&gt;bw_conv_buf;</a>
<a name="ln3910"> </a>
<a name="ln3911">      if (ip-&gt;bw_first) {</a>
<a name="ln3912">        size_t save_len = tolen;</a>
<a name="ln3913"> </a>
<a name="ln3914">        // output the initial shift state sequence</a>
<a name="ln3915">        (void)iconv(ip-&gt;bw_iconv_fd, NULL, NULL, &amp;to, &amp;tolen);</a>
<a name="ln3916"> </a>
<a name="ln3917">        // There is a bug in iconv() on Linux (which appears to be</a>
<a name="ln3918">        // wide-spread) which sets &quot;to&quot; to NULL and messes up &quot;tolen&quot;.</a>
<a name="ln3919">        if (to == NULL) {</a>
<a name="ln3920">          to = (char *)ip-&gt;bw_conv_buf;</a>
<a name="ln3921">          tolen = save_len;</a>
<a name="ln3922">        }</a>
<a name="ln3923">        ip-&gt;bw_first = false;</a>
<a name="ln3924">      }</a>
<a name="ln3925"> </a>
<a name="ln3926">      // If iconv() has an error or there is not enough room, fail.</a>
<a name="ln3927">      if ((iconv(ip-&gt;bw_iconv_fd, (void *)&amp;from, &amp;fromlen, &amp;to, &amp;tolen)</a>
<a name="ln3928">           == (size_t)-1 &amp;&amp; ICONV_ERRNO != ICONV_EINVAL)</a>
<a name="ln3929">          || fromlen &gt; CONV_RESTLEN) {</a>
<a name="ln3930">        ip-&gt;bw_conv_error = true;</a>
<a name="ln3931">        return FAIL;</a>
<a name="ln3932">      }</a>
<a name="ln3933"> </a>
<a name="ln3934">      // copy remainder to ip-&gt;bw_rest[] to be used for the next call.</a>
<a name="ln3935">      if (fromlen &gt; 0) {</a>
<a name="ln3936">        memmove(ip-&gt;bw_rest, (void *)from, fromlen);</a>
<a name="ln3937">      }</a>
<a name="ln3938">      ip-&gt;bw_restlen = (int)fromlen;</a>
<a name="ln3939"> </a>
<a name="ln3940">      buf = ip-&gt;bw_conv_buf;</a>
<a name="ln3941">      len = (int)((char_u *)to - ip-&gt;bw_conv_buf);</a>
<a name="ln3942">    }</a>
<a name="ln3943">#endif</a>
<a name="ln3944">  }</a>
<a name="ln3945"> </a>
<a name="ln3946">  if (ip-&gt;bw_fd &lt; 0) {</a>
<a name="ln3947">    // Only checking conversion, which is OK if we get here.</a>
<a name="ln3948">    return OK;</a>
<a name="ln3949">  }</a>
<a name="ln3950">  wlen = (int)write_eintr(ip-&gt;bw_fd, buf, (size_t)len);</a>
<a name="ln3951">  return (wlen &lt; len) ? FAIL : OK;</a>
<a name="ln3952">}</a>
<a name="ln3953"> </a>
<a name="ln3954">/// Convert a Unicode character to bytes.</a>
<a name="ln3955">///</a>
<a name="ln3956">/// @param c character to convert</a>
<a name="ln3957">/// @param[in,out] pp pointer to store the result at</a>
<a name="ln3958">/// @param flags FIO_ flags that specify which encoding to use</a>
<a name="ln3959">///</a>
<a name="ln3960">/// @return true for an error, false when it's OK.</a>
<a name="ln3961">static bool ucs2bytes(unsigned c, char_u **pp, int flags) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3962">{</a>
<a name="ln3963">  char_u *p = *pp;</a>
<a name="ln3964">  bool error = false;</a>
<a name="ln3965">  int cc;</a>
<a name="ln3966"> </a>
<a name="ln3967">  if (flags &amp; FIO_UCS4) {</a>
<a name="ln3968">    if (flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln3969">      *p++ = (uint8_t)c;</a>
<a name="ln3970">      *p++ = (uint8_t)(c &gt;&gt; 8);</a>
<a name="ln3971">      *p++ = (uint8_t)(c &gt;&gt; 16);</a>
<a name="ln3972">      *p++ = (uint8_t)(c &gt;&gt; 24);</a>
<a name="ln3973">    } else {</a>
<a name="ln3974">      *p++ = (uint8_t)(c &gt;&gt; 24);</a>
<a name="ln3975">      *p++ = (uint8_t)(c &gt;&gt; 16);</a>
<a name="ln3976">      *p++ = (uint8_t)(c &gt;&gt; 8);</a>
<a name="ln3977">      *p++ = (uint8_t)c;</a>
<a name="ln3978">    }</a>
<a name="ln3979">  } else if (flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln3980">    if (c &gt;= 0x10000) {</a>
<a name="ln3981">      if (flags &amp; FIO_UTF16) {</a>
<a name="ln3982">        // Make two words, ten bits of the character in each.  First</a>
<a name="ln3983">        // word is 0xd800 - 0xdbff, second one 0xdc00 - 0xdfff</a>
<a name="ln3984">        c -= 0x10000;</a>
<a name="ln3985">        if (c &gt;= 0x100000) {</a>
<a name="ln3986">          error = true;</a>
<a name="ln3987">        }</a>
<a name="ln3988">        cc = (int)(((c &gt;&gt; 10) &amp; 0x3ff) + 0xd800);</a>
<a name="ln3989">        if (flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln3990">          *p++ = (uint8_t)cc;</a>
<a name="ln3991">          *p++ = (uint8_t)(cc &gt;&gt; 8);</a>
<a name="ln3992">        } else {</a>
<a name="ln3993">          *p++ = (uint8_t)(cc &gt;&gt; 8);</a>
<a name="ln3994">          *p++ = (uint8_t)cc;</a>
<a name="ln3995">        }</a>
<a name="ln3996">        c = (c &amp; 0x3ff) + 0xdc00;</a>
<a name="ln3997">      } else {</a>
<a name="ln3998">        error = true;</a>
<a name="ln3999">      }</a>
<a name="ln4000">    }</a>
<a name="ln4001">    if (flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln4002">      *p++ = (uint8_t)c;</a>
<a name="ln4003">      *p++ = (uint8_t)(c &gt;&gt; 8);</a>
<a name="ln4004">    } else {</a>
<a name="ln4005">      *p++ = (uint8_t)(c &gt;&gt; 8);</a>
<a name="ln4006">      *p++ = (uint8_t)c;</a>
<a name="ln4007">    }</a>
<a name="ln4008">  } else {  // Latin1</a>
<a name="ln4009">    if (c &gt;= 0x100) {</a>
<a name="ln4010">      error = true;</a>
<a name="ln4011">      *p++ = 0xBF;</a>
<a name="ln4012">    } else {</a>
<a name="ln4013">      *p++ = (uint8_t)c;</a>
<a name="ln4014">    }</a>
<a name="ln4015">  }</a>
<a name="ln4016"> </a>
<a name="ln4017">  *pp = p;</a>
<a name="ln4018">  return error;</a>
<a name="ln4019">}</a>
<a name="ln4020"> </a>
<a name="ln4021">/// Return true if file encoding &quot;fenc&quot; requires conversion from or to</a>
<a name="ln4022">/// 'encoding'.</a>
<a name="ln4023">///</a>
<a name="ln4024">/// @param fenc file encoding to check</a>
<a name="ln4025">///</a>
<a name="ln4026">/// @return true if conversion is required</a>
<a name="ln4027">static bool need_conversion(const char *fenc)</a>
<a name="ln4028">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4029">{</a>
<a name="ln4030">  int same_encoding;</a>
<a name="ln4031">  int enc_flags;</a>
<a name="ln4032">  int fenc_flags;</a>
<a name="ln4033"> </a>
<a name="ln4034">  if (*fenc == NUL || strcmp(p_enc, fenc) == 0) {</a>
<a name="ln4035">    same_encoding = true;</a>
<a name="ln4036">    fenc_flags = 0;</a>
<a name="ln4037">  } else {</a>
<a name="ln4038">    // Ignore difference between &quot;ansi&quot; and &quot;latin1&quot;, &quot;ucs-4&quot; and</a>
<a name="ln4039">    // &quot;ucs-4be&quot;, etc.</a>
<a name="ln4040">    enc_flags = get_fio_flags((char_u *)p_enc);</a>
<a name="ln4041">    fenc_flags = get_fio_flags((char_u *)fenc);</a>
<a name="ln4042">    same_encoding = (enc_flags != 0 &amp;&amp; fenc_flags == enc_flags);</a>
<a name="ln4043">  }</a>
<a name="ln4044">  if (same_encoding) {</a>
<a name="ln4045">    // Specified file encoding matches UTF-8.</a>
<a name="ln4046">    return false;</a>
<a name="ln4047">  }</a>
<a name="ln4048"> </a>
<a name="ln4049">  // Encodings differ.  However, conversion is not needed when 'enc' is any</a>
<a name="ln4050">  // Unicode encoding and the file is UTF-8.</a>
<a name="ln4051">  return !(fenc_flags == FIO_UTF8);</a>
<a name="ln4052">}</a>
<a name="ln4053"> </a>
<a name="ln4054">/// Return the FIO_ flags needed for the internal conversion if 'name' was</a>
<a name="ln4055">/// unicode or latin1, otherwise 0. If &quot;name&quot; is an empty string,</a>
<a name="ln4056">/// use 'encoding'.</a>
<a name="ln4057">///</a>
<a name="ln4058">/// @param name string to check for encoding</a>
<a name="ln4059">static int get_fio_flags(const char_u *name)</a>
<a name="ln4060">{</a>
<a name="ln4061">  int prop;</a>
<a name="ln4062"> </a>
<a name="ln4063">  if (*name == NUL) {</a>
<a name="ln4064">    name = (char_u *)p_enc;</a>
<a name="ln4065">  }</a>
<a name="ln4066">  prop = enc_canon_props(name);</a>
<a name="ln4067">  if (prop &amp; ENC_UNICODE) {</a>
<a name="ln4068">    if (prop &amp; ENC_2BYTE) {</a>
<a name="ln4069">      if (prop &amp; ENC_ENDIAN_L) {</a>
<a name="ln4070">        return FIO_UCS2 | FIO_ENDIAN_L;</a>
<a name="ln4071">      }</a>
<a name="ln4072">      return FIO_UCS2;</a>
<a name="ln4073">    }</a>
<a name="ln4074">    if (prop &amp; ENC_4BYTE) {</a>
<a name="ln4075">      if (prop &amp; ENC_ENDIAN_L) {</a>
<a name="ln4076">        return FIO_UCS4 | FIO_ENDIAN_L;</a>
<a name="ln4077">      }</a>
<a name="ln4078">      return FIO_UCS4;</a>
<a name="ln4079">    }</a>
<a name="ln4080">    if (prop &amp; ENC_2WORD) {</a>
<a name="ln4081">      if (prop &amp; ENC_ENDIAN_L) {</a>
<a name="ln4082">        return FIO_UTF16 | FIO_ENDIAN_L;</a>
<a name="ln4083">      }</a>
<a name="ln4084">      return FIO_UTF16;</a>
<a name="ln4085">    }</a>
<a name="ln4086">    return FIO_UTF8;</a>
<a name="ln4087">  }</a>
<a name="ln4088">  if (prop &amp; ENC_LATIN1) {</a>
<a name="ln4089">    return FIO_LATIN1;</a>
<a name="ln4090">  }</a>
<a name="ln4091">  // must be ENC_DBCS, requires iconv()</a>
<a name="ln4092">  return 0;</a>
<a name="ln4093">}</a>
<a name="ln4094"> </a>
<a name="ln4095">/// Check for a Unicode BOM (Byte Order Mark) at the start of p[size].</a>
<a name="ln4096">/// &quot;size&quot; must be at least 2.</a>
<a name="ln4097">///</a>
<a name="ln4098">/// @return  the name of the encoding and set &quot;*lenp&quot; to the length or,</a>
<a name="ln4099">///          NULL when no BOM found.</a>
<a name="ln4100">static char_u *check_for_bom(char_u *p, long size, int *lenp, int flags)</a>
<a name="ln4101">{</a>
<a name="ln4102">  char *name = NULL;</a>
<a name="ln4103">  int len = 2;</a>
<a name="ln4104"> </a>
<a name="ln4105">  if (p[0] == 0xef &amp;&amp; p[1] == 0xbb &amp;&amp; size &gt;= 3 &amp;&amp; p[2] == 0xbf</a>
<a name="ln4106">      &amp;&amp; (flags == FIO_ALL || flags == FIO_UTF8 || flags == 0)) {</a>
<a name="ln4107">    name = &quot;utf-8&quot;;             // EF BB BF</a>
<a name="ln4108">    len = 3;</a>
<a name="ln4109">  } else if (p[0] == 0xff &amp;&amp; p[1] == 0xfe) {</a>
<a name="ln4110">    if (size &gt;= 4 &amp;&amp; p[2] == 0 &amp;&amp; p[3] == 0</a>
<a name="ln4111">        &amp;&amp; (flags == FIO_ALL || flags == (FIO_UCS4 | FIO_ENDIAN_L))) {</a>
<a name="ln4112">      name = &quot;ucs-4le&quot;;         // FF FE 00 00</a>
<a name="ln4113">      len = 4;</a>
<a name="ln4114">    } else if (flags == (FIO_UCS2 | FIO_ENDIAN_L)) {</a>
<a name="ln4115">      name = &quot;ucs-2le&quot;;         // FF FE</a>
<a name="ln4116">    } else if (flags == FIO_ALL</a>
<a name="ln4117">               || flags == (FIO_UTF16 | FIO_ENDIAN_L)) {</a>
<a name="ln4118">      // utf-16le is preferred, it also works for ucs-2le text</a>
<a name="ln4119">      name = &quot;utf-16le&quot;;        // FF FE</a>
<a name="ln4120">    }</a>
<a name="ln4121">  } else if (p[0] == 0xfe &amp;&amp; p[1] == 0xff</a>
<a name="ln4122">             &amp;&amp; (flags == FIO_ALL || flags == FIO_UCS2 || flags ==</a>
<a name="ln4123">                 FIO_UTF16)) {</a>
<a name="ln4124">    // Default to utf-16, it works also for ucs-2 text.</a>
<a name="ln4125">    if (flags == FIO_UCS2) {</a>
<a name="ln4126">      name = &quot;ucs-2&quot;;           // FE FF</a>
<a name="ln4127">    } else {</a>
<a name="ln4128">      name = &quot;utf-16&quot;;          // FE FF</a>
<a name="ln4129">    }</a>
<a name="ln4130">  } else if (size &gt;= 4 &amp;&amp; p[0] == 0 &amp;&amp; p[1] == 0 &amp;&amp; p[2] == 0xfe</a>
<a name="ln4131">             &amp;&amp; p[3] == 0xff &amp;&amp; (flags == FIO_ALL || flags == FIO_UCS4)) {</a>
<a name="ln4132">    name = &quot;ucs-4&quot;;             // 00 00 FE FF</a>
<a name="ln4133">    len = 4;</a>
<a name="ln4134">  }</a>
<a name="ln4135"> </a>
<a name="ln4136">  *lenp = len;</a>
<a name="ln4137">  return (char_u *)name;</a>
<a name="ln4138">}</a>
<a name="ln4139"> </a>
<a name="ln4140">/// Generate a BOM in &quot;buf[4]&quot; for encoding &quot;name&quot;.</a>
<a name="ln4141">///</a>
<a name="ln4142">/// @return  the length of the BOM (zero when no BOM).</a>
<a name="ln4143">static int make_bom(char_u *buf, char_u *name)</a>
<a name="ln4144">{</a>
<a name="ln4145">  int flags;</a>
<a name="ln4146">  char_u *p;</a>
<a name="ln4147"> </a>
<a name="ln4148">  flags = get_fio_flags(name);</a>
<a name="ln4149"> </a>
<a name="ln4150">  // Can't put a BOM in a non-Unicode file.</a>
<a name="ln4151">  if (flags == FIO_LATIN1 || flags == 0) {</a>
<a name="ln4152">    return 0;</a>
<a name="ln4153">  }</a>
<a name="ln4154"> </a>
<a name="ln4155">  if (flags == FIO_UTF8) {      // UTF-8</a>
<a name="ln4156">    buf[0] = 0xef;</a>
<a name="ln4157">    buf[1] = 0xbb;</a>
<a name="ln4158">    buf[2] = 0xbf;</a>
<a name="ln4159">    return 3;</a>
<a name="ln4160">  }</a>
<a name="ln4161">  p = buf;</a>
<a name="ln4162">  (void)ucs2bytes(0xfeff, &amp;p, flags);</a>
<a name="ln4163">  return (int)(p - buf);</a>
<a name="ln4164">}</a>
<a name="ln4165"> </a>
<a name="ln4166">/// Shorten filename of a buffer.</a>
<a name="ln4167">///</a>
<a name="ln4168">/// @param force  when true: Use full path from now on for files currently being</a>
<a name="ln4169">///               edited, both for file name and swap file name.  Try to shorten the file</a>
<a name="ln4170">///               names a bit, if safe to do so.</a>
<a name="ln4171">///               when false: Only try to shorten absolute file names.</a>
<a name="ln4172">///</a>
<a name="ln4173">/// For buffers that have buftype &quot;nofile&quot; or &quot;scratch&quot;: never change the file</a>
<a name="ln4174">/// name.</a>
<a name="ln4175">void shorten_buf_fname(buf_T *buf, char_u *dirname, int force)</a>
<a name="ln4176">{</a>
<a name="ln4177">  char *p;</a>
<a name="ln4178"> </a>
<a name="ln4179">  if (buf-&gt;b_fname != NULL</a>
<a name="ln4180">      &amp;&amp; !bt_nofilename(buf)</a>
<a name="ln4181">      &amp;&amp; !path_with_url(buf-&gt;b_fname)</a>
<a name="ln4182">      &amp;&amp; (force</a>
<a name="ln4183">          || buf-&gt;b_sfname == NULL</a>
<a name="ln4184">          || path_is_absolute((char_u *)buf-&gt;b_sfname))) {</a>
<a name="ln4185">    if (buf-&gt;b_sfname != buf-&gt;b_ffname) {</a>
<a name="ln4186">      XFREE_CLEAR(buf-&gt;b_sfname);</a>
<a name="ln4187">    }</a>
<a name="ln4188">    p = path_shorten_fname(buf-&gt;b_ffname, (char *)dirname);</a>
<a name="ln4189">    if (p != NULL) {</a>
<a name="ln4190">      buf-&gt;b_sfname = xstrdup(p);</a>
<a name="ln4191">      buf-&gt;b_fname = buf-&gt;b_sfname;</a>
<a name="ln4192">    }</a>
<a name="ln4193">    if (p == NULL) {</a>
<a name="ln4194">      buf-&gt;b_fname = buf-&gt;b_ffname;</a>
<a name="ln4195">    }</a>
<a name="ln4196">  }</a>
<a name="ln4197">}</a>
<a name="ln4198"> </a>
<a name="ln4199">/// Shorten filenames for all buffers.</a>
<a name="ln4200">void shorten_fnames(int force)</a>
<a name="ln4201">{</a>
<a name="ln4202">  char_u dirname[MAXPATHL];</a>
<a name="ln4203"> </a>
<a name="ln4204">  os_dirname(dirname, MAXPATHL);</a>
<a name="ln4205">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln4206">    shorten_buf_fname(buf, dirname, force);</a>
<a name="ln4207"> </a>
<a name="ln4208">    // Always make the swap file name a full path, a &quot;nofile&quot; buffer may</a>
<a name="ln4209">    // also have a swap file.</a>
<a name="ln4210">    mf_fullname(buf-&gt;b_ml.ml_mfp);</a>
<a name="ln4211">  }</a>
<a name="ln4212">  status_redraw_all();</a>
<a name="ln4213">  redraw_tabline = true;</a>
<a name="ln4214">}</a>
<a name="ln4215"> </a>
<a name="ln4216">/// Get new filename ended by given extension.</a>
<a name="ln4217">///</a>
<a name="ln4218">/// @param fname        The original filename.</a>
<a name="ln4219">///                     If NULL, use current directory name and ext to</a>
<a name="ln4220">///                     compute new filename.</a>
<a name="ln4221">/// @param ext          The extension to add to the filename.</a>
<a name="ln4222">///                     4 chars max if prefixed with a dot, 3 otherwise.</a>
<a name="ln4223">/// @param prepend_dot  If true, prefix ext with a dot.</a>
<a name="ln4224">///                     Does nothing if ext already starts with a dot, or</a>
<a name="ln4225">///                     if fname is NULL.</a>
<a name="ln4226">///</a>
<a name="ln4227">/// @return [allocated] - A new filename, made up from:</a>
<a name="ln4228">///                       * fname + ext, if fname not NULL.</a>
<a name="ln4229">///                       * current dir + ext, if fname is NULL.</a>
<a name="ln4230">///                       Result is guaranteed to:</a>
<a name="ln4231">///                       * be ended by &lt;ext&gt;.</a>
<a name="ln4232">///                       * have a basename with at most BASENAMELEN chars:</a>
<a name="ln4233">///                         original basename is truncated if necessary.</a>
<a name="ln4234">///                       * be different than original: basename chars are</a>
<a name="ln4235">///                         replaced by &quot;_&quot; if necessary. If that can't be done</a>
<a name="ln4236">///                         because truncated value of original filename was</a>
<a name="ln4237">///                         made of all underscores, replace first &quot;_&quot; by &quot;v&quot;.</a>
<a name="ln4238">///                     - NULL, if fname is NULL and there was a problem trying</a>
<a name="ln4239">///                       to get current directory.</a>
<a name="ln4240">char *modname(const char *fname, const char *ext, bool prepend_dot)</a>
<a name="ln4241">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln4242">{</a>
<a name="ln4243">  char *retval;</a>
<a name="ln4244">  size_t fnamelen;</a>
<a name="ln4245">  size_t extlen = strlen(ext);</a>
<a name="ln4246"> </a>
<a name="ln4247">  // If there is no file name we must get the name of the current directory</a>
<a name="ln4248">  // (we need the full path in case :cd is used).</a>
<a name="ln4249">  if (fname == NULL || *fname == NUL) {</a>
<a name="ln4250">    retval = xmalloc(MAXPATHL + extlen + 3);  // +3 for PATHSEP, &quot;_&quot; (Win), NUL</a>
<a name="ln4251">    if (os_dirname((char_u *)retval, MAXPATHL) == FAIL</a>
<a name="ln4252">        || strlen(retval) == 0) {</a>
<a name="ln4253">      xfree(retval);</a>
<a name="ln4254">      return NULL;</a>
<a name="ln4255">    }</a>
<a name="ln4256">    add_pathsep(retval);</a>
<a name="ln4257">    fnamelen = strlen(retval);</a>
<a name="ln4258">    prepend_dot = false;  // nothing to prepend a dot to</a>
<a name="ln4259">  } else {</a>
<a name="ln4260">    fnamelen = strlen(fname);</a>
<a name="ln4261">    retval = xmalloc(fnamelen + extlen + 3);</a>
<a name="ln4262">    strcpy(retval, fname);  // NOLINT(runtime/printf)</a>
<a name="ln4263">  }</a>
<a name="ln4264"> </a>
<a name="ln4265">  // Search backwards until we hit a '/', '\' or ':'.</a>
<a name="ln4266">  // Then truncate what is after the '/', '\' or ':' to BASENAMELEN characters.</a>
<a name="ln4267">  char *ptr = NULL;</a>
<a name="ln4268">  for (ptr = retval + fnamelen; ptr &gt; retval; MB_PTR_BACK(retval, ptr)) {</a>
<a name="ln4269">    if (vim_ispathsep(*ptr)) {</a>
<a name="ln4270">      ptr++;</a>
<a name="ln4271">      break;</a>
<a name="ln4272">    }</a>
<a name="ln4273">  }</a>
<a name="ln4274"> </a>
<a name="ln4275">  // the file name has at most BASENAMELEN characters.</a>
<a name="ln4276">  if (strlen(ptr) &gt; BASENAMELEN) {</a>
<a name="ln4277">    ptr[BASENAMELEN] = '\0';</a>
<a name="ln4278">  }</a>
<a name="ln4279"> </a>
<a name="ln4280">  char *s = ptr + strlen(ptr);</a>
<a name="ln4281"> </a>
<a name="ln4282">  // Append the extension.</a>
<a name="ln4283">  // ext can start with '.' and cannot exceed 3 more characters.</a>
<a name="ln4284">  strcpy(s, ext);  // NOLINT(runtime/printf)</a>
<a name="ln4285"> </a>
<a name="ln4286">  char *e;</a>
<a name="ln4287">  // Prepend the dot if needed.</a>
<a name="ln4288">  if (prepend_dot &amp;&amp; *(e = path_tail(retval)) != '.') {</a>
<a name="ln4289">    STRMOVE(e + 1, e);</a>
<a name="ln4290">    *e = '.';</a>
<a name="ln4291">  }</a>
<a name="ln4292"> </a>
<a name="ln4293">  // Check that, after appending the extension, the file name is really</a>
<a name="ln4294">  // different.</a>
<a name="ln4295">  if (fname != NULL &amp;&amp; strcmp(fname, retval) == 0) {</a>
<a name="ln4296">    // we search for a character that can be replaced by '_'</a>
<a name="ln4297">    while (--s &gt;= ptr) {</a>
<a name="ln4298">      if (*s != '_') {</a>
<a name="ln4299">        *s = '_';</a>
<a name="ln4300">        break;</a>
<a name="ln4301">      }</a>
<a name="ln4302">    }</a>
<a name="ln4303">    if (s &lt; ptr) {  // fname was &quot;________.&lt;ext&gt;&quot;, how tricky!</a>
<a name="ln4304">      *ptr = 'v';</a>
<a name="ln4305">    }</a>
<a name="ln4306">  }</a>
<a name="ln4307">  return retval;</a>
<a name="ln4308">}</a>
<a name="ln4309"> </a>
<a name="ln4310">/// Like fgets(), but if the file line is too long, it is truncated and the</a>
<a name="ln4311">/// rest of the line is thrown away.</a>
<a name="ln4312">///</a>
<a name="ln4313">/// @param[out] buf buffer to fill</a>
<a name="ln4314">/// @param size size of the buffer</a>
<a name="ln4315">/// @param fp file to read from</a>
<a name="ln4316">///</a>
<a name="ln4317">/// @return true for EOF or error</a>
<a name="ln4318">bool vim_fgets(char_u *buf, int size, FILE *fp) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4319">{</a>
<a name="ln4320">  char *retval;</a>
<a name="ln4321"> </a>
<a name="ln4322">  assert(size &gt; 0);</a>
<a name="ln4323">  buf[size - 2] = NUL;</a>
<a name="ln4324"> </a>
<a name="ln4325">  do {</a>
<a name="ln4326">    errno = 0;</a>
<a name="ln4327">    retval = fgets((char *)buf, size, fp);</a>
<a name="ln4328">  } while (retval == NULL &amp;&amp; errno == EINTR &amp;&amp; ferror(fp));</a>
<a name="ln4329"> </a>
<a name="ln4330">  if (buf[size - 2] != NUL &amp;&amp; buf[size - 2] != '\n') {</a>
<a name="ln4331">    char tbuf[200];</a>
<a name="ln4332"> </a>
<a name="ln4333">    buf[size - 1] = NUL;  // Truncate the line.</a>
<a name="ln4334"> </a>
<a name="ln4335">    // Now throw away the rest of the line:</a>
<a name="ln4336">    do {</a>
<a name="ln4337">      tbuf[sizeof(tbuf) - 2] = NUL;</a>
<a name="ln4338">      errno = 0;</a>
<a name="ln4339">      retval = fgets((char *)tbuf, sizeof(tbuf), fp);</a>
<a name="ln4340">      if (retval == NULL &amp;&amp; (feof(fp) || errno != EINTR)) {</a>
<a name="ln4341">        break;</a>
<a name="ln4342">      }</a>
<a name="ln4343">    } while (tbuf[sizeof(tbuf) - 2] != NUL &amp;&amp; tbuf[sizeof(tbuf) - 2] != '\n');</a>
<a name="ln4344">  }</a>
<a name="ln4345">  return retval == NULL;</a>
<a name="ln4346">}</a>
<a name="ln4347"> </a>
<a name="ln4348">/// Read 2 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln4349">///</a>
<a name="ln4350">/// @return  -1 when encountering EOF.</a>
<a name="ln4351">int get2c(FILE *fd)</a>
<a name="ln4352">{</a>
<a name="ln4353">  const int n = getc(fd);</a>
<a name="ln4354">  if (n == EOF) {</a>
<a name="ln4355">    return -1;</a>
<a name="ln4356">  }</a>
<a name="ln4357">  const int c = getc(fd);</a>
<a name="ln4358">  if (c == EOF) {</a>
<a name="ln4359">    return -1;</a>
<a name="ln4360">  }</a>
<a name="ln4361">  return (n &lt;&lt; 8) + c;</a>
<a name="ln4362">}</a>
<a name="ln4363"> </a>
<a name="ln4364">/// Read 3 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln4365">///</a>
<a name="ln4366">/// @return  -1 when encountering EOF.</a>
<a name="ln4367">int get3c(FILE *fd)</a>
<a name="ln4368">{</a>
<a name="ln4369">  int n = getc(fd);</a>
<a name="ln4370">  if (n == EOF) {</a>
<a name="ln4371">    return -1;</a>
<a name="ln4372">  }</a>
<a name="ln4373">  int c = getc(fd);</a>
<a name="ln4374">  if (c == EOF) {</a>
<a name="ln4375">    return -1;</a>
<a name="ln4376">  }</a>
<a name="ln4377">  n = (n &lt;&lt; 8) + c;</a>
<a name="ln4378">  c = getc(fd);</a>
<a name="ln4379">  if (c == EOF) {</a>
<a name="ln4380">    return -1;</a>
<a name="ln4381">  }</a>
<a name="ln4382">  return (n &lt;&lt; 8) + c;</a>
<a name="ln4383">}</a>
<a name="ln4384"> </a>
<a name="ln4385">/// Read 4 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln4386">///</a>
<a name="ln4387">/// @return  -1 when encountering EOF.</a>
<a name="ln4388">int get4c(FILE *fd)</a>
<a name="ln4389">{</a>
<a name="ln4390">  // Use unsigned rather than int otherwise result is undefined</a>
<a name="ln4391">  // when left-shift sets the MSB.</a>
<a name="ln4392">  unsigned n;</a>
<a name="ln4393"> </a>
<a name="ln4394">  int c = getc(fd);</a>
<a name="ln4395">  if (c == EOF) {</a>
<a name="ln4396">    return -1;</a>
<a name="ln4397">  }</a>
<a name="ln4398">  n = (unsigned)c;</a>
<a name="ln4399">  c = getc(fd);</a>
<a name="ln4400">  if (c == EOF) {</a>
<a name="ln4401">    return -1;</a>
<a name="ln4402">  }</a>
<a name="ln4403">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln4404">  c = getc(fd);</a>
<a name="ln4405">  if (c == EOF) {</a>
<a name="ln4406">    return -1;</a>
<a name="ln4407">  }</a>
<a name="ln4408">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln4409">  c = getc(fd);</a>
<a name="ln4410">  if (c == EOF) {</a>
<a name="ln4411">    return -1;</a>
<a name="ln4412">  }</a>
<a name="ln4413">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln4414">  return (int)n;</a>
<a name="ln4415">}</a>
<a name="ln4416"> </a>
<a name="ln4417">/// Read 8 bytes from `fd` and turn them into a time_t, MSB first.</a>
<a name="ln4418">///</a>
<a name="ln4419">/// @return  -1 when encountering EOF.</a>
<a name="ln4420">time_t get8ctime(FILE *fd)</a>
<a name="ln4421">{</a>
<a name="ln4422">  time_t n = 0;</a>
<a name="ln4423"> </a>
<a name="ln4424">  for (int i = 0; i &lt; 8; i++) {</a>
<a name="ln4425">    const int c = getc(fd);</a>
<a name="ln4426">    if (c == EOF) {</a>
<a name="ln4427">      return -1;</a>
<a name="ln4428">    }</a>
<a name="ln4429">    n = (n &lt;&lt; 8) + c;</a>
<a name="ln4430">  }</a>
<a name="ln4431">  return n;</a>
<a name="ln4432">}</a>
<a name="ln4433"> </a>
<a name="ln4434">/// Reads a string of length &quot;cnt&quot; from &quot;fd&quot; into allocated memory.</a>
<a name="ln4435">///</a>
<a name="ln4436">/// @return  pointer to the string or NULL when unable to read that many bytes.</a>
<a name="ln4437">char *read_string(FILE *fd, size_t cnt)</a>
<a name="ln4438">{</a>
<a name="ln4439">  char *str = xmallocz(cnt);</a>
<a name="ln4440">  for (size_t i = 0; i &lt; cnt; i++) {</a>
<a name="ln4441">    int c = getc(fd);</a>
<a name="ln4442">    if (c == EOF) {</a>
<a name="ln4443">      xfree(str);</a>
<a name="ln4444">      return NULL;</a>
<a name="ln4445">    }</a>
<a name="ln4446">    str[i] = (char)c;</a>
<a name="ln4447">  }</a>
<a name="ln4448">  return str;</a>
<a name="ln4449">}</a>
<a name="ln4450"> </a>
<a name="ln4451">/// Writes a number to file &quot;fd&quot;, most significant bit first, in &quot;len&quot; bytes.</a>
<a name="ln4452">///</a>
<a name="ln4453">/// @return  false in case of an error.</a>
<a name="ln4454">bool put_bytes(FILE *fd, uintmax_t number, size_t len)</a>
<a name="ln4455">{</a>
<a name="ln4456">  assert(len &gt; 0);</a>
<a name="ln4457">  for (size_t i = len - 1; i &lt; len; i--) {</a>
<a name="ln4458">    if (putc((int)(number &gt;&gt; (i * 8)), fd) == EOF) {</a>
<a name="ln4459">      return false;</a>
<a name="ln4460">    }</a>
<a name="ln4461">  }</a>
<a name="ln4462">  return true;</a>
<a name="ln4463">}</a>
<a name="ln4464"> </a>
<a name="ln4465">/// Writes time_t to file &quot;fd&quot; in 8 bytes.</a>
<a name="ln4466">///</a>
<a name="ln4467">/// @return  FAIL when the write failed.</a>
<a name="ln4468">int put_time(FILE *fd, time_t time_)</a>
<a name="ln4469">{</a>
<a name="ln4470">  uint8_t buf[8];</a>
<a name="ln4471">  time_to_bytes(time_, buf);</a>
<a name="ln4472">  return fwrite(buf, sizeof(uint8_t), ARRAY_SIZE(buf), fd) == 1 ? OK : FAIL;</a>
<a name="ln4473">}</a>
<a name="ln4474"> </a>
<a name="ln4475">/// os_rename() only works if both files are on the same file system, this</a>
<a name="ln4476">/// function will (attempts to?) copy the file across if rename fails -- webb</a>
<a name="ln4477">///</a>
<a name="ln4478">/// @return  -1 for failure, 0 for success</a>
<a name="ln4479">int vim_rename(const char *from, const char *to)</a>
<a name="ln4480">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4481">{</a>
<a name="ln4482">  int fd_in;</a>
<a name="ln4483">  int fd_out;</a>
<a name="ln4484">  int n;</a>
<a name="ln4485">  char *errmsg = NULL;</a>
<a name="ln4486">  char *buffer;</a>
<a name="ln4487">  long perm;</a>
<a name="ln4488">#ifdef HAVE_ACL</a>
<a name="ln4489">  vim_acl_T acl;                // ACL from original file</a>
<a name="ln4490">#endif</a>
<a name="ln4491">  bool use_tmp_file = false;</a>
<a name="ln4492"> </a>
<a name="ln4493">  // When the names are identical, there is nothing to do.  When they refer</a>
<a name="ln4494">  // to the same file (ignoring case and slash/backslash differences) but</a>
<a name="ln4495">  // the file name differs we need to go through a temp file.</a>
<a name="ln4496">  if (path_fnamecmp(from, to) == 0) {</a>
<a name="ln4497">    if (p_fic &amp;&amp; (strcmp(path_tail((char *)from), path_tail((char *)to))</a>
<a name="ln4498">                  != 0)) {</a>
<a name="ln4499">      use_tmp_file = true;</a>
<a name="ln4500">    } else {</a>
<a name="ln4501">      return 0;</a>
<a name="ln4502">    }</a>
<a name="ln4503">  }</a>
<a name="ln4504"> </a>
<a name="ln4505">  // Fail if the &quot;from&quot; file doesn't exist. Avoids that &quot;to&quot; is deleted.</a>
<a name="ln4506">  FileInfo from_info;</a>
<a name="ln4507">  if (!os_fileinfo((char *)from, &amp;from_info)) {</a>
<a name="ln4508">    return -1;</a>
<a name="ln4509">  }</a>
<a name="ln4510"> </a>
<a name="ln4511">  // It's possible for the source and destination to be the same file.</a>
<a name="ln4512">  // This happens when &quot;from&quot; and &quot;to&quot; differ in case and are on a FAT32</a>
<a name="ln4513">  // filesystem. In that case go through a temp file name.</a>
<a name="ln4514">  FileInfo to_info;</a>
<a name="ln4515">  if (os_fileinfo((char *)to, &amp;to_info)</a>
<a name="ln4516">      &amp;&amp; os_fileinfo_id_equal(&amp;from_info,  &amp;to_info)) {</a>
<a name="ln4517">    use_tmp_file = true;</a>
<a name="ln4518">  }</a>
<a name="ln4519"> </a>
<a name="ln4520">  if (use_tmp_file) {</a>
<a name="ln4521">    char_u tempname[MAXPATHL + 1];</a>
<a name="ln4522"> </a>
<a name="ln4523">    // Find a name that doesn't exist and is in the same directory.</a>
<a name="ln4524">    // Rename &quot;from&quot; to &quot;tempname&quot; and then rename &quot;tempname&quot; to &quot;to&quot;.</a>
<a name="ln4525">    if (strlen(from) &gt;= MAXPATHL - 5) {</a>
<a name="ln4526">      return -1;</a>
<a name="ln4527">    }</a>
<a name="ln4528">    STRCPY(tempname, from);</a>
<a name="ln4529">    for (n = 123; n &lt; 99999; n++) {</a>
<a name="ln4530">      char *tail = path_tail((char *)tempname);</a>
<a name="ln4531">      snprintf(tail, (size_t)((MAXPATHL + 1) - (tail - (char *)tempname - 1)), &quot;%d&quot;, n);</a>
<a name="ln4532"> </a>
<a name="ln4533">      if (!os_path_exists((char *)tempname)) {</a>
<a name="ln4534">        if (os_rename((char_u *)from, tempname) == OK) {</a>
<a name="ln4535">          if (os_rename(tempname, (char_u *)to) == OK) {</a>
<a name="ln4536">            return 0;</a>
<a name="ln4537">          }</a>
<a name="ln4538">          // Strange, the second step failed.  Try moving the</a>
<a name="ln4539">          // file back and return failure.</a>
<a name="ln4540">          (void)os_rename(tempname, (char_u *)from);</a>
<a name="ln4541">          return -1;</a>
<a name="ln4542">        }</a>
<a name="ln4543">        // If it fails for one temp name it will most likely fail</a>
<a name="ln4544">        // for any temp name, give up.</a>
<a name="ln4545">        return -1;</a>
<a name="ln4546">      }</a>
<a name="ln4547">    }</a>
<a name="ln4548">    return -1;</a>
<a name="ln4549">  }</a>
<a name="ln4550"> </a>
<a name="ln4551">  // Delete the &quot;to&quot; file, this is required on some systems to make the</a>
<a name="ln4552">  // os_rename() work, on other systems it makes sure that we don't have</a>
<a name="ln4553">  // two files when the os_rename() fails.</a>
<a name="ln4554"> </a>
<a name="ln4555">  os_remove((char *)to);</a>
<a name="ln4556"> </a>
<a name="ln4557">  // First try a normal rename, return if it works.</a>
<a name="ln4558">  if (os_rename((char_u *)from, (char_u *)to) == OK) {</a>
<a name="ln4559">    return 0;</a>
<a name="ln4560">  }</a>
<a name="ln4561"> </a>
<a name="ln4562">  // Rename() failed, try copying the file.</a>
<a name="ln4563">  perm = os_getperm(from);</a>
<a name="ln4564">#ifdef HAVE_ACL</a>
<a name="ln4565">  // For systems that support ACL: get the ACL from the original file.</a>
<a name="ln4566">  acl = mch_get_acl((char_u *)from);</a>
<a name="ln4567">#endif</a>
<a name="ln4568">  fd_in = os_open((char *)from, O_RDONLY, 0);</a>
<a name="ln4569">  if (fd_in &lt; 0) {</a>
<a name="ln4570">#ifdef HAVE_ACL</a>
<a name="ln4571">    mch_free_acl(acl);</a>
<a name="ln4572">#endif</a>
<a name="ln4573">    return -1;</a>
<a name="ln4574">  }</a>
<a name="ln4575"> </a>
<a name="ln4576">  // Create the new file with same permissions as the original.</a>
<a name="ln4577">  fd_out = os_open((char *)to,</a>
<a name="ln4578">                   O_CREAT|O_EXCL|O_WRONLY|O_NOFOLLOW, (int)perm);</a>
<a name="ln4579">  if (fd_out &lt; 0) {</a>
<a name="ln4580">    close(fd_in);</a>
<a name="ln4581">#ifdef HAVE_ACL</a>
<a name="ln4582">    mch_free_acl(acl);</a>
<a name="ln4583">#endif</a>
<a name="ln4584">    return -1;</a>
<a name="ln4585">  }</a>
<a name="ln4586"> </a>
<a name="ln4587">  // Avoid xmalloc() here as vim_rename() is called by buf_write() when nvim</a>
<a name="ln4588">  // is `preserve_exit()`ing.</a>
<a name="ln4589">  buffer = try_malloc(BUFSIZE);</a>
<a name="ln4590">  if (buffer == NULL) {</a>
<a name="ln4591">    close(fd_out);</a>
<a name="ln4592">    close(fd_in);</a>
<a name="ln4593">#ifdef HAVE_ACL</a>
<a name="ln4594">    mch_free_acl(acl);</a>
<a name="ln4595">#endif</a>
<a name="ln4596">    return -1;</a>
<a name="ln4597">  }</a>
<a name="ln4598"> </a>
<a name="ln4599">  while ((n = (int)read_eintr(fd_in, buffer, BUFSIZE)) &gt; 0) {</a>
<a name="ln4600">    if (write_eintr(fd_out, buffer, (size_t)n) != n) {</a>
<a name="ln4601">      errmsg = _(&quot;E208: Error writing to \&quot;%s\&quot;&quot;);</a>
<a name="ln4602">      break;</a>
<a name="ln4603">    }</a>
<a name="ln4604">  }</a>
<a name="ln4605"> </a>
<a name="ln4606">  xfree(buffer);</a>
<a name="ln4607">  close(fd_in);</a>
<a name="ln4608">  if (close(fd_out) &lt; 0) {</a>
<a name="ln4609">    errmsg = _(&quot;E209: Error closing \&quot;%s\&quot;&quot;);</a>
<a name="ln4610">  }</a>
<a name="ln4611">  if (n &lt; 0) {</a>
<a name="ln4612">    errmsg = _(&quot;E210: Error reading \&quot;%s\&quot;&quot;);</a>
<a name="ln4613">    to = from;</a>
<a name="ln4614">  }</a>
<a name="ln4615">#ifndef UNIX  // For Unix os_open() already set the permission.</a>
<a name="ln4616">  os_setperm((const char *)to, perm);</a>
<a name="ln4617">#endif</a>
<a name="ln4618">#ifdef HAVE_ACL</a>
<a name="ln4619">  mch_set_acl((char_u *)to, acl);</a>
<a name="ln4620">  mch_free_acl(acl);</a>
<a name="ln4621">#endif</a>
<a name="ln4622">  if (errmsg != NULL) {</a>
<a name="ln4623">    semsg(errmsg, to);</a>
<a name="ln4624">    return -1;</a>
<a name="ln4625">  }</a>
<a name="ln4626">  os_remove((char *)from);</a>
<a name="ln4627">  return 0;</a>
<a name="ln4628">}</a>
<a name="ln4629"> </a>
<a name="ln4630">static int already_warned = false;</a>
<a name="ln4631"> </a>
<a name="ln4632">/// Check if any not hidden buffer has been changed.</a>
<a name="ln4633">/// Postpone the check if there are characters in the stuff buffer, a global</a>
<a name="ln4634">/// command is being executed, a mapping is being executed or an autocommand is</a>
<a name="ln4635">/// busy.</a>
<a name="ln4636">///</a>
<a name="ln4637">/// @param focus  called for GUI focus event</a>
<a name="ln4638">///</a>
<a name="ln4639">/// @return       true if some message was written (screen should be redrawn and cursor positioned).</a>
<a name="ln4640">int check_timestamps(int focus)</a>
<a name="ln4641">{</a>
<a name="ln4642">  int didit = 0;</a>
<a name="ln4643"> </a>
<a name="ln4644">  // Don't check timestamps while system() or another low-level function may</a>
<a name="ln4645">  // cause us to lose and gain focus.</a>
<a name="ln4646">  if (no_check_timestamps &gt; 0) {</a>
<a name="ln4647">    return false;</a>
<a name="ln4648">  }</a>
<a name="ln4649"> </a>
<a name="ln4650">  // Avoid doing a check twice.  The OK/Reload dialog can cause a focus</a>
<a name="ln4651">  // event and we would keep on checking if the file is steadily growing.</a>
<a name="ln4652">  // Do check again after typing something.</a>
<a name="ln4653">  if (focus &amp;&amp; did_check_timestamps) {</a>
<a name="ln4654">    need_check_timestamps = true;</a>
<a name="ln4655">    return false;</a>
<a name="ln4656">  }</a>
<a name="ln4657"> </a>
<a name="ln4658">  if (!stuff_empty() || global_busy || !typebuf_typed()</a>
<a name="ln4659">      || autocmd_busy || curbuf-&gt;b_ro_locked &gt; 0</a>
<a name="ln4660">      || allbuf_lock &gt; 0) {</a>
<a name="ln4661">    need_check_timestamps = true;               // check later</a>
<a name="ln4662">  } else {</a>
<a name="ln4663">    no_wait_return++;</a>
<a name="ln4664">    did_check_timestamps = true;</a>
<a name="ln4665">    already_warned = false;</a>
<a name="ln4666">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln4667">      // Only check buffers in a window.</a>
<a name="ln4668">      if (buf-&gt;b_nwindows &gt; 0) {</a>
<a name="ln4669">        bufref_T bufref;</a>
<a name="ln4670">        set_bufref(&amp;bufref, buf);</a>
<a name="ln4671">        const int n = buf_check_timestamp(buf);</a>
<a name="ln4672">        if (didit &lt; n) {</a>
<a name="ln4673">          didit = n;</a>
<a name="ln4674">        }</a>
<a name="ln4675">        if (n &gt; 0 &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln4676">          // Autocommands have removed the buffer, start at the first one again.</a>
<a name="ln4677">          buf = firstbuf;</a>
<a name="ln4678">          continue;</a>
<a name="ln4679">        }</a>
<a name="ln4680">      }</a>
<a name="ln4681">    }</a>
<a name="ln4682">    no_wait_return--;</a>
<a name="ln4683">    need_check_timestamps = false;</a>
<a name="ln4684">    if (need_wait_return &amp;&amp; didit == 2) {</a>
<a name="ln4685">      // make sure msg isn't overwritten</a>
<a name="ln4686">      msg_puts(&quot;\n&quot;);</a>
<a name="ln4687">      ui_flush();</a>
<a name="ln4688">    }</a>
<a name="ln4689">  }</a>
<a name="ln4690">  return didit;</a>
<a name="ln4691">}</a>
<a name="ln4692"> </a>
<a name="ln4693">/// Move all the lines from buffer &quot;frombuf&quot; to buffer &quot;tobuf&quot;.</a>
<a name="ln4694">///</a>
<a name="ln4695">/// @return  OK or FAIL.</a>
<a name="ln4696">///          When FAIL &quot;tobuf&quot; is incomplete and/or &quot;frombuf&quot; is not empty.</a>
<a name="ln4697">static int move_lines(buf_T *frombuf, buf_T *tobuf)</a>
<a name="ln4698">{</a>
<a name="ln4699">  buf_T *tbuf = curbuf;</a>
<a name="ln4700">  int retval = OK;</a>
<a name="ln4701">  linenr_T lnum;</a>
<a name="ln4702">  char *p;</a>
<a name="ln4703"> </a>
<a name="ln4704">  // Copy the lines in &quot;frombuf&quot; to &quot;tobuf&quot;.</a>
<a name="ln4705">  curbuf = tobuf;</a>
<a name="ln4706">  for (lnum = 1; lnum &lt;= frombuf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln4707">    p = xstrdup(ml_get_buf(frombuf, lnum, false));</a>
<a name="ln4708">    if (ml_append(lnum - 1, p, 0, false) == FAIL) {</a>
<a name="ln4709">      xfree(p);</a>
<a name="ln4710">      retval = FAIL;</a>
<a name="ln4711">      break;</a>
<a name="ln4712">    }</a>
<a name="ln4713">    xfree(p);</a>
<a name="ln4714">  }</a>
<a name="ln4715"> </a>
<a name="ln4716">  // Delete all the lines in &quot;frombuf&quot;.</a>
<a name="ln4717">  if (retval != FAIL) {</a>
<a name="ln4718">    curbuf = frombuf;</a>
<a name="ln4719">    for (lnum = curbuf-&gt;b_ml.ml_line_count; lnum &gt; 0; lnum--) {</a>
<a name="ln4720">      if (ml_delete(lnum, false) == FAIL) {</a>
<a name="ln4721">        // Oops!  We could try putting back the saved lines, but that</a>
<a name="ln4722">        // might fail again...</a>
<a name="ln4723">        retval = FAIL;</a>
<a name="ln4724">        break;</a>
<a name="ln4725">      }</a>
<a name="ln4726">    }</a>
<a name="ln4727">  }</a>
<a name="ln4728"> </a>
<a name="ln4729">  curbuf = tbuf;</a>
<a name="ln4730">  return retval;</a>
<a name="ln4731">}</a>
<a name="ln4732"> </a>
<a name="ln4733">/// Check if buffer &quot;buf&quot; has been changed.</a>
<a name="ln4734">/// Also check if the file for a new buffer unexpectedly appeared.</a>
<a name="ln4735">///</a>
<a name="ln4736">/// @return  1 if a changed buffer was found or,</a>
<a name="ln4737">///          2 if a message has been displayed or,</a>
<a name="ln4738">///          0 otherwise.</a>
<a name="ln4739">int buf_check_timestamp(buf_T *buf)</a>
<a name="ln4740">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4741">{</a>
<a name="ln4742">  int retval = 0;</a>
<a name="ln4743">  char *path;</a>
<a name="ln4744">  char *mesg = NULL;</a>
<a name="ln4745">  char *mesg2 = &quot;&quot;;</a>
<a name="ln4746">  bool helpmesg = false;</a>
<a name="ln4747"> </a>
<a name="ln4748">  enum {</a>
<a name="ln4749">    RELOAD_NONE,</a>
<a name="ln4750">    RELOAD_NORMAL,</a>
<a name="ln4751">    RELOAD_DETECT,</a>
<a name="ln4752">  } reload = RELOAD_NONE;</a>
<a name="ln4753"> </a>
<a name="ln4754">  bool can_reload = false;</a>
<a name="ln4755">  uint64_t orig_size = buf-&gt;b_orig_size;</a>
<a name="ln4756">  int orig_mode = buf-&gt;b_orig_mode;</a>
<a name="ln4757">  static bool busy = false;</a>
<a name="ln4758">  char *s;</a>
<a name="ln4759">  char *reason;</a>
<a name="ln4760"> </a>
<a name="ln4761">  bufref_T bufref;</a>
<a name="ln4762">  set_bufref(&amp;bufref, buf);</a>
<a name="ln4763"> </a>
<a name="ln4764">  // If its a terminal, there is no file name, the buffer is not loaded,</a>
<a name="ln4765">  // 'buftype' is set, we are in the middle of a save or being called</a>
<a name="ln4766">  // recursively: ignore this buffer.</a>
<a name="ln4767">  if (buf-&gt;terminal</a>
<a name="ln4768">      || buf-&gt;b_ffname == NULL</a>
<a name="ln4769">      || buf-&gt;b_ml.ml_mfp == NULL</a>
<a name="ln4770">      || !bt_normal(buf)</a>
<a name="ln4771">      || buf-&gt;b_saving</a>
<a name="ln4772">      || busy) {</a>
<a name="ln4773">    return 0;</a>
<a name="ln4774">  }</a>
<a name="ln4775"> </a>
<a name="ln4776">  FileInfo file_info;</a>
<a name="ln4777">  bool file_info_ok;</a>
<a name="ln4778">  if (!(buf-&gt;b_flags &amp; BF_NOTEDITED)</a>
<a name="ln4779">      &amp;&amp; buf-&gt;b_mtime != 0</a>
<a name="ln4780">      &amp;&amp; (!(file_info_ok = os_fileinfo(buf-&gt;b_ffname, &amp;file_info))</a>
<a name="ln4781">          || time_differs(&amp;file_info, buf-&gt;b_mtime, buf-&gt;b_mtime_ns)</a>
<a name="ln4782">          || (int)file_info.stat.st_mode != buf-&gt;b_orig_mode)) {</a>
<a name="ln4783">    const long prev_b_mtime = buf-&gt;b_mtime;</a>
<a name="ln4784"> </a>
<a name="ln4785">    retval = 1;</a>
<a name="ln4786"> </a>
<a name="ln4787">    // set b_mtime to stop further warnings (e.g., when executing</a>
<a name="ln4788">    // FileChangedShell autocmd)</a>
<a name="ln4789">    if (!file_info_ok) {</a>
<a name="ln4790">      // Check the file again later to see if it re-appears.</a>
<a name="ln4791">      buf-&gt;b_mtime = -1;</a>
<a name="ln4792">      buf-&gt;b_orig_size = 0;</a>
<a name="ln4793">      buf-&gt;b_orig_mode = 0;</a>
<a name="ln4794">    } else {</a>
<a name="ln4795">      buf_store_file_info(buf, &amp;file_info);</a>
<a name="ln4796">    }</a>
<a name="ln4797"> </a>
<a name="ln4798">    if (os_isdir(buf-&gt;b_fname)) {</a>
<a name="ln4799">      // Don't do anything for a directory.  Might contain the file explorer.</a>
<a name="ln4800">    } else if ((buf-&gt;b_p_ar &gt;= 0 ? buf-&gt;b_p_ar : p_ar)</a>
<a name="ln4801">               &amp;&amp; !bufIsChanged(buf) &amp;&amp; file_info_ok) {</a>
<a name="ln4802">      // If 'autoread' is set, the buffer has no changes and the file still</a>
<a name="ln4803">      // exists, reload the buffer.  Use the buffer-local option value if it</a>
<a name="ln4804">      // was set, the global option value otherwise.</a>
<a name="ln4805">      reload = RELOAD_NORMAL;</a>
<a name="ln4806">    } else {</a>
<a name="ln4807">      if (!file_info_ok) {</a>
<a name="ln4808">        reason = &quot;deleted&quot;;</a>
<a name="ln4809">      } else if (bufIsChanged(buf)) {</a>
<a name="ln4810">        reason = &quot;conflict&quot;;</a>
<a name="ln4811">      } else if (orig_size != buf-&gt;b_orig_size || buf_contents_changed(buf)) {</a>
<a name="ln4812">        reason = &quot;changed&quot;;</a>
<a name="ln4813">      } else if (orig_mode != buf-&gt;b_orig_mode) {</a>
<a name="ln4814">        reason = &quot;mode&quot;;</a>
<a name="ln4815">      } else {</a>
<a name="ln4816">        reason = &quot;time&quot;;</a>
<a name="ln4817">      }</a>
<a name="ln4818"> </a>
<a name="ln4819">      // Only give the warning if there are no FileChangedShell</a>
<a name="ln4820">      // autocommands.</a>
<a name="ln4821">      // Avoid being called recursively by setting &quot;busy&quot;.</a>
<a name="ln4822">      busy = true;</a>
<a name="ln4823">      set_vim_var_string(VV_FCS_REASON, reason, -1);</a>
<a name="ln4824">      set_vim_var_string(VV_FCS_CHOICE, &quot;&quot;, -1);</a>
<a name="ln4825">      allbuf_lock++;</a>
<a name="ln4826">      bool n = apply_autocmds(EVENT_FILECHANGEDSHELL, buf-&gt;b_fname, buf-&gt;b_fname, false, buf);</a>
<a name="ln4827">      allbuf_lock--;</a>
<a name="ln4828">      busy = false;</a>
<a name="ln4829">      if (n) {</a>
<a name="ln4830">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln4831">          emsg(_(&quot;E246: FileChangedShell autocommand deleted buffer&quot;));</a>
<a name="ln4832">        }</a>
<a name="ln4833">        s = get_vim_var_str(VV_FCS_CHOICE);</a>
<a name="ln4834">        if (strcmp(s, &quot;reload&quot;) == 0 &amp;&amp; *reason != 'd') {</a>
<a name="ln4835">          reload = RELOAD_NORMAL;</a>
<a name="ln4836">        } else if (strcmp(s, &quot;edit&quot;) == 0) {</a>
<a name="ln4837">          reload = RELOAD_DETECT;</a>
<a name="ln4838">        } else if (strcmp(s, &quot;ask&quot;) == 0) {</a>
<a name="ln4839">          n = false;</a>
<a name="ln4840">        } else {</a>
<a name="ln4841">          return 2;</a>
<a name="ln4842">        }</a>
<a name="ln4843">      }</a>
<a name="ln4844">      if (!n) {</a>
<a name="ln4845">        if (*reason == 'd') {</a>
<a name="ln4846">          // Only give the message once.</a>
<a name="ln4847">          if (prev_b_mtime != -1) {</a>
<a name="ln4848">            mesg = _(&quot;E211: File \&quot;%s\&quot; no longer available&quot;);</a>
<a name="ln4849">          }</a>
<a name="ln4850">        } else {</a>
<a name="ln4851">          helpmesg = true;</a>
<a name="ln4852">          can_reload = true;</a>
<a name="ln4853"> </a>
<a name="ln4854">          // Check if the file contents really changed to avoid</a>
<a name="ln4855">          // giving a warning when only the timestamp was set (e.g.,</a>
<a name="ln4856">          // checked out of CVS).  Always warn when the buffer was</a>
<a name="ln4857">          // changed.</a>
<a name="ln4858">          if (reason[2] == 'n') {</a>
<a name="ln4859">            mesg = _(</a>
<a name="ln4860">                    &quot;W12: Warning: File \&quot;%s\&quot; has changed and the buffer was changed in Vim as well&quot;);</a>
<a name="ln4861">            mesg2 = _(&quot;See \&quot;:help W12\&quot; for more info.&quot;);</a>
<a name="ln4862">          } else if (reason[1] == 'h') {</a>
<a name="ln4863">            mesg = _(&quot;W11: Warning: File \&quot;%s\&quot; has changed since editing started&quot;);</a>
<a name="ln4864">            mesg2 = _(&quot;See \&quot;:help W11\&quot; for more info.&quot;);</a>
<a name="ln4865">          } else if (*reason == 'm') {</a>
<a name="ln4866">            mesg = _(&quot;W16: Warning: Mode of file \&quot;%s\&quot; has changed since editing started&quot;);</a>
<a name="ln4867">            mesg2 = _(&quot;See \&quot;:help W16\&quot; for more info.&quot;);</a>
<a name="ln4868">          } else {</a>
<a name="ln4869">            // Only timestamp changed, store it to avoid a warning</a>
<a name="ln4870">            // in check_mtime() later.</a>
<a name="ln4871">            buf-&gt;b_mtime_read = buf-&gt;b_mtime;</a>
<a name="ln4872">            buf-&gt;b_mtime_read_ns = buf-&gt;b_mtime_ns;</a>
<a name="ln4873">          }</a>
<a name="ln4874">        }</a>
<a name="ln4875">      }</a>
<a name="ln4876">    }</a>
<a name="ln4877">  } else if ((buf-&gt;b_flags &amp; BF_NEW) &amp;&amp; !(buf-&gt;b_flags &amp; BF_NEW_W)</a>
<a name="ln4878">             &amp;&amp; os_path_exists(buf-&gt;b_ffname)) {</a>
<a name="ln4879">    retval = 1;</a>
<a name="ln4880">    mesg = _(&quot;W13: Warning: File \&quot;%s\&quot; has been created after editing started&quot;);</a>
<a name="ln4881">    buf-&gt;b_flags |= BF_NEW_W;</a>
<a name="ln4882">    can_reload = true;</a>
<a name="ln4883">  }</a>
<a name="ln4884"> </a>
<a name="ln4885">  if (mesg != NULL) {</a>
<a name="ln4886">    path = home_replace_save(buf, buf-&gt;b_fname);</a>
<a name="ln4887">    if (!helpmesg) {</a>
<a name="ln4888">      mesg2 = &quot;&quot;;</a>
<a name="ln4889">    }</a>
<a name="ln4890">    const size_t tbuf_len = strlen(path) + strlen(mesg) + strlen(mesg2) + 2;</a>
<a name="ln4891">    char *const tbuf = xmalloc(tbuf_len);</a>
<a name="ln4892">    snprintf(tbuf, tbuf_len, mesg, path);</a>
<a name="ln4893">    // Set warningmsg here, before the unimportant and output-specific</a>
<a name="ln4894">    // mesg2 has been appended.</a>
<a name="ln4895">    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);</a>
<a name="ln4896">    if (can_reload) {</a>
<a name="ln4897">      if (*mesg2 != NUL) {</a>
<a name="ln4898">        xstrlcat(tbuf, &quot;\n&quot;, tbuf_len - 1);</a>
<a name="ln4899">        xstrlcat(tbuf, mesg2, tbuf_len - 1);</a>
<a name="ln4900">      }</a>
<a name="ln4901">      switch (do_dialog(VIM_WARNING, _(&quot;Warning&quot;), tbuf,</a>
<a name="ln4902">                        _(&quot;&amp;OK\n&amp;Load File\nLoad File &amp;and Options&quot;),</a>
<a name="ln4903">                        1, NULL, true)) {</a>
<a name="ln4904">      case 2:</a>
<a name="ln4905">        reload = RELOAD_NORMAL;</a>
<a name="ln4906">        break;</a>
<a name="ln4907">      case 3:</a>
<a name="ln4908">        reload = RELOAD_DETECT;</a>
<a name="ln4909">        break;</a>
<a name="ln4910">      }</a>
<a name="ln4911">    } else if (State &gt; MODE_NORMAL_BUSY || (State &amp; MODE_CMDLINE) || already_warned) {</a>
<a name="ln4912">      if (*mesg2 != NUL) {</a>
<a name="ln4913">        xstrlcat(tbuf, &quot;; &quot;, tbuf_len - 1);</a>
<a name="ln4914">        xstrlcat(tbuf, mesg2, tbuf_len - 1);</a>
<a name="ln4915">      }</a>
<a name="ln4916">      emsg(tbuf);</a>
<a name="ln4917">      retval = 2;</a>
<a name="ln4918">    } else {</a>
<a name="ln4919">      if (!autocmd_busy) {</a>
<a name="ln4920">        msg_start();</a>
<a name="ln4921">        msg_puts_attr(tbuf, HL_ATTR(HLF_E) + MSG_HIST);</a>
<a name="ln4922">        if (*mesg2 != NUL) {</a>
<a name="ln4923">          msg_puts_attr(mesg2, HL_ATTR(HLF_W) + MSG_HIST);</a>
<a name="ln4924">        }</a>
<a name="ln4925">        msg_clr_eos();</a>
<a name="ln4926">        (void)msg_end();</a>
<a name="ln4927">        if (emsg_silent == 0) {</a>
<a name="ln4928">          ui_flush();</a>
<a name="ln4929">          // give the user some time to think about it</a>
<a name="ln4930">          os_delay(1004L, true);</a>
<a name="ln4931"> </a>
<a name="ln4932">          // don't redraw and erase the message</a>
<a name="ln4933">          redraw_cmdline = false;</a>
<a name="ln4934">        }</a>
<a name="ln4935">      }</a>
<a name="ln4936">      already_warned = true;</a>
<a name="ln4937">    }</a>
<a name="ln4938"> </a>
<a name="ln4939">    xfree(path);</a>
<a name="ln4940">    xfree(tbuf);</a>
<a name="ln4941">  }</a>
<a name="ln4942"> </a>
<a name="ln4943">  if (reload != RELOAD_NONE) {</a>
<a name="ln4944">    // Reload the buffer.</a>
<a name="ln4945">    buf_reload(buf, orig_mode, reload == RELOAD_DETECT);</a>
<a name="ln4946">    if (buf-&gt;b_p_udf &amp;&amp; buf-&gt;b_ffname != NULL) {</a>
<a name="ln4947">      char_u hash[UNDO_HASH_SIZE];</a>
<a name="ln4948"> </a>
<a name="ln4949">      // Any existing undo file is unusable, write it now.</a>
<a name="ln4950">      u_compute_hash(buf, hash);</a>
<a name="ln4951">      u_write_undo(NULL, false, buf, hash);</a>
<a name="ln4952">    }</a>
<a name="ln4953">  }</a>
<a name="ln4954"> </a>
<a name="ln4955">  // Trigger FileChangedShell when the file was changed in any way.</a>
<a name="ln4956">  if (bufref_valid(&amp;bufref) &amp;&amp; retval != 0) {</a>
<a name="ln4957">    (void)apply_autocmds(EVENT_FILECHANGEDSHELLPOST, buf-&gt;b_fname, buf-&gt;b_fname, false, buf);</a>
<a name="ln4958">  }</a>
<a name="ln4959">  return retval;</a>
<a name="ln4960">}</a>
<a name="ln4961"> </a>
<a name="ln4962">/// Reload a buffer that is already loaded.</a>
<a name="ln4963">/// Used when the file was changed outside of Vim.</a>
<a name="ln4964">/// &quot;orig_mode&quot; is buf-&gt;b_orig_mode before the need for reloading was detected.</a>
<a name="ln4965">/// buf-&gt;b_orig_mode may have been reset already.</a>
<a name="ln4966">void buf_reload(buf_T *buf, int orig_mode, bool reload_options)</a>
<a name="ln4967">{</a>
<a name="ln4968">  exarg_T ea;</a>
<a name="ln4969">  pos_T old_cursor;</a>
<a name="ln4970">  linenr_T old_topline;</a>
<a name="ln4971">  int old_ro = buf-&gt;b_p_ro;</a>
<a name="ln4972">  buf_T *savebuf;</a>
<a name="ln4973">  bufref_T bufref;</a>
<a name="ln4974">  int saved = OK;</a>
<a name="ln4975">  aco_save_T aco;</a>
<a name="ln4976">  int flags = READ_NEW;</a>
<a name="ln4977"> </a>
<a name="ln4978">  // set curwin/curbuf for &quot;buf&quot; and save some things</a>
<a name="ln4979">  aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln4980"> </a>
<a name="ln4981">  // Unless reload_options is set, we only want to read the text from the</a>
<a name="ln4982">  // file, not reset the syntax highlighting, clear marks, diff status, etc.</a>
<a name="ln4983">  // Force the fileformat and encoding to be the same.</a>
<a name="ln4984">  if (reload_options) {</a>
<a name="ln4985">    CLEAR_FIELD(ea);</a>
<a name="ln4986">  } else {</a>
<a name="ln4987">    prep_exarg(&amp;ea, buf);</a>
<a name="ln4988">  }</a>
<a name="ln4989"> </a>
<a name="ln4990">  old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln4991">  old_topline = curwin-&gt;w_topline;</a>
<a name="ln4992"> </a>
<a name="ln4993">  if (p_ur &lt; 0 || curbuf-&gt;b_ml.ml_line_count &lt;= p_ur) {</a>
<a name="ln4994">    // Save all the text, so that the reload can be undone.</a>
<a name="ln4995">    // Sync first so that this is a separate undo-able action.</a>
<a name="ln4996">    u_sync(false);</a>
<a name="ln4997">    saved = u_savecommon(curbuf, 0, curbuf-&gt;b_ml.ml_line_count + 1, 0, true);</a>
<a name="ln4998">    flags |= READ_KEEP_UNDO;</a>
<a name="ln4999">  }</a>
<a name="ln5000"> </a>
<a name="ln5001">  // To behave like when a new file is edited (matters for</a>
<a name="ln5002">  // BufReadPost autocommands) we first need to delete the current</a>
<a name="ln5003">  // buffer contents.  But if reading the file fails we should keep</a>
<a name="ln5004">  // the old contents.  Can't use memory only, the file might be</a>
<a name="ln5005">  // too big.  Use a hidden buffer to move the buffer contents to.</a>
<a name="ln5006">  if (buf_is_empty(curbuf) || saved == FAIL) {</a>
<a name="ln5007">    savebuf = NULL;</a>
<a name="ln5008">  } else {</a>
<a name="ln5009">    // Allocate a buffer without putting it in the buffer list.</a>
<a name="ln5010">    savebuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);</a>
<a name="ln5011">    set_bufref(&amp;bufref, savebuf);</a>
<a name="ln5012">    if (savebuf != NULL &amp;&amp; buf == curbuf) {</a>
<a name="ln5013">      // Open the memline.</a>
<a name="ln5014">      curbuf = savebuf;</a>
<a name="ln5015">      curwin-&gt;w_buffer = savebuf;</a>
<a name="ln5016">      saved = ml_open(curbuf);</a>
<a name="ln5017">      curbuf = buf;</a>
<a name="ln5018">      curwin-&gt;w_buffer = buf;</a>
<a name="ln5019">    }</a>
<a name="ln5020">    if (savebuf == NULL || saved == FAIL || buf != curbuf</a>
<a name="ln5021">        || move_lines(buf, savebuf) == FAIL) {</a>
<a name="ln5022">      semsg(_(&quot;E462: Could not prepare for reloading \&quot;%s\&quot;&quot;),</a>
<a name="ln5023">            buf-&gt;b_fname);</a>
<a name="ln5024">      saved = FAIL;</a>
<a name="ln5025">    }</a>
<a name="ln5026">  }</a>
<a name="ln5027"> </a>
<a name="ln5028">  if (saved == OK) {</a>
<a name="ln5029">    curbuf-&gt;b_flags |= BF_CHECK_RO;           // check for RO again</a>
<a name="ln5030">    keep_filetype = true;                     // don't detect 'filetype'</a>
<a name="ln5031">    if (readfile(buf-&gt;b_ffname, buf-&gt;b_fname, (linenr_T)0, (linenr_T)0,</a>
<a name="ln5032">                 (linenr_T)MAXLNUM, &amp;ea, flags, false) != OK) {</a>
<a name="ln5033">      if (!aborting()) {</a>
<a name="ln5034">        semsg(_(&quot;E321: Could not reload \&quot;%s\&quot;&quot;), buf-&gt;b_fname);</a>
<a name="ln5035">      }</a>
<a name="ln5036">      if (savebuf != NULL &amp;&amp; bufref_valid(&amp;bufref) &amp;&amp; buf == curbuf) {</a>
<a name="ln5037">        // Put the text back from the save buffer.  First</a>
<a name="ln5038">        // delete any lines that readfile() added.</a>
<a name="ln5039">        while (!buf_is_empty(curbuf)) {</a>
<a name="ln5040">          if (ml_delete(buf-&gt;b_ml.ml_line_count, false) == FAIL) {</a>
<a name="ln5041">            break;</a>
<a name="ln5042">          }</a>
<a name="ln5043">        }</a>
<a name="ln5044">        (void)move_lines(savebuf, buf);</a>
<a name="ln5045">      }</a>
<a name="ln5046">    } else if (buf == curbuf) {  // &quot;buf&quot; still valid.</a>
<a name="ln5047">      // Mark the buffer as unmodified and free undo info.</a>
<a name="ln5048">      unchanged(buf, true, true);</a>
<a name="ln5049">      if ((flags &amp; READ_KEEP_UNDO) == 0) {</a>
<a name="ln5050">        u_blockfree(buf);</a>
<a name="ln5051">        u_clearall(buf);</a>
<a name="ln5052">      } else {</a>
<a name="ln5053">        // Mark all undo states as changed.</a>
<a name="ln5054">        u_unchanged(curbuf);</a>
<a name="ln5055">      }</a>
<a name="ln5056">      buf_updates_unload(curbuf, true);</a>
<a name="ln5057">      curbuf-&gt;b_mod_set = true;</a>
<a name="ln5058">    }</a>
<a name="ln5059">  }</a>
<a name="ln5060">  xfree(ea.cmd);</a>
<a name="ln5061"> </a>
<a name="ln5062">  if (savebuf != NULL &amp;&amp; bufref_valid(&amp;bufref)) {</a>
<a name="ln5063">    wipe_buffer(savebuf, false);</a>
<a name="ln5064">  }</a>
<a name="ln5065"> </a>
<a name="ln5066">  // Invalidate diff info if necessary.</a>
<a name="ln5067">  diff_invalidate(curbuf);</a>
<a name="ln5068"> </a>
<a name="ln5069">  // Restore the topline and cursor position and check it (lines may</a>
<a name="ln5070">  // have been removed).</a>
<a name="ln5071">  if (old_topline &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5072">    curwin-&gt;w_topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln5073">  } else {</a>
<a name="ln5074">    curwin-&gt;w_topline = old_topline;</a>
<a name="ln5075">  }</a>
<a name="ln5076">  curwin-&gt;w_cursor = old_cursor;</a>
<a name="ln5077">  check_cursor();</a>
<a name="ln5078">  update_topline(curwin);</a>
<a name="ln5079">  keep_filetype = false;</a>
<a name="ln5080"> </a>
<a name="ln5081">  // Update folds unless they are defined manually.</a>
<a name="ln5082">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln5083">    if (wp-&gt;w_buffer == curwin-&gt;w_buffer</a>
<a name="ln5084">        &amp;&amp; !foldmethodIsManual(wp)) {</a>
<a name="ln5085">      foldUpdateAll(wp);</a>
<a name="ln5086">    }</a>
<a name="ln5087">  }</a>
<a name="ln5088"> </a>
<a name="ln5089">  // If the mode didn't change and 'readonly' was set, keep the old</a>
<a name="ln5090">  // value; the user probably used the &quot;:view&quot; command.  But don't</a>
<a name="ln5091">  // reset it, might have had a read error.</a>
<a name="ln5092">  if (orig_mode == curbuf-&gt;b_orig_mode) {</a>
<a name="ln5093">    curbuf-&gt;b_p_ro |= old_ro;</a>
<a name="ln5094">  }</a>
<a name="ln5095"> </a>
<a name="ln5096">  // Modelines must override settings done by autocommands.</a>
<a name="ln5097">  do_modelines(0);</a>
<a name="ln5098"> </a>
<a name="ln5099">  // restore curwin/curbuf and a few other things</a>
<a name="ln5100">  aucmd_restbuf(&amp;aco);</a>
<a name="ln5101">  // Careful: autocommands may have made &quot;buf&quot; invalid!</a>
<a name="ln5102">}</a>
<a name="ln5103"> </a>
<a name="ln5104">void buf_store_file_info(buf_T *buf, FileInfo *file_info)</a>
<a name="ln5105">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5106">{</a>
<a name="ln5107">  buf-&gt;b_mtime = file_info-&gt;stat.st_mtim.tv_sec;</a>
<a name="ln5108">  buf-&gt;b_mtime_ns = file_info-&gt;stat.st_mtim.tv_nsec;</a>
<a name="ln5109">  buf-&gt;b_orig_size = os_fileinfo_size(file_info);</a>
<a name="ln5110">  buf-&gt;b_orig_mode = (int)file_info-&gt;stat.st_mode;</a>
<a name="ln5111">}</a>
<a name="ln5112"> </a>
<a name="ln5113">/// Adjust the line with missing eol, used for the next write.</a>
<a name="ln5114">/// Used for do_filter(), when the input lines for the filter are deleted.</a>
<a name="ln5115">void write_lnum_adjust(linenr_T offset)</a>
<a name="ln5116">{</a>
<a name="ln5117">  if (curbuf-&gt;b_no_eol_lnum != 0) {     // only if there is a missing eol</a>
<a name="ln5118">    curbuf-&gt;b_no_eol_lnum += offset;</a>
<a name="ln5119">  }</a>
<a name="ln5120">}</a>
<a name="ln5121"> </a>
<a name="ln5122">#if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln5123">/// Convert all backslashes in fname to forward slashes in-place,</a>
<a name="ln5124">/// unless when it looks like a URL.</a>
<a name="ln5125">void forward_slash(char_u *fname)</a>
<a name="ln5126">{</a>
<a name="ln5127">  char_u *p;</a>
<a name="ln5128"> </a>
<a name="ln5129">  if (path_with_url((const char *)fname)) {</a>
<a name="ln5130">    return;</a>
<a name="ln5131">  }</a>
<a name="ln5132">  for (p = fname; *p != NUL; p++) {</a>
<a name="ln5133">    if (*p == '\\') {</a>
<a name="ln5134">      *p = '/';</a>
<a name="ln5135">    }</a>
<a name="ln5136">  }</a>
<a name="ln5137">}</a>
<a name="ln5138">#endif</a>
<a name="ln5139"> </a>
<a name="ln5140">/// Path to Nvim's own temp dir. Ends in a slash.</a>
<a name="ln5141">static char *vim_tempdir = NULL;</a>
<a name="ln5142"> </a>
<a name="ln5143">/// Creates a directory for private use by this instance of Nvim, trying each of</a>
<a name="ln5144">/// `TEMP_DIR_NAMES` until one succeeds.</a>
<a name="ln5145">///</a>
<a name="ln5146">/// Only done once, the same directory is used for all temp files.</a>
<a name="ln5147">/// This method avoids security problems because of symlink attacks et al.</a>
<a name="ln5148">/// It's also a bit faster, because we only need to check for an existing</a>
<a name="ln5149">/// file when creating the directory and not for each temp file.</a>
<a name="ln5150">static void vim_mktempdir(void)</a>
<a name="ln5151">{</a>
<a name="ln5152">  static const char *temp_dirs[] = TEMP_DIR_NAMES;  // Try each of these until one succeeds.</a>
<a name="ln5153">  char tmp[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln5154">  char path[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln5155">  char user[40] = { 0 };</a>
<a name="ln5156"> </a>
<a name="ln5157">  (void)os_get_username(user, sizeof(user));</a>
<a name="ln5158">  // Usernames may contain slashes! #19240</a>
<a name="ln5159">  memchrsub(user, '/', '_', sizeof(user));</a>
<a name="ln5160">  memchrsub(user, '\\', '_', sizeof(user));</a>
<a name="ln5161"> </a>
<a name="ln5162">  // Make sure the umask doesn't remove the executable bit.</a>
<a name="ln5163">  // &quot;repl&quot; has been reported to use &quot;0177&quot;.</a>
<a name="ln5164">  mode_t umask_save = umask(0077);</a>
<a name="ln5165">  for (size_t i = 0; i &lt; ARRAY_SIZE(temp_dirs); i++) {</a>
<a name="ln5166">    // Expand environment variables, leave room for &quot;/tmp/nvim.&lt;user&gt;/XXXXXX/999999999&quot;.</a>
<a name="ln5167">    expand_env((char *)temp_dirs[i], tmp, TEMP_FILE_PATH_MAXLEN - 64);</a>
<a name="ln5168">    if (!os_isdir(tmp)) {</a>
<a name="ln5169">      continue;</a>
<a name="ln5170">    }</a>
<a name="ln5171"> </a>
<a name="ln5172">    // &quot;/tmp/&quot; exists, now try to create &quot;/tmp/nvim.&lt;user&gt;/&quot;.</a>
<a name="ln5173">    add_pathsep(tmp);</a>
<a name="ln5174">    xstrlcat(tmp, &quot;nvim.&quot;, sizeof(tmp));</a>
<a name="ln5175">    xstrlcat(tmp, user, sizeof(tmp));</a>
<a name="ln5176">    (void)os_mkdir(tmp, 0700);  // Always create, to avoid a race.</a>
<a name="ln5177">    bool owned = os_file_owned(tmp);</a>
<a name="ln5178">    bool isdir = os_isdir(tmp);</a>
<a name="ln5179">#ifdef UNIX</a>
<a name="ln5180">    int perm = os_getperm(tmp);  // XDG_RUNTIME_DIR must be owned by the user, mode 0700.</a>
<a name="ln5181">    bool valid = isdir &amp;&amp; owned &amp;&amp; 0700 == (perm &amp; 0777);</a>
<a name="ln5182">#else</a>
<a name="ln5183">    bool valid = isdir &amp;&amp; owned;  // TODO(justinmk): Windows ACL?</a>
<a name="ln5184">#endif</a>
<a name="ln5185">    if (valid) {</a>
<a name="ln5186">      add_pathsep(tmp);</a>
<a name="ln5187">    } else {</a>
<a name="ln5188">      if (!owned) {</a>
<a name="ln5189">        ELOG(&quot;tempdir root not owned by current user (%s): %s&quot;, user, tmp);</a>
<a name="ln5190">      } else if (!isdir) {</a>
<a name="ln5191">        ELOG(&quot;tempdir root not a directory: %s&quot;, tmp);</a>
<a name="ln5192">      }</a>
<a name="ln5193">#ifdef UNIX</a>
<a name="ln5194">      if (0700 != (perm &amp; 0777)) {</a>
<a name="ln5195">        ELOG(&quot;tempdir root has invalid permissions (%o): %s&quot;, perm, tmp);</a>
<a name="ln5196">      }</a>
<a name="ln5197">#endif</a>
<a name="ln5198">      // If our &quot;root&quot; tempdir is invalid or fails, proceed without &quot;&lt;user&gt;/&quot;.</a>
<a name="ln5199">      // Else user1 could break user2 by creating &quot;/tmp/nvim.user2/&quot;.</a>
<a name="ln5200">      tmp[strlen(tmp) - strlen(user)] = '\0';</a>
<a name="ln5201">    }</a>
<a name="ln5202"> </a>
<a name="ln5203">    // Now try to create &quot;/tmp/nvim.&lt;user&gt;/XXXXXX&quot;.</a>
<a name="ln5204">    xstrlcat(tmp, &quot;XXXXXX&quot;, sizeof(tmp));  // mkdtemp &quot;template&quot;, will be replaced with random alphanumeric chars.</a>
<a name="ln5205">    int r = os_mkdtemp(tmp, path);</a>
<a name="ln5206">    if (r != 0) {</a>
<a name="ln5207">      WLOG(&quot;tempdir create failed: %s: %s&quot;, os_strerror(r), tmp);</a>
<a name="ln5208">      continue;</a>
<a name="ln5209">    }</a>
<a name="ln5210"> </a>
<a name="ln5211">    if (vim_settempdir(path)) {</a>
<a name="ln5212">      // Successfully created and set temporary directory so stop trying.</a>
<a name="ln5213">      break;</a>
<a name="ln5214">    } else {</a>
<a name="ln5215">      // Couldn't set `vim_tempdir` to `path` so remove created directory.</a>
<a name="ln5216">      os_rmdir(path);</a>
<a name="ln5217">    }</a>
<a name="ln5218">  }</a>
<a name="ln5219">  (void)umask(umask_save);</a>
<a name="ln5220">}</a>
<a name="ln5221"> </a>
<a name="ln5222">/// Core part of &quot;readdir()&quot; function.</a>
<a name="ln5223">/// Retrieve the list of files/directories of &quot;path&quot; into &quot;gap&quot;.</a>
<a name="ln5224">///</a>
<a name="ln5225">/// @return  OK for success, FAIL for failure.</a>
<a name="ln5226">int readdir_core(garray_T *gap, const char *path, void *context, CheckItem checkitem)</a>
<a name="ln5227">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln5228">{</a>
<a name="ln5229">  ga_init(gap, (int)sizeof(char *), 20);</a>
<a name="ln5230"> </a>
<a name="ln5231">  Directory dir;</a>
<a name="ln5232">  if (!os_scandir(&amp;dir, path)) {</a>
<a name="ln5233">    smsg(_(e_notopen), path);</a>
<a name="ln5234">    return FAIL;</a>
<a name="ln5235">  }</a>
<a name="ln5236"> </a>
<a name="ln5237">  for (;;) {</a>
<a name="ln5238">    const char *p = os_scandir_next(&amp;dir);</a>
<a name="ln5239">    if (p == NULL) {</a>
<a name="ln5240">      break;</a>
<a name="ln5241">    }</a>
<a name="ln5242"> </a>
<a name="ln5243">    bool ignore = (p[0] == '.' &amp;&amp; (p[1] == NUL || (p[1] == '.' &amp;&amp; p[2] == NUL)));</a>
<a name="ln5244">    if (!ignore &amp;&amp; checkitem != NULL) {</a>
<a name="ln5245">      varnumber_T r = checkitem(context, p);</a>
<a name="ln5246">      if (r &lt; 0) {</a>
<a name="ln5247">        break;</a>
<a name="ln5248">      }</a>
<a name="ln5249">      if (r == 0) {</a>
<a name="ln5250">        ignore = true;</a>
<a name="ln5251">      }</a>
<a name="ln5252">    }</a>
<a name="ln5253"> </a>
<a name="ln5254">    if (!ignore) {</a>
<a name="ln5255">      ga_grow(gap, 1);</a>
<a name="ln5256">      ((char **)gap-&gt;ga_data)[gap-&gt;ga_len++] = xstrdup(p);</a>
<a name="ln5257">    }</a>
<a name="ln5258">  }</a>
<a name="ln5259"> </a>
<a name="ln5260">  os_closedir(&amp;dir);</a>
<a name="ln5261"> </a>
<a name="ln5262">  if (gap-&gt;ga_len &gt; 0) {</a>
<a name="ln5263">    sort_strings(gap-&gt;ga_data, gap-&gt;ga_len);</a>
<a name="ln5264">  }</a>
<a name="ln5265"> </a>
<a name="ln5266">  return OK;</a>
<a name="ln5267">}</a>
<a name="ln5268"> </a>
<a name="ln5269">/// Delete &quot;name&quot; and everything in it, recursively.</a>
<a name="ln5270">///</a>
<a name="ln5271">/// @param name  The path which should be deleted.</a>
<a name="ln5272">///</a>
<a name="ln5273">/// @return  0 for success, -1 if some file was not deleted.</a>
<a name="ln5274">int delete_recursive(const char *name)</a>
<a name="ln5275">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5276">{</a>
<a name="ln5277">  int result = 0;</a>
<a name="ln5278"> </a>
<a name="ln5279">  if (os_isrealdir(name)) {</a>
<a name="ln5280">    char *exp = xstrdup(name);</a>
<a name="ln5281">    garray_T ga;</a>
<a name="ln5282">    if (readdir_core(&amp;ga, exp, NULL, NULL) == OK) {</a>
<a name="ln5283">      for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln5284">        vim_snprintf((char *)NameBuff, MAXPATHL, &quot;%s/%s&quot;, exp, ((char_u **)ga.ga_data)[i]);</a>
<a name="ln5285">        if (delete_recursive((const char *)NameBuff) != 0) {</a>
<a name="ln5286">          // Remember the failure but continue deleting any further</a>
<a name="ln5287">          // entries.</a>
<a name="ln5288">          result = -1;</a>
<a name="ln5289">        }</a>
<a name="ln5290">      }</a>
<a name="ln5291">      ga_clear_strings(&amp;ga);</a>
<a name="ln5292">      if (os_rmdir(exp) != 0) {</a>
<a name="ln5293">        result = -1;</a>
<a name="ln5294">      }</a>
<a name="ln5295">    } else {</a>
<a name="ln5296">      result = -1;</a>
<a name="ln5297">    }</a>
<a name="ln5298">    xfree(exp);</a>
<a name="ln5299">  } else {</a>
<a name="ln5300">    // Delete symlink only.</a>
<a name="ln5301">    result = os_remove(name) == 0 ? 0 : -1;</a>
<a name="ln5302">  }</a>
<a name="ln5303"> </a>
<a name="ln5304">  return result;</a>
<a name="ln5305">}</a>
<a name="ln5306"> </a>
<a name="ln5307">/// Delete the temp directory and all files it contains.</a>
<a name="ln5308">void vim_deltempdir(void)</a>
<a name="ln5309">{</a>
<a name="ln5310">  if (vim_tempdir != NULL) {</a>
<a name="ln5311">    // remove the trailing path separator</a>
<a name="ln5312">    path_tail(vim_tempdir)[-1] = NUL;</a>
<a name="ln5313">    delete_recursive(vim_tempdir);</a>
<a name="ln5314">    XFREE_CLEAR(vim_tempdir);</a>
<a name="ln5315">  }</a>
<a name="ln5316">}</a>
<a name="ln5317"> </a>
<a name="ln5318">/// Gets path to Nvim's own temp dir (ending with slash).</a>
<a name="ln5319">///</a>
<a name="ln5320">/// Creates the directory on the first call.</a>
<a name="ln5321">char *vim_gettempdir(void)</a>
<a name="ln5322">{</a>
<a name="ln5323">  if (vim_tempdir == NULL) {</a>
<a name="ln5324">    vim_mktempdir();</a>
<a name="ln5325">  }</a>
<a name="ln5326"> </a>
<a name="ln5327">  return vim_tempdir;</a>
<a name="ln5328">}</a>
<a name="ln5329"> </a>
<a name="ln5330">/// Sets Nvim's own temporary directory name to `tempdir`. This directory must</a>
<a name="ln5331">/// already exist. Expands the name to a full path and put it in `vim_tempdir`.</a>
<a name="ln5332">/// This avoids that using `:cd` would confuse us.</a>
<a name="ln5333">///</a>
<a name="ln5334">/// @param tempdir must be no longer than MAXPATHL.</a>
<a name="ln5335">///</a>
<a name="ln5336">/// @return false if we run out of memory.</a>
<a name="ln5337">static bool vim_settempdir(char *tempdir)</a>
<a name="ln5338">{</a>
<a name="ln5339">  char *buf = verbose_try_malloc(MAXPATHL + 2);</a>
<a name="ln5340">  if (!buf) {</a>
<a name="ln5341">    return false;</a>
<a name="ln5342">  }</a>
<a name="ln5343">  vim_FullName(tempdir, buf, MAXPATHL, false);</a>
<a name="ln5344">  add_pathsep(buf);</a>
<a name="ln5345">  vim_tempdir = xstrdup(buf);</a>
<a name="ln5346">  xfree(buf);</a>
<a name="ln5347">  return true;</a>
<a name="ln5348">}</a>
<a name="ln5349"> </a>
<a name="ln5350">/// Return a unique name that can be used for a temp file.</a>
<a name="ln5351">///</a>
<a name="ln5352">/// @note The temp file is NOT created.</a>
<a name="ln5353">///</a>
<a name="ln5354">/// @return  pointer to the temp file name or NULL if Nvim can't create</a>
<a name="ln5355">///          temporary directory for its own temporary files.</a>
<a name="ln5356">char *vim_tempname(void)</a>
<a name="ln5357">{</a>
<a name="ln5358">  // Temp filename counter.</a>
<a name="ln5359">  static uint64_t temp_count;</a>
<a name="ln5360"> </a>
<a name="ln5361">  char *tempdir = vim_gettempdir();</a>
<a name="ln5362">  if (!tempdir) {</a>
<a name="ln5363">    return NULL;</a>
<a name="ln5364">  }</a>
<a name="ln5365"> </a>
<a name="ln5366">  // There is no need to check if the file exists, because we own the directory</a>
<a name="ln5367">  // and nobody else creates a file in it.</a>
<a name="ln5368">  char template[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln5369">  snprintf(template, TEMP_FILE_PATH_MAXLEN,</a>
<a name="ln5370">           &quot;%s%&quot; PRIu64, tempdir, temp_count++);</a>
<a name="ln5371">  return xstrdup(template);</a>
<a name="ln5372">}</a>
<a name="ln5373"> </a>
<a name="ln5374">/// Tries matching a filename with a &quot;pattern&quot; (&quot;prog&quot; is NULL), or use the</a>
<a name="ln5375">/// precompiled regprog &quot;prog&quot; (&quot;pattern&quot; is NULL).  That avoids calling</a>
<a name="ln5376">/// vim_regcomp() often.</a>
<a name="ln5377">///</a>
<a name="ln5378">/// Used for autocommands and 'wildignore'.</a>
<a name="ln5379">///</a>
<a name="ln5380">/// @param pattern pattern to match with</a>
<a name="ln5381">/// @param prog pre-compiled regprog or NULL</a>
<a name="ln5382">/// @param fname full path of the file name</a>
<a name="ln5383">/// @param sfname short file name or NULL</a>
<a name="ln5384">/// @param tail tail of the path</a>
<a name="ln5385">/// @param allow_dirs Allow matching with dir</a>
<a name="ln5386">///</a>
<a name="ln5387">/// @return true if there is a match, false otherwise</a>
<a name="ln5388">bool match_file_pat(char *pattern, regprog_T **prog, char *fname, char *sfname, char *tail,</a>
<a name="ln5389">                    int allow_dirs)</a>
<a name="ln5390">{</a>
<a name="ln5391">  regmatch_T regmatch;</a>
<a name="ln5392">  bool result = false;</a>
<a name="ln5393"> </a>
<a name="ln5394">  regmatch.rm_ic = p_fic;   // ignore case if 'fileignorecase' is set</a>
<a name="ln5395">  {</a>
<a name="ln5396">    if (prog != NULL) {</a>
<a name="ln5397">      regmatch.regprog = *prog;</a>
<a name="ln5398">    } else {</a>
<a name="ln5399">      regmatch.regprog = vim_regcomp(pattern, RE_MAGIC);</a>
<a name="ln5400">    }</a>
<a name="ln5401">  }</a>
<a name="ln5402"> </a>
<a name="ln5403">  // Try for a match with the pattern with:</a>
<a name="ln5404">  // 1. the full file name, when the pattern has a '/'.</a>
<a name="ln5405">  // 2. the short file name, when the pattern has a '/'.</a>
<a name="ln5406">  // 3. the tail of the file name, when the pattern has no '/'.</a>
<a name="ln5407">  if (regmatch.regprog != NULL</a>
<a name="ln5408">      &amp;&amp; ((allow_dirs</a>
<a name="ln5409">           &amp;&amp; (vim_regexec(&amp;regmatch, fname, (colnr_T)0)</a>
<a name="ln5410">               || (sfname != NULL</a>
<a name="ln5411">                   &amp;&amp; vim_regexec(&amp;regmatch, sfname, (colnr_T)0))))</a>
<a name="ln5412">          || (!allow_dirs &amp;&amp; vim_regexec(&amp;regmatch, tail, (colnr_T)0)))) {</a>
<a name="ln5413">    result = true;</a>
<a name="ln5414">  }</a>
<a name="ln5415"> </a>
<a name="ln5416">  if (prog != NULL) {</a>
<a name="ln5417">    *prog = regmatch.regprog;</a>
<a name="ln5418">  } else {</a>
<a name="ln5419">    vim_regfree(regmatch.regprog);</a>
<a name="ln5420">  }</a>
<a name="ln5421">  return result;</a>
<a name="ln5422">}</a>
<a name="ln5423"> </a>
<a name="ln5424">/// Check if a file matches with a pattern in &quot;list&quot;.</a>
<a name="ln5425">/// &quot;list&quot; is a comma-separated list of patterns, like 'wildignore'.</a>
<a name="ln5426">/// &quot;sfname&quot; is the short file name or NULL, &quot;ffname&quot; the long file name.</a>
<a name="ln5427">///</a>
<a name="ln5428">/// @param list list of patterns to match</a>
<a name="ln5429">/// @param sfname short file name</a>
<a name="ln5430">/// @param ffname full file name</a>
<a name="ln5431">///</a>
<a name="ln5432">/// @return true if there was a match</a>
<a name="ln5433">bool match_file_list(char_u *list, char_u *sfname, char_u *ffname)</a>
<a name="ln5434">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1, 3)</a>
<a name="ln5435">{</a>
<a name="ln5436">  char_u buf[100];</a>
<a name="ln5437">  char_u *tail;</a>
<a name="ln5438">  char_u *regpat;</a>
<a name="ln5439">  char allow_dirs;</a>
<a name="ln5440">  bool match;</a>
<a name="ln5441">  char *p;</a>
<a name="ln5442"> </a>
<a name="ln5443">  tail = (char_u *)path_tail((char *)sfname);</a>
<a name="ln5444"> </a>
<a name="ln5445">  // try all patterns in 'wildignore'</a>
<a name="ln5446">  p = (char *)list;</a>
<a name="ln5447">  while (*p) {</a>
<a name="ln5448">    copy_option_part(&amp;p, (char *)buf, ARRAY_SIZE(buf), &quot;,&quot;);</a>
<a name="ln5449">    regpat = (char_u *)file_pat_to_reg_pat((char *)buf, NULL, &amp;allow_dirs, false);</a>
<a name="ln5450">    if (regpat == NULL) {</a>
<a name="ln5451">      break;</a>
<a name="ln5452">    }</a>
<a name="ln5453">    match = match_file_pat((char *)regpat, NULL, (char *)ffname, (char *)sfname, (char *)tail,</a>
<a name="ln5454">                           (int)allow_dirs);</a>
<a name="ln5455">    xfree(regpat);</a>
<a name="ln5456">    if (match) {</a>
<a name="ln5457">      return true;</a>
<a name="ln5458">    }</a>
<a name="ln5459">  }</a>
<a name="ln5460">  return false;</a>
<a name="ln5461">}</a>
<a name="ln5462"> </a>
<a name="ln5463">/// Convert the given pattern &quot;pat&quot; which has shell style wildcards in it, into</a>
<a name="ln5464">/// a regular expression, and return the result in allocated memory.  If there</a>
<a name="ln5465">/// is a directory path separator to be matched, then true is put in</a>
<a name="ln5466">/// allow_dirs, otherwise false is put there -- webb.</a>
<a name="ln5467">/// Handle backslashes before special characters, like &quot;\*&quot; and &quot;\ &quot;.</a>
<a name="ln5468">///</a>
<a name="ln5469">/// @param pat_end     first char after pattern or NULL</a>
<a name="ln5470">/// @param allow_dirs  Result passed back out in here</a>
<a name="ln5471">/// @param no_bslash   Don't use a backward slash as pathsep</a>
<a name="ln5472">///</a>
<a name="ln5473">/// @return            NULL on failure.</a>
<a name="ln5474">char *file_pat_to_reg_pat(const char *pat, const char *pat_end, char *allow_dirs, int no_bslash)</a>
<a name="ln5475">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln5476">{</a>
<a name="ln5477">  const char *endp;</a>
<a name="ln5478">  char *reg_pat;</a>
<a name="ln5479">  const char *p;</a>
<a name="ln5480">  int nested = 0;</a>
<a name="ln5481">  bool add_dollar = true;</a>
<a name="ln5482"> </a>
<a name="ln5483">  if (allow_dirs != NULL) {</a>
<a name="ln5484">    *allow_dirs = false;</a>
<a name="ln5485">  }</a>
<a name="ln5486">  if (pat_end == NULL) {</a>
<a name="ln5487">    pat_end = pat + strlen(pat);</a>
<a name="ln5488">  }</a>
<a name="ln5489"> </a>
<a name="ln5490">  if (pat_end == pat) {</a>
<a name="ln5491">    return xstrdup(&quot;^$&quot;);</a>
<a name="ln5492">  }</a>
<a name="ln5493"> </a>
<a name="ln5494">  size_t size = 2;  // '^' at start, '$' at end.</a>
<a name="ln5495"> </a>
<a name="ln5496">  for (p = pat; p &lt; pat_end; p++) {</a>
<a name="ln5497">    switch (*p) {</a>
<a name="ln5498">    case '*':</a>
<a name="ln5499">    case '.':</a>
<a name="ln5500">    case ',':</a>
<a name="ln5501">    case '{':</a>
<a name="ln5502">    case '}':</a>
<a name="ln5503">    case '~':</a>
<a name="ln5504">      size += 2;                // extra backslash</a>
<a name="ln5505">      break;</a>
<a name="ln5506">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5507">    case '\\':</a>
<a name="ln5508">    case '/':</a>
<a name="ln5509">      size += 4;                // could become &quot;[\/]&quot;</a>
<a name="ln5510">      break;</a>
<a name="ln5511">#endif</a>
<a name="ln5512">    default:</a>
<a name="ln5513">      size++;</a>
<a name="ln5514">      break;</a>
<a name="ln5515">    }</a>
<a name="ln5516">  }</a>
<a name="ln5517">  reg_pat = xmalloc(size + 1);</a>
<a name="ln5518"> </a>
<a name="ln5519">  size_t i = 0;</a>
<a name="ln5520"> </a>
<a name="ln5521">  if (pat[0] == '*') {</a>
<a name="ln5522">    while (pat[0] == '*' &amp;&amp; pat &lt; pat_end - 1) {</a>
<a name="ln5523">      pat++;</a>
<a name="ln5524">    }</a>
<a name="ln5525">  } else {</a>
<a name="ln5526">    reg_pat[i++] = '^';</a>
<a name="ln5527">  }</a>
<a name="ln5528">  endp = pat_end - 1;</a>
<a name="ln5529">  if (endp &gt;= pat &amp;&amp; *endp == '*') {</a>
<a name="ln5530">    while (endp - pat &gt; 0 &amp;&amp; *endp == '*') {</a>
<a name="ln5531">      endp--;</a>
<a name="ln5532">    }</a>
<a name="ln5533">    add_dollar = false;</a>
<a name="ln5534">  }</a>
<a name="ln5535">  for (p = pat; *p &amp;&amp; nested &gt;= 0 &amp;&amp; p &lt;= endp; p++) {</a>
<a name="ln5536">    switch (*p) {</a>
<a name="ln5537">    case '*':</a>
<a name="ln5538">      reg_pat[i++] = '.';</a>
<a name="ln5539">      reg_pat[i++] = '*';</a>
<a name="ln5540">      while (p[1] == '*') {  // &quot;**&quot; matches like &quot;*&quot;</a>
<a name="ln5541">        p++;</a>
<a name="ln5542">      }</a>
<a name="ln5543">      break;</a>
<a name="ln5544">    case '.':</a>
<a name="ln5545">    case '~':</a>
<a name="ln5546">      reg_pat[i++] = '\\';</a>
<a name="ln5547">      reg_pat[i++] = *p;</a>
<a name="ln5548">      break;</a>
<a name="ln5549">    case '?':</a>
<a name="ln5550">      reg_pat[i++] = '.';</a>
<a name="ln5551">      break;</a>
<a name="ln5552">    case '\\':</a>
<a name="ln5553">      if (p[1] == NUL) {</a>
<a name="ln5554">        break;</a>
<a name="ln5555">      }</a>
<a name="ln5556">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5557">      if (!no_bslash) {</a>
<a name="ln5558">        // translate:</a>
<a name="ln5559">        // &quot;\x&quot; to &quot;\\x&quot;  e.g., &quot;dir\file&quot;</a>
<a name="ln5560">        // &quot;\*&quot; to &quot;\\.*&quot; e.g., &quot;dir\*.c&quot;</a>
<a name="ln5561">        // &quot;\?&quot; to &quot;\\.&quot;  e.g., &quot;dir\??.c&quot;</a>
<a name="ln5562">        // &quot;\+&quot; to &quot;\+&quot;   e.g., &quot;fileX\+.c&quot;</a>
<a name="ln5563">        if ((vim_isfilec(p[1]) || p[1] == '*' || p[1] == '?')</a>
<a name="ln5564">            &amp;&amp; p[1] != '+') {</a>
<a name="ln5565">          reg_pat[i++] = '[';</a>
<a name="ln5566">          reg_pat[i++] = '\\';</a>
<a name="ln5567">          reg_pat[i++] = '/';</a>
<a name="ln5568">          reg_pat[i++] = ']';</a>
<a name="ln5569">          if (allow_dirs != NULL) {</a>
<a name="ln5570">            *allow_dirs = true;</a>
<a name="ln5571">          }</a>
<a name="ln5572">          break;</a>
<a name="ln5573">        }</a>
<a name="ln5574">      }</a>
<a name="ln5575">#endif</a>
<a name="ln5576">      // Undo escaping from ExpandEscape():</a>
<a name="ln5577">      // foo\?bar -&gt; foo?bar</a>
<a name="ln5578">      // foo\%bar -&gt; foo%bar</a>
<a name="ln5579">      // foo\,bar -&gt; foo,bar</a>
<a name="ln5580">      // foo\ bar -&gt; foo bar</a>
<a name="ln5581">      // Don't unescape \, * and others that are also special in a</a>
<a name="ln5582">      // regexp.</a>
<a name="ln5583">      // An escaped { must be unescaped since we use magic not</a>
<a name="ln5584">      // verymagic.  Use &quot;\\\{n,m\}&quot;&quot; to get &quot;\{n,m}&quot;.</a>
<a name="ln5585">      if (*++p == '?'</a>
<a name="ln5586">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5587">          &amp;&amp; no_bslash</a>
<a name="ln5588">#endif</a>
<a name="ln5589">          ) {</a>
<a name="ln5590">        reg_pat[i++] = '?';</a>
<a name="ln5591">      } else if (*p == ',' || *p == '%' || *p == '#'</a>
<a name="ln5592">                 || ascii_isspace(*p) || *p == '{' || *p == '}') {</a>
<a name="ln5593">        reg_pat[i++] = *p;</a>
<a name="ln5594">      } else if (*p == '\\' &amp;&amp; p[1] == '\\' &amp;&amp; p[2] == '{') {</a>
<a name="ln5595">        reg_pat[i++] = '\\';</a>
<a name="ln5596">        reg_pat[i++] = '{';</a>
<a name="ln5597">        p += 2;</a>
<a name="ln5598">      } else {</a>
<a name="ln5599">        if (allow_dirs != NULL &amp;&amp; vim_ispathsep(*p)</a>
<a name="ln5600">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5601">            &amp;&amp; (!no_bslash || *p != '\\')</a>
<a name="ln5602">#endif</a>
<a name="ln5603">            ) {</a>
<a name="ln5604">          *allow_dirs = true;</a>
<a name="ln5605">        }</a>
<a name="ln5606">        reg_pat[i++] = '\\';</a>
<a name="ln5607">        reg_pat[i++] = *p;</a>
<a name="ln5608">      }</a>
<a name="ln5609">      break;</a>
<a name="ln5610">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5611">    case '/':</a>
<a name="ln5612">      reg_pat[i++] = '[';</a>
<a name="ln5613">      reg_pat[i++] = '\\';</a>
<a name="ln5614">      reg_pat[i++] = '/';</a>
<a name="ln5615">      reg_pat[i++] = ']';</a>
<a name="ln5616">      if (allow_dirs != NULL) {</a>
<a name="ln5617">        *allow_dirs = true;</a>
<a name="ln5618">      }</a>
<a name="ln5619">      break;</a>
<a name="ln5620">#endif</a>
<a name="ln5621">    case '{':</a>
<a name="ln5622">      reg_pat[i++] = '\\';</a>
<a name="ln5623">      reg_pat[i++] = '(';</a>
<a name="ln5624">      nested++;</a>
<a name="ln5625">      break;</a>
<a name="ln5626">    case '}':</a>
<a name="ln5627">      reg_pat[i++] = '\\';</a>
<a name="ln5628">      reg_pat[i++] = ')';</a>
<a name="ln5629">      nested--;</a>
<a name="ln5630">      break;</a>
<a name="ln5631">    case ',':</a>
<a name="ln5632">      if (nested) {</a>
<a name="ln5633">        reg_pat[i++] = '\\';</a>
<a name="ln5634">        reg_pat[i++] = '|';</a>
<a name="ln5635">      } else {</a>
<a name="ln5636">        reg_pat[i++] = ',';</a>
<a name="ln5637">      }</a>
<a name="ln5638">      break;</a>
<a name="ln5639">    default:</a>
<a name="ln5640">      if (allow_dirs != NULL &amp;&amp; vim_ispathsep(*p)) {</a>
<a name="ln5641">        *allow_dirs = true;</a>
<a name="ln5642">      }</a>
<a name="ln5643">      reg_pat[i++] = *p;</a>
<a name="ln5644">      break;</a>
<a name="ln5645">    }</a>
<a name="ln5646">  }</a>
<a name="ln5647">  if (add_dollar) {</a>
<a name="ln5648">    reg_pat[i++] = '$';</a>
<a name="ln5649">  }</a>
<a name="ln5650">  reg_pat[i] = NUL;</a>
<a name="ln5651">  if (nested != 0) {</a>
<a name="ln5652">    if (nested &lt; 0) {</a>
<a name="ln5653">      emsg(_(&quot;E219: Missing {.&quot;));</a>
<a name="ln5654">    } else {</a>
<a name="ln5655">      emsg(_(&quot;E220: Missing }.&quot;));</a>
<a name="ln5656">    }</a>
<a name="ln5657">    XFREE_CLEAR(reg_pat);</a>
<a name="ln5658">  }</a>
<a name="ln5659">  return reg_pat;</a>
<a name="ln5660">}</a>
<a name="ln5661"> </a>
<a name="ln5662">#if defined(EINTR)</a>
<a name="ln5663"> </a>
<a name="ln5664">/// Version of read() that retries when interrupted by EINTR (possibly</a>
<a name="ln5665">/// by a SIGWINCH).</a>
<a name="ln5666">long read_eintr(int fd, void *buf, size_t bufsize)</a>
<a name="ln5667">{</a>
<a name="ln5668">  long ret;</a>
<a name="ln5669"> </a>
<a name="ln5670">  for (;;) {</a>
<a name="ln5671">    ret = read(fd, buf, bufsize);</a>
<a name="ln5672">    if (ret &gt;= 0 || errno != EINTR) {</a>
<a name="ln5673">      break;</a>
<a name="ln5674">    }</a>
<a name="ln5675">  }</a>
<a name="ln5676">  return ret;</a>
<a name="ln5677">}</a>
<a name="ln5678"> </a>
<a name="ln5679">/// Version of write() that retries when interrupted by EINTR (possibly</a>
<a name="ln5680">/// by a SIGWINCH).</a>
<a name="ln5681">long write_eintr(int fd, void *buf, size_t bufsize)</a>
<a name="ln5682">{</a>
<a name="ln5683">  long ret = 0;</a>
<a name="ln5684"> </a>
<a name="ln5685">  // Repeat the write() so long it didn't fail, other than being interrupted</a>
<a name="ln5686">  // by a signal.</a>
<a name="ln5687">  while (ret &lt; (long)bufsize) {</a>
<a name="ln5688">    long wlen = write(fd, (char *)buf + ret, bufsize - (size_t)ret);</a>
<a name="ln5689">    if (wlen &lt; 0) {</a>
<a name="ln5690">      if (errno != EINTR) {</a>
<a name="ln5691">        break;</a>
<a name="ln5692">      }</a>
<a name="ln5693">    } else {</a>
<a name="ln5694">      ret += wlen;</a>
<a name="ln5695">    }</a>
<a name="ln5696">  }</a>
<a name="ln5697">  return ret;</a>
<a name="ln5698">}</a>
<a name="ln5699">#endif</a>
</code></pre>
<div class="balloon" rel="5200"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'strlen(tmp) - strlen(user)' index could reach 18446744073709551615.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>