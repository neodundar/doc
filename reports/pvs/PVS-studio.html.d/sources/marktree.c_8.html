<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>marktree.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// Tree data structure for storing marks at (row, col) positions and updating</a>
<a name="ln5">// them to arbitrary text changes. Derivative work of kbtree in klib, whose</a>
<a name="ln6">// copyright notice is reproduced below. Also inspired by the design of the</a>
<a name="ln7">// marker tree data structure of the Atom editor, regarding efficient updates</a>
<a name="ln8">// to text changes.</a>
<a name="ln9">//</a>
<a name="ln10">// Marks are inserted using marktree_put. Text changes are processed using</a>
<a name="ln11">// marktree_splice. All read and delete operations use the iterator.</a>
<a name="ln12">// use marktree_itr_get to put an iterator at a given position or</a>
<a name="ln13">// marktree_lookup to lookup a mark by its id (iterator optional in this case).</a>
<a name="ln14">// Use marktree_itr_current and marktree_itr_next/prev to read marks in a loop.</a>
<a name="ln15">// marktree_del_itr deletes the current mark of the iterator and implicitly</a>
<a name="ln16">// moves the iterator to the next mark.</a>
<a name="ln17">//</a>
<a name="ln18">// Work is ongoing to fully support ranges (mark pairs).</a>
<a name="ln19"> </a>
<a name="ln20">// Copyright notice for kbtree (included in heavily modified form):</a>
<a name="ln21">//</a>
<a name="ln22">// Copyright 1997-1999, 2001, John-Mark Gurney.</a>
<a name="ln23">//           2008-2009, Attractive Chaos &lt;attractor@live.co.uk&gt;</a>
<a name="ln24">//</a>
<a name="ln25">// Redistribution and use in source and binary forms, with or without</a>
<a name="ln26">// modification, are permitted provided that the following conditions</a>
<a name="ln27">// are met:</a>
<a name="ln28">//</a>
<a name="ln29">// 1. Redistributions of source code must retain the above copyright</a>
<a name="ln30">//    notice, this list of conditions and the following disclaimer.</a>
<a name="ln31">// 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln32">//    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln33">//    documentation and/or other materials provided with the distribution.</a>
<a name="ln34">//</a>
<a name="ln35">// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln36">// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln37">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln38">// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</a>
<a name="ln39">// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln40">// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln41">// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln42">// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln43">// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln44">// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln45">// SUCH DAMAGE.</a>
<a name="ln46">//</a>
<a name="ln47">// Changes done by by the neovim project follow the Apache v2 license available</a>
<a name="ln48">// at the repo root.</a>
<a name="ln49"> </a>
<a name="ln50">#include &lt;assert.h&gt;</a>
<a name="ln51"> </a>
<a name="ln52">#include &quot;klib/kvec.h&quot;</a>
<a name="ln53">#include &quot;nvim/garray.h&quot;</a>
<a name="ln54">#include &quot;nvim/marktree.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56">#define T MT_BRANCH_FACTOR</a>
<a name="ln57">#define ILEN (sizeof(mtnode_t) + (2 * T) * sizeof(void *))</a>
<a name="ln58"> </a>
<a name="ln59">#define ID_INCR (((uint64_t)1) &lt;&lt; 2)</a>
<a name="ln60"> </a>
<a name="ln61">#define rawkey(itr) ((itr)-&gt;node-&gt;key[(itr)-&gt;i])</a>
<a name="ln62"> </a>
<a name="ln63">static bool pos_leq(mtpos_t a, mtpos_t b)</a>
<a name="ln64">{</a>
<a name="ln65">  return a.row &lt; b.row || (a.row == b.row &amp;&amp; a.col &lt;= b.col);</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">static void relative(mtpos_t base, mtpos_t *val)</a>
<a name="ln69">{</a>
<a name="ln70">  assert(pos_leq(base, *val));</a>
<a name="ln71">  if (val-&gt;row == base.row) {</a>
<a name="ln72">    val-&gt;row = 0;</a>
<a name="ln73">    val-&gt;col -= base.col;</a>
<a name="ln74">  } else {</a>
<a name="ln75">    val-&gt;row -= base.row;</a>
<a name="ln76">  }</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">static void unrelative(mtpos_t base, mtpos_t *val)</a>
<a name="ln80">{</a>
<a name="ln81">  if (val-&gt;row == 0) {</a>
<a name="ln82">    val-&gt;row = base.row;</a>
<a name="ln83">    val-&gt;col += base.col;</a>
<a name="ln84">  } else {</a>
<a name="ln85">    val-&gt;row += base.row;</a>
<a name="ln86">  }</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">static void compose(mtpos_t *base, mtpos_t val)</a>
<a name="ln90">{</a>
<a name="ln91">  if (val.row == 0) {</a>
<a name="ln92">    base-&gt;col += val.col;</a>
<a name="ln93">  } else {</a>
<a name="ln94">    base-&gt;row += val.row;</a>
<a name="ln95">    base-&gt;col = val.col;</a>
<a name="ln96">  }</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln100"># include &quot;marktree.c.generated.h&quot;</a>
<a name="ln101">#endif</a>
<a name="ln102"> </a>
<a name="ln103">#define mt_generic_cmp(a, b) (((b) &lt; (a)) - ((a) &lt; (b)))</a>
<a name="ln104">static int key_cmp(mtkey_t a, mtkey_t b)</a>
<a name="ln105">{</a>
<a name="ln106">  int cmp = mt_generic_cmp(a.pos.row, b.pos.row);</a>
<a name="ln107">  if (cmp != 0) {</a>
<a name="ln108">    return cmp;</a>
<a name="ln109">  }</a>
<a name="ln110">  cmp = mt_generic_cmp(a.pos.col, b.pos.col);</a>
<a name="ln111">  if (cmp != 0) {</a>
<a name="ln112">    return cmp;</a>
<a name="ln113">  }</a>
<a name="ln114">  // NB: keeping the events at the same pos sorted by id is actually not</a>
<a name="ln115">  // necessary only make sure that START is before END etc.</a>
<a name="ln116">  return mt_generic_cmp(a.flags, b.flags);</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">static inline int marktree_getp_aux(const mtnode_t *x, mtkey_t k, int *r)</a>
<a name="ln120">{</a>
<a name="ln121">  int tr, *rr, begin = 0, end = x-&gt;n;</a>
<a name="ln122">  if (x-&gt;n == 0) {</a>
<a name="ln123">    return -1;</a>
<a name="ln124">  }</a>
<a name="ln125">  rr = r? r : &amp;tr;</a>
<a name="ln126">  while (begin &lt; end) {</a>
<a name="ln127">    int mid = (begin + end) &gt;&gt; 1;</a>
<a name="ln128">    if (key_cmp(x-&gt;key[mid], k) &lt; 0) {</a>
<a name="ln129">      begin = mid + 1;</a>
<a name="ln130">    } else {</a>
<a name="ln131">      end = mid;</a>
<a name="ln132">    }</a>
<a name="ln133">  }</a>
<a name="ln134">  if (begin == x-&gt;n) {</a>
<a name="ln135">    *rr = 1; return x-&gt;n - 1;</a>
<a name="ln136">  }</a>
<a name="ln137">  if ((*rr = key_cmp(k, x-&gt;key[begin])) &lt; 0) {</a>
<a name="ln138">    begin--;</a>
<a name="ln139">  }</a>
<a name="ln140">  return begin;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">static inline void refkey(MarkTree *b, mtnode_t *x, int i)</a>
<a name="ln144">{</a>
<a name="ln145">  pmap_put(uint64_t)(b-&gt;id2node, mt_lookup_key(x-&gt;key[i]), x);</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">// put functions</a>
<a name="ln149"> </a>
<a name="ln150">// x must be an internal node, which is not full</a>
<a name="ln151">// x-&gt;ptr[i] should be a full node, i e x-&gt;ptr[i]-&gt;n == 2*T-1</a>
<a name="ln152">static inline void split_node(MarkTree *b, mtnode_t *x, const int i)</a>
<a name="ln153">{</a>
<a name="ln154">  mtnode_t *y = x-&gt;ptr[i];</a>
<a name="ln155">  mtnode_t *z;</a>
<a name="ln156">  z = (mtnode_t *)xcalloc(1, y-&gt;level ? ILEN : sizeof(mtnode_t));</a>
<a name="ln157">  b-&gt;n_nodes++;</a>
<a name="ln158">  z-&gt;level = y-&gt;level;</a>
<a name="ln159">  z-&gt;n = T - 1;</a>
<a name="ln160">  memcpy(z-&gt;key, &amp;y-&gt;key[T], sizeof(mtkey_t) * (T - 1));</a>
<a name="ln161">  for (int j = 0; j &lt; T - 1; j++) {</a>
<a name="ln162">    refkey(b, z, j);</a>
<a name="ln163">  }</a>
<a name="ln164">  if (y-&gt;level) {</a>
<a name="ln165">    memcpy(z-&gt;ptr, &amp;y-&gt;ptr[T], sizeof(mtnode_t *) * T);</a>
<a name="ln166">    for (int j = 0; j &lt; T; j++) {</a>
<a name="ln167">      z-&gt;ptr[j]-&gt;parent = z;</a>
<a name="ln168">    }</a>
<a name="ln169">  }</a>
<a name="ln170">  y-&gt;n = T - 1;</a>
<a name="ln171">  memmove(&amp;x-&gt;ptr[i + 2], &amp;x-&gt;ptr[i + 1],</a>
<a name="ln172">          sizeof(mtnode_t *) * (size_t)(x-&gt;n - i));</a>
<a name="ln173">  x-&gt;ptr[i + 1] = z;</a>
<a name="ln174">  z-&gt;parent = x;  // == y-&gt;parent</a>
<a name="ln175">  memmove(&amp;x-&gt;key[i + 1], &amp;x-&gt;key[i], sizeof(mtkey_t) * (size_t)(x-&gt;n - i));</a>
<a name="ln176"> </a>
<a name="ln177">  // move key to internal layer:</a>
<a name="ln178">  x-&gt;key[i] = y-&gt;key[T - 1];</a>
<a name="ln179">  refkey(b, x, i);</a>
<a name="ln180">  x-&gt;n++;</a>
<a name="ln181"> </a>
<a name="ln182">  for (int j = 0; j &lt; T - 1; j++) {</a>
<a name="ln183">    relative(x-&gt;key[i].pos, &amp;z-&gt;key[j].pos);</a>
<a name="ln184">  }</a>
<a name="ln185">  if (i &gt; 0) {</a>
<a name="ln186">    unrelative(x-&gt;key[i - 1].pos, &amp;x-&gt;key[i].pos);</a>
<a name="ln187">  }</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">// x must not be a full node (even if there might be internal space)</a>
<a name="ln191">static inline void marktree_putp_aux(MarkTree *b, mtnode_t *x, mtkey_t k)</a>
<a name="ln192">{</a>
<a name="ln193">  int i;</a>
<a name="ln194">  if (x-&gt;level == 0) {</a>
<a name="ln195">    i = marktree_getp_aux(x, k, 0);</a>
<a name="ln196">    if (i != x-&gt;n - 1) {</a>
<a name="ln197">      memmove(&amp;x-&gt;key[i + 2], &amp;x-&gt;key[i + 1],</a>
<a name="ln198">              (size_t)(x-&gt;n - i - 1) * sizeof(mtkey_t));</a>
<a name="ln199">    }</a>
<a name="ln200">    x-&gt;key[i + 1] = k;</a>
<a name="ln201">    refkey(b, x, i + 1);</a>
<a name="ln202">    x-&gt;n++;</a>
<a name="ln203">  } else {</a>
<a name="ln204">    i = marktree_getp_aux(x, k, 0) + 1;</a>
<a name="ln205">    if (x-&gt;ptr[i]-&gt;n == 2 * T - 1) {</a>
<a name="ln206">      split_node(b, x, i);</a>
<a name="ln207">      if (key_cmp(k, x-&gt;key[i]) &gt; 0) {</a>
<a name="ln208">        i++;</a>
<a name="ln209">      }</a>
<a name="ln210">    }</a>
<a name="ln211">    if (i &gt; 0) {</a>
<a name="ln212">      relative(x-&gt;key[i - 1].pos, &amp;k.pos);</a>
<a name="ln213">    }</a>
<a name="ln214">    marktree_putp_aux(b, x-&gt;ptr[i], k);</a>
<a name="ln215">  }</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">void marktree_put(MarkTree *b, mtkey_t key, int end_row, int end_col, bool end_right)</a>
<a name="ln219">{</a>
<a name="ln220">  assert(!(key.flags &amp; ~MT_FLAG_EXTERNAL_MASK));</a>
<a name="ln221">  if (end_row &gt;= 0) {</a>
<a name="ln222">    key.flags |= MT_FLAG_PAIRED;</a>
<a name="ln223">  }</a>
<a name="ln224"> </a>
<a name="ln225">  marktree_put_key(b, key);</a>
<a name="ln226"> </a>
<a name="ln227">  if (end_row &gt;= 0) {</a>
<a name="ln228">    mtkey_t end_key = key;</a>
<a name="ln229">    end_key.flags = (uint16_t)((uint16_t)(key.flags &amp; ~MT_FLAG_RIGHT_GRAVITY)</a>
<a name="ln230">                               |(uint16_t)MT_FLAG_END</a>
<a name="ln231">                               |(uint16_t)(end_right ? MT_FLAG_RIGHT_GRAVITY : 0));</a>
<a name="ln232">    end_key.pos = (mtpos_t){ end_row, end_col };</a>
<a name="ln233">    marktree_put_key(b, end_key);</a>
<a name="ln234">  }</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">void marktree_put_key(MarkTree *b, mtkey_t k)</a>
<a name="ln238">{</a>
<a name="ln239">  k.flags |= MT_FLAG_REAL;  // let's be real.</a>
<a name="ln240">  if (!b-&gt;root) {</a>
<a name="ln241">    b-&gt;root = (mtnode_t *)xcalloc(1, ILEN);</a>
<a name="ln242">    b-&gt;n_nodes++;</a>
<a name="ln243">  }</a>
<a name="ln244">  mtnode_t *r, *s;</a>
<a name="ln245">  b-&gt;n_keys++;</a>
<a name="ln246">  r = b-&gt;root;</a>
<a name="ln247">  if (r-&gt;n == 2 * T - 1) {</a>
<a name="ln248">    b-&gt;n_nodes++;</a>
<a name="ln249">    s = (mtnode_t *)xcalloc(1, ILEN);</a>
<a name="ln250">    b-&gt;root = s; s-&gt;level = r-&gt;level + 1; s-&gt;n = 0;</a>
<a name="ln251">    s-&gt;ptr[0] = r;</a>
<a name="ln252">    r-&gt;parent = s;</a>
<a name="ln253">    split_node(b, s, 0);</a>
<a name="ln254">    r = s;</a>
<a name="ln255">  }</a>
<a name="ln256">  marktree_putp_aux(b, r, k);</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">/// INITIATING DELETION PROTOCOL:</a>
<a name="ln260">///</a>
<a name="ln261">/// 1. Construct a valid iterator to the node to delete (argument)</a>
<a name="ln262">/// 2. If an &quot;internal&quot; key. Iterate one step to the left or right,</a>
<a name="ln263">///     which gives an internal key &quot;auxiliary key&quot;.</a>
<a name="ln264">/// 3. Now delete this internal key (intended or auxiliary).</a>
<a name="ln265">///    The leaf node X might become undersized.</a>
<a name="ln266">/// 4. If step two was done: now replace the key that _should_ be</a>
<a name="ln267">///    deleted with the auxiliary key. Adjust relative</a>
<a name="ln268">/// 5. Now &quot;repair&quot; the tree as needed. We always start at a leaf node X.</a>
<a name="ln269">///     - if the node is big enough, terminate</a>
<a name="ln270">///     - if we can steal from the left, steal</a>
<a name="ln271">///     - if we can steal from the right, steal</a>
<a name="ln272">///     - otherwise merge this node with a neighbour. This might make our</a>
<a name="ln273">///       parent undersized. So repeat 5 for the parent.</a>
<a name="ln274">/// 6. If 4 went all the way to the root node. The root node</a>
<a name="ln275">///    might have ended up with size 0. Delete it then.</a>
<a name="ln276">///</a>
<a name="ln277">/// NB: ideally keeps the iterator valid. Like point to the key after this</a>
<a name="ln278">/// if present.</a>
<a name="ln279">///</a>
<a name="ln280">/// @param rev should be true if we plan to iterate _backwards_ and delete</a>
<a name="ln281">///            stuff before this key. Most of the time this is false (the</a>
<a name="ln282">///            recommended strategy is to always iterate forward)</a>
<a name="ln283">void marktree_del_itr(MarkTree *b, MarkTreeIter *itr, bool rev)</a>
<a name="ln284">{</a>
<a name="ln285">  int adjustment = 0;</a>
<a name="ln286"> </a>
<a name="ln287">  mtnode_t *cur = itr-&gt;node;</a>
<a name="ln288">  int curi = itr-&gt;i;</a>
<a name="ln289">  uint64_t id = mt_lookup_key(cur-&gt;key[curi]);</a>
<a name="ln290">  // fprintf(stderr, &quot;\nDELET %lu\n&quot;, id);</a>
<a name="ln291"> </a>
<a name="ln292">  if (itr-&gt;node-&gt;level) {</a>
<a name="ln293">    if (rev) {</a>
<a name="ln294">      abort();</a>
<a name="ln295">    } else {</a>
<a name="ln296">      // fprintf(stderr, &quot;INTERNAL %d\n&quot;, cur-&gt;level);</a>
<a name="ln297">      // steal previous node</a>
<a name="ln298">      marktree_itr_prev(b, itr);</a>
<a name="ln299">      adjustment = -1;</a>
<a name="ln300">    }</a>
<a name="ln301">  }</a>
<a name="ln302"> </a>
<a name="ln303">  // 3.</a>
<a name="ln304">  mtnode_t *x = itr-&gt;node;</a>
<a name="ln305">  assert(x-&gt;level == 0);</a>
<a name="ln306">  mtkey_t intkey = x-&gt;key[itr-&gt;i];</a>
<a name="ln307">  if (x-&gt;n &gt; itr-&gt;i + 1) {</a>
<a name="ln308">    memmove(&amp;x-&gt;key[itr-&gt;i], &amp;x-&gt;key[itr-&gt;i + 1],</a>
<a name="ln309">            sizeof(mtkey_t) * (size_t)(x-&gt;n - itr-&gt;i - 1));</a>
<a name="ln310">  }</a>
<a name="ln311">  x-&gt;n--;</a>
<a name="ln312"> </a>
<a name="ln313">  // 4.</a>
<a name="ln314">  // if (adjustment == 1) {</a>
<a name="ln315">  //   abort();</a>
<a name="ln316">  // }</a>
<a name="ln317">  if (adjustment == -1) {</a>
<a name="ln318">    int ilvl = itr-&gt;lvl - 1;</a>
<a name="ln319">    const mtnode_t *lnode = x;</a>
<a name="ln320">    do {</a>
<a name="ln321">      const mtnode_t *const p = lnode-&gt;parent;</a>
<a name="ln322">      if (ilvl &lt; 0) {</a>
<a name="ln323">        abort();</a>
<a name="ln324">      }</a>
<a name="ln325">      const int i = itr-&gt;s[ilvl].i;</a>
<a name="ln326">      assert(p-&gt;ptr[i] == lnode);</a>
<a name="ln327">      if (i &gt; 0) {</a>
<a name="ln328">        unrelative(p-&gt;key[i - 1].pos, &amp;intkey.pos);</a>
<a name="ln329">      }</a>
<a name="ln330">      lnode = p;</a>
<a name="ln331">      ilvl--;</a>
<a name="ln332">    } while (lnode != cur);</a>
<a name="ln333"> </a>
<a name="ln334">    mtkey_t deleted = cur-&gt;key[curi];</a>
<a name="ln335">    cur-&gt;key[curi] = intkey;</a>
<a name="ln336">    refkey(b, cur, curi);</a>
<a name="ln337">    relative(intkey.pos, &amp;deleted.pos);</a>
<a name="ln338">    mtnode_t *y = cur-&gt;ptr[curi + 1];</a>
<a name="ln339">    if (deleted.pos.row || deleted.pos.col) {</a>
<a name="ln340">      while (y) {</a>
<a name="ln341">        for (int k = 0; k &lt; y-&gt;n; k++) {</a>
<a name="ln342">          unrelative(deleted.pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln343">        }</a>
<a name="ln344">        y = y-&gt;level ? y-&gt;ptr[0] : NULL;</a>
<a name="ln345">      }</a>
<a name="ln346">    }</a>
<a name="ln347">    itr-&gt;i--;</a>
<a name="ln348">  }</a>
<a name="ln349"> </a>
<a name="ln350">  b-&gt;n_keys--;</a>
<a name="ln351">  pmap_del(uint64_t)(b-&gt;id2node, id);</a>
<a name="ln352"> </a>
<a name="ln353">  // 5.</a>
<a name="ln354">  bool itr_dirty = false;</a>
<a name="ln355">  int rlvl = itr-&gt;lvl - 1;</a>
<a name="ln356">  int *lasti = &amp;itr-&gt;i;</a>
<a name="ln357">  while (x != b-&gt;root) {</a>
<a name="ln358">    assert(rlvl &gt;= 0);</a>
<a name="ln359">    mtnode_t *p = x-&gt;parent;</a>
<a name="ln360">    if (x-&gt;n &gt;= T - 1) {</a>
<a name="ln361">      // we are done, if this node is fine the rest of the tree will be</a>
<a name="ln362">      break;</a>
<a name="ln363">    }</a>
<a name="ln364">    int pi = itr-&gt;s[rlvl].i;</a>
<a name="ln365">    assert(p-&gt;ptr[pi] == x);</a>
<a name="ln366">    if (pi &gt; 0 &amp;&amp; p-&gt;ptr[pi - 1]-&gt;n &gt; T - 1) {</a>
<a name="ln367">      *lasti += 1;</a>
<a name="ln368">      itr_dirty = true;</a>
<a name="ln369">      // steal one key from the left neighbour</a>
<a name="ln370">      pivot_right(b, p, pi - 1);</a>
<a name="ln371">      break;</a>
<a name="ln372">    } else if (pi &lt; p-&gt;n &amp;&amp; p-&gt;ptr[pi + 1]-&gt;n &gt; T - 1) {</a>
<a name="ln373">      // steal one key from right neighbour</a>
<a name="ln374">      pivot_left(b, p, pi);</a>
<a name="ln375">      break;</a>
<a name="ln376">    } else if (pi &gt; 0) {</a>
<a name="ln377">      // fprintf(stderr, &quot;LEFT &quot;);</a>
<a name="ln378">      assert(p-&gt;ptr[pi - 1]-&gt;n == T - 1);</a>
<a name="ln379">      // merge with left neighbour</a>
<a name="ln380">      *lasti += T;</a>
<a name="ln381">      x = merge_node(b, p, pi - 1);</a>
<a name="ln382">      if (lasti == &amp;itr-&gt;i) {</a>
<a name="ln383">        // TRICKY: we merged the node the iterator was on</a>
<a name="ln384">        itr-&gt;node = x;</a>
<a name="ln385">      }</a>
<a name="ln386">      itr-&gt;s[rlvl].i--;</a>
<a name="ln387">      itr_dirty = true;</a>
<a name="ln388">    } else {</a>
<a name="ln389">      // fprintf(stderr, &quot;RIGHT &quot;);</a>
<a name="ln390">      assert(pi &lt; p-&gt;n &amp;&amp; p-&gt;ptr[pi + 1]-&gt;n == T - 1);</a>
<a name="ln391">      merge_node(b, p, pi);</a>
<a name="ln392">      // no iter adjustment needed</a>
<a name="ln393">    }</a>
<a name="ln394">    lasti = &amp;itr-&gt;s[rlvl].i;</a>
<a name="ln395">    rlvl--;</a>
<a name="ln396">    x = p;</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">  // 6.</a>
<a name="ln400">  if (b-&gt;root-&gt;n == 0) {</a>
<a name="ln401">    if (itr-&gt;lvl &gt; 0) {</a>
<a name="ln402">      memmove(itr-&gt;s, itr-&gt;s + 1, (size_t)(itr-&gt;lvl - 1) * sizeof(*itr-&gt;s));</a>
<a name="ln403">      itr-&gt;lvl--;</a>
<a name="ln404">    }</a>
<a name="ln405">    if (b-&gt;root-&gt;level) {</a>
<a name="ln406">      mtnode_t *oldroot = b-&gt;root;</a>
<a name="ln407">      b-&gt;root = b-&gt;root-&gt;ptr[0];</a>
<a name="ln408">      b-&gt;root-&gt;parent = NULL;</a>
<a name="ln409">      xfree(oldroot);</a>
<a name="ln410">    } else {</a>
<a name="ln411">      // no items, nothing for iterator to point to</a>
<a name="ln412">      // not strictly needed, should handle delete right-most mark anyway</a>
<a name="ln413">      itr-&gt;node = NULL;</a>
<a name="ln414">    }</a>
<a name="ln415">  }</a>
<a name="ln416"> </a>
<a name="ln417">  if (itr-&gt;node &amp;&amp; itr_dirty) {</a>
<a name="ln418">    marktree_itr_fix_pos(b, itr);</a>
<a name="ln419">  }</a>
<a name="ln420"> </a>
<a name="ln421">  // BONUS STEP: fix the iterator, so that it points to the key afterwards</a>
<a name="ln422">  // TODO(bfredl): with &quot;rev&quot; should point before</a>
<a name="ln423">  // if (adjustment == 1) {</a>
<a name="ln424">  //   abort();</a>
<a name="ln425">  // }</a>
<a name="ln426">  if (adjustment == -1) {</a>
<a name="ln427">    // tricky: we stand at the deleted space in the previous leaf node.</a>
<a name="ln428">    // But the inner key is now the previous key we stole, so we need</a>
<a name="ln429">    // to skip that one as well.</a>
<a name="ln430">    marktree_itr_next(b, itr);</a>
<a name="ln431">    marktree_itr_next(b, itr);</a>
<a name="ln432">  } else {</a>
<a name="ln433">    if (itr-&gt;node &amp;&amp; itr-&gt;i &gt;= itr-&gt;node-&gt;n) {</a>
<a name="ln434">      // we deleted the last key of a leaf node</a>
<a name="ln435">      // go to the inner key after that.</a>
<a name="ln436">      assert(itr-&gt;node-&gt;level == 0);</a>
<a name="ln437">      marktree_itr_next(b, itr);</a>
<a name="ln438">    }</a>
<a name="ln439">  }</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">static mtnode_t *merge_node(MarkTree *b, mtnode_t *p, int i)</a>
<a name="ln443">{</a>
<a name="ln444">  mtnode_t *x = p-&gt;ptr[i], *y = p-&gt;ptr[i + 1];</a>
<a name="ln445"> </a>
<a name="ln446">  x-&gt;key[x-&gt;n] = p-&gt;key[i];</a>
<a name="ln447">  refkey(b, x, x-&gt;n);</a>
<a name="ln448">  if (i &gt; 0) {</a>
<a name="ln449">    relative(p-&gt;key[i - 1].pos, &amp;x-&gt;key[x-&gt;n].pos);</a>
<a name="ln450">  }</a>
<a name="ln451"> </a>
<a name="ln452">  memmove(&amp;x-&gt;key[x-&gt;n + 1], y-&gt;key, (size_t)y-&gt;n * sizeof(mtkey_t));</a>
<a name="ln453">  for (int k = 0; k &lt; y-&gt;n; k++) {</a>
<a name="ln454">    refkey(b, x, x-&gt;n + 1 + k);</a>
<a name="ln455">    unrelative(x-&gt;key[x-&gt;n].pos, &amp;x-&gt;key[x-&gt;n + 1 + k].pos);</a>
<a name="ln456">  }</a>
<a name="ln457">  if (x-&gt;level) {</a>
<a name="ln458">    memmove(&amp;x-&gt;ptr[x-&gt;n + 1], y-&gt;ptr, ((size_t)y-&gt;n + 1) * sizeof(mtnode_t *));</a>
<a name="ln459">    for (int k = 0; k &lt; y-&gt;n + 1; k++) {</a>
<a name="ln460">      x-&gt;ptr[x-&gt;n + k + 1]-&gt;parent = x;</a>
<a name="ln461">    }</a>
<a name="ln462">  }</a>
<a name="ln463">  x-&gt;n += y-&gt;n + 1;</a>
<a name="ln464">  memmove(&amp;p-&gt;key[i], &amp;p-&gt;key[i + 1], (size_t)(p-&gt;n - i - 1) * sizeof(mtkey_t));</a>
<a name="ln465">  memmove(&amp;p-&gt;ptr[i + 1], &amp;p-&gt;ptr[i + 2],</a>
<a name="ln466">          (size_t)(p-&gt;n - i - 1) * sizeof(mtkey_t *));</a>
<a name="ln467">  p-&gt;n--;</a>
<a name="ln468">  xfree(y);</a>
<a name="ln469">  b-&gt;n_nodes--;</a>
<a name="ln470">  return x;</a>
<a name="ln471">}</a>
<a name="ln472"> </a>
<a name="ln473">// TODO(bfredl): as a potential &quot;micro&quot; optimization, pivoting should balance</a>
<a name="ln474">// the two nodes instead of stealing just one key</a>
<a name="ln475">static void pivot_right(MarkTree *b, mtnode_t *p, int i)</a>
<a name="ln476">{</a>
<a name="ln477">  mtnode_t *x = p-&gt;ptr[i], *y = p-&gt;ptr[i + 1];</a>
<a name="ln478">  memmove(&amp;y-&gt;key[1], y-&gt;key, (size_t)y-&gt;n * sizeof(mtkey_t));</a>
<a name="ln479">  if (y-&gt;level) {</a>
<a name="ln480">    memmove(&amp;y-&gt;ptr[1], y-&gt;ptr, ((size_t)y-&gt;n + 1) * sizeof(mtnode_t *));</a>
<a name="ln481">  }</a>
<a name="ln482">  y-&gt;key[0] = p-&gt;key[i];</a>
<a name="ln483">  refkey(b, y, 0);</a>
<a name="ln484">  p-&gt;key[i] = x-&gt;key[x-&gt;n - 1];</a>
<a name="ln485">  refkey(b, p, i);</a>
<a name="ln486">  if (x-&gt;level) {</a>
<a name="ln487">    y-&gt;ptr[0] = x-&gt;ptr[x-&gt;n];</a>
<a name="ln488">    y-&gt;ptr[0]-&gt;parent = y;</a>
<a name="ln489">  }</a>
<a name="ln490">  x-&gt;n--;</a>
<a name="ln491">  y-&gt;n++;</a>
<a name="ln492">  if (i &gt; 0) {</a>
<a name="ln493">    unrelative(p-&gt;key[i - 1].pos, &amp;p-&gt;key[i].pos);</a>
<a name="ln494">  }</a>
<a name="ln495">  relative(p-&gt;key[i].pos, &amp;y-&gt;key[0].pos);</a>
<a name="ln496">  for (int k = 1; k &lt; y-&gt;n; k++) {</a>
<a name="ln497">    unrelative(y-&gt;key[0].pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln498">  }</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">static void pivot_left(MarkTree *b, mtnode_t *p, int i)</a>
<a name="ln502">{</a>
<a name="ln503">  mtnode_t *x = p-&gt;ptr[i], *y = p-&gt;ptr[i + 1];</a>
<a name="ln504"> </a>
<a name="ln505">  // reverse from how we &quot;always&quot; do it. but pivot_left</a>
<a name="ln506">  // is just the inverse of pivot_right, so reverse it literally.</a>
<a name="ln507">  for (int k = 1; k &lt; y-&gt;n; k++) {</a>
<a name="ln508">    relative(y-&gt;key[0].pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln509">  }</a>
<a name="ln510">  unrelative(p-&gt;key[i].pos, &amp;y-&gt;key[0].pos);</a>
<a name="ln511">  if (i &gt; 0) {</a>
<a name="ln512">    relative(p-&gt;key[i - 1].pos, &amp;p-&gt;key[i].pos);</a>
<a name="ln513">  }</a>
<a name="ln514"> </a>
<a name="ln515">  x-&gt;key[x-&gt;n] = p-&gt;key[i];</a>
<a name="ln516">  refkey(b, x, x-&gt;n);</a>
<a name="ln517">  p-&gt;key[i] = y-&gt;key[0];</a>
<a name="ln518">  refkey(b, p, i);</a>
<a name="ln519">  if (x-&gt;level) {</a>
<a name="ln520">    x-&gt;ptr[x-&gt;n + 1] = y-&gt;ptr[0];</a>
<a name="ln521">    x-&gt;ptr[x-&gt;n + 1]-&gt;parent = x;</a>
<a name="ln522">  }</a>
<a name="ln523">  memmove(y-&gt;key, &amp;y-&gt;key[1], (size_t)(y-&gt;n - 1) * sizeof(mtkey_t));</a>
<a name="ln524">  if (y-&gt;level) {</a>
<a name="ln525">    memmove(y-&gt;ptr, &amp;y-&gt;ptr[1], (size_t)y-&gt;n * sizeof(mtnode_t *));</a>
<a name="ln526">  }</a>
<a name="ln527">  x-&gt;n++;</a>
<a name="ln528">  y-&gt;n--;</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">/// frees all mem, resets tree to valid empty state</a>
<a name="ln532">void marktree_clear(MarkTree *b)</a>
<a name="ln533">{</a>
<a name="ln534">  if (b-&gt;root) {</a>
<a name="ln535">    marktree_free_node(b-&gt;root);</a>
<a name="ln536">    b-&gt;root = NULL;</a>
<a name="ln537">  }</a>
<a name="ln538">  if (b-&gt;id2node-&gt;table.keys) {</a>
<a name="ln539">    pmap_destroy(uint64_t)(b-&gt;id2node);</a>
<a name="ln540">    pmap_init(uint64_t, b-&gt;id2node);</a>
<a name="ln541">  }</a>
<a name="ln542">  b-&gt;n_keys = 0;</a>
<a name="ln543">  b-&gt;n_nodes = 0;</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">void marktree_free_node(mtnode_t *x)</a>
<a name="ln547">{</a>
<a name="ln548">  if (x-&gt;level) {</a>
<a name="ln549">    for (int i = 0; i &lt; x-&gt;n + 1; i++) {</a>
<a name="ln550">      marktree_free_node(x-&gt;ptr[i]);</a>
<a name="ln551">    }</a>
<a name="ln552">  }</a>
<a name="ln553">  xfree(x);</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">/// NB: caller must check not pair!</a>
<a name="ln557">void marktree_revise(MarkTree *b, MarkTreeIter *itr, uint8_t decor_level, mtkey_t key)</a>
<a name="ln558">{</a>
<a name="ln559">  // TODO(bfredl): clean up this mess and re-instantiate &amp;= and |= forms</a>
<a name="ln560">  // once we upgrade to a non-broken version of gcc in functionaltest-lua CI</a>
<a name="ln561">  rawkey(itr).flags = (uint16_t)(rawkey(itr).flags &amp; (uint16_t) ~MT_FLAG_DECOR_MASK);</a>
<a name="ln562">  rawkey(itr).flags = (uint16_t)(rawkey(itr).flags</a>
<a name="ln563">                                 | (uint16_t)(decor_level &lt;&lt; MT_FLAG_DECOR_OFFSET)</a>
<a name="ln564">                                 | (uint16_t)(key.flags &amp; MT_FLAG_DECOR_MASK));</a>
<a name="ln565">  rawkey(itr).decor_full = key.decor_full;</a>
<a name="ln566">  rawkey(itr).hl_id = key.hl_id;</a>
<a name="ln567">  rawkey(itr).priority = key.priority;</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">void marktree_move(MarkTree *b, MarkTreeIter *itr, int row, int col)</a>
<a name="ln571">{</a>
<a name="ln572">  mtkey_t key = rawkey(itr);</a>
<a name="ln573">  // TODO(bfredl): optimize when moving a mark within a leaf without moving it</a>
<a name="ln574">  // across neighbours!</a>
<a name="ln575">  marktree_del_itr(b, itr, false);</a>
<a name="ln576">  key.pos = (mtpos_t){ row, col };</a>
<a name="ln577"> </a>
<a name="ln578">  marktree_put_key(b, key);</a>
<a name="ln579">  itr-&gt;node = NULL;  // itr might become invalid by put</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">// itr functions</a>
<a name="ln583"> </a>
<a name="ln584">// TODO(bfredl): static inline?</a>
<a name="ln585">bool marktree_itr_get(MarkTree *b, int32_t row, int col, MarkTreeIter *itr)</a>
<a name="ln586">{</a>
<a name="ln587">  return marktree_itr_get_ext(b, (mtpos_t){ row, col },</a>
<a name="ln588">                              itr, false, false, NULL);</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">bool marktree_itr_get_ext(MarkTree *b, mtpos_t p, MarkTreeIter *itr, bool last, bool gravity,</a>
<a name="ln592">                          mtpos_t *oldbase)</a>
<a name="ln593">{</a>
<a name="ln594">  if (b-&gt;n_keys == 0) {</a>
<a name="ln595">    itr-&gt;node = NULL;</a>
<a name="ln596">    return false;</a>
<a name="ln597">  }</a>
<a name="ln598"> </a>
<a name="ln599">  mtkey_t k = { .pos = p, .flags = gravity ? MT_FLAG_RIGHT_GRAVITY : 0 };</a>
<a name="ln600">  if (last &amp;&amp; !gravity) {</a>
<a name="ln601">    k.flags = MT_FLAG_LAST;</a>
<a name="ln602">  }</a>
<a name="ln603">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln604">  itr-&gt;node = b-&gt;root;</a>
<a name="ln605">  itr-&gt;lvl = 0;</a>
<a name="ln606">  if (oldbase) {</a>
<a name="ln607">    oldbase[itr-&gt;lvl] = itr-&gt;pos;</a>
<a name="ln608">  }</a>
<a name="ln609">  while (true) {</a>
<a name="ln610">    itr-&gt;i = marktree_getp_aux(itr-&gt;node, k, 0) + 1;</a>
<a name="ln611"> </a>
<a name="ln612">    if (itr-&gt;node-&gt;level == 0) {</a>
<a name="ln613">      break;</a>
<a name="ln614">    }</a>
<a name="ln615"> </a>
<a name="ln616">    itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln617">    itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln618"> </a>
<a name="ln619">    if (itr-&gt;i &gt; 0) {</a>
<a name="ln620">      compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i - 1].pos);</a>
<a name="ln621">      relative(itr-&gt;node-&gt;key[itr-&gt;i - 1].pos, &amp;k.pos);</a>
<a name="ln622">    }</a>
<a name="ln623">    itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln624">    itr-&gt;lvl++;</a>
<a name="ln625">    if (oldbase) {</a>
<a name="ln626">      oldbase[itr-&gt;lvl] = itr-&gt;pos;</a>
<a name="ln627">    }</a>
<a name="ln628">  }</a>
<a name="ln629"> </a>
<a name="ln630">  if (last) {</a>
<a name="ln631">    return marktree_itr_prev(b, itr);</a>
<a name="ln632">  } else if (itr-&gt;i &gt;= itr-&gt;node-&gt;n) {</a>
<a name="ln633">    return marktree_itr_next(b, itr);</a>
<a name="ln634">  }</a>
<a name="ln635">  return true;</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">bool marktree_itr_first(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln639">{</a>
<a name="ln640">  itr-&gt;node = b-&gt;root;</a>
<a name="ln641">  if (b-&gt;n_keys == 0) {</a>
<a name="ln642">    return false;</a>
<a name="ln643">  }</a>
<a name="ln644"> </a>
<a name="ln645">  itr-&gt;i = 0;</a>
<a name="ln646">  itr-&gt;lvl = 0;</a>
<a name="ln647">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln648">  while (itr-&gt;node-&gt;level &gt; 0) {</a>
<a name="ln649">    itr-&gt;s[itr-&gt;lvl].i = 0;</a>
<a name="ln650">    itr-&gt;s[itr-&gt;lvl].oldcol = 0;</a>
<a name="ln651">    itr-&gt;lvl++;</a>
<a name="ln652">    itr-&gt;node = itr-&gt;node-&gt;ptr[0];</a>
<a name="ln653">  }</a>
<a name="ln654">  return true;</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">// gives the first key that is greater or equal to p</a>
<a name="ln658">int marktree_itr_last(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln659">{</a>
<a name="ln660">  if (b-&gt;n_keys == 0) {</a>
<a name="ln661">    itr-&gt;node = NULL;</a>
<a name="ln662">    return false;</a>
<a name="ln663">  }</a>
<a name="ln664">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln665">  itr-&gt;node = b-&gt;root;</a>
<a name="ln666">  itr-&gt;lvl = 0;</a>
<a name="ln667">  while (true) {</a>
<a name="ln668">    itr-&gt;i = itr-&gt;node-&gt;n;</a>
<a name="ln669"> </a>
<a name="ln670">    if (itr-&gt;node-&gt;level == 0) {</a>
<a name="ln671">      break;</a>
<a name="ln672">    }</a>
<a name="ln673"> </a>
<a name="ln674">    itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln675">    itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln676"> </a>
<a name="ln677">    assert(itr-&gt;i &gt; 0);</a>
<a name="ln678">    compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i - 1].pos);</a>
<a name="ln679"> </a>
<a name="ln680">    itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln681">    itr-&gt;lvl++;</a>
<a name="ln682">  }</a>
<a name="ln683">  itr-&gt;i--;</a>
<a name="ln684">  return true;</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687">// TODO(bfredl): static inline</a>
<a name="ln688">bool marktree_itr_next(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln689">{</a>
<a name="ln690">  return marktree_itr_next_skip(b, itr, false, NULL);</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">static bool marktree_itr_next_skip(MarkTree *b, MarkTreeIter *itr, bool skip, mtpos_t oldbase[])</a>
<a name="ln694">{</a>
<a name="ln695">  if (!itr-&gt;node) {</a>
<a name="ln696">    return false;</a>
<a name="ln697">  }</a>
<a name="ln698">  itr-&gt;i++;</a>
<a name="ln699">  if (itr-&gt;node-&gt;level == 0 || skip) {</a>
<a name="ln700">    if (itr-&gt;i &lt; itr-&gt;node-&gt;n) {</a>
<a name="ln701">      // TODO(bfredl): this is the common case,</a>
<a name="ln702">      // and could be handled by inline wrapper</a>
<a name="ln703">      return true;</a>
<a name="ln704">    }</a>
<a name="ln705">    // we ran out of non-internal keys. Go up until we find an internal key</a>
<a name="ln706">    while (itr-&gt;i &gt;= itr-&gt;node-&gt;n) {</a>
<a name="ln707">      itr-&gt;node = itr-&gt;node-&gt;parent;</a>
<a name="ln708">      if (itr-&gt;node == NULL) {</a>
<a name="ln709">        return false;</a>
<a name="ln710">      }</a>
<a name="ln711">      itr-&gt;lvl--;</a>
<a name="ln712">      itr-&gt;i = itr-&gt;s[itr-&gt;lvl].i;</a>
<a name="ln713">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln714">        itr-&gt;pos.row -= itr-&gt;node-&gt;key[itr-&gt;i - 1].pos.row;</a>
<a name="ln715">        itr-&gt;pos.col = itr-&gt;s[itr-&gt;lvl].oldcol;</a>
<a name="ln716">      }</a>
<a name="ln717">    }</a>
<a name="ln718">  } else {</a>
<a name="ln719">    // we stood at an &quot;internal&quot; key. Go down to the first non-internal</a>
<a name="ln720">    // key after it.</a>
<a name="ln721">    while (itr-&gt;node-&gt;level &gt; 0) {</a>
<a name="ln722">      // internal key, there is always a child after</a>
<a name="ln723">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln724">        itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln725">        compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i - 1].pos);</a>
<a name="ln726">      }</a>
<a name="ln727">      if (oldbase &amp;&amp; itr-&gt;i == 0) {</a>
<a name="ln728">        oldbase[itr-&gt;lvl + 1] = oldbase[itr-&gt;lvl];</a>
<a name="ln729">      }</a>
<a name="ln730">      itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln731">      assert(itr-&gt;node-&gt;ptr[itr-&gt;i]-&gt;parent == itr-&gt;node);</a>
<a name="ln732">      itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln733">      itr-&gt;i = 0;</a>
<a name="ln734">      itr-&gt;lvl++;</a>
<a name="ln735">    }</a>
<a name="ln736">  }</a>
<a name="ln737">  return true;</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">bool marktree_itr_prev(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln741">{</a>
<a name="ln742">  if (!itr-&gt;node) {</a>
<a name="ln743">    return false;</a>
<a name="ln744">  }</a>
<a name="ln745">  if (itr-&gt;node-&gt;level == 0) {</a>
<a name="ln746">    itr-&gt;i--;</a>
<a name="ln747">    if (itr-&gt;i &gt;= 0) {</a>
<a name="ln748">      // TODO(bfredl): this is the common case,</a>
<a name="ln749">      // and could be handled by inline wrapper</a>
<a name="ln750">      return true;</a>
<a name="ln751">    }</a>
<a name="ln752">    // we ran out of non-internal keys. Go up until we find a non-internal key</a>
<a name="ln753">    while (itr-&gt;i &lt; 0) {</a>
<a name="ln754">      itr-&gt;node = itr-&gt;node-&gt;parent;</a>
<a name="ln755">      if (itr-&gt;node == NULL) {</a>
<a name="ln756">        return false;</a>
<a name="ln757">      }</a>
<a name="ln758">      itr-&gt;lvl--;</a>
<a name="ln759">      itr-&gt;i = itr-&gt;s[itr-&gt;lvl].i - 1;</a>
<a name="ln760">      if (itr-&gt;i &gt;= 0) {</a>
<a name="ln761">        itr-&gt;pos.row -= itr-&gt;node-&gt;key[itr-&gt;i].pos.row;</a>
<a name="ln762">        itr-&gt;pos.col = itr-&gt;s[itr-&gt;lvl].oldcol;</a>
<a name="ln763">      }</a>
<a name="ln764">    }</a>
<a name="ln765">  } else {</a>
<a name="ln766">    // we stood at an &quot;internal&quot; key. Go down to the last non-internal</a>
<a name="ln767">    // key before it.</a>
<a name="ln768">    while (itr-&gt;node-&gt;level &gt; 0) {</a>
<a name="ln769">      // internal key, there is always a child before</a>
<a name="ln770">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln771">        itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln772">        compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i - 1].pos);</a>
<a name="ln773">      }</a>
<a name="ln774">      itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln775">      assert(itr-&gt;node-&gt;ptr[itr-&gt;i]-&gt;parent == itr-&gt;node);</a>
<a name="ln776">      itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln777">      itr-&gt;i = itr-&gt;node-&gt;n;</a>
<a name="ln778">      itr-&gt;lvl++;</a>
<a name="ln779">    }</a>
<a name="ln780">    itr-&gt;i--;</a>
<a name="ln781">  }</a>
<a name="ln782">  return true;</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785">void marktree_itr_rewind(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln786">{</a>
<a name="ln787">  if (!itr-&gt;node) {</a>
<a name="ln788">    return;</a>
<a name="ln789">  }</a>
<a name="ln790">  if (itr-&gt;node-&gt;level) {</a>
<a name="ln791">    marktree_itr_prev(b, itr);</a>
<a name="ln792">  }</a>
<a name="ln793">  itr-&gt;i = 0;</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">bool marktree_itr_node_done(MarkTreeIter *itr)</a>
<a name="ln797">{</a>
<a name="ln798">  return !itr-&gt;node || itr-&gt;i == itr-&gt;node-&gt;n - 1;</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801">mtpos_t marktree_itr_pos(MarkTreeIter *itr)</a>
<a name="ln802">{</a>
<a name="ln803">  mtpos_t pos = rawkey(itr).pos;</a>
<a name="ln804">  unrelative(itr-&gt;pos, &amp;pos);</a>
<a name="ln805">  return pos;</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808">mtkey_t marktree_itr_current(MarkTreeIter *itr)</a>
<a name="ln809">{</a>
<a name="ln810">  if (itr-&gt;node) {</a>
<a name="ln811">    mtkey_t key = rawkey(itr);</a>
<a name="ln812">    key.pos = marktree_itr_pos(itr);</a>
<a name="ln813">    return key;</a>
<a name="ln814">  }</a>
<a name="ln815">  return MT_INVALID_KEY;</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">static bool itr_eq(MarkTreeIter *itr1, MarkTreeIter *itr2)</a>
<a name="ln819">{</a>
<a name="ln820">  return (&amp;rawkey(itr1) == &amp;rawkey(itr2));</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">static void itr_swap(MarkTreeIter *itr1, MarkTreeIter *itr2)</a>
<a name="ln824">{</a>
<a name="ln825">  mtkey_t key1 = rawkey(itr1);</a>
<a name="ln826">  mtkey_t key2 = rawkey(itr2);</a>
<a name="ln827">  rawkey(itr1) = key2;</a>
<a name="ln828">  rawkey(itr1).pos = key1.pos;</a>
<a name="ln829">  rawkey(itr2) = key1;</a>
<a name="ln830">  rawkey(itr2).pos = key2.pos;</a>
<a name="ln831">}</a>
<a name="ln832"> </a>
<a name="ln833">bool marktree_splice(MarkTree *b, int32_t start_line, int start_col, int old_extent_line,</a>
<a name="ln834">                     int old_extent_col, int new_extent_line, int new_extent_col)</a>
<a name="ln835">{</a>
<a name="ln836">  mtpos_t start = { start_line, start_col };</a>
<a name="ln837">  mtpos_t old_extent = { old_extent_line, old_extent_col };</a>
<a name="ln838">  mtpos_t new_extent = { new_extent_line, new_extent_col };</a>
<a name="ln839"> </a>
<a name="ln840">  bool may_delete = (old_extent.row != 0 || old_extent.col != 0);</a>
<a name="ln841">  bool same_line = old_extent.row == 0 &amp;&amp; new_extent.row == 0;</a>
<a name="ln842">  unrelative(start, &amp;old_extent);</a>
<a name="ln843">  unrelative(start, &amp;new_extent);</a>
<a name="ln844">  MarkTreeIter itr[1] = { 0 };</a>
<a name="ln845">  MarkTreeIter enditr[1] = { 0 };</a>
<a name="ln846"> </a>
<a name="ln847">  mtpos_t oldbase[MT_MAX_DEPTH] = { 0 };</a>
<a name="ln848"> </a>
<a name="ln849">  marktree_itr_get_ext(b, start, itr, false, true, oldbase);</a>
<a name="ln850">  if (!itr-&gt;node) {</a>
<a name="ln851">    // den e FÃ„RDIG</a>
<a name="ln852">    return false;</a>
<a name="ln853">  }</a>
<a name="ln854">  mtpos_t delta = { new_extent.row - old_extent.row,</a>
<a name="ln855">                    new_extent.col - old_extent.col };</a>
<a name="ln856"> </a>
<a name="ln857">  if (may_delete) {</a>
<a name="ln858">    mtpos_t ipos = marktree_itr_pos(itr);</a>
<a name="ln859">    if (!pos_leq(old_extent, ipos)</a>
<a name="ln860">        || (old_extent.row == ipos.row &amp;&amp; old_extent.col == ipos.col</a>
<a name="ln861">            &amp;&amp; !mt_right(rawkey(itr)))) {</a>
<a name="ln862">      marktree_itr_get_ext(b, old_extent, enditr, true, true, NULL);</a>
<a name="ln863">      assert(enditr-&gt;node);</a>
<a name="ln864">      // &quot;assert&quot; (itr &lt;= enditr)</a>
<a name="ln865">    } else {</a>
<a name="ln866">      may_delete = false;</a>
<a name="ln867">    }</a>
<a name="ln868">  }</a>
<a name="ln869"> </a>
<a name="ln870">  bool past_right = false;</a>
<a name="ln871">  bool moved = false;</a>
<a name="ln872"> </a>
<a name="ln873">  // Follow the general strategy of messing things up and fix them later</a>
<a name="ln874">  // &quot;oldbase&quot; carries the information needed to calculate old position of</a>
<a name="ln875">  // children.</a>
<a name="ln876">  if (may_delete) {</a>
<a name="ln877">    while (itr-&gt;node &amp;&amp; !past_right) {</a>
<a name="ln878">      mtpos_t loc_start = start;</a>
<a name="ln879">      mtpos_t loc_old = old_extent;</a>
<a name="ln880">      relative(itr-&gt;pos, &amp;loc_start);</a>
<a name="ln881"> </a>
<a name="ln882">      relative(oldbase[itr-&gt;lvl], &amp;loc_old);</a>
<a name="ln883"> </a>
<a name="ln884">continue_same_node:</a>
<a name="ln885">      // NB: strictly should be less than the right gravity of loc_old, but</a>
<a name="ln886">      // the iter comparison below will already break on that.</a>
<a name="ln887">      if (!pos_leq(rawkey(itr).pos, loc_old)) {</a>
<a name="ln888">        break;</a>
<a name="ln889">      }</a>
<a name="ln890"> </a>
<a name="ln891">      if (mt_right(rawkey(itr))) {</a>
<a name="ln892">        while (!itr_eq(itr, enditr)</a>
<a name="ln893">               &amp;&amp; mt_right(rawkey(enditr))) {</a>
<a name="ln894">          marktree_itr_prev(b, enditr);</a>
<a name="ln895">        }</a>
<a name="ln896">        if (!mt_right(rawkey(enditr))) {</a>
<a name="ln897">          itr_swap(itr, enditr);</a>
<a name="ln898">          refkey(b, itr-&gt;node, itr-&gt;i);</a>
<a name="ln899">          refkey(b, enditr-&gt;node, enditr-&gt;i);</a>
<a name="ln900">        } else {</a>
<a name="ln901">          past_right = true;  // NOLINT</a>
<a name="ln902">          (void)past_right;</a>
<a name="ln903">          break;</a>
<a name="ln904">        }</a>
<a name="ln905">      }</a>
<a name="ln906"> </a>
<a name="ln907">      if (itr_eq(itr, enditr)) {</a>
<a name="ln908">        // actually, will be past_right after this key</a>
<a name="ln909">        past_right = true;</a>
<a name="ln910">      }</a>
<a name="ln911"> </a>
<a name="ln912">      moved = true;</a>
<a name="ln913">      if (itr-&gt;node-&gt;level) {</a>
<a name="ln914">        oldbase[itr-&gt;lvl + 1] = rawkey(itr).pos;</a>
<a name="ln915">        unrelative(oldbase[itr-&gt;lvl], &amp;oldbase[itr-&gt;lvl + 1]);</a>
<a name="ln916">        rawkey(itr).pos = loc_start;</a>
<a name="ln917">        marktree_itr_next_skip(b, itr, false, oldbase);</a>
<a name="ln918">      } else {</a>
<a name="ln919">        rawkey(itr).pos = loc_start;</a>
<a name="ln920">        if (itr-&gt;i &lt; itr-&gt;node-&gt;n - 1) {</a>
<a name="ln921">          itr-&gt;i++;</a>
<a name="ln922">          if (!past_right) {</a>
<a name="ln923">            goto continue_same_node;</a>
<a name="ln924">          }</a>
<a name="ln925">        } else {</a>
<a name="ln926">          marktree_itr_next(b, itr);</a>
<a name="ln927">        }</a>
<a name="ln928">      }</a>
<a name="ln929">    }</a>
<a name="ln930">    while (itr-&gt;node) {</a>
<a name="ln931">      mtpos_t loc_new = new_extent;</a>
<a name="ln932">      relative(itr-&gt;pos, &amp;loc_new);</a>
<a name="ln933">      mtpos_t limit = old_extent;</a>
<a name="ln934"> </a>
<a name="ln935">      relative(oldbase[itr-&gt;lvl], &amp;limit);</a>
<a name="ln936"> </a>
<a name="ln937">past_continue_same_node:</a>
<a name="ln938"> </a>
<a name="ln939">      if (pos_leq(limit, rawkey(itr).pos)) {</a>
<a name="ln940">        break;</a>
<a name="ln941">      }</a>
<a name="ln942"> </a>
<a name="ln943">      mtpos_t oldpos = rawkey(itr).pos;</a>
<a name="ln944">      rawkey(itr).pos = loc_new;</a>
<a name="ln945">      moved = true;</a>
<a name="ln946">      if (itr-&gt;node-&gt;level) {</a>
<a name="ln947">        oldbase[itr-&gt;lvl + 1] = oldpos;</a>
<a name="ln948">        unrelative(oldbase[itr-&gt;lvl], &amp;oldbase[itr-&gt;lvl + 1]);</a>
<a name="ln949"> </a>
<a name="ln950">        marktree_itr_next_skip(b, itr, false, oldbase);</a>
<a name="ln951">      } else {</a>
<a name="ln952">        if (itr-&gt;i &lt; itr-&gt;node-&gt;n - 1) {</a>
<a name="ln953">          itr-&gt;i++;</a>
<a name="ln954">          goto past_continue_same_node;</a>
<a name="ln955">        } else {</a>
<a name="ln956">          marktree_itr_next(b, itr);</a>
<a name="ln957">        }</a>
<a name="ln958">      }</a>
<a name="ln959">    }</a>
<a name="ln960">  }</a>
<a name="ln961"> </a>
<a name="ln962">  while (itr-&gt;node) {</a>
<a name="ln963">    unrelative(oldbase[itr-&gt;lvl], &amp;rawkey(itr).pos);</a>
<a name="ln964">    int realrow = rawkey(itr).pos.row;</a>
<a name="ln965">    assert(realrow &gt;= old_extent.row);</a>
<a name="ln966">    bool done = false;</a>
<a name="ln967">    if (realrow == old_extent.row) {</a>
<a name="ln968">      if (delta.col) {</a>
<a name="ln969">        rawkey(itr).pos.col += delta.col;</a>
<a name="ln970">        moved = true;</a>
<a name="ln971">      }</a>
<a name="ln972">    } else {</a>
<a name="ln973">      if (same_line) {</a>
<a name="ln974">        // optimization: column only adjustment can skip remaining rows</a>
<a name="ln975">        done = true;</a>
<a name="ln976">      }</a>
<a name="ln977">    }</a>
<a name="ln978">    if (delta.row) {</a>
<a name="ln979">      rawkey(itr).pos.row += delta.row;</a>
<a name="ln980">      moved = true;</a>
<a name="ln981">    }</a>
<a name="ln982">    relative(itr-&gt;pos, &amp;rawkey(itr).pos);</a>
<a name="ln983">    if (done) {</a>
<a name="ln984">      break;</a>
<a name="ln985">    }</a>
<a name="ln986">    marktree_itr_next_skip(b, itr, true, NULL);</a>
<a name="ln987">  }</a>
<a name="ln988">  return moved;</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991">void marktree_move_region(MarkTree *b, int start_row, colnr_T start_col, int extent_row,</a>
<a name="ln992">                          colnr_T extent_col, int new_row, colnr_T new_col)</a>
<a name="ln993">{</a>
<a name="ln994">  mtpos_t start = { start_row, start_col }, size = { extent_row, extent_col };</a>
<a name="ln995">  mtpos_t end = size;</a>
<a name="ln996">  unrelative(start, &amp;end);</a>
<a name="ln997">  MarkTreeIter itr[1] = { 0 };</a>
<a name="ln998">  marktree_itr_get_ext(b, start, itr, false, true, NULL);</a>
<a name="ln999">  kvec_t(mtkey_t) saved = KV_INITIAL_VALUE;</a>
<a name="ln1000">  while (itr-&gt;node) {</a>
<a name="ln1001">    mtkey_t k = marktree_itr_current(itr);</a>
<a name="ln1002">    if (!pos_leq(k.pos, end) || (k.pos.row == end.row &amp;&amp; k.pos.col == end.col</a>
<a name="ln1003">                                 &amp;&amp; mt_right(k))) {</a>
<a name="ln1004">      break;</a>
<a name="ln1005">    }</a>
<a name="ln1006">    relative(start, &amp;k.pos);</a>
<a name="ln1007">    kv_push(saved, k);</a>
<a name="ln1008">    marktree_del_itr(b, itr, false);</a>
<a name="ln1009">  }</a>
<a name="ln1010"> </a>
<a name="ln1011">  marktree_splice(b, start.row, start.col, size.row, size.col, 0, 0);</a>
<a name="ln1012">  mtpos_t new = { new_row, new_col };</a>
<a name="ln1013">  marktree_splice(b, new.row, new.col,</a>
<a name="ln1014">                  0, 0, size.row, size.col);</a>
<a name="ln1015"> </a>
<a name="ln1016">  for (size_t i = 0; i &lt; kv_size(saved); i++) {</a>
<a name="ln1017">    mtkey_t item = kv_A(saved, i);</a>
<a name="ln1018">    unrelative(new, &amp;item.pos);</a>
<a name="ln1019">    marktree_put_key(b, item);</a>
<a name="ln1020">  }</a>
<a name="ln1021">  kv_destroy(saved);</a>
<a name="ln1022">}</a>
<a name="ln1023"> </a>
<a name="ln1024">/// @param itr OPTIONAL. set itr to pos.</a>
<a name="ln1025">mtkey_t marktree_lookup_ns(MarkTree *b, uint32_t ns, uint32_t id, bool end, MarkTreeIter *itr)</a>
<a name="ln1026">{</a>
<a name="ln1027">  return marktree_lookup(b, mt_lookup_id(ns, id, end), itr);</a>
<a name="ln1028">}</a>
<a name="ln1029"> </a>
<a name="ln1030">/// @param itr OPTIONAL. set itr to pos.</a>
<a name="ln1031">mtkey_t marktree_lookup(MarkTree *b, uint64_t id, MarkTreeIter *itr)</a>
<a name="ln1032">{</a>
<a name="ln1033">  mtnode_t *n = pmap_get(uint64_t)(b-&gt;id2node, id);</a>
<a name="ln1034">  if (n == NULL) {</a>
<a name="ln1035">    if (itr) {</a>
<a name="ln1036">      itr-&gt;node = NULL;</a>
<a name="ln1037">    }</a>
<a name="ln1038">    return MT_INVALID_KEY;</a>
<a name="ln1039">  }</a>
<a name="ln1040">  int i = 0;</a>
<a name="ln1041">  for (i = 0; i &lt; n-&gt;n; i++) {</a>
<a name="ln1042">    if (mt_lookup_key(n-&gt;key[i]) == id) {</a>
<a name="ln1043">      goto found;</a>
<a name="ln1044">    }</a>
<a name="ln1045">  }</a>
<a name="ln1046">  abort();</a>
<a name="ln1047">found: {}</a>
<a name="ln1048">  mtkey_t key = n-&gt;key[i];</a>
<a name="ln1049">  if (itr) {</a>
<a name="ln1050">    itr-&gt;i = i;</a>
<a name="ln1051">    itr-&gt;node = n;</a>
<a name="ln1052">    itr-&gt;lvl = b-&gt;root-&gt;level - n-&gt;level;</a>
<a name="ln1053">  }</a>
<a name="ln1054">  while (n-&gt;parent != NULL) {</a>
<a name="ln1055">    mtnode_t *p = n-&gt;parent;</a>
<a name="ln1056">    for (i = 0; i &lt; p-&gt;n + 1; i++) {</a>
<a name="ln1057">      if (p-&gt;ptr[i] == n) {</a>
<a name="ln1058">        goto found_node;</a>
<a name="ln1059">      }</a>
<a name="ln1060">    }</a>
<a name="ln1061">    abort();</a>
<a name="ln1062">found_node:</a>
<a name="ln1063">    if (itr) {</a>
<a name="ln1064">      itr-&gt;s[b-&gt;root-&gt;level - p-&gt;level].i = i;</a>
<a name="ln1065">    }</a>
<a name="ln1066">    if (i &gt; 0) {</a>
<a name="ln1067">      unrelative(p-&gt;key[i - 1].pos, &amp;key.pos);</a>
<a name="ln1068">    }</a>
<a name="ln1069">    n = p;</a>
<a name="ln1070">  }</a>
<a name="ln1071">  if (itr) {</a>
<a name="ln1072">    marktree_itr_fix_pos(b, itr);</a>
<a name="ln1073">  }</a>
<a name="ln1074">  return key;</a>
<a name="ln1075">}</a>
<a name="ln1076"> </a>
<a name="ln1077">mtpos_t marktree_get_altpos(MarkTree *b, mtkey_t mark, MarkTreeIter *itr)</a>
<a name="ln1078">{</a>
<a name="ln1079">  return marktree_get_alt(b, mark, itr).pos;</a>
<a name="ln1080">}</a>
<a name="ln1081"> </a>
<a name="ln1082">mtkey_t marktree_get_alt(MarkTree *b, mtkey_t mark, MarkTreeIter *itr)</a>
<a name="ln1083">{</a>
<a name="ln1084">  mtkey_t end = MT_INVALID_KEY;</a>
<a name="ln1085">  if (mt_paired(mark)) {</a>
<a name="ln1086">    end = marktree_lookup_ns(b, mark.ns, mark.id, !mt_end(mark), itr);</a>
<a name="ln1087">  }</a>
<a name="ln1088">  return end;</a>
<a name="ln1089">}</a>
<a name="ln1090"> </a>
<a name="ln1091">static void marktree_itr_fix_pos(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln1092">{</a>
<a name="ln1093">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln1094">  mtnode_t *x = b-&gt;root;</a>
<a name="ln1095">  for (int lvl = 0; lvl &lt; itr-&gt;lvl; lvl++) {</a>
<a name="ln1096">    itr-&gt;s[lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln1097">    int i = itr-&gt;s[lvl].i;</a>
<a name="ln1098">    if (i &gt; 0) {</a>
<a name="ln1099">      compose(&amp;itr-&gt;pos, x-&gt;key[i - 1].pos);</a>
<a name="ln1100">    }</a>
<a name="ln1101">    assert(x-&gt;level);</a>
<a name="ln1102">    x = x-&gt;ptr[i];</a>
<a name="ln1103">  }</a>
<a name="ln1104">  assert(x == itr-&gt;node);</a>
<a name="ln1105">}</a>
<a name="ln1106"> </a>
<a name="ln1107">// for unit test</a>
<a name="ln1108">void marktree_put_test(MarkTree *b, uint32_t id, int row, int col, bool right_gravity)</a>
<a name="ln1109">{</a>
<a name="ln1110">  mtkey_t key = { { row, col }, UINT32_MAX, id, 0,</a>
<a name="ln1111">                  mt_flags(right_gravity, 0), 0, NULL };</a>
<a name="ln1112">  marktree_put(b, key, -1, -1, false);</a>
<a name="ln1113">}</a>
<a name="ln1114"> </a>
<a name="ln1115">// for unit test</a>
<a name="ln1116">bool mt_right_test(mtkey_t key)</a>
<a name="ln1117">{</a>
<a name="ln1118">  return mt_right(key);</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121">void marktree_check(MarkTree *b)</a>
<a name="ln1122">{</a>
<a name="ln1123">#ifndef NDEBUG</a>
<a name="ln1124">  if (b-&gt;root == NULL) {</a>
<a name="ln1125">    assert(b-&gt;n_keys == 0);</a>
<a name="ln1126">    assert(b-&gt;n_nodes == 0);</a>
<a name="ln1127">    assert(b-&gt;id2node == NULL || map_size(b-&gt;id2node) == 0);</a>
<a name="ln1128">    return;</a>
<a name="ln1129">  }</a>
<a name="ln1130"> </a>
<a name="ln1131">  mtpos_t dummy;</a>
<a name="ln1132">  bool last_right = false;</a>
<a name="ln1133">  size_t nkeys = check_node(b, b-&gt;root, &amp;dummy, &amp;last_right);</a>
<a name="ln1134">  assert(b-&gt;n_keys == nkeys);</a>
<a name="ln1135">  assert(b-&gt;n_keys == map_size(b-&gt;id2node));</a>
<a name="ln1136">#else</a>
<a name="ln1137">  // Do nothing, as assertions are required</a>
<a name="ln1138">  (void)b;</a>
<a name="ln1139">#endif</a>
<a name="ln1140">}</a>
<a name="ln1141"> </a>
<a name="ln1142">#ifndef NDEBUG</a>
<a name="ln1143">static size_t check_node(MarkTree *b, mtnode_t *x, mtpos_t *last, bool *last_right)</a>
<a name="ln1144">{</a>
<a name="ln1145">  assert(x-&gt;n &lt;= 2 * T - 1);</a>
<a name="ln1146">  // TODO(bfredl): too strict if checking &quot;in repair&quot; post-delete tree.</a>
<a name="ln1147">  assert(x-&gt;n &gt;= (x != b-&gt;root ? T - 1 : 0));</a>
<a name="ln1148">  size_t n_keys = (size_t)x-&gt;n;</a>
<a name="ln1149"> </a>
<a name="ln1150">  for (int i = 0; i &lt; x-&gt;n; i++) {</a>
<a name="ln1151">    if (x-&gt;level) {</a>
<a name="ln1152">      n_keys += check_node(b, x-&gt;ptr[i], last, last_right);</a>
<a name="ln1153">    } else {</a>
<a name="ln1154">      *last = (mtpos_t) { 0, 0 };</a>
<a name="ln1155">    }</a>
<a name="ln1156">    if (i &gt; 0) {</a>
<a name="ln1157">      unrelative(x-&gt;key[i - 1].pos, last);</a>
<a name="ln1158">    }</a>
<a name="ln1159">    assert(pos_leq(*last, x-&gt;key[i].pos));</a>
<a name="ln1160">    if (last-&gt;row == x-&gt;key[i].pos.row &amp;&amp; last-&gt;col == x-&gt;key[i].pos.col) {</a>
<a name="ln1161">      assert(!*last_right || mt_right(x-&gt;key[i]));</a>
<a name="ln1162">    }</a>
<a name="ln1163">    *last_right = mt_right(x-&gt;key[i]);</a>
<a name="ln1164">    assert(x-&gt;key[i].pos.col &gt;= 0);</a>
<a name="ln1165">    assert(pmap_get(uint64_t)(b-&gt;id2node, mt_lookup_key(x-&gt;key[i])) == x);</a>
<a name="ln1166">  }</a>
<a name="ln1167"> </a>
<a name="ln1168">  if (x-&gt;level) {</a>
<a name="ln1169">    n_keys += check_node(b, x-&gt;ptr[x-&gt;n], last, last_right);</a>
<a name="ln1170">    unrelative(x-&gt;key[x-&gt;n - 1].pos, last);</a>
<a name="ln1171"> </a>
<a name="ln1172">    for (int i = 0; i &lt; x-&gt;n + 1; i++) {</a>
<a name="ln1173">      assert(x-&gt;ptr[i]-&gt;parent == x);</a>
<a name="ln1174">      assert(x-&gt;ptr[i]-&gt;level == x-&gt;level - 1);</a>
<a name="ln1175">      // PARANOIA: check no double node ref</a>
<a name="ln1176">      for (int j = 0; j &lt; i; j++) {</a>
<a name="ln1177">        assert(x-&gt;ptr[i] != x-&gt;ptr[j]);</a>
<a name="ln1178">      }</a>
<a name="ln1179">    }</a>
<a name="ln1180">  } else {</a>
<a name="ln1181">    *last = x-&gt;key[x-&gt;n - 1].pos;</a>
<a name="ln1182">  }</a>
<a name="ln1183">  return n_keys;</a>
<a name="ln1184">}</a>
<a name="ln1185">#endif</a>
<a name="ln1186"> </a>
<a name="ln1187">char *mt_inspect_rec(MarkTree *b)</a>
<a name="ln1188">{</a>
<a name="ln1189">  garray_T ga;</a>
<a name="ln1190">  ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln1191">  mtpos_t p = { 0, 0 };</a>
<a name="ln1192">  mt_inspect_node(b, &amp;ga, b-&gt;root, p);</a>
<a name="ln1193">  return ga.ga_data;</a>
<a name="ln1194">}</a>
<a name="ln1195"> </a>
<a name="ln1196">void mt_inspect_node(MarkTree *b, garray_T *ga, mtnode_t *n, mtpos_t off)</a>
<a name="ln1197">{</a>
<a name="ln1198">  static char buf[1024];</a>
<a name="ln1199">  ga_concat(ga, &quot;[&quot;);</a>
<a name="ln1200">  if (n-&gt;level) {</a>
<a name="ln1201">    mt_inspect_node(b, ga, n-&gt;ptr[0], off);</a>
<a name="ln1202">  }</a>
<a name="ln1203">  for (int i = 0; i &lt; n-&gt;n; i++) {</a>
<a name="ln1204">    mtpos_t p = n-&gt;key[i].pos;</a>
<a name="ln1205">    unrelative(off, &amp;p);</a>
<a name="ln1206">    snprintf((char *)buf, sizeof(buf), &quot;%d/%d&quot;, p.row, p.col);</a>
<a name="ln1207">    ga_concat(ga, buf);</a>
<a name="ln1208">    if (n-&gt;level) {</a>
<a name="ln1209">      mt_inspect_node(b, ga, n-&gt;ptr[i + 1], p);</a>
<a name="ln1210">    } else {</a>
<a name="ln1211">      ga_concat(ga, &quot;,&quot;);</a>
<a name="ln1212">    }</a>
<a name="ln1213">  }</a>
<a name="ln1214">  ga_concat(ga, &quot;]&quot;);</a>
<a name="ln1215">}</a>
</code></pre>
<div class="balloon" rel="160"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1086/" target="_blank">V1086</a> A call of the 'memcpy' function will lead to underflow of the buffer 'z-&gt;key'.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>