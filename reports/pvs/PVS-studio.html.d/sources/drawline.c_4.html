<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>drawline.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// drawline.c: Functions for drawing window lines on the screen.</a>
<a name="ln5">// This is the middle level, drawscreen.c is the top and grid.c/screen.c the lower level.</a>
<a name="ln6"> </a>
<a name="ln7">#include &lt;assert.h&gt;</a>
<a name="ln8">#include &lt;inttypes.h&gt;</a>
<a name="ln9">#include &lt;stdbool.h&gt;</a>
<a name="ln10">#include &lt;string.h&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;nvim/arabic.h&quot;</a>
<a name="ln13">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln14">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln15">#include &quot;nvim/charset.h&quot;</a>
<a name="ln16">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln17">#include &quot;nvim/cursor_shape.h&quot;</a>
<a name="ln18">#include &quot;nvim/decoration.h&quot;</a>
<a name="ln19">#include &quot;nvim/diff.h&quot;</a>
<a name="ln20">#include &quot;nvim/drawline.h&quot;</a>
<a name="ln21">#include &quot;nvim/fold.h&quot;</a>
<a name="ln22">#include &quot;nvim/grid.h&quot;</a>
<a name="ln23">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln24">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln25">#include &quot;nvim/indent.h&quot;</a>
<a name="ln26">#include &quot;nvim/match.h&quot;</a>
<a name="ln27">#include &quot;nvim/move.h&quot;</a>
<a name="ln28">#include &quot;nvim/option.h&quot;</a>
<a name="ln29">#include &quot;nvim/plines.h&quot;</a>
<a name="ln30">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln31">#include &quot;nvim/search.h&quot;</a>
<a name="ln32">#include &quot;nvim/sign.h&quot;</a>
<a name="ln33">#include &quot;nvim/spell.h&quot;</a>
<a name="ln34">#include &quot;nvim/state.h&quot;</a>
<a name="ln35">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln36">#include &quot;nvim/undo.h&quot;</a>
<a name="ln37">#include &quot;nvim/window.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#define MB_FILLER_CHAR '&lt;'  // character used when a double-width character</a>
<a name="ln40">                            // doesn't fit.</a>
<a name="ln41"> </a>
<a name="ln42">/// for line_putchar. Contains the state that needs to be remembered from</a>
<a name="ln43">/// putting one character to the next.</a>
<a name="ln44">typedef struct {</a>
<a name="ln45">  const char *p;</a>
<a name="ln46">  int prev_c;   ///&lt; previous Arabic character</a>
<a name="ln47">  int prev_c1;  ///&lt; first composing char for prev_c</a>
<a name="ln48">} LineState;</a>
<a name="ln49">#define LINE_STATE(p) { p, 0, 0 }</a>
<a name="ln50"> </a>
<a name="ln51">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln52"># include &quot;drawline.c.generated.h&quot;</a>
<a name="ln53">#endif</a>
<a name="ln54"> </a>
<a name="ln55">/// Advance **color_cols</a>
<a name="ln56">///</a>
<a name="ln57">/// @return  true when there are columns to draw.</a>
<a name="ln58">static bool advance_color_col(int vcol, int **color_cols)</a>
<a name="ln59">{</a>
<a name="ln60">  while (**color_cols &gt;= 0 &amp;&amp; vcol &gt; **color_cols) {</a>
<a name="ln61">    (*color_cols)++;</a>
<a name="ln62">  }</a>
<a name="ln63">  return **color_cols &gt;= 0;</a>
<a name="ln64">}</a>
<a name="ln65"> </a>
<a name="ln66">/// Used when 'cursorlineopt' contains &quot;screenline&quot;: compute the margins between</a>
<a name="ln67">/// which the highlighting is used.</a>
<a name="ln68">static void margin_columns_win(win_T *wp, int *left_col, int *right_col)</a>
<a name="ln69">{</a>
<a name="ln70">  // cache previous calculations depending on w_virtcol</a>
<a name="ln71">  static int saved_w_virtcol;</a>
<a name="ln72">  static win_T *prev_wp;</a>
<a name="ln73">  static int prev_left_col;</a>
<a name="ln74">  static int prev_right_col;</a>
<a name="ln75">  static int prev_col_off;</a>
<a name="ln76"> </a>
<a name="ln77">  int cur_col_off = win_col_off(wp);</a>
<a name="ln78">  int width1;</a>
<a name="ln79">  int width2;</a>
<a name="ln80"> </a>
<a name="ln81">  if (saved_w_virtcol == wp-&gt;w_virtcol &amp;&amp; prev_wp == wp</a>
<a name="ln82">      &amp;&amp; prev_col_off == cur_col_off) {</a>
<a name="ln83">    *right_col = prev_right_col;</a>
<a name="ln84">    *left_col = prev_left_col;</a>
<a name="ln85">    return;</a>
<a name="ln86">  }</a>
<a name="ln87"> </a>
<a name="ln88">  width1 = wp-&gt;w_width - cur_col_off;</a>
<a name="ln89">  width2 = width1 + win_col_off2(wp);</a>
<a name="ln90"> </a>
<a name="ln91">  *left_col = 0;</a>
<a name="ln92">  *right_col = width1;</a>
<a name="ln93"> </a>
<a name="ln94">  if (wp-&gt;w_virtcol &gt;= (colnr_T)width1) {</a>
<a name="ln95">    *right_col = width1 + ((wp-&gt;w_virtcol - width1) / width2 + 1) * width2;</a>
<a name="ln96">  }</a>
<a name="ln97">  if (wp-&gt;w_virtcol &gt;= (colnr_T)width1 &amp;&amp; width2 &gt; 0) {</a>
<a name="ln98">    *left_col = (wp-&gt;w_virtcol - width1) / width2 * width2 + width1;</a>
<a name="ln99">  }</a>
<a name="ln100"> </a>
<a name="ln101">  // cache values</a>
<a name="ln102">  prev_left_col = *left_col;</a>
<a name="ln103">  prev_right_col = *right_col;</a>
<a name="ln104">  prev_wp = wp;</a>
<a name="ln105">  saved_w_virtcol = wp-&gt;w_virtcol;</a>
<a name="ln106">  prev_col_off = cur_col_off;</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">/// Put a single char from an UTF-8 buffer into a line buffer.</a>
<a name="ln110">///</a>
<a name="ln111">/// Handles composing chars and arabic shaping state.</a>
<a name="ln112">static int line_putchar(buf_T *buf, LineState *s, schar_T *dest, int maxcells, bool rl, int vcol)</a>
<a name="ln113">{</a>
<a name="ln114">  const char_u *p = (char_u *)s-&gt;p;</a>
<a name="ln115">  int cells = utf_ptr2cells((char *)p);</a>
<a name="ln116">  int c_len = utfc_ptr2len((char *)p);</a>
<a name="ln117">  int u8c, u8cc[MAX_MCO];</a>
<a name="ln118">  if (cells &gt; maxcells) {</a>
<a name="ln119">    return -1;</a>
<a name="ln120">  }</a>
<a name="ln121">  u8c = utfc_ptr2char((char *)p, u8cc);</a>
<a name="ln122">  if (*p == TAB) {</a>
<a name="ln123">    cells = MIN(tabstop_padding(vcol, buf-&gt;b_p_ts, buf-&gt;b_p_vts_array), maxcells);</a>
<a name="ln124">    for (int c = 0; c &lt; cells; c++) {</a>
<a name="ln125">      schar_from_ascii(dest[c], ' ');</a>
<a name="ln126">    }</a>
<a name="ln127">    goto done;</a>
<a name="ln128">  } else if (*p &lt; 0x80 &amp;&amp; u8cc[0] == 0) {</a>
<a name="ln129">    schar_from_ascii(dest[0], (char)(*p));</a>
<a name="ln130">    s-&gt;prev_c = u8c;</a>
<a name="ln131">  } else {</a>
<a name="ln132">    if (p_arshape &amp;&amp; !p_tbidi &amp;&amp; ARABIC_CHAR(u8c)) {</a>
<a name="ln133">      // Do Arabic shaping.</a>
<a name="ln134">      int pc, pc1, nc;</a>
<a name="ln135">      int pcc[MAX_MCO];</a>
<a name="ln136">      int firstbyte = *p;</a>
<a name="ln137"> </a>
<a name="ln138">      // The idea of what is the previous and next</a>
<a name="ln139">      // character depends on 'rightleft'.</a>
<a name="ln140">      if (rl) {</a>
<a name="ln141">        pc = s-&gt;prev_c;</a>
<a name="ln142">        pc1 = s-&gt;prev_c1;</a>
<a name="ln143">        nc = utf_ptr2char((char *)p + c_len);</a>
<a name="ln144">        s-&gt;prev_c1 = u8cc[0];</a>
<a name="ln145">      } else {</a>
<a name="ln146">        pc = utfc_ptr2char((char *)p + c_len, pcc);</a>
<a name="ln147">        nc = s-&gt;prev_c;</a>
<a name="ln148">        pc1 = pcc[0];</a>
<a name="ln149">      }</a>
<a name="ln150">      s-&gt;prev_c = u8c;</a>
<a name="ln151"> </a>
<a name="ln152">      u8c = arabic_shape(u8c, &amp;firstbyte, &amp;u8cc[0], pc, pc1, nc);</a>
<a name="ln153">    } else {</a>
<a name="ln154">      s-&gt;prev_c = u8c;</a>
<a name="ln155">    }</a>
<a name="ln156">    schar_from_cc(dest[0], u8c, u8cc);</a>
<a name="ln157">  }</a>
<a name="ln158">  if (cells &gt; 1) {</a>
<a name="ln159">    dest[1][0] = 0;</a>
<a name="ln160">  }</a>
<a name="ln161">done:</a>
<a name="ln162">  s-&gt;p += c_len;</a>
<a name="ln163">  return cells;</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">static inline void provider_err_virt_text(linenr_T lnum, char *err)</a>
<a name="ln167">{</a>
<a name="ln168">  Decoration err_decor = DECORATION_INIT;</a>
<a name="ln169">  int hl_err = syn_check_group(S_LEN(&quot;ErrorMsg&quot;));</a>
<a name="ln170">  kv_push(err_decor.virt_text,</a>
<a name="ln171">          ((VirtTextChunk){ .text = err,</a>
<a name="ln172">                            .hl_id = hl_err }));</a>
<a name="ln173">  err_decor.virt_text_width = (int)mb_string2cells(err);</a>
<a name="ln174">  decor_add_ephemeral(lnum - 1, 0, lnum - 1, 0, &amp;err_decor, 0, 0);</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">static void draw_virt_text(win_T *wp, buf_T *buf, int col_off, int *end_col, int max_col,</a>
<a name="ln178">                           int win_row)</a>
<a name="ln179">{</a>
<a name="ln180">  DecorState *state = &amp;decor_state;</a>
<a name="ln181">  int right_pos = max_col;</a>
<a name="ln182">  bool do_eol = state-&gt;eol_col &gt; -1;</a>
<a name="ln183">  for (size_t i = 0; i &lt; kv_size(state-&gt;active); i++) {</a>
<a name="ln184">    DecorRange *item = &amp;kv_A(state-&gt;active, i);</a>
<a name="ln185">    if (!(item-&gt;start_row == state-&gt;row</a>
<a name="ln186">          &amp;&amp; (kv_size(item-&gt;decor.virt_text) || item-&gt;decor.ui_watched))) {</a>
<a name="ln187">      continue;</a>
<a name="ln188">    }</a>
<a name="ln189">    if (item-&gt;win_col == -1) {</a>
<a name="ln190">      if (item-&gt;decor.virt_text_pos == kVTRightAlign) {</a>
<a name="ln191">        right_pos -= item-&gt;decor.virt_text_width;</a>
<a name="ln192">        item-&gt;win_col = right_pos;</a>
<a name="ln193">      } else if (item-&gt;decor.virt_text_pos == kVTEndOfLine &amp;&amp; do_eol) {</a>
<a name="ln194">        item-&gt;win_col = state-&gt;eol_col;</a>
<a name="ln195">      } else if (item-&gt;decor.virt_text_pos == kVTWinCol) {</a>
<a name="ln196">        item-&gt;win_col = MAX(item-&gt;decor.col + col_off, 0);</a>
<a name="ln197">      }</a>
<a name="ln198">    }</a>
<a name="ln199">    if (item-&gt;win_col &lt; 0) {</a>
<a name="ln200">      continue;</a>
<a name="ln201">    }</a>
<a name="ln202">    int col;</a>
<a name="ln203">    if (item-&gt;decor.ui_watched) {</a>
<a name="ln204">      // send mark position to UI</a>
<a name="ln205">      col = item-&gt;win_col;</a>
<a name="ln206">      WinExtmark m = { (NS)item-&gt;ns_id, item-&gt;mark_id, win_row, col };</a>
<a name="ln207">      kv_push(win_extmark_arr, m);</a>
<a name="ln208">    }</a>
<a name="ln209">    if (kv_size(item-&gt;decor.virt_text)) {</a>
<a name="ln210">      col = draw_virt_text_item(buf, item-&gt;win_col, item-&gt;decor.virt_text,</a>
<a name="ln211">                                item-&gt;decor.hl_mode, max_col, item-&gt;win_col - col_off);</a>
<a name="ln212">    }</a>
<a name="ln213">    item-&gt;win_col = -2;  // deactivate</a>
<a name="ln214">    if (item-&gt;decor.virt_text_pos == kVTEndOfLine &amp;&amp; do_eol) {</a>
<a name="ln215">      state-&gt;eol_col = col + 1;</a>
<a name="ln216">    }</a>
<a name="ln217"> </a>
<a name="ln218">    *end_col = MAX(*end_col, col);</a>
<a name="ln219">  }</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">static int draw_virt_text_item(buf_T *buf, int col, VirtText vt, HlMode hl_mode, int max_col,</a>
<a name="ln223">                               int vcol)</a>
<a name="ln224">{</a>
<a name="ln225">  LineState s = LINE_STATE(&quot;&quot;);</a>
<a name="ln226">  int virt_attr = 0;</a>
<a name="ln227">  size_t virt_pos = 0;</a>
<a name="ln228"> </a>
<a name="ln229">  while (col &lt; max_col) {</a>
<a name="ln230">    if (!*s.p) {</a>
<a name="ln231">      if (virt_pos &gt;= kv_size(vt)) {</a>
<a name="ln232">        break;</a>
<a name="ln233">      }</a>
<a name="ln234">      virt_attr = 0;</a>
<a name="ln235">      do {</a>
<a name="ln236">        s.p = kv_A(vt, virt_pos).text;</a>
<a name="ln237">        int hl_id = kv_A(vt, virt_pos).hl_id;</a>
<a name="ln238">        virt_attr = hl_combine_attr(virt_attr,</a>
<a name="ln239">                                    hl_id &gt; 0 ? syn_id2attr(hl_id) : 0);</a>
<a name="ln240">        virt_pos++;</a>
<a name="ln241">      } while (!s.p &amp;&amp; virt_pos &lt; kv_size(vt));</a>
<a name="ln242">      if (!s.p) {</a>
<a name="ln243">        break;</a>
<a name="ln244">      }</a>
<a name="ln245">    }</a>
<a name="ln246">    if (!*s.p) {</a>
<a name="ln247">      continue;</a>
<a name="ln248">    }</a>
<a name="ln249">    int attr;</a>
<a name="ln250">    bool through = false;</a>
<a name="ln251">    if (hl_mode == kHlModeCombine) {</a>
<a name="ln252">      attr = hl_combine_attr(linebuf_attr[col], virt_attr);</a>
<a name="ln253">    } else if (hl_mode == kHlModeBlend) {</a>
<a name="ln254">      through = (*s.p == ' ');</a>
<a name="ln255">      attr = hl_blend_attrs(linebuf_attr[col], virt_attr, &amp;through);</a>
<a name="ln256">    } else {</a>
<a name="ln257">      attr = virt_attr;</a>
<a name="ln258">    }</a>
<a name="ln259">    schar_T dummy[2];</a>
<a name="ln260">    int cells = line_putchar(buf, &amp;s, through ? dummy : &amp;linebuf_char[col],</a>
<a name="ln261">                             max_col - col, false, vcol);</a>
<a name="ln262">    // if we failed to emit a char, we still need to advance</a>
<a name="ln263">    cells = MAX(cells, 1);</a>
<a name="ln264"> </a>
<a name="ln265">    for (int c = 0; c &lt; cells; c++) {</a>
<a name="ln266">      linebuf_attr[col++] = attr;</a>
<a name="ln267">    }</a>
<a name="ln268">    vcol += cells;</a>
<a name="ln269">  }</a>
<a name="ln270">  return col;</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">/// Return true if CursorLineSign highlight is to be used.</a>
<a name="ln274">static bool use_cursor_line_sign(win_T *wp, linenr_T lnum)</a>
<a name="ln275">{</a>
<a name="ln276">  return wp-&gt;w_p_cul</a>
<a name="ln277">         &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln278">         &amp;&amp; (wp-&gt;w_p_culopt_flags &amp; CULOPT_NBR);</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">// Get information needed to display the sign in line 'lnum' in window 'wp'.</a>
<a name="ln282">// If 'nrcol' is true, the sign is going to be displayed in the number column.</a>
<a name="ln283">// Otherwise the sign is going to be displayed in the sign column.</a>
<a name="ln284">//</a>
<a name="ln285">// @param count max number of signs</a>
<a name="ln286">// @param[out] n_extrap number of characters from pp_extra to display</a>
<a name="ln287">// @param sign_idxp Index of the displayed sign</a>
<a name="ln288">static void get_sign_display_info(bool nrcol, win_T *wp, linenr_T lnum, SignTextAttrs sattrs[],</a>
<a name="ln289">                                  int row, int startrow, int filler_lines, int filler_todo,</a>
<a name="ln290">                                  int *c_extrap, int *c_finalp, char_u *extra, size_t extra_size,</a>
<a name="ln291">                                  char_u **pp_extra, int *n_extrap, int *char_attrp, int sign_idx,</a>
<a name="ln292">                                  int cul_attr)</a>
<a name="ln293">{</a>
<a name="ln294">  // Draw cells with the sign value or blank.</a>
<a name="ln295">  *c_extrap = ' ';</a>
<a name="ln296">  *c_finalp = NUL;</a>
<a name="ln297">  if (nrcol) {</a>
<a name="ln298">    *n_extrap = number_width(wp) + 1;</a>
<a name="ln299">  } else {</a>
<a name="ln300">    if (use_cursor_line_sign(wp, lnum)) {</a>
<a name="ln301">      *char_attrp = win_hl_attr(wp, HLF_CLS);</a>
<a name="ln302">    } else {</a>
<a name="ln303">      *char_attrp = win_hl_attr(wp, HLF_SC);</a>
<a name="ln304">    }</a>
<a name="ln305">    *n_extrap = win_signcol_width(wp);</a>
<a name="ln306">  }</a>
<a name="ln307"> </a>
<a name="ln308">  if (row == startrow + filler_lines &amp;&amp; filler_todo &lt;= 0) {</a>
<a name="ln309">    SignTextAttrs *sattr = sign_get_attr(sign_idx, sattrs, wp-&gt;w_scwidth);</a>
<a name="ln310">    if (sattr != NULL) {</a>
<a name="ln311">      *pp_extra = (char_u *)sattr-&gt;text;</a>
<a name="ln312">      if (*pp_extra != NULL) {</a>
<a name="ln313">        *c_extrap = NUL;</a>
<a name="ln314">        *c_finalp = NUL;</a>
<a name="ln315"> </a>
<a name="ln316">        if (nrcol) {</a>
<a name="ln317">          int n, width = number_width(wp) - 2;</a>
<a name="ln318">          for (n = 0; n &lt; width; n++) {</a>
<a name="ln319">            extra[n] = ' ';</a>
<a name="ln320">          }</a>
<a name="ln321">          extra[n] = NUL;</a>
<a name="ln322">          STRCAT(extra, *pp_extra);</a>
<a name="ln323">          STRCAT(extra, &quot; &quot;);</a>
<a name="ln324">          *pp_extra = extra;</a>
<a name="ln325">          *n_extrap = (int)STRLEN(*pp_extra);</a>
<a name="ln326">        } else {</a>
<a name="ln327">          size_t symbol_blen = STRLEN(*pp_extra);</a>
<a name="ln328"> </a>
<a name="ln329">          // TODO(oni-link): Is sign text already extended to</a>
<a name="ln330">          // full cell width?</a>
<a name="ln331">          assert((size_t)win_signcol_width(wp) &gt;= mb_string2cells((char *)(*pp_extra)));</a>
<a name="ln332">          // symbol(s) bytes + (filling spaces) (one byte each)</a>
<a name="ln333">          *n_extrap = (int)symbol_blen + win_signcol_width(wp) -</a>
<a name="ln334">                      (int)mb_string2cells((char *)(*pp_extra));</a>
<a name="ln335"> </a>
<a name="ln336">          assert(extra_size &gt; symbol_blen);</a>
<a name="ln337">          memset(extra, ' ', extra_size);</a>
<a name="ln338">          memcpy(extra, *pp_extra, symbol_blen);</a>
<a name="ln339"> </a>
<a name="ln340">          *pp_extra = extra;</a>
<a name="ln341">          (*pp_extra)[*n_extrap] = NUL;</a>
<a name="ln342">        }</a>
<a name="ln343">      }</a>
<a name="ln344"> </a>
<a name="ln345">      if (use_cursor_line_sign(wp, lnum) &amp;&amp; cul_attr &gt; 0) {</a>
<a name="ln346">        *char_attrp = cul_attr;</a>
<a name="ln347">      } else {</a>
<a name="ln348">        *char_attrp = sattr-&gt;hl_attr_id;</a>
<a name="ln349">      }</a>
<a name="ln350">    }</a>
<a name="ln351">  }</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">static int get_sign_attrs(buf_T *buf, linenr_T lnum, SignTextAttrs *sattrs, int *line_attr,</a>
<a name="ln355">                          int *num_attr, int *cul_attr)</a>
<a name="ln356">{</a>
<a name="ln357">  HlPriAttr line_attrs = { *line_attr, 0 };</a>
<a name="ln358">  HlPriAttr num_attrs  = { *num_attr,  0 };</a>
<a name="ln359">  HlPriAttr cul_attrs  = { *cul_attr,  0 };</a>
<a name="ln360"> </a>
<a name="ln361">  // TODO(bfredl, vigoux): line_attr should not take priority over decoration!</a>
<a name="ln362">  int num_signs = buf_get_signattrs(buf, lnum, sattrs, &amp;num_attrs, &amp;line_attrs, &amp;cul_attrs);</a>
<a name="ln363">  decor_redraw_signs(buf, lnum - 1, &amp;num_signs, sattrs, &amp;num_attrs, &amp;line_attrs, &amp;cul_attrs);</a>
<a name="ln364"> </a>
<a name="ln365">  *line_attr = line_attrs.attr_id;</a>
<a name="ln366">  *num_attr = num_attrs.attr_id;</a>
<a name="ln367">  *cul_attr = cul_attrs.attr_id;</a>
<a name="ln368"> </a>
<a name="ln369">  return num_signs;</a>
<a name="ln370">}</a>
<a name="ln371"> </a>
<a name="ln372">/// Return true if CursorLineNr highlight is to be used for the number column.</a>
<a name="ln373">///</a>
<a name="ln374">/// - 'cursorline' must be set</a>
<a name="ln375">/// - lnum must be the cursor line</a>
<a name="ln376">/// - 'cursorlineopt' has &quot;number&quot;</a>
<a name="ln377">/// - don't highlight filler lines (when in diff mode)</a>
<a name="ln378">/// - When line is wrapped and 'cursorlineopt' does not have &quot;line&quot;, only highlight the line number</a>
<a name="ln379">///   itself on the first screenline of the wrapped line, otherwise highlight the number column of</a>
<a name="ln380">///   all screenlines of the wrapped line.</a>
<a name="ln381">static bool use_cursor_line_nr(win_T *wp, linenr_T lnum, int row, int startrow, int filler_lines)</a>
<a name="ln382">{</a>
<a name="ln383">  return wp-&gt;w_p_cul</a>
<a name="ln384">         &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln385">         &amp;&amp; (wp-&gt;w_p_culopt_flags &amp; CULOPT_NBR)</a>
<a name="ln386">         &amp;&amp; (row == startrow + filler_lines</a>
<a name="ln387">             || (row &gt; startrow + filler_lines</a>
<a name="ln388">                 &amp;&amp; (wp-&gt;w_p_culopt_flags &amp; CULOPT_LINE)));</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">static inline void get_line_number_str(win_T *wp, linenr_T lnum, char_u *buf, size_t buf_len)</a>
<a name="ln392">{</a>
<a name="ln393">  long num;</a>
<a name="ln394">  char *fmt = &quot;%*ld &quot;;</a>
<a name="ln395"> </a>
<a name="ln396">  if (wp-&gt;w_p_nu &amp;&amp; !wp-&gt;w_p_rnu) {</a>
<a name="ln397">    // 'number' + 'norelativenumber'</a>
<a name="ln398">    num = (long)lnum;</a>
<a name="ln399">  } else {</a>
<a name="ln400">    // 'relativenumber', don't use negative numbers</a>
<a name="ln401">    num = labs((long)get_cursor_rel_lnum(wp, lnum));</a>
<a name="ln402">    if (num == 0 &amp;&amp; wp-&gt;w_p_nu &amp;&amp; wp-&gt;w_p_rnu) {</a>
<a name="ln403">      // 'number' + 'relativenumber'</a>
<a name="ln404">      num = lnum;</a>
<a name="ln405">      fmt = &quot;%-*ld &quot;;</a>
<a name="ln406">    }</a>
<a name="ln407">  }</a>
<a name="ln408"> </a>
<a name="ln409">  snprintf((char *)buf, buf_len, fmt, number_width(wp), num);</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">static int get_line_number_attr(win_T *wp, linenr_T lnum, int row, int startrow, int filler_lines)</a>
<a name="ln413">{</a>
<a name="ln414">  if (wp-&gt;w_p_rnu) {</a>
<a name="ln415">    if (lnum &lt; wp-&gt;w_cursor.lnum) {</a>
<a name="ln416">      // Use LineNrAbove</a>
<a name="ln417">      return win_hl_attr(wp, HLF_LNA);</a>
<a name="ln418">    }</a>
<a name="ln419">    if (lnum &gt; wp-&gt;w_cursor.lnum) {</a>
<a name="ln420">      // Use LineNrBelow</a>
<a name="ln421">      return win_hl_attr(wp, HLF_LNB);</a>
<a name="ln422">    }</a>
<a name="ln423">  }</a>
<a name="ln424"> </a>
<a name="ln425">  if (use_cursor_line_nr(wp, lnum, row, startrow, filler_lines)) {</a>
<a name="ln426">    // TODO(vim): Can we use CursorLine instead of CursorLineNr</a>
<a name="ln427">    // when CursorLineNr isn't set?</a>
<a name="ln428">    return win_hl_attr(wp, HLF_CLN);</a>
<a name="ln429">  }</a>
<a name="ln430"> </a>
<a name="ln431">  return win_hl_attr(wp, HLF_N);</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">static void apply_cursorline_highlight(win_T *wp, linenr_T lnum, int *line_attr, int *cul_attr,</a>
<a name="ln435">                                       int *line_attr_lowprio)</a>
<a name="ln436">{</a>
<a name="ln437">  *cul_attr = win_hl_attr(wp, HLF_CUL);</a>
<a name="ln438">  HlAttrs ae = syn_attr2entry(*cul_attr);</a>
<a name="ln439">  // We make a compromise here (#7383):</a>
<a name="ln440">  //  * low-priority CursorLine if fg is not set</a>
<a name="ln441">  //  * high-priority (&quot;same as Vim&quot; priority) CursorLine if fg is set</a>
<a name="ln442">  if (ae.rgb_fg_color == -1 &amp;&amp; ae.cterm_fg_color == 0) {</a>
<a name="ln443">    *line_attr_lowprio = *cul_attr;</a>
<a name="ln444">  } else {</a>
<a name="ln445">    if (!(State &amp; MODE_INSERT) &amp;&amp; bt_quickfix(wp-&gt;w_buffer)</a>
<a name="ln446">        &amp;&amp; qf_current_entry(wp) == lnum) {</a>
<a name="ln447">      *line_attr = hl_combine_attr(*cul_attr, *line_attr);</a>
<a name="ln448">    } else {</a>
<a name="ln449">      *line_attr = *cul_attr;</a>
<a name="ln450">    }</a>
<a name="ln451">  }</a>
<a name="ln452">}</a>
<a name="ln453"> </a>
<a name="ln454">static bool check_mb_utf8(int *c, int *u8cc)</a>
<a name="ln455">{</a>
<a name="ln456">  if (utf_char2len(*c) &gt; 1) {</a>
<a name="ln457">    *u8cc = 0;</a>
<a name="ln458">    *c = 0xc0;</a>
<a name="ln459">    return true;</a>
<a name="ln460">  }</a>
<a name="ln461">  return false;</a>
<a name="ln462">}</a>
<a name="ln463"> </a>
<a name="ln464">/// Display line &quot;lnum&quot; of window 'wp' on the screen.</a>
<a name="ln465">/// wp-&gt;w_virtcol needs to be valid.</a>
<a name="ln466">///</a>
<a name="ln467">/// @param lnum         line to display</a>
<a name="ln468">/// @param startrow     first row relative to window grid</a>
<a name="ln469">/// @param endrow       last grid row to be redrawn</a>
<a name="ln470">/// @param nochange     not updating for changed text</a>
<a name="ln471">/// @param number_only  only update the number column</a>
<a name="ln472">/// @param foldinfo     fold info for this line</a>
<a name="ln473">/// @param[in, out] providers  decoration providers active this line</a>
<a name="ln474">///                            items will be disables if they cause errors</a>
<a name="ln475">///                            or explicitly return `false`.</a>
<a name="ln476">///</a>
<a name="ln477">/// @return             the number of last row the line occupies.</a>
<a name="ln478">int win_line(win_T *wp, linenr_T lnum, int startrow, int endrow, bool nochange, bool number_only,</a>
<a name="ln479">             foldinfo_T foldinfo, DecorProviders *providers, char **provider_err)</a>
<a name="ln480">{</a>
<a name="ln481">  int c = 0;                          // init for GCC</a>
<a name="ln482">  long vcol = 0;                      // virtual column (for tabs)</a>
<a name="ln483">  long vcol_sbr = -1;                 // virtual column after showbreak</a>
<a name="ln484">  long vcol_prev = -1;                // &quot;vcol&quot; of previous character</a>
<a name="ln485">  char_u *line;                  // current line</a>
<a name="ln486">  char_u *ptr;                   // current position in &quot;line&quot;</a>
<a name="ln487">  int row;                            // row in the window, excl w_winrow</a>
<a name="ln488">  ScreenGrid *grid = &amp;wp-&gt;w_grid;     // grid specific to the window</a>
<a name="ln489"> </a>
<a name="ln490">  char_u extra[57];                   // sign, line number and 'fdc' must</a>
<a name="ln491">                                      // fit in here</a>
<a name="ln492">  int n_extra = 0;                    // number of extra chars</a>
<a name="ln493">  char_u *p_extra = NULL;        // string of extra chars, plus NUL</a>
<a name="ln494">  char_u *p_extra_free = NULL;   // p_extra needs to be freed</a>
<a name="ln495">  int c_extra = NUL;                  // extra chars, all the same</a>
<a name="ln496">  int c_final = NUL;                  // final char, mandatory if set</a>
<a name="ln497">  int extra_attr = 0;                 // attributes when n_extra != 0</a>
<a name="ln498">  static char_u *at_end_str = (char_u *)&quot;&quot;;  // used for p_extra when displaying</a>
<a name="ln499">                                             // curwin-&gt;w_p_lcs_chars.eol at</a>
<a name="ln500">                                             // end-of-line</a>
<a name="ln501">  int lcs_eol_one = wp-&gt;w_p_lcs_chars.eol;     // 'eol'  until it's been used</a>
<a name="ln502">  int lcs_prec_todo = wp-&gt;w_p_lcs_chars.prec;  // 'prec' until it's been used</a>
<a name="ln503">  bool has_fold = foldinfo.fi_level != 0 &amp;&amp; foldinfo.fi_lines &gt; 0;</a>
<a name="ln504"> </a>
<a name="ln505">  // saved &quot;extra&quot; items for when draw_state becomes WL_LINE (again)</a>
<a name="ln506">  int saved_n_extra = 0;</a>
<a name="ln507">  char_u *saved_p_extra = NULL;</a>
<a name="ln508">  int saved_c_extra = 0;</a>
<a name="ln509">  int saved_c_final = 0;</a>
<a name="ln510">  int saved_char_attr = 0;</a>
<a name="ln511"> </a>
<a name="ln512">  int n_attr = 0;                       // chars with special attr</a>
<a name="ln513">  int saved_attr2 = 0;                  // char_attr saved for n_attr</a>
<a name="ln514">  int n_attr3 = 0;                      // chars with overruling special attr</a>
<a name="ln515">  int saved_attr3 = 0;                  // char_attr saved for n_attr3</a>
<a name="ln516"> </a>
<a name="ln517">  int n_skip = 0;                       // nr of chars to skip for 'nowrap'</a>
<a name="ln518"> </a>
<a name="ln519">  int fromcol = -10;                    // start of inverting</a>
<a name="ln520">  int tocol = MAXCOL;                   // end of inverting</a>
<a name="ln521">  int fromcol_prev = -2;                // start of inverting after cursor</a>
<a name="ln522">  bool noinvcur = false;                // don't invert the cursor</a>
<a name="ln523">  bool lnum_in_visual_area = false;</a>
<a name="ln524">  pos_T pos;</a>
<a name="ln525">  long v;</a>
<a name="ln526"> </a>
<a name="ln527">  int char_attr = 0;                    // attributes for next character</a>
<a name="ln528">  bool attr_pri = false;                // char_attr has priority</a>
<a name="ln529">  bool area_highlighting = false;       // Visual or incsearch highlighting in this line</a>
<a name="ln530">  int attr = 0;                         // attributes for area highlighting</a>
<a name="ln531">  int area_attr = 0;                    // attributes desired by highlighting</a>
<a name="ln532">  int search_attr = 0;                  // attributes desired by 'hlsearch'</a>
<a name="ln533">  int vcol_save_attr = 0;               // saved attr for 'cursorcolumn'</a>
<a name="ln534">  int syntax_attr = 0;                  // attributes desired by syntax</a>
<a name="ln535">  bool has_syntax = false;              // this buffer has syntax highl.</a>
<a name="ln536">  int save_did_emsg;</a>
<a name="ln537">  int eol_hl_off = 0;                   // 1 if highlighted char after EOL</a>
<a name="ln538">  bool draw_color_col = false;          // highlight colorcolumn</a>
<a name="ln539">  int *color_cols = NULL;               // pointer to according columns array</a>
<a name="ln540">  bool has_spell = false;               // this buffer has spell checking</a>
<a name="ln541">#define SPWORDLEN 150</a>
<a name="ln542">  char_u nextline[SPWORDLEN * 2];       // text with start of the next line</a>
<a name="ln543">  int nextlinecol = 0;                  // column where nextline[] starts</a>
<a name="ln544">  int nextline_idx = 0;                 // index in nextline[] where next line</a>
<a name="ln545">                                        // starts</a>
<a name="ln546">  int spell_attr = 0;                   // attributes desired by spelling</a>
<a name="ln547">  int word_end = 0;                     // last byte with same spell_attr</a>
<a name="ln548">  static linenr_T checked_lnum = 0;     // line number for &quot;checked_col&quot;</a>
<a name="ln549">  static int checked_col = 0;           // column in &quot;checked_lnum&quot; up to which</a>
<a name="ln550">                                        // there are no spell errors</a>
<a name="ln551">  static int cap_col = -1;              // column to check for Cap word</a>
<a name="ln552">  static linenr_T capcol_lnum = 0;      // line number where &quot;cap_col&quot;</a>
<a name="ln553">  int cur_checked_col = 0;              // checked column for current line</a>
<a name="ln554">  int extra_check = 0;                  // has syntax or linebreak</a>
<a name="ln555">  int multi_attr = 0;                   // attributes desired by multibyte</a>
<a name="ln556">  int mb_l = 1;                         // multi-byte byte length</a>
<a name="ln557">  int mb_c = 0;                         // decoded multi-byte character</a>
<a name="ln558">  bool mb_utf8 = false;                 // screen char is UTF-8 char</a>
<a name="ln559">  int u8cc[MAX_MCO];                    // composing UTF-8 chars</a>
<a name="ln560">  int filler_lines;                     // nr of filler lines to be drawn</a>
<a name="ln561">  int filler_todo;                      // nr of filler lines still to do + 1</a>
<a name="ln562">  hlf_T diff_hlf = (hlf_T)0;            // type of diff highlighting</a>
<a name="ln563">  int change_start = MAXCOL;            // first col of changed area</a>
<a name="ln564">  int change_end = -1;                  // last col of changed area</a>
<a name="ln565">  colnr_T trailcol = MAXCOL;            // start of trailing spaces</a>
<a name="ln566">  colnr_T leadcol = 0;                  // start of leading spaces</a>
<a name="ln567">  bool in_multispace = false;           // in multiple consecutive spaces</a>
<a name="ln568">  int multispace_pos = 0;               // position in lcs-multispace string</a>
<a name="ln569">  bool need_showbreak = false;          // overlong line, skip first x chars</a>
<a name="ln570">  int line_attr = 0;                    // attribute for the whole line</a>
<a name="ln571">  int line_attr_save;</a>
<a name="ln572">  int line_attr_lowprio = 0;            // low-priority attribute for the line</a>
<a name="ln573">  int line_attr_lowprio_save;</a>
<a name="ln574">  int prev_c = 0;                       // previous Arabic character</a>
<a name="ln575">  int prev_c1 = 0;                      // first composing char for prev_c</a>
<a name="ln576"> </a>
<a name="ln577">  bool search_attr_from_match = false;  // if search_attr is from :match</a>
<a name="ln578">  bool has_decor = false;               // this buffer has decoration</a>
<a name="ln579">  int win_col_offset = 0;               // offset for window columns</a>
<a name="ln580"> </a>
<a name="ln581">  char_u buf_fold[FOLD_TEXT_LEN];       // Hold value returned by get_foldtext</a>
<a name="ln582"> </a>
<a name="ln583">  bool area_active = false;</a>
<a name="ln584"> </a>
<a name="ln585">  int cul_attr = 0;                     // set when 'cursorline' active</a>
<a name="ln586">  // 'cursorlineopt' has &quot;screenline&quot; and cursor is in this line</a>
<a name="ln587">  bool cul_screenline = false;</a>
<a name="ln588">  // margin columns for the screen line, needed for when 'cursorlineopt'</a>
<a name="ln589">  // contains &quot;screenline&quot;</a>
<a name="ln590">  int left_curline_col = 0;</a>
<a name="ln591">  int right_curline_col = 0;</a>
<a name="ln592"> </a>
<a name="ln593">  // draw_state: items that are drawn in sequence:</a>
<a name="ln594">#define WL_START        0               // nothing done yet</a>
<a name="ln595">#define WL_CMDLINE      (WL_START + 1)    // cmdline window column</a>
<a name="ln596">#define WL_FOLD         (WL_CMDLINE + 1)  // 'foldcolumn'</a>
<a name="ln597">#define WL_SIGN         (WL_FOLD + 1)     // column for signs</a>
<a name="ln598">#define WL_NR           (WL_SIGN + 1)     // line number</a>
<a name="ln599">#define WL_BRI          (WL_NR + 1)       // 'breakindent'</a>
<a name="ln600">#define WL_SBR          (WL_BRI + 1)      // 'showbreak' or 'diff'</a>
<a name="ln601">#define WL_LINE         (WL_SBR + 1)      // text in the line</a>
<a name="ln602">  int draw_state = WL_START;            // what to draw next</a>
<a name="ln603"> </a>
<a name="ln604">  int syntax_flags    = 0;</a>
<a name="ln605">  int syntax_seqnr    = 0;</a>
<a name="ln606">  int prev_syntax_id  = 0;</a>
<a name="ln607">  int conceal_attr    = win_hl_attr(wp, HLF_CONCEAL);</a>
<a name="ln608">  bool is_concealing  = false;</a>
<a name="ln609">  int boguscols       = 0;              ///&lt; nonexistent columns added to</a>
<a name="ln610">                                        ///&lt; force wrapping</a>
<a name="ln611">  int vcol_off        = 0;              ///&lt; offset for concealed characters</a>
<a name="ln612">  int did_wcol        = false;</a>
<a name="ln613">  int match_conc      = 0;              ///&lt; cchar for match functions</a>
<a name="ln614">  int old_boguscols = 0;</a>
<a name="ln615">#define VCOL_HLC (vcol - vcol_off)</a>
<a name="ln616">#define FIX_FOR_BOGUSCOLS \</a>
<a name="ln617">  { \</a>
<a name="ln618">    n_extra += vcol_off; \</a>
<a name="ln619">    vcol -= vcol_off; \</a>
<a name="ln620">    vcol_off = 0; \</a>
<a name="ln621">    col -= boguscols; \</a>
<a name="ln622">    old_boguscols = boguscols; \</a>
<a name="ln623">    boguscols = 0; \</a>
<a name="ln624">  }</a>
<a name="ln625"> </a>
<a name="ln626">  if (startrow &gt; endrow) {              // past the end already!</a>
<a name="ln627">    return startrow;</a>
<a name="ln628">  }</a>
<a name="ln629"> </a>
<a name="ln630">  row = startrow;</a>
<a name="ln631"> </a>
<a name="ln632">  buf_T *buf = wp-&gt;w_buffer;</a>
<a name="ln633">  bool end_fill = (lnum == buf-&gt;b_ml.ml_line_count + 1);</a>
<a name="ln634"> </a>
<a name="ln635">  if (!number_only) {</a>
<a name="ln636">    // To speed up the loop below, set extra_check when there is linebreak,</a>
<a name="ln637">    // trailing white space and/or syntax processing to be done.</a>
<a name="ln638">    extra_check = wp-&gt;w_p_lbr;</a>
<a name="ln639">    if (syntax_present(wp) &amp;&amp; !wp-&gt;w_s-&gt;b_syn_error &amp;&amp; !wp-&gt;w_s-&gt;b_syn_slow</a>
<a name="ln640">        &amp;&amp; !has_fold &amp;&amp; !end_fill) {</a>
<a name="ln641">      // Prepare for syntax highlighting in this line.  When there is an</a>
<a name="ln642">      // error, stop syntax highlighting.</a>
<a name="ln643">      save_did_emsg = did_emsg;</a>
<a name="ln644">      did_emsg = false;</a>
<a name="ln645">      syntax_start(wp, lnum);</a>
<a name="ln646">      if (did_emsg) {</a>
<a name="ln647">        wp-&gt;w_s-&gt;b_syn_error = true;</a>
<a name="ln648">      } else {</a>
<a name="ln649">        did_emsg = save_did_emsg;</a>
<a name="ln650">        if (!wp-&gt;w_s-&gt;b_syn_slow) {</a>
<a name="ln651">          has_syntax = true;</a>
<a name="ln652">          extra_check = true;</a>
<a name="ln653">        }</a>
<a name="ln654">      }</a>
<a name="ln655">    }</a>
<a name="ln656"> </a>
<a name="ln657">    has_decor = decor_redraw_line(buf, lnum - 1, &amp;decor_state);</a>
<a name="ln658"> </a>
<a name="ln659">    decor_providers_invoke_line(wp, providers, lnum - 1, &amp;has_decor, provider_err);</a>
<a name="ln660"> </a>
<a name="ln661">    if (*provider_err) {</a>
<a name="ln662">      provider_err_virt_text(lnum, *provider_err);</a>
<a name="ln663">      has_decor = true;</a>
<a name="ln664">      *provider_err = NULL;</a>
<a name="ln665">    }</a>
<a name="ln666"> </a>
<a name="ln667">    if (has_decor) {</a>
<a name="ln668">      extra_check = true;</a>
<a name="ln669">    }</a>
<a name="ln670"> </a>
<a name="ln671">    // Check for columns to display for 'colorcolumn'.</a>
<a name="ln672">    color_cols = wp-&gt;w_buffer-&gt;terminal ? NULL : wp-&gt;w_p_cc_cols;</a>
<a name="ln673">    if (color_cols != NULL) {</a>
<a name="ln674">      draw_color_col = advance_color_col((int)VCOL_HLC, &amp;color_cols);</a>
<a name="ln675">    }</a>
<a name="ln676"> </a>
<a name="ln677">    if (wp-&gt;w_p_spell</a>
<a name="ln678">        &amp;&amp; !has_fold</a>
<a name="ln679">        &amp;&amp; !end_fill</a>
<a name="ln680">        &amp;&amp; *wp-&gt;w_s-&gt;b_p_spl != NUL</a>
<a name="ln681">        &amp;&amp; !GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)</a>
<a name="ln682">        &amp;&amp; *(char **)(wp-&gt;w_s-&gt;b_langp.ga_data) != NULL) {</a>
<a name="ln683">      // Prepare for spell checking.</a>
<a name="ln684">      has_spell = true;</a>
<a name="ln685">      extra_check = true;</a>
<a name="ln686"> </a>
<a name="ln687">      // Get the start of the next line, so that words that wrap to the next</a>
<a name="ln688">      // line are found too: &quot;et&lt;line-break&gt;al.&quot;.</a>
<a name="ln689">      // Trick: skip a few chars for C/shell/Vim comments</a>
<a name="ln690">      nextline[SPWORDLEN] = NUL;</a>
<a name="ln691">      if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln692">        line = (char_u *)ml_get_buf(wp-&gt;w_buffer, lnum + 1, false);</a>
<a name="ln693">        spell_cat_line(nextline + SPWORDLEN, line, SPWORDLEN);</a>
<a name="ln694">      }</a>
<a name="ln695"> </a>
<a name="ln696">      // When a word wrapped from the previous line the start of the current</a>
<a name="ln697">      // line is valid.</a>
<a name="ln698">      if (lnum == checked_lnum) {</a>
<a name="ln699">        cur_checked_col = checked_col;</a>
<a name="ln700">      }</a>
<a name="ln701">      checked_lnum = 0;</a>
<a name="ln702"> </a>
<a name="ln703">      // When there was a sentence end in the previous line may require a</a>
<a name="ln704">      // word starting with capital in this line.  In line 1 always check</a>
<a name="ln705">      // the first word.</a>
<a name="ln706">      if (lnum != capcol_lnum) {</a>
<a name="ln707">        cap_col = -1;</a>
<a name="ln708">      }</a>
<a name="ln709">      if (lnum == 1) {</a>
<a name="ln710">        cap_col = 0;</a>
<a name="ln711">      }</a>
<a name="ln712">      capcol_lnum = 0;</a>
<a name="ln713">    }</a>
<a name="ln714"> </a>
<a name="ln715">    // handle Visual active in this window</a>
<a name="ln716">    if (VIsual_active &amp;&amp; wp-&gt;w_buffer == curwin-&gt;w_buffer) {</a>
<a name="ln717">      pos_T *top, *bot;</a>
<a name="ln718"> </a>
<a name="ln719">      if (ltoreq(curwin-&gt;w_cursor, VIsual)) {</a>
<a name="ln720">        // Visual is after curwin-&gt;w_cursor</a>
<a name="ln721">        top = &amp;curwin-&gt;w_cursor;</a>
<a name="ln722">        bot = &amp;VIsual;</a>
<a name="ln723">      } else {</a>
<a name="ln724">        // Visual is before curwin-&gt;w_cursor</a>
<a name="ln725">        top = &amp;VIsual;</a>
<a name="ln726">        bot = &amp;curwin-&gt;w_cursor;</a>
<a name="ln727">      }</a>
<a name="ln728">      lnum_in_visual_area = (lnum &gt;= top-&gt;lnum &amp;&amp; lnum &lt;= bot-&gt;lnum);</a>
<a name="ln729">      if (VIsual_mode == Ctrl_V) {</a>
<a name="ln730">        // block mode</a>
<a name="ln731">        if (lnum_in_visual_area) {</a>
<a name="ln732">          fromcol = wp-&gt;w_old_cursor_fcol;</a>
<a name="ln733">          tocol = wp-&gt;w_old_cursor_lcol;</a>
<a name="ln734">        }</a>
<a name="ln735">      } else {</a>
<a name="ln736">        // non-block mode</a>
<a name="ln737">        if (lnum &gt; top-&gt;lnum &amp;&amp; lnum &lt;= bot-&gt;lnum) {</a>
<a name="ln738">          fromcol = 0;</a>
<a name="ln739">        } else if (lnum == top-&gt;lnum) {</a>
<a name="ln740">          if (VIsual_mode == 'V') {       // linewise</a>
<a name="ln741">            fromcol = 0;</a>
<a name="ln742">          } else {</a>
<a name="ln743">            getvvcol(wp, top, (colnr_T *)&amp;fromcol, NULL, NULL);</a>
<a name="ln744">            if (gchar_pos(top) == NUL) {</a>
<a name="ln745">              tocol = fromcol + 1;</a>
<a name="ln746">            }</a>
<a name="ln747">          }</a>
<a name="ln748">        }</a>
<a name="ln749">        if (VIsual_mode != 'V' &amp;&amp; lnum == bot-&gt;lnum) {</a>
<a name="ln750">          if (*p_sel == 'e' &amp;&amp; bot-&gt;col == 0</a>
<a name="ln751">              &amp;&amp; bot-&gt;coladd == 0) {</a>
<a name="ln752">            fromcol = -10;</a>
<a name="ln753">            tocol = MAXCOL;</a>
<a name="ln754">          } else if (bot-&gt;col == MAXCOL) {</a>
<a name="ln755">            tocol = MAXCOL;</a>
<a name="ln756">          } else {</a>
<a name="ln757">            pos = *bot;</a>
<a name="ln758">            if (*p_sel == 'e') {</a>
<a name="ln759">              getvvcol(wp, &amp;pos, (colnr_T *)&amp;tocol, NULL, NULL);</a>
<a name="ln760">            } else {</a>
<a name="ln761">              getvvcol(wp, &amp;pos, NULL, NULL, (colnr_T *)&amp;tocol);</a>
<a name="ln762">              tocol++;</a>
<a name="ln763">            }</a>
<a name="ln764">          }</a>
<a name="ln765">        }</a>
<a name="ln766">      }</a>
<a name="ln767"> </a>
<a name="ln768">      // Check if the char under the cursor should be inverted (highlighted).</a>
<a name="ln769">      if (!highlight_match &amp;&amp; lnum == curwin-&gt;w_cursor.lnum &amp;&amp; wp == curwin</a>
<a name="ln770">          &amp;&amp; cursor_is_block_during_visual(*p_sel == 'e')) {</a>
<a name="ln771">        noinvcur = true;</a>
<a name="ln772">      }</a>
<a name="ln773"> </a>
<a name="ln774">      // if inverting in this line set area_highlighting</a>
<a name="ln775">      if (fromcol &gt;= 0) {</a>
<a name="ln776">        area_highlighting = true;</a>
<a name="ln777">        attr = win_hl_attr(wp, HLF_V);</a>
<a name="ln778">      }</a>
<a name="ln779">      // handle 'incsearch' and &quot;:s///c&quot; highlighting</a>
<a name="ln780">    } else if (highlight_match</a>
<a name="ln781">               &amp;&amp; wp == curwin</a>
<a name="ln782">               &amp;&amp; !has_fold</a>
<a name="ln783">               &amp;&amp; lnum &gt;= curwin-&gt;w_cursor.lnum</a>
<a name="ln784">               &amp;&amp; lnum &lt;= curwin-&gt;w_cursor.lnum + search_match_lines) {</a>
<a name="ln785">      if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln786">        getvcol(curwin, &amp;(curwin-&gt;w_cursor),</a>
<a name="ln787">                (colnr_T *)&amp;fromcol, NULL, NULL);</a>
<a name="ln788">      } else {</a>
<a name="ln789">        fromcol = 0;</a>
<a name="ln790">      }</a>
<a name="ln791">      if (lnum == curwin-&gt;w_cursor.lnum + search_match_lines) {</a>
<a name="ln792">        pos.lnum = lnum;</a>
<a name="ln793">        pos.col = search_match_endcol;</a>
<a name="ln794">        getvcol(curwin, &amp;pos, (colnr_T *)&amp;tocol, NULL, NULL);</a>
<a name="ln795">      }</a>
<a name="ln796">      // do at least one character; happens when past end of line</a>
<a name="ln797">      if (fromcol == tocol &amp;&amp; search_match_endcol) {</a>
<a name="ln798">        tocol = fromcol + 1;</a>
<a name="ln799">      }</a>
<a name="ln800">      area_highlighting = true;</a>
<a name="ln801">      attr = win_hl_attr(wp, HLF_I);</a>
<a name="ln802">    }</a>
<a name="ln803">  }</a>
<a name="ln804"> </a>
<a name="ln805">  int bg_attr = win_bg_attr(wp);</a>
<a name="ln806"> </a>
<a name="ln807">  filler_lines = diff_check(wp, lnum);</a>
<a name="ln808">  if (filler_lines &lt; 0) {</a>
<a name="ln809">    if (filler_lines == -1) {</a>
<a name="ln810">      if (diff_find_change(wp, lnum, &amp;change_start, &amp;change_end)) {</a>
<a name="ln811">        diff_hlf = HLF_ADD;             // added line</a>
<a name="ln812">      } else if (change_start == 0) {</a>
<a name="ln813">        diff_hlf = HLF_TXD;             // changed text</a>
<a name="ln814">      } else {</a>
<a name="ln815">        diff_hlf = HLF_CHD;             // changed line</a>
<a name="ln816">      }</a>
<a name="ln817">    } else {</a>
<a name="ln818">      diff_hlf = HLF_ADD;               // added line</a>
<a name="ln819">    }</a>
<a name="ln820">    filler_lines = 0;</a>
<a name="ln821">    area_highlighting = true;</a>
<a name="ln822">  }</a>
<a name="ln823">  VirtLines virt_lines = KV_INITIAL_VALUE;</a>
<a name="ln824">  int n_virt_lines = decor_virt_lines(wp, lnum, &amp;virt_lines);</a>
<a name="ln825">  filler_lines += n_virt_lines;</a>
<a name="ln826">  if (lnum == wp-&gt;w_topline) {</a>
<a name="ln827">    filler_lines = wp-&gt;w_topfill;</a>
<a name="ln828">    n_virt_lines = MIN(n_virt_lines, filler_lines);</a>
<a name="ln829">  }</a>
<a name="ln830">  filler_todo = filler_lines;</a>
<a name="ln831"> </a>
<a name="ln832">  // Cursor line highlighting for 'cursorline' in the current window.</a>
<a name="ln833">  if (lnum == wp-&gt;w_cursor.lnum) {</a>
<a name="ln834">    // Do not show the cursor line in the text when Visual mode is active,</a>
<a name="ln835">    // because it's not clear what is selected then.</a>
<a name="ln836">    if (wp-&gt;w_p_cul &amp;&amp; !(wp == curwin &amp;&amp; VIsual_active)</a>
<a name="ln837">        &amp;&amp; wp-&gt;w_p_culopt_flags != CULOPT_NBR) {</a>
<a name="ln838">      cul_screenline = (wp-&gt;w_p_wrap</a>
<a name="ln839">                        &amp;&amp; (wp-&gt;w_p_culopt_flags &amp; CULOPT_SCRLINE));</a>
<a name="ln840">      if (!cul_screenline) {</a>
<a name="ln841">        apply_cursorline_highlight(wp, lnum, &amp;line_attr, &amp;cul_attr, &amp;line_attr_lowprio);</a>
<a name="ln842">      } else {</a>
<a name="ln843">        margin_columns_win(wp, &amp;left_curline_col, &amp;right_curline_col);</a>
<a name="ln844">      }</a>
<a name="ln845">      area_highlighting = true;</a>
<a name="ln846">    }</a>
<a name="ln847">  }</a>
<a name="ln848"> </a>
<a name="ln849">  SignTextAttrs sattrs[SIGN_SHOW_MAX];  // sign attributes for the sign column</a>
<a name="ln850">  int sign_num_attr = 0;                // sign attribute for the number column</a>
<a name="ln851">  int sign_cul_attr = 0;                // sign attribute for cursorline</a>
<a name="ln852">  CLEAR_FIELD(sattrs);</a>
<a name="ln853">  int num_signs = get_sign_attrs(buf, lnum, sattrs, &amp;line_attr, &amp;sign_num_attr, &amp;sign_cul_attr);</a>
<a name="ln854"> </a>
<a name="ln855">  // Highlight the current line in the quickfix window.</a>
<a name="ln856">  if (bt_quickfix(wp-&gt;w_buffer) &amp;&amp; qf_current_entry(wp) == lnum) {</a>
<a name="ln857">    line_attr = win_hl_attr(wp, HLF_QFL);</a>
<a name="ln858">  }</a>
<a name="ln859"> </a>
<a name="ln860">  if (line_attr_lowprio || line_attr) {</a>
<a name="ln861">    area_highlighting = true;</a>
<a name="ln862">  }</a>
<a name="ln863"> </a>
<a name="ln864">  if (cul_screenline) {</a>
<a name="ln865">    line_attr_save = line_attr;</a>
<a name="ln866">    line_attr_lowprio_save = line_attr_lowprio;</a>
<a name="ln867">  }</a>
<a name="ln868"> </a>
<a name="ln869">  line = end_fill ? (char_u *)&quot;&quot; : (char_u *)ml_get_buf(wp-&gt;w_buffer, lnum, false);</a>
<a name="ln870">  ptr = line;</a>
<a name="ln871"> </a>
<a name="ln872">  if (has_spell &amp;&amp; !number_only) {</a>
<a name="ln873">    // For checking first word with a capital skip white space.</a>
<a name="ln874">    if (cap_col == 0) {</a>
<a name="ln875">      cap_col = (int)getwhitecols((char *)line);</a>
<a name="ln876">    }</a>
<a name="ln877"> </a>
<a name="ln878">    // To be able to spell-check over line boundaries copy the end of the</a>
<a name="ln879">    // current line into nextline[].  Above the start of the next line was</a>
<a name="ln880">    // copied to nextline[SPWORDLEN].</a>
<a name="ln881">    if (nextline[SPWORDLEN] == NUL) {</a>
<a name="ln882">      // No next line or it is empty.</a>
<a name="ln883">      nextlinecol = MAXCOL;</a>
<a name="ln884">      nextline_idx = 0;</a>
<a name="ln885">    } else {</a>
<a name="ln886">      v = (long)STRLEN(line);</a>
<a name="ln887">      if (v &lt; SPWORDLEN) {</a>
<a name="ln888">        // Short line, use it completely and append the start of the</a>
<a name="ln889">        // next line.</a>
<a name="ln890">        nextlinecol = 0;</a>
<a name="ln891">        memmove(nextline, line, (size_t)v);</a>
<a name="ln892">        STRMOVE(nextline + v, nextline + SPWORDLEN);</a>
<a name="ln893">        nextline_idx = (int)v + 1;</a>
<a name="ln894">      } else {</a>
<a name="ln895">        // Long line, use only the last SPWORDLEN bytes.</a>
<a name="ln896">        nextlinecol = (int)v - SPWORDLEN;</a>
<a name="ln897">        memmove(nextline, line + nextlinecol, SPWORDLEN);  // -V1086</a>
<a name="ln898">        nextline_idx = SPWORDLEN + 1;</a>
<a name="ln899">      }</a>
<a name="ln900">    }</a>
<a name="ln901">  }</a>
<a name="ln902"> </a>
<a name="ln903">  if (wp-&gt;w_p_list &amp;&amp; !has_fold &amp;&amp; !end_fill) {</a>
<a name="ln904">    if (wp-&gt;w_p_lcs_chars.space</a>
<a name="ln905">        || wp-&gt;w_p_lcs_chars.multispace != NULL</a>
<a name="ln906">        || wp-&gt;w_p_lcs_chars.leadmultispace != NULL</a>
<a name="ln907">        || wp-&gt;w_p_lcs_chars.trail</a>
<a name="ln908">        || wp-&gt;w_p_lcs_chars.lead</a>
<a name="ln909">        || wp-&gt;w_p_lcs_chars.nbsp) {</a>
<a name="ln910">      extra_check = true;</a>
<a name="ln911">    }</a>
<a name="ln912">    // find start of trailing whitespace</a>
<a name="ln913">    if (wp-&gt;w_p_lcs_chars.trail) {</a>
<a name="ln914">      trailcol = (colnr_T)STRLEN(ptr);</a>
<a name="ln915">      while (trailcol &gt; (colnr_T)0 &amp;&amp; ascii_iswhite(ptr[trailcol - 1])) {</a>
<a name="ln916">        trailcol--;</a>
<a name="ln917">      }</a>
<a name="ln918">      trailcol += (colnr_T)(ptr - line);</a>
<a name="ln919">    }</a>
<a name="ln920">    // find end of leading whitespace</a>
<a name="ln921">    if (wp-&gt;w_p_lcs_chars.lead || wp-&gt;w_p_lcs_chars.leadmultispace != NULL) {</a>
<a name="ln922">      leadcol = 0;</a>
<a name="ln923">      while (ascii_iswhite(ptr[leadcol])) {</a>
<a name="ln924">        leadcol++;</a>
<a name="ln925">      }</a>
<a name="ln926">      if (ptr[leadcol] == NUL) {</a>
<a name="ln927">        // in a line full of spaces all of them are treated as trailing</a>
<a name="ln928">        leadcol = (colnr_T)0;</a>
<a name="ln929">      } else {</a>
<a name="ln930">        // keep track of the first column not filled with spaces</a>
<a name="ln931">        leadcol += (colnr_T)(ptr - line) + 1;</a>
<a name="ln932">      }</a>
<a name="ln933">    }</a>
<a name="ln934">  }</a>
<a name="ln935"> </a>
<a name="ln936">  // 'nowrap' or 'wrap' and a single line that doesn't fit: Advance to the</a>
<a name="ln937">  // first character to be displayed.</a>
<a name="ln938">  if (wp-&gt;w_p_wrap) {</a>
<a name="ln939">    v = wp-&gt;w_skipcol;</a>
<a name="ln940">  } else {</a>
<a name="ln941">    v = wp-&gt;w_leftcol;</a>
<a name="ln942">  }</a>
<a name="ln943">  if (v &gt; 0 &amp;&amp; !number_only) {</a>
<a name="ln944">    char_u *prev_ptr = ptr;</a>
<a name="ln945">    chartabsize_T cts;</a>
<a name="ln946">    int charsize;</a>
<a name="ln947"> </a>
<a name="ln948">    init_chartabsize_arg(&amp;cts, wp, lnum, (colnr_T)vcol, (char *)line, (char *)ptr);</a>
<a name="ln949">    while (cts.cts_vcol &lt; v &amp;&amp; *cts.cts_ptr != NUL) {</a>
<a name="ln950">      charsize = win_lbr_chartabsize(&amp;cts, NULL);</a>
<a name="ln951">      cts.cts_vcol += charsize;</a>
<a name="ln952">      prev_ptr = (char_u *)cts.cts_ptr;</a>
<a name="ln953">      MB_PTR_ADV(cts.cts_ptr);</a>
<a name="ln954">    }</a>
<a name="ln955">    vcol = cts.cts_vcol;</a>
<a name="ln956">    ptr = (char_u *)cts.cts_ptr;</a>
<a name="ln957">    clear_chartabsize_arg(&amp;cts);</a>
<a name="ln958"> </a>
<a name="ln959">    // When:</a>
<a name="ln960">    // - 'cuc' is set, or</a>
<a name="ln961">    // - 'colorcolumn' is set, or</a>
<a name="ln962">    // - 'virtualedit' is set, or</a>
<a name="ln963">    // - the visual mode is active,</a>
<a name="ln964">    // the end of the line may be before the start of the displayed part.</a>
<a name="ln965">    if (vcol &lt; v &amp;&amp; (wp-&gt;w_p_cuc</a>
<a name="ln966">                     || draw_color_col</a>
<a name="ln967">                     || virtual_active()</a>
<a name="ln968">                     || (VIsual_active &amp;&amp; wp-&gt;w_buffer == curwin-&gt;w_buffer))) {</a>
<a name="ln969">      vcol = v;</a>
<a name="ln970">    }</a>
<a name="ln971"> </a>
<a name="ln972">    // Handle a character that's not completely on the screen: Put ptr at</a>
<a name="ln973">    // that character but skip the first few screen characters.</a>
<a name="ln974">    if (vcol &gt; v) {</a>
<a name="ln975">      vcol -= charsize;</a>
<a name="ln976">      ptr = prev_ptr;</a>
<a name="ln977">      // If the character fits on the screen, don't need to skip it.</a>
<a name="ln978">      // Except for a TAB.</a>
<a name="ln979">      if (utf_ptr2cells((char *)ptr) &gt;= charsize || *ptr == TAB) {</a>
<a name="ln980">        n_skip = (int)(v - vcol);</a>
<a name="ln981">      }</a>
<a name="ln982">    }</a>
<a name="ln983"> </a>
<a name="ln984">    // Adjust for when the inverted text is before the screen,</a>
<a name="ln985">    // and when the start of the inverted text is before the screen.</a>
<a name="ln986">    if (tocol &lt;= vcol) {</a>
<a name="ln987">      fromcol = 0;</a>
<a name="ln988">    } else if (fromcol &gt;= 0 &amp;&amp; fromcol &lt; vcol) {</a>
<a name="ln989">      fromcol = (int)vcol;</a>
<a name="ln990">    }</a>
<a name="ln991"> </a>
<a name="ln992">    // When w_skipcol is non-zero, first line needs 'showbreak'</a>
<a name="ln993">    if (wp-&gt;w_p_wrap) {</a>
<a name="ln994">      need_showbreak = true;</a>
<a name="ln995">    }</a>
<a name="ln996">    // When spell checking a word we need to figure out the start of the</a>
<a name="ln997">    // word and if it's badly spelled or not.</a>
<a name="ln998">    if (has_spell) {</a>
<a name="ln999">      size_t len;</a>
<a name="ln1000">      colnr_T linecol = (colnr_T)(ptr - line);</a>
<a name="ln1001">      hlf_T spell_hlf = HLF_COUNT;</a>
<a name="ln1002"> </a>
<a name="ln1003">      pos = wp-&gt;w_cursor;</a>
<a name="ln1004">      wp-&gt;w_cursor.lnum = lnum;</a>
<a name="ln1005">      wp-&gt;w_cursor.col = linecol;</a>
<a name="ln1006">      len = spell_move_to(wp, FORWARD, true, true, &amp;spell_hlf);</a>
<a name="ln1007"> </a>
<a name="ln1008">      // spell_move_to() may call ml_get() and make &quot;line&quot; invalid</a>
<a name="ln1009">      line = (char_u *)ml_get_buf(wp-&gt;w_buffer, lnum, false);</a>
<a name="ln1010">      ptr = line + linecol;</a>
<a name="ln1011"> </a>
<a name="ln1012">      if (len == 0 || (int)wp-&gt;w_cursor.col &gt; ptr - line) {</a>
<a name="ln1013">        // no bad word found at line start, don't check until end of a</a>
<a name="ln1014">        // word</a>
<a name="ln1015">        spell_hlf = HLF_COUNT;</a>
<a name="ln1016">        word_end = (int)(spell_to_word_end(ptr, wp) - line + 1);</a>
<a name="ln1017">      } else {</a>
<a name="ln1018">        // bad word found, use attributes until end of word</a>
<a name="ln1019">        assert(len &lt;= INT_MAX);</a>
<a name="ln1020">        word_end = wp-&gt;w_cursor.col + (int)len + 1;</a>
<a name="ln1021"> </a>
<a name="ln1022">        // Turn index into actual attributes.</a>
<a name="ln1023">        if (spell_hlf != HLF_COUNT) {</a>
<a name="ln1024">          spell_attr = highlight_attr[spell_hlf];</a>
<a name="ln1025">        }</a>
<a name="ln1026">      }</a>
<a name="ln1027">      wp-&gt;w_cursor = pos;</a>
<a name="ln1028"> </a>
<a name="ln1029">      // Need to restart syntax highlighting for this line.</a>
<a name="ln1030">      if (has_syntax) {</a>
<a name="ln1031">        syntax_start(wp, lnum);</a>
<a name="ln1032">      }</a>
<a name="ln1033">    }</a>
<a name="ln1034">  }</a>
<a name="ln1035"> </a>
<a name="ln1036">  // Correct highlighting for cursor that can't be disabled.</a>
<a name="ln1037">  // Avoids having to check this for each character.</a>
<a name="ln1038">  if (fromcol &gt;= 0) {</a>
<a name="ln1039">    if (noinvcur) {</a>
<a name="ln1040">      if ((colnr_T)fromcol == wp-&gt;w_virtcol) {</a>
<a name="ln1041">        // highlighting starts at cursor, let it start just after the</a>
<a name="ln1042">        // cursor</a>
<a name="ln1043">        fromcol_prev = fromcol;</a>
<a name="ln1044">        fromcol = -1;</a>
<a name="ln1045">      } else if ((colnr_T)fromcol &lt; wp-&gt;w_virtcol) {</a>
<a name="ln1046">        // restart highlighting after the cursor</a>
<a name="ln1047">        fromcol_prev = wp-&gt;w_virtcol;</a>
<a name="ln1048">      }</a>
<a name="ln1049">    }</a>
<a name="ln1050">    if (fromcol &gt;= tocol) {</a>
<a name="ln1051">      fromcol = -1;</a>
<a name="ln1052">    }</a>
<a name="ln1053">  }</a>
<a name="ln1054"> </a>
<a name="ln1055">  if (!number_only &amp;&amp; !has_fold &amp;&amp; !end_fill) {</a>
<a name="ln1056">    v = ptr - line;</a>
<a name="ln1057">    area_highlighting |= prepare_search_hl_line(wp, lnum, (colnr_T)v,</a>
<a name="ln1058">                                                &amp;line, &amp;screen_search_hl, &amp;search_attr,</a>
<a name="ln1059">                                                &amp;search_attr_from_match);</a>
<a name="ln1060">    ptr = line + v;  // &quot;line&quot; may have been updated</a>
<a name="ln1061">  }</a>
<a name="ln1062"> </a>
<a name="ln1063">  int off = 0;  // Offset relative start of line</a>
<a name="ln1064">  int col = 0;  // Visual column on screen.</a>
<a name="ln1065">  if (wp-&gt;w_p_rl) {</a>
<a name="ln1066">    // Rightleft window: process the text in the normal direction, but put</a>
<a name="ln1067">    // it in linebuf_char[off] from right to left.  Start at the</a>
<a name="ln1068">    // rightmost column of the window.</a>
<a name="ln1069">    col = grid-&gt;cols - 1;</a>
<a name="ln1070">    off += col;</a>
<a name="ln1071">  }</a>
<a name="ln1072"> </a>
<a name="ln1073">  // won't highlight after TERM_ATTRS_MAX columns</a>
<a name="ln1074">  int term_attrs[TERM_ATTRS_MAX] = { 0 };</a>
<a name="ln1075">  if (wp-&gt;w_buffer-&gt;terminal) {</a>
<a name="ln1076">    terminal_get_line_attributes(wp-&gt;w_buffer-&gt;terminal, wp, lnum, term_attrs);</a>
<a name="ln1077">    extra_check = true;</a>
<a name="ln1078">  }</a>
<a name="ln1079"> </a>
<a name="ln1080">  int sign_idx = 0;</a>
<a name="ln1081">  // Repeat for the whole displayed line.</a>
<a name="ln1082">  for (;;) {</a>
<a name="ln1083">    int has_match_conc = 0;  ///&lt; match wants to conceal</a>
<a name="ln1084">    int decor_conceal = 0;</a>
<a name="ln1085"> </a>
<a name="ln1086">    bool did_decrement_ptr = false;</a>
<a name="ln1087"> </a>
<a name="ln1088">    // Skip this quickly when working on the text.</a>
<a name="ln1089">    if (draw_state != WL_LINE) {</a>
<a name="ln1090">      if (cul_screenline) {</a>
<a name="ln1091">        cul_attr = 0;</a>
<a name="ln1092">        line_attr = line_attr_save;</a>
<a name="ln1093">        line_attr_lowprio = line_attr_lowprio_save;</a>
<a name="ln1094">      }</a>
<a name="ln1095"> </a>
<a name="ln1096">      if (draw_state == WL_CMDLINE - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln1097">        draw_state = WL_CMDLINE;</a>
<a name="ln1098">        if (cmdwin_type != 0 &amp;&amp; wp == curwin) {</a>
<a name="ln1099">          // Draw the cmdline character.</a>
<a name="ln1100">          n_extra = 1;</a>
<a name="ln1101">          c_extra = cmdwin_type;</a>
<a name="ln1102">          c_final = NUL;</a>
<a name="ln1103">          char_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln1104">        }</a>
<a name="ln1105">      }</a>
<a name="ln1106"> </a>
<a name="ln1107">      if (draw_state == WL_FOLD - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln1108">        int fdc = compute_foldcolumn(wp, 0);</a>
<a name="ln1109"> </a>
<a name="ln1110">        draw_state = WL_FOLD;</a>
<a name="ln1111">        if (fdc &gt; 0) {</a>
<a name="ln1112">          // Draw the 'foldcolumn'.  Allocate a buffer, &quot;extra&quot; may</a>
<a name="ln1113">          // already be in use.</a>
<a name="ln1114">          xfree(p_extra_free);</a>
<a name="ln1115">          p_extra_free = xmalloc(MAX_MCO * (size_t)fdc + 1);</a>
<a name="ln1116">          n_extra = (int)fill_foldcolumn(p_extra_free, wp, foldinfo, lnum);</a>
<a name="ln1117">          p_extra_free[n_extra] = NUL;</a>
<a name="ln1118">          p_extra = p_extra_free;</a>
<a name="ln1119">          c_extra = NUL;</a>
<a name="ln1120">          c_final = NUL;</a>
<a name="ln1121">          if (use_cursor_line_sign(wp, lnum)) {</a>
<a name="ln1122">            char_attr = win_hl_attr(wp, HLF_CLF);</a>
<a name="ln1123">          } else {</a>
<a name="ln1124">            char_attr = win_hl_attr(wp, HLF_FC);</a>
<a name="ln1125">          }</a>
<a name="ln1126">        }</a>
<a name="ln1127">      }</a>
<a name="ln1128"> </a>
<a name="ln1129">      // sign column, this is hit until sign_idx reaches count</a>
<a name="ln1130">      if (draw_state == WL_SIGN - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln1131">        draw_state = WL_SIGN;</a>
<a name="ln1132">        // Show the sign column when there are any signs in this buffer</a>
<a name="ln1133">        if (wp-&gt;w_scwidth &gt; 0) {</a>
<a name="ln1134">          get_sign_display_info(false, wp, lnum, sattrs, row,</a>
<a name="ln1135">                                startrow, filler_lines, filler_todo,</a>
<a name="ln1136">                                &amp;c_extra, &amp;c_final, extra, sizeof(extra),</a>
<a name="ln1137">                                &amp;p_extra, &amp;n_extra, &amp;char_attr, sign_idx,</a>
<a name="ln1138">                                sign_cul_attr);</a>
<a name="ln1139">          sign_idx++;</a>
<a name="ln1140">          if (sign_idx &lt; wp-&gt;w_scwidth) {</a>
<a name="ln1141">            draw_state = WL_SIGN - 1;</a>
<a name="ln1142">          } else {</a>
<a name="ln1143">            sign_idx = 0;</a>
<a name="ln1144">          }</a>
<a name="ln1145">        }</a>
<a name="ln1146">      }</a>
<a name="ln1147"> </a>
<a name="ln1148">      if (draw_state == WL_NR - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln1149">        draw_state = WL_NR;</a>
<a name="ln1150">        // Display the absolute or relative line number. After the</a>
<a name="ln1151">        // first fill with blanks when the 'n' flag isn't in 'cpo'</a>
<a name="ln1152">        if ((wp-&gt;w_p_nu || wp-&gt;w_p_rnu)</a>
<a name="ln1153">            &amp;&amp; (row == startrow + filler_lines</a>
<a name="ln1154">                || vim_strchr(p_cpo, CPO_NUMCOL) == NULL)) {</a>
<a name="ln1155">          // If 'signcolumn' is set to 'number' and a sign is present</a>
<a name="ln1156">          // in 'lnum', then display the sign instead of the line</a>
<a name="ln1157">          // number.</a>
<a name="ln1158">          if (*wp-&gt;w_p_scl == 'n' &amp;&amp; *(wp-&gt;w_p_scl + 1) == 'u' &amp;&amp; num_signs &gt; 0) {</a>
<a name="ln1159">            get_sign_display_info(true, wp, lnum, sattrs, row,</a>
<a name="ln1160">                                  startrow, filler_lines, filler_todo,</a>
<a name="ln1161">                                  &amp;c_extra, &amp;c_final, extra, sizeof(extra),</a>
<a name="ln1162">                                  &amp;p_extra, &amp;n_extra, &amp;char_attr, sign_idx,</a>
<a name="ln1163">                                  sign_cul_attr);</a>
<a name="ln1164">          } else {</a>
<a name="ln1165">            // Draw the line number (empty space after wrapping).</a>
<a name="ln1166">            if (row == startrow + filler_lines) {</a>
<a name="ln1167">              get_line_number_str(wp, lnum, (char_u *)extra, sizeof(extra));</a>
<a name="ln1168">              if (wp-&gt;w_skipcol &gt; 0) {</a>
<a name="ln1169">                for (p_extra = extra; *p_extra == ' '; p_extra++) {</a>
<a name="ln1170">                  *p_extra = '-';</a>
<a name="ln1171">                }</a>
<a name="ln1172">              }</a>
<a name="ln1173">              if (wp-&gt;w_p_rl) {                       // reverse line numbers</a>
<a name="ln1174">                // like rl_mirror(), but keep the space at the end</a>
<a name="ln1175">                char_u *p2 = (char_u *)skipwhite((char *)extra);</a>
<a name="ln1176">                p2 = (char_u *)skiptowhite((char *)p2) - 1;</a>
<a name="ln1177">                for (char_u *p1 = (char_u *)skipwhite((char *)extra); p1 &lt; p2; p1++, p2--) {</a>
<a name="ln1178">                  const char_u t = *p1;</a>
<a name="ln1179">                  *p1 = *p2;</a>
<a name="ln1180">                  *p2 = t;</a>
<a name="ln1181">                }</a>
<a name="ln1182">              }</a>
<a name="ln1183">              p_extra = extra;</a>
<a name="ln1184">              c_extra = NUL;</a>
<a name="ln1185">            } else {</a>
<a name="ln1186">              c_extra = ' ';</a>
<a name="ln1187">            }</a>
<a name="ln1188">            c_final = NUL;</a>
<a name="ln1189">            n_extra = number_width(wp) + 1;</a>
<a name="ln1190">            if (sign_num_attr &gt; 0) {</a>
<a name="ln1191">              char_attr = sign_num_attr;</a>
<a name="ln1192">            } else {</a>
<a name="ln1193">              char_attr = get_line_number_attr(wp, lnum, row, startrow, filler_lines);</a>
<a name="ln1194">            }</a>
<a name="ln1195">          }</a>
<a name="ln1196">        }</a>
<a name="ln1197">      }</a>
<a name="ln1198"> </a>
<a name="ln1199">      if (draw_state == WL_NR &amp;&amp; n_extra == 0) {</a>
<a name="ln1200">        win_col_offset = off;</a>
<a name="ln1201">      }</a>
<a name="ln1202"> </a>
<a name="ln1203">      if (wp-&gt;w_briopt_sbr &amp;&amp; draw_state == WL_BRI - 1</a>
<a name="ln1204">          &amp;&amp; n_extra == 0 &amp;&amp; *get_showbreak_value(wp) != NUL) {</a>
<a name="ln1205">        // draw indent after showbreak value</a>
<a name="ln1206">        draw_state = WL_BRI;</a>
<a name="ln1207">      } else if (wp-&gt;w_briopt_sbr &amp;&amp; draw_state == WL_SBR &amp;&amp; n_extra == 0) {</a>
<a name="ln1208">        // after the showbreak, draw the breakindent</a>
<a name="ln1209">        draw_state = WL_BRI - 1;</a>
<a name="ln1210">      }</a>
<a name="ln1211"> </a>
<a name="ln1212">      // draw 'breakindent': indent wrapped text accordingly</a>
<a name="ln1213">      if (draw_state == WL_BRI - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln1214">        draw_state = WL_BRI;</a>
<a name="ln1215">        // if need_showbreak is set, breakindent also applies</a>
<a name="ln1216">        if (wp-&gt;w_p_bri &amp;&amp; (row != startrow || need_showbreak)</a>
<a name="ln1217">            &amp;&amp; filler_lines == 0) {</a>
<a name="ln1218">          char_attr = 0;</a>
<a name="ln1219"> </a>
<a name="ln1220">          if (diff_hlf != (hlf_T)0) {</a>
<a name="ln1221">            char_attr = win_hl_attr(wp, (int)diff_hlf);</a>
<a name="ln1222">          }</a>
<a name="ln1223">          p_extra = NULL;</a>
<a name="ln1224">          c_extra = ' ';</a>
<a name="ln1225">          c_final = NUL;</a>
<a name="ln1226">          n_extra =</a>
<a name="ln1227">            get_breakindent_win(wp, (char_u *)ml_get_buf(wp-&gt;w_buffer, lnum, false));</a>
<a name="ln1228">          if (row == startrow) {</a>
<a name="ln1229">            n_extra -= win_col_off2(wp);</a>
<a name="ln1230">            if (n_extra &lt; 0) {</a>
<a name="ln1231">              n_extra = 0;</a>
<a name="ln1232">            }</a>
<a name="ln1233">          }</a>
<a name="ln1234">          if (wp-&gt;w_skipcol &gt; 0 &amp;&amp; wp-&gt;w_p_wrap &amp;&amp; wp-&gt;w_briopt_sbr) {</a>
<a name="ln1235">            need_showbreak = false;</a>
<a name="ln1236">          }</a>
<a name="ln1237">          // Correct end of highlighted area for 'breakindent',</a>
<a name="ln1238">          // required wen 'linebreak' is also set.</a>
<a name="ln1239">          if (tocol == vcol) {</a>
<a name="ln1240">            tocol += n_extra;</a>
<a name="ln1241">          }</a>
<a name="ln1242">        }</a>
<a name="ln1243">      }</a>
<a name="ln1244"> </a>
<a name="ln1245">      if (draw_state == WL_SBR - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln1246">        draw_state = WL_SBR;</a>
<a name="ln1247">        if (filler_todo &gt; filler_lines - n_virt_lines) {</a>
<a name="ln1248">          // TODO(bfredl): check this doesn't inhibit TUI-style</a>
<a name="ln1249">          //               clear-to-end-of-line.</a>
<a name="ln1250">          c_extra = ' ';</a>
<a name="ln1251">          c_final = NUL;</a>
<a name="ln1252">          if (wp-&gt;w_p_rl) {</a>
<a name="ln1253">            n_extra = col + 1;</a>
<a name="ln1254">          } else {</a>
<a name="ln1255">            n_extra = grid-&gt;cols - col;</a>
<a name="ln1256">          }</a>
<a name="ln1257">          char_attr = 0;</a>
<a name="ln1258">        } else if (filler_todo &gt; 0) {</a>
<a name="ln1259">          // Draw &quot;deleted&quot; diff line(s)</a>
<a name="ln1260">          if (char2cells(wp-&gt;w_p_fcs_chars.diff) &gt; 1) {</a>
<a name="ln1261">            c_extra = '-';</a>
<a name="ln1262">            c_final = NUL;</a>
<a name="ln1263">          } else {</a>
<a name="ln1264">            c_extra = wp-&gt;w_p_fcs_chars.diff;</a>
<a name="ln1265">            c_final = NUL;</a>
<a name="ln1266">          }</a>
<a name="ln1267">          if (wp-&gt;w_p_rl) {</a>
<a name="ln1268">            n_extra = col + 1;</a>
<a name="ln1269">          } else {</a>
<a name="ln1270">            n_extra = grid-&gt;cols - col;</a>
<a name="ln1271">          }</a>
<a name="ln1272">          char_attr = win_hl_attr(wp, HLF_DED);</a>
<a name="ln1273">        }</a>
<a name="ln1274">        char_u *const sbr = get_showbreak_value(wp);</a>
<a name="ln1275">        if (*sbr != NUL &amp;&amp; need_showbreak) {</a>
<a name="ln1276">          // Draw 'showbreak' at the start of each broken line.</a>
<a name="ln1277">          p_extra = sbr;</a>
<a name="ln1278">          c_extra = NUL;</a>
<a name="ln1279">          c_final = NUL;</a>
<a name="ln1280">          n_extra = (int)STRLEN(sbr);</a>
<a name="ln1281">          char_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln1282">          if (wp-&gt;w_skipcol == 0 || !wp-&gt;w_p_wrap) {</a>
<a name="ln1283">            need_showbreak = false;</a>
<a name="ln1284">          }</a>
<a name="ln1285">          vcol_sbr = vcol + mb_charlen(sbr);</a>
<a name="ln1286">          // Correct end of highlighted area for 'showbreak',</a>
<a name="ln1287">          // required when 'linebreak' is also set.</a>
<a name="ln1288">          if (tocol == vcol) {</a>
<a name="ln1289">            tocol += n_extra;</a>
<a name="ln1290">          }</a>
<a name="ln1291">          // Combine 'showbreak' with 'cursorline', prioritizing 'showbreak'.</a>
<a name="ln1292">          if (cul_attr) {</a>
<a name="ln1293">            char_attr = hl_combine_attr(cul_attr, char_attr);</a>
<a name="ln1294">          }</a>
<a name="ln1295">        }</a>
<a name="ln1296">      }</a>
<a name="ln1297"> </a>
<a name="ln1298">      if (draw_state == WL_LINE - 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln1299">        sign_idx = 0;</a>
<a name="ln1300">        draw_state = WL_LINE;</a>
<a name="ln1301"> </a>
<a name="ln1302">        if (has_decor &amp;&amp; row == startrow + filler_lines) {</a>
<a name="ln1303">          // hide virt_text on text hidden by 'nowrap'</a>
<a name="ln1304">          decor_redraw_col(wp-&gt;w_buffer, (int)vcol, off, true, &amp;decor_state);</a>
<a name="ln1305">        }</a>
<a name="ln1306"> </a>
<a name="ln1307">        if (saved_n_extra) {</a>
<a name="ln1308">          // Continue item from end of wrapped line.</a>
<a name="ln1309">          n_extra = saved_n_extra;</a>
<a name="ln1310">          c_extra = saved_c_extra;</a>
<a name="ln1311">          c_final = saved_c_final;</a>
<a name="ln1312">          p_extra = saved_p_extra;</a>
<a name="ln1313">          char_attr = saved_char_attr;</a>
<a name="ln1314">        } else {</a>
<a name="ln1315">          char_attr = 0;</a>
<a name="ln1316">        }</a>
<a name="ln1317">      }</a>
<a name="ln1318">    }</a>
<a name="ln1319"> </a>
<a name="ln1320">    if (cul_screenline &amp;&amp; draw_state == WL_LINE</a>
<a name="ln1321">        &amp;&amp; vcol &gt;= left_curline_col</a>
<a name="ln1322">        &amp;&amp; vcol &lt; right_curline_col) {</a>
<a name="ln1323">      apply_cursorline_highlight(wp, lnum, &amp;line_attr, &amp;cul_attr, &amp;line_attr_lowprio);</a>
<a name="ln1324">    }</a>
<a name="ln1325"> </a>
<a name="ln1326">    // When still displaying '$' of change command, stop at cursor</a>
<a name="ln1327">    if (((dollar_vcol &gt;= 0</a>
<a name="ln1328">          &amp;&amp; wp == curwin</a>
<a name="ln1329">          &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln1330">          &amp;&amp; vcol &gt;= (long)wp-&gt;w_virtcol)</a>
<a name="ln1331">         || (number_only &amp;&amp; draw_state &gt; WL_NR))</a>
<a name="ln1332">        &amp;&amp; filler_todo &lt;= 0) {</a>
<a name="ln1333">      draw_virt_text(wp, buf, win_col_offset, &amp;col, grid-&gt;cols, row);</a>
<a name="ln1334">      grid_put_linebuf(grid, row, 0, col, -grid-&gt;cols, wp-&gt;w_p_rl, wp, bg_attr, false);</a>
<a name="ln1335">      // Pretend we have finished updating the window.  Except when</a>
<a name="ln1336">      // 'cursorcolumn' is set.</a>
<a name="ln1337">      if (wp-&gt;w_p_cuc) {</a>
<a name="ln1338">        row = wp-&gt;w_cline_row + wp-&gt;w_cline_height;</a>
<a name="ln1339">      } else {</a>
<a name="ln1340">        row = grid-&gt;rows;</a>
<a name="ln1341">      }</a>
<a name="ln1342">      break;</a>
<a name="ln1343">    }</a>
<a name="ln1344"> </a>
<a name="ln1345">    if (draw_state == WL_LINE</a>
<a name="ln1346">        &amp;&amp; has_fold</a>
<a name="ln1347">        &amp;&amp; col == win_col_offset</a>
<a name="ln1348">        &amp;&amp; n_extra == 0</a>
<a name="ln1349">        &amp;&amp; row == startrow) {</a>
<a name="ln1350">      char_attr = win_hl_attr(wp, HLF_FL);</a>
<a name="ln1351"> </a>
<a name="ln1352">      linenr_T lnume = lnum + foldinfo.fi_lines - 1;</a>
<a name="ln1353">      memset(buf_fold, ' ', FOLD_TEXT_LEN);</a>
<a name="ln1354">      p_extra = (char_u *)get_foldtext(wp, lnum, lnume, foldinfo, (char *)buf_fold);</a>
<a name="ln1355">      n_extra = (int)STRLEN(p_extra);</a>
<a name="ln1356"> </a>
<a name="ln1357">      if (p_extra != buf_fold) {</a>
<a name="ln1358">        xfree(p_extra_free);</a>
<a name="ln1359">        p_extra_free = p_extra;</a>
<a name="ln1360">      }</a>
<a name="ln1361">      c_extra = NUL;</a>
<a name="ln1362">      c_final = NUL;</a>
<a name="ln1363">      p_extra[n_extra] = NUL;</a>
<a name="ln1364">    }</a>
<a name="ln1365"> </a>
<a name="ln1366">    if (draw_state == WL_LINE</a>
<a name="ln1367">        &amp;&amp; has_fold</a>
<a name="ln1368">        &amp;&amp; col &lt; grid-&gt;cols</a>
<a name="ln1369">        &amp;&amp; n_extra == 0</a>
<a name="ln1370">        &amp;&amp; row == startrow) {</a>
<a name="ln1371">      // fill rest of line with 'fold'</a>
<a name="ln1372">      c_extra = wp-&gt;w_p_fcs_chars.fold;</a>
<a name="ln1373">      c_final = NUL;</a>
<a name="ln1374"> </a>
<a name="ln1375">      n_extra = wp-&gt;w_p_rl ? (col + 1) : (grid-&gt;cols - col);</a>
<a name="ln1376">    }</a>
<a name="ln1377"> </a>
<a name="ln1378">    if (draw_state == WL_LINE</a>
<a name="ln1379">        &amp;&amp; has_fold</a>
<a name="ln1380">        &amp;&amp; col &gt;= grid-&gt;cols</a>
<a name="ln1381">        &amp;&amp; n_extra != 0</a>
<a name="ln1382">        &amp;&amp; row == startrow) {</a>
<a name="ln1383">      // Truncate the folding.</a>
<a name="ln1384">      n_extra = 0;</a>
<a name="ln1385">    }</a>
<a name="ln1386"> </a>
<a name="ln1387">    if (draw_state == WL_LINE &amp;&amp; (area_highlighting || has_spell)) {</a>
<a name="ln1388">      // handle Visual or match highlighting in this line</a>
<a name="ln1389">      if (vcol == fromcol</a>
<a name="ln1390">          || (vcol + 1 == fromcol &amp;&amp; n_extra == 0</a>
<a name="ln1391">              &amp;&amp; utf_ptr2cells((char *)ptr) &gt; 1)</a>
<a name="ln1392">          || ((int)vcol_prev == fromcol_prev</a>
<a name="ln1393">              &amp;&amp; vcol_prev &lt; vcol               // not at margin</a>
<a name="ln1394">              &amp;&amp; vcol &lt; tocol)) {</a>
<a name="ln1395">        area_attr = attr;                       // start highlighting</a>
<a name="ln1396">        if (area_highlighting) {</a>
<a name="ln1397">          area_active = true;</a>
<a name="ln1398">        }</a>
<a name="ln1399">      } else if (area_attr != 0 &amp;&amp; (vcol == tocol</a>
<a name="ln1400">                                    || (noinvcur</a>
<a name="ln1401">                                        &amp;&amp; (colnr_T)vcol == wp-&gt;w_virtcol))) {</a>
<a name="ln1402">        area_attr = 0;                          // stop highlighting</a>
<a name="ln1403">        area_active = false;</a>
<a name="ln1404">      }</a>
<a name="ln1405"> </a>
<a name="ln1406">      if (!n_extra) {</a>
<a name="ln1407">        // Check for start/end of 'hlsearch' and other matches.</a>
<a name="ln1408">        // After end, check for start/end of next match.</a>
<a name="ln1409">        // When another match, have to check for start again.</a>
<a name="ln1410">        v = (ptr - line);</a>
<a name="ln1411">        search_attr = update_search_hl(wp, lnum, (colnr_T)v, &amp;line, &amp;screen_search_hl,</a>
<a name="ln1412">                                       &amp;has_match_conc,</a>
<a name="ln1413">                                       &amp;match_conc, lcs_eol_one, &amp;search_attr_from_match);</a>
<a name="ln1414">        ptr = line + v;  // &quot;line&quot; may have been changed</a>
<a name="ln1415"> </a>
<a name="ln1416">        // Do not allow a conceal over EOL otherwise EOL will be missed</a>
<a name="ln1417">        // and bad things happen.</a>
<a name="ln1418">        if (*ptr == NUL) {</a>
<a name="ln1419">          has_match_conc = 0;</a>
<a name="ln1420">        }</a>
<a name="ln1421">      }</a>
<a name="ln1422"> </a>
<a name="ln1423">      if (diff_hlf != (hlf_T)0) {</a>
<a name="ln1424">        if (diff_hlf == HLF_CHD &amp;&amp; ptr - line &gt;= change_start</a>
<a name="ln1425">            &amp;&amp; n_extra == 0) {</a>
<a name="ln1426">          diff_hlf = HLF_TXD;                   // changed text</a>
<a name="ln1427">        }</a>
<a name="ln1428">        if (diff_hlf == HLF_TXD &amp;&amp; ptr - line &gt; change_end</a>
<a name="ln1429">            &amp;&amp; n_extra == 0) {</a>
<a name="ln1430">          diff_hlf = HLF_CHD;                   // changed line</a>
<a name="ln1431">        }</a>
<a name="ln1432">        line_attr = win_hl_attr(wp, (int)diff_hlf);</a>
<a name="ln1433">        // Overlay CursorLine onto diff-mode highlight.</a>
<a name="ln1434">        if (cul_attr) {</a>
<a name="ln1435">          line_attr = 0 != line_attr_lowprio  // Low-priority CursorLine</a>
<a name="ln1436">            ? hl_combine_attr(hl_combine_attr(cul_attr, line_attr),</a>
<a name="ln1437">                              hl_get_underline())</a>
<a name="ln1438">            : hl_combine_attr(line_attr, cul_attr);</a>
<a name="ln1439">        }</a>
<a name="ln1440">      }</a>
<a name="ln1441"> </a>
<a name="ln1442">      // Decide which of the highlight attributes to use.</a>
<a name="ln1443">      attr_pri = true;</a>
<a name="ln1444"> </a>
<a name="ln1445">      if (area_attr != 0) {</a>
<a name="ln1446">        char_attr = hl_combine_attr(line_attr, area_attr);</a>
<a name="ln1447">        if (!highlight_match) {</a>
<a name="ln1448">          // let search highlight show in Visual area if possible</a>
<a name="ln1449">          char_attr = hl_combine_attr(search_attr, char_attr);</a>
<a name="ln1450">        }</a>
<a name="ln1451">      } else if (search_attr != 0) {</a>
<a name="ln1452">        char_attr = hl_combine_attr(line_attr, search_attr);</a>
<a name="ln1453">      } else if (line_attr != 0 &amp;&amp; ((fromcol == -10 &amp;&amp; tocol == MAXCOL)</a>
<a name="ln1454">                                    || vcol &lt; fromcol || vcol_prev &lt; fromcol_prev</a>
<a name="ln1455">                                    || vcol &gt;= tocol)) {</a>
<a name="ln1456">        // Use line_attr when not in the Visual or 'incsearch' area</a>
<a name="ln1457">        // (area_attr may be 0 when &quot;noinvcur&quot; is set).</a>
<a name="ln1458">        char_attr = line_attr;</a>
<a name="ln1459">      } else {</a>
<a name="ln1460">        attr_pri = false;</a>
<a name="ln1461">        if (has_syntax) {</a>
<a name="ln1462">          char_attr = syntax_attr;</a>
<a name="ln1463">        } else {</a>
<a name="ln1464">          char_attr = 0;</a>
<a name="ln1465">        }</a>
<a name="ln1466">      }</a>
<a name="ln1467">    }</a>
<a name="ln1468"> </a>
<a name="ln1469">    // Get the next character to put on the screen.</a>
<a name="ln1470">    //</a>
<a name="ln1471">    // The &quot;p_extra&quot; points to the extra stuff that is inserted to</a>
<a name="ln1472">    // represent special characters (non-printable stuff) and other</a>
<a name="ln1473">    // things.  When all characters are the same, c_extra is used.</a>
<a name="ln1474">    // If c_final is set, it will compulsorily be used at the end.</a>
<a name="ln1475">    // &quot;p_extra&quot; must end in a NUL to avoid utfc_ptr2len() reads past</a>
<a name="ln1476">    // &quot;p_extra[n_extra]&quot;.</a>
<a name="ln1477">    // For the '$' of the 'list' option, n_extra == 1, p_extra == &quot;&quot;.</a>
<a name="ln1478">    if (n_extra &gt; 0) {</a>
<a name="ln1479">      if (c_extra != NUL || (n_extra == 1 &amp;&amp; c_final != NUL)) {</a>
<a name="ln1480">        c = (n_extra == 1 &amp;&amp; c_final != NUL) ? c_final : c_extra;</a>
<a name="ln1481">        mb_c = c;               // doesn't handle non-utf-8 multi-byte!</a>
<a name="ln1482">        mb_utf8 = check_mb_utf8(&amp;c, u8cc);</a>
<a name="ln1483">      } else {</a>
<a name="ln1484">        assert(p_extra != NULL);</a>
<a name="ln1485">        c = *p_extra;</a>
<a name="ln1486">        mb_c = c;</a>
<a name="ln1487">        // If the UTF-8 character is more than one byte:</a>
<a name="ln1488">        // Decode it into &quot;mb_c&quot;.</a>
<a name="ln1489">        mb_l = utfc_ptr2len((char *)p_extra);</a>
<a name="ln1490">        mb_utf8 = false;</a>
<a name="ln1491">        if (mb_l &gt; n_extra) {</a>
<a name="ln1492">          mb_l = 1;</a>
<a name="ln1493">        } else if (mb_l &gt; 1) {</a>
<a name="ln1494">          mb_c = utfc_ptr2char((char *)p_extra, u8cc);</a>
<a name="ln1495">          mb_utf8 = true;</a>
<a name="ln1496">          c = 0xc0;</a>
<a name="ln1497">        }</a>
<a name="ln1498">        if (mb_l == 0) {          // at the NUL at end-of-line</a>
<a name="ln1499">          mb_l = 1;</a>
<a name="ln1500">        }</a>
<a name="ln1501"> </a>
<a name="ln1502">        // If a double-width char doesn't fit display a '&gt;' in the last column.</a>
<a name="ln1503">        if ((wp-&gt;w_p_rl ? (col &lt;= 0) : (col &gt;= grid-&gt;cols - 1))</a>
<a name="ln1504">            &amp;&amp; utf_char2cells(mb_c) == 2) {</a>
<a name="ln1505">          c = '&gt;';</a>
<a name="ln1506">          mb_c = c;</a>
<a name="ln1507">          mb_l = 1;</a>
<a name="ln1508">          (void)mb_l;</a>
<a name="ln1509">          multi_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln1510"> </a>
<a name="ln1511">          if (cul_attr) {</a>
<a name="ln1512">            multi_attr = 0 != line_attr_lowprio</a>
<a name="ln1513">              ? hl_combine_attr(cul_attr, multi_attr)</a>
<a name="ln1514">              : hl_combine_attr(multi_attr, cul_attr);</a>
<a name="ln1515">          }</a>
<a name="ln1516"> </a>
<a name="ln1517">          // put the pointer back to output the double-width</a>
<a name="ln1518">          // character at the start of the next line.</a>
<a name="ln1519">          n_extra++;</a>
<a name="ln1520">          p_extra--;</a>
<a name="ln1521">        } else {</a>
<a name="ln1522">          n_extra -= mb_l - 1;</a>
<a name="ln1523">          p_extra += mb_l - 1;</a>
<a name="ln1524">        }</a>
<a name="ln1525">        p_extra++;</a>
<a name="ln1526">      }</a>
<a name="ln1527">      n_extra--;</a>
<a name="ln1528">    } else if (foldinfo.fi_lines &gt; 0) {</a>
<a name="ln1529">      // skip writing the buffer line itself</a>
<a name="ln1530">      c = NUL;</a>
<a name="ln1531">      XFREE_CLEAR(p_extra_free);</a>
<a name="ln1532">    } else {</a>
<a name="ln1533">      int c0;</a>
<a name="ln1534"> </a>
<a name="ln1535">      XFREE_CLEAR(p_extra_free);</a>
<a name="ln1536"> </a>
<a name="ln1537">      // Get a character from the line itself.</a>
<a name="ln1538">      c0 = c = *ptr;</a>
<a name="ln1539">      mb_c = c;</a>
<a name="ln1540">      // If the UTF-8 character is more than one byte: Decode it</a>
<a name="ln1541">      // into &quot;mb_c&quot;.</a>
<a name="ln1542">      mb_l = utfc_ptr2len((char *)ptr);</a>
<a name="ln1543">      mb_utf8 = false;</a>
<a name="ln1544">      if (mb_l &gt; 1) {</a>
<a name="ln1545">        mb_c = utfc_ptr2char((char *)ptr, u8cc);</a>
<a name="ln1546">        // Overlong encoded ASCII or ASCII with composing char</a>
<a name="ln1547">        // is displayed normally, except a NUL.</a>
<a name="ln1548">        if (mb_c &lt; 0x80) {</a>
<a name="ln1549">          c0 = c = mb_c;</a>
<a name="ln1550">        }</a>
<a name="ln1551">        mb_utf8 = true;</a>
<a name="ln1552"> </a>
<a name="ln1553">        // At start of the line we can have a composing char.</a>
<a name="ln1554">        // Draw it as a space with a composing char.</a>
<a name="ln1555">        if (utf_iscomposing(mb_c)) {</a>
<a name="ln1556">          int i;</a>
<a name="ln1557"> </a>
<a name="ln1558">          for (i = MAX_MCO - 1; i &gt; 0; i--) {</a>
<a name="ln1559">            u8cc[i] = u8cc[i - 1];</a>
<a name="ln1560">          }</a>
<a name="ln1561">          u8cc[0] = mb_c;</a>
<a name="ln1562">          mb_c = ' ';</a>
<a name="ln1563">        }</a>
<a name="ln1564">      }</a>
<a name="ln1565"> </a>
<a name="ln1566">      if ((mb_l == 1 &amp;&amp; c &gt;= 0x80)</a>
<a name="ln1567">          || (mb_l &gt;= 1 &amp;&amp; mb_c == 0)</a>
<a name="ln1568">          || (mb_l &gt; 1 &amp;&amp; (!vim_isprintc(mb_c)))) {</a>
<a name="ln1569">        // Illegal UTF-8 byte: display as &lt;xx&gt;.</a>
<a name="ln1570">        // Non-BMP character : display as ? or fullwidth ?.</a>
<a name="ln1571">        transchar_hex((char *)extra, mb_c);</a>
<a name="ln1572">        if (wp-&gt;w_p_rl) {  // reverse</a>
<a name="ln1573">          rl_mirror(extra);</a>
<a name="ln1574">        }</a>
<a name="ln1575"> </a>
<a name="ln1576">        p_extra = extra;</a>
<a name="ln1577">        c = *p_extra;</a>
<a name="ln1578">        mb_c = mb_ptr2char_adv((const char_u **)&amp;p_extra);</a>
<a name="ln1579">        mb_utf8 = (c &gt;= 0x80);</a>
<a name="ln1580">        n_extra = (int)STRLEN(p_extra);</a>
<a name="ln1581">        c_extra = NUL;</a>
<a name="ln1582">        c_final = NUL;</a>
<a name="ln1583">        if (area_attr == 0 &amp;&amp; search_attr == 0) {</a>
<a name="ln1584">          n_attr = n_extra + 1;</a>
<a name="ln1585">          extra_attr = win_hl_attr(wp, HLF_8);</a>
<a name="ln1586">          saved_attr2 = char_attr;               // save current attr</a>
<a name="ln1587">        }</a>
<a name="ln1588">      } else if (mb_l == 0) {        // at the NUL at end-of-line</a>
<a name="ln1589">        mb_l = 1;</a>
<a name="ln1590">      } else if (p_arshape &amp;&amp; !p_tbidi &amp;&amp; ARABIC_CHAR(mb_c)) {</a>
<a name="ln1591">        // Do Arabic shaping.</a>
<a name="ln1592">        int pc, pc1, nc;</a>
<a name="ln1593">        int pcc[MAX_MCO];</a>
<a name="ln1594"> </a>
<a name="ln1595">        // The idea of what is the previous and next</a>
<a name="ln1596">        // character depends on 'rightleft'.</a>
<a name="ln1597">        if (wp-&gt;w_p_rl) {</a>
<a name="ln1598">          pc = prev_c;</a>
<a name="ln1599">          pc1 = prev_c1;</a>
<a name="ln1600">          nc = utf_ptr2char((char *)ptr + mb_l);</a>
<a name="ln1601">          prev_c1 = u8cc[0];</a>
<a name="ln1602">        } else {</a>
<a name="ln1603">          pc = utfc_ptr2char((char *)ptr + mb_l, pcc);</a>
<a name="ln1604">          nc = prev_c;</a>
<a name="ln1605">          pc1 = pcc[0];</a>
<a name="ln1606">        }</a>
<a name="ln1607">        prev_c = mb_c;</a>
<a name="ln1608"> </a>
<a name="ln1609">        mb_c = arabic_shape(mb_c, &amp;c, &amp;u8cc[0], pc, pc1, nc);</a>
<a name="ln1610">      } else {</a>
<a name="ln1611">        prev_c = mb_c;</a>
<a name="ln1612">      }</a>
<a name="ln1613">      // If a double-width char doesn't fit display a '&gt;' in the</a>
<a name="ln1614">      // last column; the character is displayed at the start of the</a>
<a name="ln1615">      // next line.</a>
<a name="ln1616">      if ((wp-&gt;w_p_rl ? (col &lt;= 0) :</a>
<a name="ln1617">           (col &gt;= grid-&gt;cols - 1))</a>
<a name="ln1618">          &amp;&amp; utf_char2cells(mb_c) == 2) {</a>
<a name="ln1619">        c = '&gt;';</a>
<a name="ln1620">        mb_c = c;</a>
<a name="ln1621">        mb_utf8 = false;</a>
<a name="ln1622">        mb_l = 1;</a>
<a name="ln1623">        multi_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln1624">        // Put pointer back so that the character will be</a>
<a name="ln1625">        // displayed at the start of the next line.</a>
<a name="ln1626">        ptr--;</a>
<a name="ln1627">        did_decrement_ptr = true;</a>
<a name="ln1628">      } else if (*ptr != NUL) {</a>
<a name="ln1629">        ptr += mb_l - 1;</a>
<a name="ln1630">      }</a>
<a name="ln1631"> </a>
<a name="ln1632">      // If a double-width char doesn't fit at the left side display a '&lt;' in</a>
<a name="ln1633">      // the first column.  Don't do this for unprintable characters.</a>
<a name="ln1634">      if (n_skip &gt; 0 &amp;&amp; mb_l &gt; 1 &amp;&amp; n_extra == 0) {</a>
<a name="ln1635">        n_extra = 1;</a>
<a name="ln1636">        c_extra = MB_FILLER_CHAR;</a>
<a name="ln1637">        c_final = NUL;</a>
<a name="ln1638">        c = ' ';</a>
<a name="ln1639">        if (area_attr == 0 &amp;&amp; search_attr == 0) {</a>
<a name="ln1640">          n_attr = n_extra + 1;</a>
<a name="ln1641">          extra_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln1642">          saved_attr2 = char_attr;             // save current attr</a>
<a name="ln1643">        }</a>
<a name="ln1644">        mb_c = c;</a>
<a name="ln1645">        mb_utf8 = false;</a>
<a name="ln1646">        mb_l = 1;</a>
<a name="ln1647">      }</a>
<a name="ln1648">      ptr++;</a>
<a name="ln1649"> </a>
<a name="ln1650">      if (extra_check) {</a>
<a name="ln1651">        bool no_plain_buffer = (wp-&gt;w_s-&gt;b_p_spo_flags &amp; SPO_NPBUFFER) != 0;</a>
<a name="ln1652">        bool can_spell = !no_plain_buffer;</a>
<a name="ln1653"> </a>
<a name="ln1654">        // Get syntax attribute, unless still at the start of the line</a>
<a name="ln1655">        // (double-wide char that doesn't fit).</a>
<a name="ln1656">        v = (ptr - line);</a>
<a name="ln1657">        if (has_syntax &amp;&amp; v &gt; 0) {</a>
<a name="ln1658">          // Get the syntax attribute for the character.  If there</a>
<a name="ln1659">          // is an error, disable syntax highlighting.</a>
<a name="ln1660">          save_did_emsg = did_emsg;</a>
<a name="ln1661">          did_emsg = false;</a>
<a name="ln1662"> </a>
<a name="ln1663">          syntax_attr = get_syntax_attr((colnr_T)v - 1,</a>
<a name="ln1664">                                        has_spell ? &amp;can_spell : NULL, false);</a>
<a name="ln1665"> </a>
<a name="ln1666">          if (did_emsg) {</a>
<a name="ln1667">            wp-&gt;w_s-&gt;b_syn_error = true;</a>
<a name="ln1668">            has_syntax = false;</a>
<a name="ln1669">          } else {</a>
<a name="ln1670">            did_emsg = save_did_emsg;</a>
<a name="ln1671">          }</a>
<a name="ln1672"> </a>
<a name="ln1673">          if (wp-&gt;w_s-&gt;b_syn_slow) {</a>
<a name="ln1674">            has_syntax = false;</a>
<a name="ln1675">          }</a>
<a name="ln1676"> </a>
<a name="ln1677">          // Need to get the line again, a multi-line regexp may</a>
<a name="ln1678">          // have made it invalid.</a>
<a name="ln1679">          line = (char_u *)ml_get_buf(wp-&gt;w_buffer, lnum, false);</a>
<a name="ln1680">          ptr = line + v;</a>
<a name="ln1681"> </a>
<a name="ln1682">          if (!attr_pri) {</a>
<a name="ln1683">            if (cul_attr) {</a>
<a name="ln1684">              char_attr = 0 != line_attr_lowprio</a>
<a name="ln1685">                ? hl_combine_attr(cul_attr, syntax_attr)</a>
<a name="ln1686">                : hl_combine_attr(syntax_attr, cul_attr);</a>
<a name="ln1687">            } else {</a>
<a name="ln1688">              char_attr = syntax_attr;</a>
<a name="ln1689">            }</a>
<a name="ln1690">          } else {</a>
<a name="ln1691">            char_attr = hl_combine_attr(syntax_attr, char_attr);</a>
<a name="ln1692">          }</a>
<a name="ln1693">          // no concealing past the end of the line, it interferes</a>
<a name="ln1694">          // with line highlighting.</a>
<a name="ln1695">          if (c == NUL) {</a>
<a name="ln1696">            syntax_flags = 0;</a>
<a name="ln1697">          } else {</a>
<a name="ln1698">            syntax_flags = get_syntax_info(&amp;syntax_seqnr);</a>
<a name="ln1699">          }</a>
<a name="ln1700">        } else if (!attr_pri) {</a>
<a name="ln1701">          char_attr = 0;</a>
<a name="ln1702">        }</a>
<a name="ln1703"> </a>
<a name="ln1704">        if (has_decor &amp;&amp; v &gt; 0) {</a>
<a name="ln1705">          bool selected = (area_active || (area_highlighting &amp;&amp; noinvcur</a>
<a name="ln1706">                                           &amp;&amp; (colnr_T)vcol == wp-&gt;w_virtcol));</a>
<a name="ln1707">          int extmark_attr = decor_redraw_col(wp-&gt;w_buffer, (colnr_T)v - 1, off,</a>
<a name="ln1708">                                              selected, &amp;decor_state);</a>
<a name="ln1709">          if (extmark_attr != 0) {</a>
<a name="ln1710">            if (!attr_pri) {</a>
<a name="ln1711">              char_attr = hl_combine_attr(char_attr, extmark_attr);</a>
<a name="ln1712">            } else {</a>
<a name="ln1713">              char_attr = hl_combine_attr(extmark_attr, char_attr);</a>
<a name="ln1714">            }</a>
<a name="ln1715">          }</a>
<a name="ln1716"> </a>
<a name="ln1717">          decor_conceal = decor_state.conceal;</a>
<a name="ln1718">          if (decor_conceal &amp;&amp; decor_state.conceal_char) {</a>
<a name="ln1719">            decor_conceal = 2;  // really??</a>
<a name="ln1720">          }</a>
<a name="ln1721"> </a>
<a name="ln1722">          if (decor_state.spell) {</a>
<a name="ln1723">            can_spell = true;</a>
<a name="ln1724">          }</a>
<a name="ln1725">        }</a>
<a name="ln1726"> </a>
<a name="ln1727">        // Check spelling (unless at the end of the line).</a>
<a name="ln1728">        // Only do this when there is no syntax highlighting, the</a>
<a name="ln1729">        // @Spell cluster is not used or the current syntax item</a>
<a name="ln1730">        // contains the @Spell cluster.</a>
<a name="ln1731">        v = (ptr - line);</a>
<a name="ln1732">        if (has_spell &amp;&amp; v &gt;= word_end &amp;&amp; v &gt; cur_checked_col) {</a>
<a name="ln1733">          spell_attr = 0;</a>
<a name="ln1734">          if (!attr_pri) {</a>
<a name="ln1735">            char_attr = hl_combine_attr(char_attr, syntax_attr);</a>
<a name="ln1736">          }</a>
<a name="ln1737">          if (c != 0 &amp;&amp; ((!has_syntax &amp;&amp; !no_plain_buffer) || can_spell)) {</a>
<a name="ln1738">            char_u *prev_ptr;</a>
<a name="ln1739">            char_u *p;</a>
<a name="ln1740">            int len;</a>
<a name="ln1741">            hlf_T spell_hlf = HLF_COUNT;</a>
<a name="ln1742">            prev_ptr = ptr - mb_l;</a>
<a name="ln1743">            v -= mb_l - 1;</a>
<a name="ln1744"> </a>
<a name="ln1745">            // Use nextline[] if possible, it has the start of the</a>
<a name="ln1746">            // next line concatenated.</a>
<a name="ln1747">            if ((prev_ptr - line) - nextlinecol &gt;= 0) {</a>
<a name="ln1748">              p = nextline + ((prev_ptr - line) - nextlinecol);</a>
<a name="ln1749">            } else {</a>
<a name="ln1750">              p = prev_ptr;</a>
<a name="ln1751">            }</a>
<a name="ln1752">            cap_col -= (int)(prev_ptr - line);</a>
<a name="ln1753">            size_t tmplen = spell_check(wp, p, &amp;spell_hlf, &amp;cap_col, nochange);</a>
<a name="ln1754">            assert(tmplen &lt;= INT_MAX);</a>
<a name="ln1755">            len = (int)tmplen;</a>
<a name="ln1756">            word_end = (int)v + len;</a>
<a name="ln1757"> </a>
<a name="ln1758">            // In Insert mode only highlight a word that</a>
<a name="ln1759">            // doesn't touch the cursor.</a>
<a name="ln1760">            if (spell_hlf != HLF_COUNT</a>
<a name="ln1761">                &amp;&amp; (State &amp; MODE_INSERT)</a>
<a name="ln1762">                &amp;&amp; wp-&gt;w_cursor.lnum == lnum</a>
<a name="ln1763">                &amp;&amp; wp-&gt;w_cursor.col &gt;=</a>
<a name="ln1764">                (colnr_T)(prev_ptr - line)</a>
<a name="ln1765">                &amp;&amp; wp-&gt;w_cursor.col &lt; (colnr_T)word_end) {</a>
<a name="ln1766">              spell_hlf = HLF_COUNT;</a>
<a name="ln1767">              spell_redraw_lnum = lnum;</a>
<a name="ln1768">            }</a>
<a name="ln1769"> </a>
<a name="ln1770">            if (spell_hlf == HLF_COUNT &amp;&amp; p != prev_ptr</a>
<a name="ln1771">                &amp;&amp; (p - nextline) + len &gt; nextline_idx) {</a>
<a name="ln1772">              // Remember that the good word continues at the</a>
<a name="ln1773">              // start of the next line.</a>
<a name="ln1774">              checked_lnum = lnum + 1;</a>
<a name="ln1775">              checked_col = (int)((p - nextline) + len - nextline_idx);</a>
<a name="ln1776">            }</a>
<a name="ln1777"> </a>
<a name="ln1778">            // Turn index into actual attributes.</a>
<a name="ln1779">            if (spell_hlf != HLF_COUNT) {</a>
<a name="ln1780">              spell_attr = highlight_attr[spell_hlf];</a>
<a name="ln1781">            }</a>
<a name="ln1782"> </a>
<a name="ln1783">            if (cap_col &gt; 0) {</a>
<a name="ln1784">              if (p != prev_ptr</a>
<a name="ln1785">                  &amp;&amp; (p - nextline) + cap_col &gt;= nextline_idx) {</a>
<a name="ln1786">                // Remember that the word in the next line</a>
<a name="ln1787">                // must start with a capital.</a>
<a name="ln1788">                capcol_lnum = lnum + 1;</a>
<a name="ln1789">                cap_col = (int)((p - nextline) + cap_col</a>
<a name="ln1790">                                - nextline_idx);</a>
<a name="ln1791">              } else {</a>
<a name="ln1792">                // Compute the actual column.</a>
<a name="ln1793">                cap_col += (int)(prev_ptr - line);</a>
<a name="ln1794">              }</a>
<a name="ln1795">            }</a>
<a name="ln1796">          }</a>
<a name="ln1797">        }</a>
<a name="ln1798">        if (spell_attr != 0) {</a>
<a name="ln1799">          if (!attr_pri) {</a>
<a name="ln1800">            char_attr = hl_combine_attr(char_attr, spell_attr);</a>
<a name="ln1801">          } else {</a>
<a name="ln1802">            char_attr = hl_combine_attr(spell_attr, char_attr);</a>
<a name="ln1803">          }</a>
<a name="ln1804">        }</a>
<a name="ln1805"> </a>
<a name="ln1806">        if (wp-&gt;w_buffer-&gt;terminal) {</a>
<a name="ln1807">          char_attr = hl_combine_attr(term_attrs[vcol], char_attr);</a>
<a name="ln1808">        }</a>
<a name="ln1809"> </a>
<a name="ln1810">        // Found last space before word: check for line break.</a>
<a name="ln1811">        if (wp-&gt;w_p_lbr &amp;&amp; c0 == c &amp;&amp; vim_isbreak(c)</a>
<a name="ln1812">            &amp;&amp; !vim_isbreak((int)(*ptr))) {</a>
<a name="ln1813">          int mb_off = utf_head_off((char *)line, (char *)ptr - 1);</a>
<a name="ln1814">          char_u *p = ptr - (mb_off + 1);</a>
<a name="ln1815">          chartabsize_T cts;</a>
<a name="ln1816"> </a>
<a name="ln1817">          init_chartabsize_arg(&amp;cts, wp, lnum, (colnr_T)vcol, (char *)line, (char *)p);</a>
<a name="ln1818">          n_extra = win_lbr_chartabsize(&amp;cts, NULL) - 1;</a>
<a name="ln1819"> </a>
<a name="ln1820">          // We have just drawn the showbreak value, no need to add</a>
<a name="ln1821">          // space for it again.</a>
<a name="ln1822">          if (vcol == vcol_sbr) {</a>
<a name="ln1823">            n_extra -= mb_charlen(get_showbreak_value(wp));</a>
<a name="ln1824">            if (n_extra &lt; 0) {</a>
<a name="ln1825">              n_extra = 0;</a>
<a name="ln1826">            }</a>
<a name="ln1827">          }</a>
<a name="ln1828"> </a>
<a name="ln1829">          if (c == TAB &amp;&amp; n_extra + col &gt; grid-&gt;cols) {</a>
<a name="ln1830">            n_extra = tabstop_padding((colnr_T)vcol, wp-&gt;w_buffer-&gt;b_p_ts,</a>
<a name="ln1831">                                      wp-&gt;w_buffer-&gt;b_p_vts_array) - 1;</a>
<a name="ln1832">          }</a>
<a name="ln1833">          c_extra = mb_off &gt; 0 ? MB_FILLER_CHAR : ' ';</a>
<a name="ln1834">          c_final = NUL;</a>
<a name="ln1835">          if (ascii_iswhite(c)) {</a>
<a name="ln1836">            if (c == TAB) {</a>
<a name="ln1837">              // See &quot;Tab alignment&quot; below.</a>
<a name="ln1838">              FIX_FOR_BOGUSCOLS;</a>
<a name="ln1839">            }</a>
<a name="ln1840">            if (!wp-&gt;w_p_list) {</a>
<a name="ln1841">              c = ' ';</a>
<a name="ln1842">            }</a>
<a name="ln1843">          }</a>
<a name="ln1844">          clear_chartabsize_arg(&amp;cts);</a>
<a name="ln1845">        }</a>
<a name="ln1846"> </a>
<a name="ln1847">        in_multispace = c == ' ' &amp;&amp; ((ptr &gt; line + 1 &amp;&amp; ptr[-2] == ' ') || *ptr == ' ');</a>
<a name="ln1848">        if (!in_multispace) {</a>
<a name="ln1849">          multispace_pos = 0;</a>
<a name="ln1850">        }</a>
<a name="ln1851"> </a>
<a name="ln1852">        // 'list': Change char 160 to 'nbsp' and space to 'space'.</a>
<a name="ln1853">        // But not when the character is followed by a composing</a>
<a name="ln1854">        // character (use mb_l to check that).</a>
<a name="ln1855">        if (wp-&gt;w_p_list</a>
<a name="ln1856">            &amp;&amp; ((((c == 160 &amp;&amp; mb_l == 1)</a>
<a name="ln1857">                  || (mb_utf8</a>
<a name="ln1858">                      &amp;&amp; ((mb_c == 160 &amp;&amp; mb_l == 2)</a>
<a name="ln1859">                          || (mb_c == 0x202f &amp;&amp; mb_l == 3))))</a>
<a name="ln1860">                 &amp;&amp; wp-&gt;w_p_lcs_chars.nbsp)</a>
<a name="ln1861">                || (c == ' '</a>
<a name="ln1862">                    &amp;&amp; mb_l == 1</a>
<a name="ln1863">                    &amp;&amp; (wp-&gt;w_p_lcs_chars.space</a>
<a name="ln1864">                        || (in_multispace &amp;&amp; wp-&gt;w_p_lcs_chars.multispace != NULL))</a>
<a name="ln1865">                    &amp;&amp; ptr - line &gt;= leadcol</a>
<a name="ln1866">                    &amp;&amp; ptr - line &lt;= trailcol))) {</a>
<a name="ln1867">          if (in_multispace &amp;&amp; wp-&gt;w_p_lcs_chars.multispace != NULL) {</a>
<a name="ln1868">            c = wp-&gt;w_p_lcs_chars.multispace[multispace_pos++];</a>
<a name="ln1869">            if (wp-&gt;w_p_lcs_chars.multispace[multispace_pos] == NUL) {</a>
<a name="ln1870">              multispace_pos = 0;</a>
<a name="ln1871">            }</a>
<a name="ln1872">          } else {</a>
<a name="ln1873">            c = (c == ' ') ? wp-&gt;w_p_lcs_chars.space : wp-&gt;w_p_lcs_chars.nbsp;</a>
<a name="ln1874">          }</a>
<a name="ln1875">          n_attr = 1;</a>
<a name="ln1876">          extra_attr = win_hl_attr(wp, HLF_0);</a>
<a name="ln1877">          saved_attr2 = char_attr;  // save current attr</a>
<a name="ln1878">          mb_c = c;</a>
<a name="ln1879">          mb_utf8 = check_mb_utf8(&amp;c, u8cc);</a>
<a name="ln1880">        }</a>
<a name="ln1881"> </a>
<a name="ln1882">        if (c == ' ' &amp;&amp; ((trailcol != MAXCOL &amp;&amp; ptr &gt; line + trailcol)</a>
<a name="ln1883">                         || (leadcol != 0 &amp;&amp; ptr &lt; line + leadcol))) {</a>
<a name="ln1884">          if (leadcol != 0 &amp;&amp; in_multispace &amp;&amp; ptr &lt; line + leadcol</a>
<a name="ln1885">              &amp;&amp; wp-&gt;w_p_lcs_chars.leadmultispace != NULL) {</a>
<a name="ln1886">            c = wp-&gt;w_p_lcs_chars.leadmultispace[multispace_pos++];</a>
<a name="ln1887">            if (wp-&gt;w_p_lcs_chars.leadmultispace[multispace_pos] == NUL) {</a>
<a name="ln1888">              multispace_pos = 0;</a>
<a name="ln1889">            }</a>
<a name="ln1890">          } else if (ptr &gt; line + trailcol &amp;&amp; wp-&gt;w_p_lcs_chars.trail) {</a>
<a name="ln1891">            c = wp-&gt;w_p_lcs_chars.trail;</a>
<a name="ln1892">          } else if (ptr &lt; line + leadcol &amp;&amp; wp-&gt;w_p_lcs_chars.lead) {</a>
<a name="ln1893">            c = wp-&gt;w_p_lcs_chars.lead;</a>
<a name="ln1894">          } else if (leadcol != 0 &amp;&amp; wp-&gt;w_p_lcs_chars.space) {</a>
<a name="ln1895">            c = wp-&gt;w_p_lcs_chars.space;</a>
<a name="ln1896">          }</a>
<a name="ln1897"> </a>
<a name="ln1898">          n_attr = 1;</a>
<a name="ln1899">          extra_attr = win_hl_attr(wp, HLF_0);</a>
<a name="ln1900">          saved_attr2 = char_attr;  // save current attr</a>
<a name="ln1901">          mb_c = c;</a>
<a name="ln1902">          mb_utf8 = check_mb_utf8(&amp;c, u8cc);</a>
<a name="ln1903">        }</a>
<a name="ln1904">      }</a>
<a name="ln1905"> </a>
<a name="ln1906">      // Handling of non-printable characters.</a>
<a name="ln1907">      if (!vim_isprintc(c)) {</a>
<a name="ln1908">        // when getting a character from the file, we may have to</a>
<a name="ln1909">        // turn it into something else on the way to putting it on the screen.</a>
<a name="ln1910">        if (c == TAB &amp;&amp; (!wp-&gt;w_p_list || wp-&gt;w_p_lcs_chars.tab1)) {</a>
<a name="ln1911">          int tab_len = 0;</a>
<a name="ln1912">          long vcol_adjusted = vcol;  // removed showbreak length</a>
<a name="ln1913">          char_u *const sbr = get_showbreak_value(wp);</a>
<a name="ln1914"> </a>
<a name="ln1915">          // Only adjust the tab_len, when at the first column after the</a>
<a name="ln1916">          // showbreak value was drawn.</a>
<a name="ln1917">          if (*sbr != NUL &amp;&amp; vcol == vcol_sbr &amp;&amp; wp-&gt;w_p_wrap) {</a>
<a name="ln1918">            vcol_adjusted = vcol - mb_charlen(sbr);</a>
<a name="ln1919">          }</a>
<a name="ln1920">          // tab amount depends on current column</a>
<a name="ln1921">          tab_len = tabstop_padding((colnr_T)vcol_adjusted,</a>
<a name="ln1922">                                    wp-&gt;w_buffer-&gt;b_p_ts,</a>
<a name="ln1923">                                    wp-&gt;w_buffer-&gt;b_p_vts_array) - 1;</a>
<a name="ln1924"> </a>
<a name="ln1925">          if (!wp-&gt;w_p_lbr || !wp-&gt;w_p_list) {</a>
<a name="ln1926">            n_extra = tab_len;</a>
<a name="ln1927">          } else {</a>
<a name="ln1928">            char_u *p;</a>
<a name="ln1929">            int i;</a>
<a name="ln1930">            int saved_nextra = n_extra;</a>
<a name="ln1931"> </a>
<a name="ln1932">            if (vcol_off &gt; 0) {</a>
<a name="ln1933">              // there are characters to conceal</a>
<a name="ln1934">              tab_len += vcol_off;</a>
<a name="ln1935">            }</a>
<a name="ln1936">            // boguscols before FIX_FOR_BOGUSCOLS macro from above.</a>
<a name="ln1937">            if (wp-&gt;w_p_lcs_chars.tab1 &amp;&amp; old_boguscols &gt; 0</a>
<a name="ln1938">                &amp;&amp; n_extra &gt; tab_len) {</a>
<a name="ln1939">              tab_len += n_extra - tab_len;</a>
<a name="ln1940">            }</a>
<a name="ln1941"> </a>
<a name="ln1942">            // If n_extra &gt; 0, it gives the number of chars</a>
<a name="ln1943">            // to use for a tab, else we need to calculate the width</a>
<a name="ln1944">            // for a tab.</a>
<a name="ln1945">            int len = (tab_len * utf_char2len(wp-&gt;w_p_lcs_chars.tab2));</a>
<a name="ln1946">            if (wp-&gt;w_p_lcs_chars.tab3) {</a>
<a name="ln1947">              len += utf_char2len(wp-&gt;w_p_lcs_chars.tab3);</a>
<a name="ln1948">            }</a>
<a name="ln1949">            if (n_extra &gt; 0) {</a>
<a name="ln1950">              len += n_extra - tab_len;</a>
<a name="ln1951">            }</a>
<a name="ln1952">            c = wp-&gt;w_p_lcs_chars.tab1;</a>
<a name="ln1953">            p = xmalloc((size_t)len + 1);</a>
<a name="ln1954">            memset(p, ' ', (size_t)len);</a>
<a name="ln1955">            p[len] = NUL;</a>
<a name="ln1956">            xfree(p_extra_free);</a>
<a name="ln1957">            p_extra_free = p;</a>
<a name="ln1958">            for (i = 0; i &lt; tab_len; i++) {</a>
<a name="ln1959">              if (*p == NUL) {</a>
<a name="ln1960">                tab_len = i;</a>
<a name="ln1961">                break;</a>
<a name="ln1962">              }</a>
<a name="ln1963">              int lcs = wp-&gt;w_p_lcs_chars.tab2;</a>
<a name="ln1964"> </a>
<a name="ln1965">              // if tab3 is given, use it for the last char</a>
<a name="ln1966">              if (wp-&gt;w_p_lcs_chars.tab3 &amp;&amp; i == tab_len - 1) {</a>
<a name="ln1967">                lcs = wp-&gt;w_p_lcs_chars.tab3;</a>
<a name="ln1968">              }</a>
<a name="ln1969">              p += utf_char2bytes(lcs, (char *)p);</a>
<a name="ln1970">              n_extra += utf_char2len(lcs) - (saved_nextra &gt; 0 ? 1 : 0);</a>
<a name="ln1971">            }</a>
<a name="ln1972">            p_extra = p_extra_free;</a>
<a name="ln1973"> </a>
<a name="ln1974">            // n_extra will be increased by FIX_FOX_BOGUSCOLS</a>
<a name="ln1975">            // macro below, so need to adjust for that here</a>
<a name="ln1976">            if (vcol_off &gt; 0) {</a>
<a name="ln1977">              n_extra -= vcol_off;</a>
<a name="ln1978">            }</a>
<a name="ln1979">          }</a>
<a name="ln1980"> </a>
<a name="ln1981">          {</a>
<a name="ln1982">            int vc_saved = vcol_off;</a>
<a name="ln1983"> </a>
<a name="ln1984">            // Tab alignment should be identical regardless of</a>
<a name="ln1985">            // 'conceallevel' value. So tab compensates of all</a>
<a name="ln1986">            // previous concealed characters, and thus resets</a>
<a name="ln1987">            // vcol_off and boguscols accumulated so far in the</a>
<a name="ln1988">            // line. Note that the tab can be longer than</a>
<a name="ln1989">            // 'tabstop' when there are concealed characters.</a>
<a name="ln1990">            FIX_FOR_BOGUSCOLS;</a>
<a name="ln1991"> </a>
<a name="ln1992">            // Make sure, the highlighting for the tab char will be</a>
<a name="ln1993">            // correctly set further below (effectively reverts the</a>
<a name="ln1994">            // FIX_FOR_BOGSUCOLS macro).</a>
<a name="ln1995">            if (n_extra == tab_len + vc_saved &amp;&amp; wp-&gt;w_p_list</a>
<a name="ln1996">                &amp;&amp; wp-&gt;w_p_lcs_chars.tab1) {</a>
<a name="ln1997">              tab_len += vc_saved;</a>
<a name="ln1998">            }</a>
<a name="ln1999">          }</a>
<a name="ln2000"> </a>
<a name="ln2001">          mb_utf8 = false;  // don't draw as UTF-8</a>
<a name="ln2002">          if (wp-&gt;w_p_list) {</a>
<a name="ln2003">            c = (n_extra == 0 &amp;&amp; wp-&gt;w_p_lcs_chars.tab3)</a>
<a name="ln2004">                 ? wp-&gt;w_p_lcs_chars.tab3</a>
<a name="ln2005">                 : wp-&gt;w_p_lcs_chars.tab1;</a>
<a name="ln2006">            if (wp-&gt;w_p_lbr) {</a>
<a name="ln2007">              c_extra = NUL;  // using p_extra from above</a>
<a name="ln2008">            } else {</a>
<a name="ln2009">              c_extra = wp-&gt;w_p_lcs_chars.tab2;</a>
<a name="ln2010">            }</a>
<a name="ln2011">            c_final = wp-&gt;w_p_lcs_chars.tab3;</a>
<a name="ln2012">            n_attr = tab_len + 1;</a>
<a name="ln2013">            extra_attr = win_hl_attr(wp, HLF_0);</a>
<a name="ln2014">            saved_attr2 = char_attr;  // save current attr</a>
<a name="ln2015">            mb_c = c;</a>
<a name="ln2016">            mb_utf8 = check_mb_utf8(&amp;c, u8cc);</a>
<a name="ln2017">          } else {</a>
<a name="ln2018">            c_final = NUL;</a>
<a name="ln2019">            c_extra = ' ';</a>
<a name="ln2020">            c = ' ';</a>
<a name="ln2021">          }</a>
<a name="ln2022">        } else if (c == NUL</a>
<a name="ln2023">                   &amp;&amp; (wp-&gt;w_p_list</a>
<a name="ln2024">                       || ((fromcol &gt;= 0 || fromcol_prev &gt;= 0)</a>
<a name="ln2025">                           &amp;&amp; tocol &gt; vcol</a>
<a name="ln2026">                           &amp;&amp; VIsual_mode != Ctrl_V</a>
<a name="ln2027">                           &amp;&amp; (wp-&gt;w_p_rl ? (col &gt;= 0) : (col &lt; grid-&gt;cols))</a>
<a name="ln2028">                           &amp;&amp; !(noinvcur</a>
<a name="ln2029">                                &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln2030">                                &amp;&amp; (colnr_T)vcol == wp-&gt;w_virtcol)))</a>
<a name="ln2031">                   &amp;&amp; lcs_eol_one &gt; 0) {</a>
<a name="ln2032">          // Display a '$' after the line or highlight an extra</a>
<a name="ln2033">          // character if the line break is included.</a>
<a name="ln2034">          // For a diff line the highlighting continues after the &quot;$&quot;.</a>
<a name="ln2035">          if (diff_hlf == (hlf_T)0</a>
<a name="ln2036">              &amp;&amp; line_attr == 0</a>
<a name="ln2037">              &amp;&amp; line_attr_lowprio == 0) {</a>
<a name="ln2038">            // In virtualedit, visual selections may extend beyond end of line</a>
<a name="ln2039">            if (area_highlighting &amp;&amp; virtual_active()</a>
<a name="ln2040">                &amp;&amp; tocol != MAXCOL &amp;&amp; vcol &lt; tocol) {</a>
<a name="ln2041">              n_extra = 0;</a>
<a name="ln2042">            } else {</a>
<a name="ln2043">              p_extra = at_end_str;</a>
<a name="ln2044">              n_extra = 1;</a>
<a name="ln2045">              c_extra = NUL;</a>
<a name="ln2046">              c_final = NUL;</a>
<a name="ln2047">            }</a>
<a name="ln2048">          }</a>
<a name="ln2049">          if (wp-&gt;w_p_list &amp;&amp; wp-&gt;w_p_lcs_chars.eol &gt; 0) {</a>
<a name="ln2050">            c = wp-&gt;w_p_lcs_chars.eol;</a>
<a name="ln2051">          } else {</a>
<a name="ln2052">            c = ' ';</a>
<a name="ln2053">          }</a>
<a name="ln2054">          lcs_eol_one = -1;</a>
<a name="ln2055">          ptr--;  // put it back at the NUL</a>
<a name="ln2056">          extra_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln2057">          n_attr = 1;</a>
<a name="ln2058">          mb_c = c;</a>
<a name="ln2059">          mb_utf8 = check_mb_utf8(&amp;c, u8cc);</a>
<a name="ln2060">        } else if (c != NUL) {</a>
<a name="ln2061">          p_extra = transchar_buf(wp-&gt;w_buffer, c);</a>
<a name="ln2062">          if (n_extra == 0) {</a>
<a name="ln2063">            n_extra = byte2cells(c) - 1;</a>
<a name="ln2064">          }</a>
<a name="ln2065">          if ((dy_flags &amp; DY_UHEX) &amp;&amp; wp-&gt;w_p_rl) {</a>
<a name="ln2066">            rl_mirror(p_extra);                 // reverse &quot;&lt;12&gt;&quot;</a>
<a name="ln2067">          }</a>
<a name="ln2068">          c_extra = NUL;</a>
<a name="ln2069">          c_final = NUL;</a>
<a name="ln2070">          if (wp-&gt;w_p_lbr) {</a>
<a name="ln2071">            char_u *p;</a>
<a name="ln2072"> </a>
<a name="ln2073">            c = *p_extra;</a>
<a name="ln2074">            p = xmalloc((size_t)n_extra + 1);</a>
<a name="ln2075">            memset(p, ' ', (size_t)n_extra);</a>
<a name="ln2076">            STRNCPY(p, p_extra + 1, STRLEN(p_extra) - 1);  // NOLINT(runtime/printf)</a>
<a name="ln2077">            p[n_extra] = NUL;</a>
<a name="ln2078">            xfree(p_extra_free);</a>
<a name="ln2079">            p_extra_free = p_extra = p;</a>
<a name="ln2080">          } else {</a>
<a name="ln2081">            n_extra = byte2cells(c) - 1;</a>
<a name="ln2082">            c = *p_extra++;</a>
<a name="ln2083">          }</a>
<a name="ln2084">          n_attr = n_extra + 1;</a>
<a name="ln2085">          extra_attr = win_hl_attr(wp, HLF_8);</a>
<a name="ln2086">          saved_attr2 = char_attr;  // save current attr</a>
<a name="ln2087">          mb_utf8 = false;   // don't draw as UTF-8</a>
<a name="ln2088">        } else if (VIsual_active</a>
<a name="ln2089">                   &amp;&amp; (VIsual_mode == Ctrl_V || VIsual_mode == 'v')</a>
<a name="ln2090">                   &amp;&amp; virtual_active()</a>
<a name="ln2091">                   &amp;&amp; tocol != MAXCOL</a>
<a name="ln2092">                   &amp;&amp; vcol &lt; tocol</a>
<a name="ln2093">                   &amp;&amp; (wp-&gt;w_p_rl ? (col &gt;= 0) : (col &lt; grid-&gt;cols))) {</a>
<a name="ln2094">          c = ' ';</a>
<a name="ln2095">          ptr--;  // put it back at the NUL</a>
<a name="ln2096">        }</a>
<a name="ln2097">      }</a>
<a name="ln2098"> </a>
<a name="ln2099">      if (wp-&gt;w_p_cole &gt; 0</a>
<a name="ln2100">          &amp;&amp; (wp != curwin || lnum != wp-&gt;w_cursor.lnum || conceal_cursor_line(wp))</a>
<a name="ln2101">          &amp;&amp; ((syntax_flags &amp; HL_CONCEAL) != 0 || has_match_conc &gt; 0 || decor_conceal &gt; 0)</a>
<a name="ln2102">          &amp;&amp; !(lnum_in_visual_area &amp;&amp; vim_strchr(wp-&gt;w_p_cocu, 'v') == NULL)) {</a>
<a name="ln2103">        char_attr = conceal_attr;</a>
<a name="ln2104">        if (((prev_syntax_id != syntax_seqnr &amp;&amp; (syntax_flags &amp; HL_CONCEAL) != 0)</a>
<a name="ln2105">             || has_match_conc &gt; 1 || decor_conceal &gt; 1)</a>
<a name="ln2106">            &amp;&amp; (syn_get_sub_char() != NUL</a>
<a name="ln2107">                || (has_match_conc &amp;&amp; match_conc)</a>
<a name="ln2108">                || (decor_conceal &amp;&amp; decor_state.conceal_char)</a>
<a name="ln2109">                || wp-&gt;w_p_cole == 1)</a>
<a name="ln2110">            &amp;&amp; wp-&gt;w_p_cole != 3) {</a>
<a name="ln2111">          // First time at this concealed item: display one</a>
<a name="ln2112">          // character.</a>
<a name="ln2113">          if (has_match_conc &amp;&amp; match_conc) {</a>
<a name="ln2114">            c = match_conc;</a>
<a name="ln2115">          } else if (decor_conceal &amp;&amp; decor_state.conceal_char) {</a>
<a name="ln2116">            c = decor_state.conceal_char;</a>
<a name="ln2117">            if (decor_state.conceal_attr) {</a>
<a name="ln2118">              char_attr = decor_state.conceal_attr;</a>
<a name="ln2119">            }</a>
<a name="ln2120">          } else if (syn_get_sub_char() != NUL) {</a>
<a name="ln2121">            c = syn_get_sub_char();</a>
<a name="ln2122">          } else if (wp-&gt;w_p_lcs_chars.conceal != NUL) {</a>
<a name="ln2123">            c = wp-&gt;w_p_lcs_chars.conceal;</a>
<a name="ln2124">          } else {</a>
<a name="ln2125">            c = ' ';</a>
<a name="ln2126">          }</a>
<a name="ln2127"> </a>
<a name="ln2128">          prev_syntax_id = syntax_seqnr;</a>
<a name="ln2129"> </a>
<a name="ln2130">          if (n_extra &gt; 0) {</a>
<a name="ln2131">            vcol_off += n_extra;</a>
<a name="ln2132">          }</a>
<a name="ln2133">          vcol += n_extra;</a>
<a name="ln2134">          if (wp-&gt;w_p_wrap &amp;&amp; n_extra &gt; 0) {</a>
<a name="ln2135">            if (wp-&gt;w_p_rl) {</a>
<a name="ln2136">              col -= n_extra;</a>
<a name="ln2137">              boguscols -= n_extra;</a>
<a name="ln2138">            } else {</a>
<a name="ln2139">              boguscols += n_extra;</a>
<a name="ln2140">              col += n_extra;</a>
<a name="ln2141">            }</a>
<a name="ln2142">          }</a>
<a name="ln2143">          n_extra = 0;</a>
<a name="ln2144">          n_attr = 0;</a>
<a name="ln2145">        } else if (n_skip == 0) {</a>
<a name="ln2146">          is_concealing = true;</a>
<a name="ln2147">          n_skip = 1;</a>
<a name="ln2148">        }</a>
<a name="ln2149">        mb_c = c;</a>
<a name="ln2150">        mb_utf8 = check_mb_utf8(&amp;c, u8cc);</a>
<a name="ln2151">      } else {</a>
<a name="ln2152">        prev_syntax_id = 0;</a>
<a name="ln2153">        is_concealing = false;</a>
<a name="ln2154">      }</a>
<a name="ln2155"> </a>
<a name="ln2156">      if (n_skip &gt; 0 &amp;&amp; did_decrement_ptr) {</a>
<a name="ln2157">        // not showing the '&gt;', put pointer back to avoid getting stuck</a>
<a name="ln2158">        ptr++;</a>
<a name="ln2159">      }</a>
<a name="ln2160">    }  // end of printing from buffer content</a>
<a name="ln2161"> </a>
<a name="ln2162">    // In the cursor line and we may be concealing characters: correct</a>
<a name="ln2163">    // the cursor column when we reach its position.</a>
<a name="ln2164">    if (!did_wcol &amp;&amp; draw_state == WL_LINE</a>
<a name="ln2165">        &amp;&amp; wp == curwin &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln2166">        &amp;&amp; conceal_cursor_line(wp)</a>
<a name="ln2167">        &amp;&amp; (int)wp-&gt;w_virtcol &lt;= vcol + n_skip) {</a>
<a name="ln2168">      if (wp-&gt;w_p_rl) {</a>
<a name="ln2169">        wp-&gt;w_wcol = grid-&gt;cols - col + boguscols - 1;</a>
<a name="ln2170">      } else {</a>
<a name="ln2171">        wp-&gt;w_wcol = col - boguscols;</a>
<a name="ln2172">      }</a>
<a name="ln2173">      wp-&gt;w_wrow = row;</a>
<a name="ln2174">      did_wcol = true;</a>
<a name="ln2175">      wp-&gt;w_valid |= VALID_WCOL|VALID_WROW|VALID_VIRTCOL;</a>
<a name="ln2176">    }</a>
<a name="ln2177"> </a>
<a name="ln2178">    // Don't override visual selection highlighting.</a>
<a name="ln2179">    if (n_attr &gt; 0 &amp;&amp; draw_state == WL_LINE &amp;&amp; !search_attr_from_match) {</a>
<a name="ln2180">      char_attr = hl_combine_attr(char_attr, extra_attr);</a>
<a name="ln2181">    }</a>
<a name="ln2182"> </a>
<a name="ln2183">    // Handle the case where we are in column 0 but not on the first</a>
<a name="ln2184">    // character of the line and the user wants us to show us a</a>
<a name="ln2185">    // special character (via 'listchars' option &quot;precedes:&lt;char&gt;&quot;.</a>
<a name="ln2186">    if (lcs_prec_todo != NUL</a>
<a name="ln2187">        &amp;&amp; wp-&gt;w_p_list</a>
<a name="ln2188">        &amp;&amp; (wp-&gt;w_p_wrap ? (wp-&gt;w_skipcol &gt; 0 &amp;&amp; row == 0) : wp-&gt;w_leftcol &gt; 0)</a>
<a name="ln2189">        &amp;&amp; filler_todo &lt;= 0</a>
<a name="ln2190">        &amp;&amp; draw_state &gt; WL_NR</a>
<a name="ln2191">        &amp;&amp; c != NUL) {</a>
<a name="ln2192">      c = wp-&gt;w_p_lcs_chars.prec;</a>
<a name="ln2193">      lcs_prec_todo = NUL;</a>
<a name="ln2194">      if (utf_char2cells(mb_c) &gt; 1) {</a>
<a name="ln2195">        // Double-width character being overwritten by the &quot;precedes&quot;</a>
<a name="ln2196">        // character, need to fill up half the character.</a>
<a name="ln2197">        c_extra = MB_FILLER_CHAR;</a>
<a name="ln2198">        c_final = NUL;</a>
<a name="ln2199">        n_extra = 1;</a>
<a name="ln2200">        n_attr = 2;</a>
<a name="ln2201">        extra_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln2202">      }</a>
<a name="ln2203">      mb_c = c;</a>
<a name="ln2204">      mb_utf8 = check_mb_utf8(&amp;c, u8cc);</a>
<a name="ln2205">      saved_attr3 = char_attr;  // save current attr</a>
<a name="ln2206">      char_attr = win_hl_attr(wp, HLF_AT);  // overwriting char_attr</a>
<a name="ln2207">      n_attr3 = 1;</a>
<a name="ln2208">    }</a>
<a name="ln2209"> </a>
<a name="ln2210">    // At end of the text line or just after the last character.</a>
<a name="ln2211">    if (c == NUL &amp;&amp; eol_hl_off == 0) {</a>
<a name="ln2212">      // flag to indicate whether prevcol equals startcol of search_hl or</a>
<a name="ln2213">      // one of the matches</a>
<a name="ln2214">      bool prevcol_hl_flag = get_prevcol_hl_flag(wp, &amp;screen_search_hl,</a>
<a name="ln2215">                                                 (long)(ptr - line) - 1);</a>
<a name="ln2216"> </a>
<a name="ln2217">      // Invert at least one char, used for Visual and empty line or</a>
<a name="ln2218">      // highlight match at end of line. If it's beyond the last</a>
<a name="ln2219">      // char on the screen, just overwrite that one (tricky!)  Not</a>
<a name="ln2220">      // needed when a '$' was displayed for 'list'.</a>
<a name="ln2221">      if (wp-&gt;w_p_lcs_chars.eol == lcs_eol_one</a>
<a name="ln2222">          &amp;&amp; ((area_attr != 0 &amp;&amp; vcol == fromcol</a>
<a name="ln2223">               &amp;&amp; (VIsual_mode != Ctrl_V</a>
<a name="ln2224">                   || lnum == VIsual.lnum</a>
<a name="ln2225">                   || lnum == curwin-&gt;w_cursor.lnum))</a>
<a name="ln2226">              // highlight 'hlsearch' match at end of line</a>
<a name="ln2227">              || prevcol_hl_flag)) {</a>
<a name="ln2228">        int n = 0;</a>
<a name="ln2229"> </a>
<a name="ln2230">        if (wp-&gt;w_p_rl) {</a>
<a name="ln2231">          if (col &lt; 0) {</a>
<a name="ln2232">            n = 1;</a>
<a name="ln2233">          }</a>
<a name="ln2234">        } else {</a>
<a name="ln2235">          if (col &gt;= grid-&gt;cols) {</a>
<a name="ln2236">            n = -1;</a>
<a name="ln2237">          }</a>
<a name="ln2238">        }</a>
<a name="ln2239">        if (n != 0) {</a>
<a name="ln2240">          // At the window boundary, highlight the last character</a>
<a name="ln2241">          // instead (better than nothing).</a>
<a name="ln2242">          off += n;</a>
<a name="ln2243">          col += n;</a>
<a name="ln2244">        } else {</a>
<a name="ln2245">          // Add a blank character to highlight.</a>
<a name="ln2246">          schar_from_ascii(linebuf_char[off], ' ');</a>
<a name="ln2247">        }</a>
<a name="ln2248">        if (area_attr == 0 &amp;&amp; !has_fold) {</a>
<a name="ln2249">          // Use attributes from match with highest priority among</a>
<a name="ln2250">          // 'search_hl' and the match list.</a>
<a name="ln2251">          get_search_match_hl(wp, &amp;screen_search_hl, (long)(ptr - line), &amp;char_attr);</a>
<a name="ln2252">        }</a>
<a name="ln2253"> </a>
<a name="ln2254">        int eol_attr = char_attr;</a>
<a name="ln2255">        if (cul_attr) {</a>
<a name="ln2256">          eol_attr = hl_combine_attr(cul_attr, eol_attr);</a>
<a name="ln2257">        }</a>
<a name="ln2258">        linebuf_attr[off] = eol_attr;</a>
<a name="ln2259">        if (wp-&gt;w_p_rl) {</a>
<a name="ln2260">          col--;</a>
<a name="ln2261">          off--;</a>
<a name="ln2262">        } else {</a>
<a name="ln2263">          col++;</a>
<a name="ln2264">          off++;</a>
<a name="ln2265">        }</a>
<a name="ln2266">        vcol++;</a>
<a name="ln2267">        eol_hl_off = 1;</a>
<a name="ln2268">      }</a>
<a name="ln2269">      // Highlight 'cursorcolumn' &amp; 'colorcolumn' past end of the line.</a>
<a name="ln2270">      if (wp-&gt;w_p_wrap) {</a>
<a name="ln2271">        v = wp-&gt;w_skipcol;</a>
<a name="ln2272">      } else {</a>
<a name="ln2273">        v = wp-&gt;w_leftcol;</a>
<a name="ln2274">      }</a>
<a name="ln2275"> </a>
<a name="ln2276">      // check if line ends before left margin</a>
<a name="ln2277">      if (vcol &lt; v + col - win_col_off(wp)) {</a>
<a name="ln2278">        vcol = v + col - win_col_off(wp);</a>
<a name="ln2279">      }</a>
<a name="ln2280">      // Get rid of the boguscols now, we want to draw until the right</a>
<a name="ln2281">      // edge for 'cursorcolumn'.</a>
<a name="ln2282">      col -= boguscols;</a>
<a name="ln2283">      // boguscols = 0;  // Disabled because value never read after this</a>
<a name="ln2284"> </a>
<a name="ln2285">      if (draw_color_col) {</a>
<a name="ln2286">        draw_color_col = advance_color_col((int)VCOL_HLC, &amp;color_cols);</a>
<a name="ln2287">      }</a>
<a name="ln2288"> </a>
<a name="ln2289">      bool has_virttext = false;</a>
<a name="ln2290">      // Make sure alignment is the same regardless</a>
<a name="ln2291">      // if listchars=eol:X is used or not.</a>
<a name="ln2292">      int eol_skip = (wp-&gt;w_p_lcs_chars.eol == lcs_eol_one &amp;&amp; eol_hl_off == 0</a>
<a name="ln2293">                      ? 1 : 0);</a>
<a name="ln2294"> </a>
<a name="ln2295">      if (has_decor) {</a>
<a name="ln2296">        has_virttext = decor_redraw_eol(wp-&gt;w_buffer, &amp;decor_state, &amp;line_attr,</a>
<a name="ln2297">                                        col + eol_skip);</a>
<a name="ln2298">      }</a>
<a name="ln2299"> </a>
<a name="ln2300">      if (((wp-&gt;w_p_cuc</a>
<a name="ln2301">            &amp;&amp; (int)wp-&gt;w_virtcol &gt;= VCOL_HLC - eol_hl_off</a>
<a name="ln2302">            &amp;&amp; (int)wp-&gt;w_virtcol &lt;</a>
<a name="ln2303">            (long)grid-&gt;cols * (row - startrow + 1) + v</a>
<a name="ln2304">            &amp;&amp; lnum != wp-&gt;w_cursor.lnum)</a>
<a name="ln2305">           || draw_color_col || line_attr_lowprio || line_attr</a>
<a name="ln2306">           || diff_hlf != (hlf_T)0 || has_virttext)) {</a>
<a name="ln2307">        int rightmost_vcol = 0;</a>
<a name="ln2308">        int i;</a>
<a name="ln2309"> </a>
<a name="ln2310">        if (wp-&gt;w_p_cuc) {</a>
<a name="ln2311">          rightmost_vcol = wp-&gt;w_virtcol;</a>
<a name="ln2312">        }</a>
<a name="ln2313"> </a>
<a name="ln2314">        if (draw_color_col) {</a>
<a name="ln2315">          // determine rightmost colorcolumn to possibly draw</a>
<a name="ln2316">          for (i = 0; color_cols[i] &gt;= 0; i++) {</a>
<a name="ln2317">            if (rightmost_vcol &lt; color_cols[i]) {</a>
<a name="ln2318">              rightmost_vcol = color_cols[i];</a>
<a name="ln2319">            }</a>
<a name="ln2320">          }</a>
<a name="ln2321">        }</a>
<a name="ln2322"> </a>
<a name="ln2323">        int cuc_attr = win_hl_attr(wp, HLF_CUC);</a>
<a name="ln2324">        int mc_attr = win_hl_attr(wp, HLF_MC);</a>
<a name="ln2325"> </a>
<a name="ln2326">        int diff_attr = 0;</a>
<a name="ln2327">        if (diff_hlf == HLF_TXD) {</a>
<a name="ln2328">          diff_hlf = HLF_CHD;</a>
<a name="ln2329">        }</a>
<a name="ln2330">        if (diff_hlf != 0) {</a>
<a name="ln2331">          diff_attr = win_hl_attr(wp, (int)diff_hlf);</a>
<a name="ln2332">        }</a>
<a name="ln2333"> </a>
<a name="ln2334">        int base_attr = hl_combine_attr(line_attr_lowprio, diff_attr);</a>
<a name="ln2335">        if (base_attr || line_attr || has_virttext) {</a>
<a name="ln2336">          rightmost_vcol = INT_MAX;</a>
<a name="ln2337">        }</a>
<a name="ln2338"> </a>
<a name="ln2339">        int col_stride = wp-&gt;w_p_rl ? -1 : 1;</a>
<a name="ln2340"> </a>
<a name="ln2341">        while (wp-&gt;w_p_rl ? col &gt;= 0 : col &lt; grid-&gt;cols) {</a>
<a name="ln2342">          schar_from_ascii(linebuf_char[off], ' ');</a>
<a name="ln2343">          col += col_stride;</a>
<a name="ln2344">          if (draw_color_col) {</a>
<a name="ln2345">            draw_color_col = advance_color_col((int)VCOL_HLC, &amp;color_cols);</a>
<a name="ln2346">          }</a>
<a name="ln2347"> </a>
<a name="ln2348">          int col_attr = base_attr;</a>
<a name="ln2349"> </a>
<a name="ln2350">          if (wp-&gt;w_p_cuc &amp;&amp; VCOL_HLC == (long)wp-&gt;w_virtcol) {</a>
<a name="ln2351">            col_attr = cuc_attr;</a>
<a name="ln2352">          } else if (draw_color_col &amp;&amp; VCOL_HLC == *color_cols) {</a>
<a name="ln2353">            col_attr = mc_attr;</a>
<a name="ln2354">          }</a>
<a name="ln2355"> </a>
<a name="ln2356">          col_attr = hl_combine_attr(col_attr, line_attr);</a>
<a name="ln2357"> </a>
<a name="ln2358">          linebuf_attr[off] = col_attr;</a>
<a name="ln2359">          off += col_stride;</a>
<a name="ln2360"> </a>
<a name="ln2361">          if (VCOL_HLC &gt;= rightmost_vcol) {</a>
<a name="ln2362">            break;</a>
<a name="ln2363">          }</a>
<a name="ln2364"> </a>
<a name="ln2365">          vcol += 1;</a>
<a name="ln2366">        }</a>
<a name="ln2367">      }</a>
<a name="ln2368"> </a>
<a name="ln2369">      // TODO(bfredl): integrate with the common beyond-the-end-loop</a>
<a name="ln2370">      if (wp-&gt;w_buffer-&gt;terminal) {</a>
<a name="ln2371">        // terminal buffers may need to highlight beyond the end of the</a>
<a name="ln2372">        // logical line</a>
<a name="ln2373">        int n = wp-&gt;w_p_rl ? -1 : 1;</a>
<a name="ln2374">        while (col &gt;= 0 &amp;&amp; col &lt; grid-&gt;cols) {</a>
<a name="ln2375">          schar_from_ascii(linebuf_char[off], ' ');</a>
<a name="ln2376">          linebuf_attr[off] = vcol &gt;= TERM_ATTRS_MAX ? 0 : term_attrs[vcol];</a>
<a name="ln2377">          off += n;</a>
<a name="ln2378">          vcol += n;</a>
<a name="ln2379">          col += n;</a>
<a name="ln2380">        }</a>
<a name="ln2381">      }</a>
<a name="ln2382"> </a>
<a name="ln2383">      draw_virt_text(wp, buf, win_col_offset, &amp;col, grid-&gt;cols, row);</a>
<a name="ln2384">      grid_put_linebuf(grid, row, 0, col, grid-&gt;cols, wp-&gt;w_p_rl, wp, bg_attr, false);</a>
<a name="ln2385">      row++;</a>
<a name="ln2386"> </a>
<a name="ln2387">      // Update w_cline_height and w_cline_folded if the cursor line was</a>
<a name="ln2388">      // updated (saves a call to plines_win() later).</a>
<a name="ln2389">      if (wp == curwin &amp;&amp; lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln2390">        curwin-&gt;w_cline_row = startrow;</a>
<a name="ln2391">        curwin-&gt;w_cline_height = row - startrow;</a>
<a name="ln2392">        curwin-&gt;w_cline_folded = foldinfo.fi_lines &gt; 0;</a>
<a name="ln2393">        curwin-&gt;w_valid |= (VALID_CHEIGHT|VALID_CROW);</a>
<a name="ln2394">        conceal_cursor_used = conceal_cursor_line(curwin);</a>
<a name="ln2395">      }</a>
<a name="ln2396">      break;</a>
<a name="ln2397">    }</a>
<a name="ln2398"> </a>
<a name="ln2399">    // Show &quot;extends&quot; character from 'listchars' if beyond the line end and</a>
<a name="ln2400">    // 'list' is set.</a>
<a name="ln2401">    if (wp-&gt;w_p_lcs_chars.ext != NUL</a>
<a name="ln2402">        &amp;&amp; draw_state == WL_LINE</a>
<a name="ln2403">        &amp;&amp; wp-&gt;w_p_list</a>
<a name="ln2404">        &amp;&amp; !wp-&gt;w_p_wrap</a>
<a name="ln2405">        &amp;&amp; filler_todo &lt;= 0</a>
<a name="ln2406">        &amp;&amp; (wp-&gt;w_p_rl ? col == 0 : col == grid-&gt;cols - 1)</a>
<a name="ln2407">        &amp;&amp; !has_fold</a>
<a name="ln2408">        &amp;&amp; (*ptr != NUL</a>
<a name="ln2409">            || lcs_eol_one &gt; 0</a>
<a name="ln2410">            || (n_extra &amp;&amp; (c_extra != NUL || *p_extra != NUL)))) {</a>
<a name="ln2411">      c = wp-&gt;w_p_lcs_chars.ext;</a>
<a name="ln2412">      char_attr = win_hl_attr(wp, HLF_AT);</a>
<a name="ln2413">      mb_c = c;</a>
<a name="ln2414">      mb_utf8 = check_mb_utf8(&amp;c, u8cc);</a>
<a name="ln2415">    }</a>
<a name="ln2416"> </a>
<a name="ln2417">    // advance to the next 'colorcolumn'</a>
<a name="ln2418">    if (draw_color_col) {</a>
<a name="ln2419">      draw_color_col = advance_color_col((int)VCOL_HLC, &amp;color_cols);</a>
<a name="ln2420">    }</a>
<a name="ln2421"> </a>
<a name="ln2422">    // Highlight the cursor column if 'cursorcolumn' is set.  But don't</a>
<a name="ln2423">    // highlight the cursor position itself.</a>
<a name="ln2424">    // Also highlight the 'colorcolumn' if it is different than</a>
<a name="ln2425">    // 'cursorcolumn'</a>
<a name="ln2426">    // Also highlight the 'colorcolumn' if 'breakindent' and/or 'showbreak'</a>
<a name="ln2427">    // options are set</a>
<a name="ln2428">    vcol_save_attr = -1;</a>
<a name="ln2429">    if ((draw_state == WL_LINE</a>
<a name="ln2430">         || draw_state == WL_BRI</a>
<a name="ln2431">         || draw_state == WL_SBR)</a>
<a name="ln2432">        &amp;&amp; !lnum_in_visual_area</a>
<a name="ln2433">        &amp;&amp; search_attr == 0</a>
<a name="ln2434">        &amp;&amp; area_attr == 0</a>
<a name="ln2435">        &amp;&amp; filler_todo &lt;= 0) {</a>
<a name="ln2436">      if (wp-&gt;w_p_cuc &amp;&amp; VCOL_HLC == (long)wp-&gt;w_virtcol</a>
<a name="ln2437">          &amp;&amp; lnum != wp-&gt;w_cursor.lnum) {</a>
<a name="ln2438">        vcol_save_attr = char_attr;</a>
<a name="ln2439">        char_attr = hl_combine_attr(win_hl_attr(wp, HLF_CUC), char_attr);</a>
<a name="ln2440">      } else if (draw_color_col &amp;&amp; VCOL_HLC == *color_cols) {</a>
<a name="ln2441">        vcol_save_attr = char_attr;</a>
<a name="ln2442">        char_attr = hl_combine_attr(win_hl_attr(wp, HLF_MC), char_attr);</a>
<a name="ln2443">      }</a>
<a name="ln2444">    }</a>
<a name="ln2445"> </a>
<a name="ln2446">    // Apply lowest-priority line attr now, so everything can override it.</a>
<a name="ln2447">    if (draw_state == WL_LINE) {</a>
<a name="ln2448">      char_attr = hl_combine_attr(line_attr_lowprio, char_attr);</a>
<a name="ln2449">    }</a>
<a name="ln2450"> </a>
<a name="ln2451">    // Store character to be displayed.</a>
<a name="ln2452">    // Skip characters that are left of the screen for 'nowrap'.</a>
<a name="ln2453">    vcol_prev = vcol;</a>
<a name="ln2454">    if (draw_state &lt; WL_LINE || n_skip &lt;= 0) {</a>
<a name="ln2455">      //</a>
<a name="ln2456">      // Store the character.</a>
<a name="ln2457">      //</a>
<a name="ln2458">      if (wp-&gt;w_p_rl &amp;&amp; utf_char2cells(mb_c) &gt; 1) {</a>
<a name="ln2459">        // A double-wide character is: put first half in left cell.</a>
<a name="ln2460">        off--;</a>
<a name="ln2461">        col--;</a>
<a name="ln2462">      }</a>
<a name="ln2463">      if (mb_utf8) {</a>
<a name="ln2464">        schar_from_cc(linebuf_char[off], mb_c, u8cc);</a>
<a name="ln2465">      } else {</a>
<a name="ln2466">        schar_from_ascii(linebuf_char[off], (char)c);</a>
<a name="ln2467">      }</a>
<a name="ln2468">      if (multi_attr) {</a>
<a name="ln2469">        linebuf_attr[off] = multi_attr;</a>
<a name="ln2470">        multi_attr = 0;</a>
<a name="ln2471">      } else {</a>
<a name="ln2472">        linebuf_attr[off] = char_attr;</a>
<a name="ln2473">      }</a>
<a name="ln2474"> </a>
<a name="ln2475">      if (utf_char2cells(mb_c) &gt; 1) {</a>
<a name="ln2476">        // Need to fill two screen columns.</a>
<a name="ln2477">        off++;</a>
<a name="ln2478">        col++;</a>
<a name="ln2479">        // UTF-8: Put a 0 in the second screen char.</a>
<a name="ln2480">        linebuf_char[off][0] = 0;</a>
<a name="ln2481">        if (draw_state &gt; WL_NR &amp;&amp; filler_todo &lt;= 0) {</a>
<a name="ln2482">          vcol++;</a>
<a name="ln2483">        }</a>
<a name="ln2484">        // When &quot;tocol&quot; is halfway through a character, set it to the end of</a>
<a name="ln2485">        // the character, otherwise highlighting won't stop.</a>
<a name="ln2486">        if (tocol == vcol) {</a>
<a name="ln2487">          tocol++;</a>
<a name="ln2488">        }</a>
<a name="ln2489">        if (wp-&gt;w_p_rl) {</a>
<a name="ln2490">          // now it's time to backup one cell</a>
<a name="ln2491">          off--;</a>
<a name="ln2492">          col--;</a>
<a name="ln2493">        }</a>
<a name="ln2494">      }</a>
<a name="ln2495">      if (wp-&gt;w_p_rl) {</a>
<a name="ln2496">        off--;</a>
<a name="ln2497">        col--;</a>
<a name="ln2498">      } else {</a>
<a name="ln2499">        off++;</a>
<a name="ln2500">        col++;</a>
<a name="ln2501">      }</a>
<a name="ln2502">    } else if (wp-&gt;w_p_cole &gt; 0 &amp;&amp; is_concealing) {</a>
<a name="ln2503">      n_skip--;</a>
<a name="ln2504">      vcol_off++;</a>
<a name="ln2505">      if (n_extra &gt; 0) {</a>
<a name="ln2506">        vcol_off += n_extra;</a>
<a name="ln2507">      }</a>
<a name="ln2508">      if (wp-&gt;w_p_wrap) {</a>
<a name="ln2509">        // Special voodoo required if 'wrap' is on.</a>
<a name="ln2510">        //</a>
<a name="ln2511">        // Advance the column indicator to force the line</a>
<a name="ln2512">        // drawing to wrap early. This will make the line</a>
<a name="ln2513">        // take up the same screen space when parts are concealed,</a>
<a name="ln2514">        // so that cursor line computations aren't messed up.</a>
<a name="ln2515">        //</a>
<a name="ln2516">        // To avoid the fictitious advance of 'col' causing</a>
<a name="ln2517">        // trailing junk to be written out of the screen line</a>
<a name="ln2518">        // we are building, 'boguscols' keeps track of the number</a>
<a name="ln2519">        // of bad columns we have advanced.</a>
<a name="ln2520">        if (n_extra &gt; 0) {</a>
<a name="ln2521">          vcol += n_extra;</a>
<a name="ln2522">          if (wp-&gt;w_p_rl) {</a>
<a name="ln2523">            col -= n_extra;</a>
<a name="ln2524">            boguscols -= n_extra;</a>
<a name="ln2525">          } else {</a>
<a name="ln2526">            col += n_extra;</a>
<a name="ln2527">            boguscols += n_extra;</a>
<a name="ln2528">          }</a>
<a name="ln2529">          n_extra = 0;</a>
<a name="ln2530">          n_attr = 0;</a>
<a name="ln2531">        }</a>
<a name="ln2532"> </a>
<a name="ln2533">        if (utf_char2cells(mb_c) &gt; 1) {</a>
<a name="ln2534">          // Need to fill two screen columns.</a>
<a name="ln2535">          if (wp-&gt;w_p_rl) {</a>
<a name="ln2536">            boguscols--;</a>
<a name="ln2537">            col--;</a>
<a name="ln2538">          } else {</a>
<a name="ln2539">            boguscols++;</a>
<a name="ln2540">            col++;</a>
<a name="ln2541">          }</a>
<a name="ln2542">        }</a>
<a name="ln2543"> </a>
<a name="ln2544">        if (wp-&gt;w_p_rl) {</a>
<a name="ln2545">          boguscols--;</a>
<a name="ln2546">          col--;</a>
<a name="ln2547">        } else {</a>
<a name="ln2548">          boguscols++;</a>
<a name="ln2549">          col++;</a>
<a name="ln2550">        }</a>
<a name="ln2551">      } else {</a>
<a name="ln2552">        if (n_extra &gt; 0) {</a>
<a name="ln2553">          vcol += n_extra;</a>
<a name="ln2554">          n_extra = 0;</a>
<a name="ln2555">          n_attr = 0;</a>
<a name="ln2556">        }</a>
<a name="ln2557">      }</a>
<a name="ln2558">    } else {</a>
<a name="ln2559">      n_skip--;</a>
<a name="ln2560">    }</a>
<a name="ln2561"> </a>
<a name="ln2562">    // Only advance the &quot;vcol&quot; when after the 'number' or 'relativenumber'</a>
<a name="ln2563">    // column.</a>
<a name="ln2564">    if (draw_state &gt; WL_NR</a>
<a name="ln2565">        &amp;&amp; filler_todo &lt;= 0) {</a>
<a name="ln2566">      vcol++;</a>
<a name="ln2567">    }</a>
<a name="ln2568"> </a>
<a name="ln2569">    if (vcol_save_attr &gt;= 0) {</a>
<a name="ln2570">      char_attr = vcol_save_attr;</a>
<a name="ln2571">    }</a>
<a name="ln2572"> </a>
<a name="ln2573">    // restore attributes after &quot;predeces&quot; in 'listchars'</a>
<a name="ln2574">    if (draw_state &gt; WL_NR &amp;&amp; n_attr3 &gt; 0 &amp;&amp; --n_attr3 == 0) {</a>
<a name="ln2575">      char_attr = saved_attr3;</a>
<a name="ln2576">    }</a>
<a name="ln2577"> </a>
<a name="ln2578">    // restore attributes after last 'listchars' or 'number' char</a>
<a name="ln2579">    if (n_attr &gt; 0 &amp;&amp; draw_state == WL_LINE &amp;&amp; --n_attr == 0) {</a>
<a name="ln2580">      char_attr = saved_attr2;</a>
<a name="ln2581">    }</a>
<a name="ln2582"> </a>
<a name="ln2583">    // At end of screen line and there is more to come: Display the line</a>
<a name="ln2584">    // so far.  If there is no more to display it is caught above.</a>
<a name="ln2585">    if ((wp-&gt;w_p_rl ? (col &lt; 0) : (col &gt;= grid-&gt;cols))</a>
<a name="ln2586">        &amp;&amp; foldinfo.fi_lines == 0</a>
<a name="ln2587">        &amp;&amp; (draw_state != WL_LINE</a>
<a name="ln2588">            || *ptr != NUL</a>
<a name="ln2589">            || filler_todo &gt; 0</a>
<a name="ln2590">            || (wp-&gt;w_p_list &amp;&amp; wp-&gt;w_p_lcs_chars.eol != NUL</a>
<a name="ln2591">                &amp;&amp; p_extra != at_end_str)</a>
<a name="ln2592">            || (n_extra != 0</a>
<a name="ln2593">                &amp;&amp; (c_extra != NUL || *p_extra != NUL)))) {</a>
<a name="ln2594">      bool wrap = wp-&gt;w_p_wrap       // Wrapping enabled.</a>
<a name="ln2595">                  &amp;&amp; filler_todo &lt;= 0          // Not drawing diff filler lines.</a>
<a name="ln2596">                  &amp;&amp; lcs_eol_one != -1         // Haven't printed the lcs_eol character.</a>
<a name="ln2597">                  &amp;&amp; row != endrow - 1         // Not the last line being displayed.</a>
<a name="ln2598">                  &amp;&amp; (grid-&gt;cols == Columns  // Window spans the width of the screen,</a>
<a name="ln2599">                      || ui_has(kUIMultigrid))  // or has dedicated grid.</a>
<a name="ln2600">                  &amp;&amp; !wp-&gt;w_p_rl;              // Not right-to-left.</a>
<a name="ln2601"> </a>
<a name="ln2602">      int draw_col = col - boguscols;</a>
<a name="ln2603">      if (filler_todo &gt; 0) {</a>
<a name="ln2604">        int index = filler_todo - (filler_lines - n_virt_lines);</a>
<a name="ln2605">        if (index &gt; 0) {</a>
<a name="ln2606">          int i = (int)kv_size(virt_lines) - index;</a>
<a name="ln2607">          assert(i &gt;= 0);</a>
<a name="ln2608">          int offset = kv_A(virt_lines, i).left_col ? 0 : win_col_offset;</a>
<a name="ln2609">          draw_virt_text_item(buf, offset, kv_A(virt_lines, i).line,</a>
<a name="ln2610">                              kHlModeReplace, grid-&gt;cols, 0);</a>
<a name="ln2611">        }</a>
<a name="ln2612">      } else {</a>
<a name="ln2613">        draw_virt_text(wp, buf, win_col_offset, &amp;draw_col, grid-&gt;cols, row);</a>
<a name="ln2614">      }</a>
<a name="ln2615"> </a>
<a name="ln2616">      grid_put_linebuf(grid, row, 0, draw_col, grid-&gt;cols, wp-&gt;w_p_rl, wp, bg_attr, wrap);</a>
<a name="ln2617">      if (wrap) {</a>
<a name="ln2618">        ScreenGrid *current_grid = grid;</a>
<a name="ln2619">        int current_row = row, dummy_col = 0;  // dummy_col unused</a>
<a name="ln2620">        grid_adjust(&amp;current_grid, &amp;current_row, &amp;dummy_col);</a>
<a name="ln2621"> </a>
<a name="ln2622">        // Force a redraw of the first column of the next line.</a>
<a name="ln2623">        current_grid-&gt;attrs[current_grid-&gt;line_offset[current_row + 1]] = -1;</a>
<a name="ln2624"> </a>
<a name="ln2625">        // Remember that the line wraps, used for modeless copy.</a>
<a name="ln2626">        current_grid-&gt;line_wraps[current_row] = true;</a>
<a name="ln2627">      }</a>
<a name="ln2628"> </a>
<a name="ln2629">      boguscols = 0;</a>
<a name="ln2630">      row++;</a>
<a name="ln2631"> </a>
<a name="ln2632">      // When not wrapping and finished diff lines, or when displayed</a>
<a name="ln2633">      // '$' and highlighting until last column, break here.</a>
<a name="ln2634">      if ((!wp-&gt;w_p_wrap &amp;&amp; filler_todo &lt;= 0) || lcs_eol_one == -1) {</a>
<a name="ln2635">        break;</a>
<a name="ln2636">      }</a>
<a name="ln2637"> </a>
<a name="ln2638">      // When the window is too narrow draw all &quot;@&quot; lines.</a>
<a name="ln2639">      if (draw_state != WL_LINE &amp;&amp; filler_todo &lt;= 0) {</a>
<a name="ln2640">        win_draw_end(wp, '@', ' ', true, row, wp-&gt;w_grid.rows, HLF_AT);</a>
<a name="ln2641">        set_empty_rows(wp, row);</a>
<a name="ln2642">        row = endrow;</a>
<a name="ln2643">      }</a>
<a name="ln2644"> </a>
<a name="ln2645">      // When line got too long for screen break here.</a>
<a name="ln2646">      if (row == endrow) {</a>
<a name="ln2647">        row++;</a>
<a name="ln2648">        break;</a>
<a name="ln2649">      }</a>
<a name="ln2650"> </a>
<a name="ln2651">      col = 0;</a>
<a name="ln2652">      off = 0;</a>
<a name="ln2653">      if (wp-&gt;w_p_rl) {</a>
<a name="ln2654">        col = grid-&gt;cols - 1;  // col is not used if breaking!</a>
<a name="ln2655">        off += col;</a>
<a name="ln2656">      }</a>
<a name="ln2657"> </a>
<a name="ln2658">      // reset the drawing state for the start of a wrapped line</a>
<a name="ln2659">      draw_state = WL_START;</a>
<a name="ln2660">      saved_n_extra = n_extra;</a>
<a name="ln2661">      saved_p_extra = p_extra;</a>
<a name="ln2662">      saved_c_extra = c_extra;</a>
<a name="ln2663">      saved_c_final = c_final;</a>
<a name="ln2664">      saved_char_attr = char_attr;</a>
<a name="ln2665">      n_extra = 0;</a>
<a name="ln2666">      lcs_prec_todo = wp-&gt;w_p_lcs_chars.prec;</a>
<a name="ln2667">      if (filler_todo &lt;= 0) {</a>
<a name="ln2668">        need_showbreak = true;</a>
<a name="ln2669">      }</a>
<a name="ln2670">      filler_todo--;</a>
<a name="ln2671">      // When the filler lines are actually below the last line of the</a>
<a name="ln2672">      // file, don't draw the line itself, break here.</a>
<a name="ln2673">      if (filler_todo == 0 &amp;&amp; (wp-&gt;w_botfill || end_fill)) {</a>
<a name="ln2674">        break;</a>
<a name="ln2675">      }</a>
<a name="ln2676">    }</a>
<a name="ln2677">  }     // for every character in the line</a>
<a name="ln2678"> </a>
<a name="ln2679">  // After an empty line check first word for capital.</a>
<a name="ln2680">  if (*skipwhite((char *)line) == NUL) {</a>
<a name="ln2681">    capcol_lnum = lnum + 1;</a>
<a name="ln2682">    cap_col = 0;</a>
<a name="ln2683">  }</a>
<a name="ln2684"> </a>
<a name="ln2685">  kv_destroy(virt_lines);</a>
<a name="ln2686">  xfree(p_extra_free);</a>
<a name="ln2687">  return row;</a>
<a name="ln2688">}</a>
</code></pre>
<div class="balloon" rel="2211"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: eol_hl_off == 0.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>