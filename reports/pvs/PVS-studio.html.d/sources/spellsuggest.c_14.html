<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>spellsuggest.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// spellsuggest.c: functions for spelling suggestions</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln7">#include &quot;nvim/change.h&quot;</a>
<a name="ln8">#include &quot;nvim/charset.h&quot;</a>
<a name="ln9">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln10">#include &quot;nvim/eval.h&quot;</a>
<a name="ln11">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln12">#include &quot;nvim/garray.h&quot;</a>
<a name="ln13">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln14">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln15">#include &quot;nvim/input.h&quot;</a>
<a name="ln16">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln17">#include &quot;nvim/memline.h&quot;</a>
<a name="ln18">#include &quot;nvim/memory.h&quot;</a>
<a name="ln19">#include &quot;nvim/message.h&quot;</a>
<a name="ln20">#include &quot;nvim/option.h&quot;</a>
<a name="ln21">#include &quot;nvim/os/fs.h&quot;</a>
<a name="ln22">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln23">#include &quot;nvim/profile.h&quot;</a>
<a name="ln24">#include &quot;nvim/screen.h&quot;</a>
<a name="ln25">#include &quot;nvim/spell.h&quot;</a>
<a name="ln26">#include &quot;nvim/spell_defs.h&quot;</a>
<a name="ln27">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln28">#include &quot;nvim/spellsuggest.h&quot;</a>
<a name="ln29">#include &quot;nvim/strings.h&quot;</a>
<a name="ln30">#include &quot;nvim/ui.h&quot;</a>
<a name="ln31">#include &quot;nvim/undo.h&quot;</a>
<a name="ln32">#include &quot;nvim/vim.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">// Use this to adjust the score after finding suggestions, based on the</a>
<a name="ln35">// suggested word sounding like the bad word.  This is much faster than doing</a>
<a name="ln36">// it for every possible suggestion.</a>
<a name="ln37">// Disadvantage: When &quot;the&quot; is typed as &quot;hte&quot; it sounds quite different (&quot;@&quot;</a>
<a name="ln38">// vs &quot;ht&quot;) and goes down in the list.</a>
<a name="ln39">// Used when 'spellsuggest' is set to &quot;best&quot;.</a>
<a name="ln40">#define RESCORE(word_score, sound_score) ((3 * (word_score) + (sound_score)) / 4)</a>
<a name="ln41"> </a>
<a name="ln42">// Do the opposite: based on a maximum end score and a known sound score,</a>
<a name="ln43">// compute the maximum word score that can be used.</a>
<a name="ln44">#define MAXSCORE(word_score, sound_score) ((4 * (word_score) - (sound_score)) / 3)</a>
<a name="ln45"> </a>
<a name="ln46">// only used for su_badflags</a>
<a name="ln47">#define WF_MIXCAP   0x20        // mix of upper and lower case: macaRONI</a>
<a name="ln48"> </a>
<a name="ln49">/// Information used when looking for suggestions.</a>
<a name="ln50">typedef struct suginfo_S {</a>
<a name="ln51">  garray_T su_ga;                  ///&lt; suggestions, contains &quot;suggest_T&quot;</a>
<a name="ln52">  int su_maxcount;                 ///&lt; max. number of suggestions displayed</a>
<a name="ln53">  int su_maxscore;                 ///&lt; maximum score for adding to su_ga</a>
<a name="ln54">  int su_sfmaxscore;               ///&lt; idem, for when doing soundfold words</a>
<a name="ln55">  garray_T su_sga;                 ///&lt; like su_ga, sound-folded scoring</a>
<a name="ln56">  char_u *su_badptr;               ///&lt; start of bad word in line</a>
<a name="ln57">  int su_badlen;                   ///&lt; length of detected bad word in line</a>
<a name="ln58">  int su_badflags;                 ///&lt; caps flags for bad word</a>
<a name="ln59">  char_u su_badword[MAXWLEN];      ///&lt; bad word truncated at su_badlen</a>
<a name="ln60">  char_u su_fbadword[MAXWLEN];     ///&lt; su_badword case-folded</a>
<a name="ln61">  char_u su_sal_badword[MAXWLEN];  ///&lt; su_badword soundfolded</a>
<a name="ln62">  hashtab_T su_banned;             ///&lt; table with banned words</a>
<a name="ln63">  slang_T *su_sallang;             ///&lt; default language for sound folding</a>
<a name="ln64">} suginfo_T;</a>
<a name="ln65"> </a>
<a name="ln66">/// One word suggestion.  Used in &quot;si_ga&quot;.</a>
<a name="ln67">typedef struct {</a>
<a name="ln68">  char *st_word;      ///&lt; suggested word, allocated string</a>
<a name="ln69">  int st_wordlen;     ///&lt; strlen(st_word)</a>
<a name="ln70">  int st_orglen;      ///&lt; length of replaced text</a>
<a name="ln71">  int st_score;       ///&lt; lower is better</a>
<a name="ln72">  int st_altscore;    ///&lt; used when st_score compares equal</a>
<a name="ln73">  bool st_salscore;   ///&lt; st_score is for soundalike</a>
<a name="ln74">  bool st_had_bonus;  ///&lt; bonus already included in score</a>
<a name="ln75">  slang_T *st_slang;  ///&lt; language used for sound folding</a>
<a name="ln76">} suggest_T;</a>
<a name="ln77"> </a>
<a name="ln78">#define SUG(ga, i) (((suggest_T *)(ga).ga_data)[i])</a>
<a name="ln79"> </a>
<a name="ln80">// True if a word appears in the list of banned words.</a>
<a name="ln81">#define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&amp;(su)-&gt;su_banned, word)))</a>
<a name="ln82"> </a>
<a name="ln83">// Number of suggestions kept when cleaning up.  We need to keep more than</a>
<a name="ln84">// what is displayed, because when rescore_suggestions() is called the score</a>
<a name="ln85">// may change and wrong suggestions may be removed later.</a>
<a name="ln86">#define SUG_CLEAN_COUNT(su)    ((su)-&gt;su_maxcount &lt; \</a>
<a name="ln87">                                130 ? 150 : (su)-&gt;su_maxcount + 20)</a>
<a name="ln88"> </a>
<a name="ln89">// Threshold for sorting and cleaning up suggestions.  Don't want to keep lots</a>
<a name="ln90">// of suggestions that are not going to be displayed.</a>
<a name="ln91">#define SUG_MAX_COUNT(su)       (SUG_CLEAN_COUNT(su) + 50)</a>
<a name="ln92"> </a>
<a name="ln93">// score for various changes</a>
<a name="ln94">#define SCORE_SPLIT     149     // split bad word</a>
<a name="ln95">#define SCORE_SPLIT_NO  249     // split bad word with NOSPLITSUGS</a>
<a name="ln96">#define SCORE_ICASE     52      // slightly different case</a>
<a name="ln97">#define SCORE_REGION    200     // word is for different region</a>
<a name="ln98">#define SCORE_RARE      180     // rare word</a>
<a name="ln99">#define SCORE_SWAP      75      // swap two characters</a>
<a name="ln100">#define SCORE_SWAP3     110     // swap two characters in three</a>
<a name="ln101">#define SCORE_REP       65      // REP replacement</a>
<a name="ln102">#define SCORE_SUBST     93      // substitute a character</a>
<a name="ln103">#define SCORE_SIMILAR   33      // substitute a similar character</a>
<a name="ln104">#define SCORE_SUBCOMP   33      // substitute a composing character</a>
<a name="ln105">#define SCORE_DEL       94      // delete a character</a>
<a name="ln106">#define SCORE_DELDUP    66      // delete a duplicated character</a>
<a name="ln107">#define SCORE_DELCOMP   28      // delete a composing character</a>
<a name="ln108">#define SCORE_INS       96      // insert a character</a>
<a name="ln109">#define SCORE_INSDUP    67      // insert a duplicate character</a>
<a name="ln110">#define SCORE_INSCOMP   30      // insert a composing character</a>
<a name="ln111">#define SCORE_NONWORD   103     // change non-word to word char</a>
<a name="ln112"> </a>
<a name="ln113">#define SCORE_FILE      30      // suggestion from a file</a>
<a name="ln114">#define SCORE_MAXINIT   350     // Initial maximum score: higher == slower.</a>
<a name="ln115">                                // 350 allows for about three changes.</a>
<a name="ln116"> </a>
<a name="ln117">#define SCORE_COMMON1   30      // subtracted for words seen before</a>
<a name="ln118">#define SCORE_COMMON2   40      // subtracted for words often seen</a>
<a name="ln119">#define SCORE_COMMON3   50      // subtracted for words very often seen</a>
<a name="ln120">#define SCORE_THRES2    10      // word count threshold for COMMON2</a>
<a name="ln121">#define SCORE_THRES3    100     // word count threshold for COMMON3</a>
<a name="ln122"> </a>
<a name="ln123">// When trying changed soundfold words it becomes slow when trying more than</a>
<a name="ln124">// two changes.  With less than two changes it's slightly faster but we miss a</a>
<a name="ln125">// few good suggestions.  In rare cases we need to try three of four changes.</a>
<a name="ln126">#define SCORE_SFMAX1    200     // maximum score for first try</a>
<a name="ln127">#define SCORE_SFMAX2    300     // maximum score for second try</a>
<a name="ln128">#define SCORE_SFMAX3    400     // maximum score for third try</a>
<a name="ln129"> </a>
<a name="ln130">#define SCORE_BIG       (SCORE_INS * 3)  // big difference</a>
<a name="ln131">#define SCORE_MAXMAX    999999           // accept any score</a>
<a name="ln132">#define SCORE_LIMITMAX  350              // for spell_edit_score_limit()</a>
<a name="ln133"> </a>
<a name="ln134">// for spell_edit_score_limit() we need to know the minimum value of</a>
<a name="ln135">// SCORE_ICASE, SCORE_SWAP, SCORE_DEL, SCORE_SIMILAR and SCORE_INS</a>
<a name="ln136">#define SCORE_EDIT_MIN  SCORE_SIMILAR</a>
<a name="ln137"> </a>
<a name="ln138">/// For finding suggestions: At each node in the tree these states are tried:</a>
<a name="ln139">typedef enum {</a>
<a name="ln140">  STATE_START = 0,  ///&lt; At start of node check for NUL bytes (goodword</a>
<a name="ln141">                    ///&lt; ends); if badword ends there is a match, otherwise</a>
<a name="ln142">                    ///&lt; try splitting word.</a>
<a name="ln143">  STATE_NOPREFIX,   ///&lt; try without prefix</a>
<a name="ln144">  STATE_SPLITUNDO,  ///&lt; Undo splitting.</a>
<a name="ln145">  STATE_ENDNUL,     ///&lt; Past NUL bytes at start of the node.</a>
<a name="ln146">  STATE_PLAIN,      ///&lt; Use each byte of the node.</a>
<a name="ln147">  STATE_DEL,        ///&lt; Delete a byte from the bad word.</a>
<a name="ln148">  STATE_INS_PREP,   ///&lt; Prepare for inserting bytes.</a>
<a name="ln149">  STATE_INS,        ///&lt; Insert a byte in the bad word.</a>
<a name="ln150">  STATE_SWAP,       ///&lt; Swap two bytes.</a>
<a name="ln151">  STATE_UNSWAP,     ///&lt; Undo swap two characters.</a>
<a name="ln152">  STATE_SWAP3,      ///&lt; Swap two characters over three.</a>
<a name="ln153">  STATE_UNSWAP3,    ///&lt; Undo Swap two characters over three.</a>
<a name="ln154">  STATE_UNROT3L,    ///&lt; Undo rotate three characters left</a>
<a name="ln155">  STATE_UNROT3R,    ///&lt; Undo rotate three characters right</a>
<a name="ln156">  STATE_REP_INI,    ///&lt; Prepare for using REP items.</a>
<a name="ln157">  STATE_REP,        ///&lt; Use matching REP items from the .aff file.</a>
<a name="ln158">  STATE_REP_UNDO,   ///&lt; Undo a REP item replacement.</a>
<a name="ln159">  STATE_FINAL,      ///&lt; End of this node.</a>
<a name="ln160">} state_T;</a>
<a name="ln161"> </a>
<a name="ln162">/// Struct to keep the state at each level in suggest_try_change().</a>
<a name="ln163">typedef struct trystate_S {</a>
<a name="ln164">  state_T ts_state;         ///&lt; state at this level, STATE_</a>
<a name="ln165">  int ts_score;             ///&lt; score</a>
<a name="ln166">  idx_T ts_arridx;          ///&lt; index in tree array, start of node</a>
<a name="ln167">  int16_t ts_curi;          ///&lt; index in list of child nodes</a>
<a name="ln168">  char_u ts_fidx;           ///&lt; index in fword[], case-folded bad word</a>
<a name="ln169">  char_u ts_fidxtry;        ///&lt; ts_fidx at which bytes may be changed</a>
<a name="ln170">  char_u ts_twordlen;       ///&lt; valid length of tword[]</a>
<a name="ln171">  char_u ts_prefixdepth;    ///&lt; stack depth for end of prefix or</a>
<a name="ln172">                            ///&lt; PFD_PREFIXTREE or PFD_NOPREFIX</a>
<a name="ln173">  char_u ts_flags;          ///&lt; TSF_ flags</a>
<a name="ln174">  char_u ts_tcharlen;       ///&lt; number of bytes in tword character</a>
<a name="ln175">  char_u ts_tcharidx;       ///&lt; current byte index in tword character</a>
<a name="ln176">  char_u ts_isdiff;         ///&lt; DIFF_ values</a>
<a name="ln177">  char_u ts_fcharstart;     ///&lt; index in fword where badword char started</a>
<a name="ln178">  char_u ts_prewordlen;     ///&lt; length of word in &quot;preword[]&quot;</a>
<a name="ln179">  char_u ts_splitoff;       ///&lt; index in &quot;tword&quot; after last split</a>
<a name="ln180">  char_u ts_splitfidx;      ///&lt; &quot;ts_fidx&quot; at word split</a>
<a name="ln181">  char_u ts_complen;        ///&lt; nr of compound words used</a>
<a name="ln182">  char_u ts_compsplit;      ///&lt; index for &quot;compflags&quot; where word was spit</a>
<a name="ln183">  char_u ts_save_badflags;  ///&lt; su_badflags saved here</a>
<a name="ln184">  char_u ts_delidx;         ///&lt; index in fword for char that was deleted,</a>
<a name="ln185">                            ///&lt; valid when &quot;ts_flags&quot; has TSF_DIDDEL</a>
<a name="ln186">} trystate_T;</a>
<a name="ln187"> </a>
<a name="ln188">// values for ts_isdiff</a>
<a name="ln189">#define DIFF_NONE       0       // no different byte (yet)</a>
<a name="ln190">#define DIFF_YES        1       // different byte found</a>
<a name="ln191">#define DIFF_INSERT     2       // inserting character</a>
<a name="ln192"> </a>
<a name="ln193">// values for ts_flags</a>
<a name="ln194">#define TSF_PREFIXOK    1       // already checked that prefix is OK</a>
<a name="ln195">#define TSF_DIDSPLIT    2       // tried split at this point</a>
<a name="ln196">#define TSF_DIDDEL      4       // did a delete, &quot;ts_delidx&quot; has index</a>
<a name="ln197"> </a>
<a name="ln198">// special values ts_prefixdepth</a>
<a name="ln199">#define PFD_NOPREFIX    0xff    // not using prefixes</a>
<a name="ln200">#define PFD_PREFIXTREE  0xfe    // walking through the prefix tree</a>
<a name="ln201">#define PFD_NOTSPECIAL  0xfd    // highest value that's not special</a>
<a name="ln202"> </a>
<a name="ln203">static long spell_suggest_timeout = 5000;</a>
<a name="ln204"> </a>
<a name="ln205">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln206"># include &quot;spellsuggest.c.generated.h&quot;</a>
<a name="ln207">#endif</a>
<a name="ln208"> </a>
<a name="ln209">/// Returns true when the sequence of flags in &quot;compflags&quot; plus &quot;flag&quot; can</a>
<a name="ln210">/// possibly form a valid compounded word.  This also checks the COMPOUNDRULE</a>
<a name="ln211">/// lines if they don't contain wildcards.</a>
<a name="ln212">static bool can_be_compound(trystate_T *sp, slang_T *slang, char_u *compflags, int flag)</a>
<a name="ln213">{</a>
<a name="ln214">  // If the flag doesn't appear in sl_compstartflags or sl_compallflags</a>
<a name="ln215">  // then it can't possibly compound.</a>
<a name="ln216">  if (!byte_in_str(sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln217">                   ? slang-&gt;sl_compstartflags : slang-&gt;sl_compallflags, flag)) {</a>
<a name="ln218">    return false;</a>
<a name="ln219">  }</a>
<a name="ln220"> </a>
<a name="ln221">  // If there are no wildcards, we can check if the flags collected so far</a>
<a name="ln222">  // possibly can form a match with COMPOUNDRULE patterns.  This only</a>
<a name="ln223">  // makes sense when we have two or more words.</a>
<a name="ln224">  if (slang-&gt;sl_comprules != NULL &amp;&amp; sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit) {</a>
<a name="ln225">    compflags[sp-&gt;ts_complen] = (char_u)flag;</a>
<a name="ln226">    compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln227">    bool v = match_compoundrule(slang, compflags + sp-&gt;ts_compsplit);</a>
<a name="ln228">    compflags[sp-&gt;ts_complen] = NUL;</a>
<a name="ln229">    return v;</a>
<a name="ln230">  }</a>
<a name="ln231"> </a>
<a name="ln232">  return true;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">/// Adjust the score of common words.</a>
<a name="ln236">///</a>
<a name="ln237">/// @param split  word was split, less bonus</a>
<a name="ln238">static int score_wordcount_adj(slang_T *slang, int score, char_u *word, bool split)</a>
<a name="ln239">{</a>
<a name="ln240">  wordcount_T *wc;</a>
<a name="ln241">  int bonus;</a>
<a name="ln242">  int newscore;</a>
<a name="ln243"> </a>
<a name="ln244">  hashitem_T *hi = hash_find(&amp;slang-&gt;sl_wordcount, (char *)word);</a>
<a name="ln245">  if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln246">    wc = HI2WC(hi);</a>
<a name="ln247">    if (wc-&gt;wc_count &lt; SCORE_THRES2) {</a>
<a name="ln248">      bonus = SCORE_COMMON1;</a>
<a name="ln249">    } else if (wc-&gt;wc_count &lt; SCORE_THRES3) {</a>
<a name="ln250">      bonus = SCORE_COMMON2;</a>
<a name="ln251">    } else {</a>
<a name="ln252">      bonus = SCORE_COMMON3;</a>
<a name="ln253">    }</a>
<a name="ln254">    if (split) {</a>
<a name="ln255">      newscore = score - bonus / 2;</a>
<a name="ln256">    } else {</a>
<a name="ln257">      newscore = score - bonus;</a>
<a name="ln258">    }</a>
<a name="ln259">    if (newscore &lt; 0) {</a>
<a name="ln260">      return 0;</a>
<a name="ln261">    }</a>
<a name="ln262">    return newscore;</a>
<a name="ln263">  }</a>
<a name="ln264">  return score;</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">/// Like captype() but for a KEEPCAP word add ONECAP if the word starts with a</a>
<a name="ln268">/// capital.  So that make_case_word() can turn WOrd into Word.</a>
<a name="ln269">/// Add ALLCAP for &quot;WOrD&quot;.</a>
<a name="ln270">static int badword_captype(char_u *word, char_u *end)</a>
<a name="ln271">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln272">{</a>
<a name="ln273">  int flags = captype(word, end);</a>
<a name="ln274">  int c;</a>
<a name="ln275">  int l, u;</a>
<a name="ln276">  bool first;</a>
<a name="ln277">  char_u *p;</a>
<a name="ln278"> </a>
<a name="ln279">  if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln280">    // Count the number of UPPER and lower case letters.</a>
<a name="ln281">    l = u = 0;</a>
<a name="ln282">    first = false;</a>
<a name="ln283">    for (p = word; p &lt; end; MB_PTR_ADV(p)) {</a>
<a name="ln284">      c = utf_ptr2char((char *)p);</a>
<a name="ln285">      if (SPELL_ISUPPER(c)) {</a>
<a name="ln286">        u++;</a>
<a name="ln287">        if (p == word) {</a>
<a name="ln288">          first = true;</a>
<a name="ln289">        }</a>
<a name="ln290">      } else {</a>
<a name="ln291">        l++;</a>
<a name="ln292">      }</a>
<a name="ln293">    }</a>
<a name="ln294"> </a>
<a name="ln295">    // If there are more UPPER than lower case letters suggest an</a>
<a name="ln296">    // ALLCAP word.  Otherwise, if the first letter is UPPER then</a>
<a name="ln297">    // suggest ONECAP.  Exception: &quot;ALl&quot; most likely should be &quot;All&quot;,</a>
<a name="ln298">    // require three upper case letters.</a>
<a name="ln299">    if (u &gt; l &amp;&amp; u &gt; 2) {</a>
<a name="ln300">      flags |= WF_ALLCAP;</a>
<a name="ln301">    } else if (first) {</a>
<a name="ln302">      flags |= WF_ONECAP;</a>
<a name="ln303">    }</a>
<a name="ln304"> </a>
<a name="ln305">    if (u &gt;= 2 &amp;&amp; l &gt;= 2) {     // maCARONI maCAroni</a>
<a name="ln306">      flags |= WF_MIXCAP;</a>
<a name="ln307">    }</a>
<a name="ln308">  }</a>
<a name="ln309">  return flags;</a>
<a name="ln310">}</a>
<a name="ln311"> </a>
<a name="ln312">/// Opposite of offset2bytes().</a>
<a name="ln313">/// &quot;pp&quot; points to the bytes and is advanced over it.</a>
<a name="ln314">///</a>
<a name="ln315">/// @return  the offset.</a>
<a name="ln316">static int bytes2offset(char_u **pp)</a>
<a name="ln317">{</a>
<a name="ln318">  char_u *p = *pp;</a>
<a name="ln319">  int nr;</a>
<a name="ln320">  int c;</a>
<a name="ln321"> </a>
<a name="ln322">  c = *p++;</a>
<a name="ln323">  if ((c &amp; 0x80) == 0x00) {             // 1 byte</a>
<a name="ln324">    nr = c - 1;</a>
<a name="ln325">  } else if ((c &amp; 0xc0) == 0x80) {      // 2 bytes</a>
<a name="ln326">    nr = (c &amp; 0x3f) - 1;</a>
<a name="ln327">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln328">  } else if ((c &amp; 0xe0) == 0xc0) {      // 3 bytes</a>
<a name="ln329">    nr = (c &amp; 0x1f) - 1;</a>
<a name="ln330">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln331">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln332">  } else {                              // 4 bytes</a>
<a name="ln333">    nr = (c &amp; 0x0f) - 1;</a>
<a name="ln334">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln335">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln336">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln337">  }</a>
<a name="ln338"> </a>
<a name="ln339">  *pp = p;</a>
<a name="ln340">  return nr;</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">// values for sps_flags</a>
<a name="ln344">#define SPS_BEST    1</a>
<a name="ln345">#define SPS_FAST    2</a>
<a name="ln346">#define SPS_DOUBLE  4</a>
<a name="ln347"> </a>
<a name="ln348">static int sps_flags = SPS_BEST;  ///&lt; flags from 'spellsuggest'</a>
<a name="ln349">static int sps_limit = 9999;      ///&lt; max nr of suggestions given</a>
<a name="ln350"> </a>
<a name="ln351">/// Check the 'spellsuggest' option.  Return FAIL if it's wrong.</a>
<a name="ln352">/// Sets &quot;sps_flags&quot; and &quot;sps_limit&quot;.</a>
<a name="ln353">int spell_check_sps(void)</a>
<a name="ln354">{</a>
<a name="ln355">  char *p;</a>
<a name="ln356">  char *s;</a>
<a name="ln357">  char buf[MAXPATHL];</a>
<a name="ln358">  int f;</a>
<a name="ln359"> </a>
<a name="ln360">  sps_flags = 0;</a>
<a name="ln361">  sps_limit = 9999;</a>
<a name="ln362"> </a>
<a name="ln363">  for (p = p_sps; *p != NUL;) {</a>
<a name="ln364">    copy_option_part(&amp;p, (char *)buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln365"> </a>
<a name="ln366">    f = 0;</a>
<a name="ln367">    if (ascii_isdigit(*buf)) {</a>
<a name="ln368">      s = (char *)buf;</a>
<a name="ln369">      sps_limit = getdigits_int(&amp;s, true, 0);</a>
<a name="ln370">      if (*s != NUL &amp;&amp; !ascii_isdigit(*s)) {</a>
<a name="ln371">        f = -1;</a>
<a name="ln372">      }</a>
<a name="ln373">    } else if (strcmp(buf, &quot;best&quot;) == 0) {</a>
<a name="ln374">      f = SPS_BEST;</a>
<a name="ln375">    } else if (strcmp(buf, &quot;fast&quot;) == 0) {</a>
<a name="ln376">      f = SPS_FAST;</a>
<a name="ln377">    } else if (strcmp(buf, &quot;double&quot;) == 0) {</a>
<a name="ln378">      f = SPS_DOUBLE;</a>
<a name="ln379">    } else if (STRNCMP(buf, &quot;expr:&quot;, 5) != 0</a>
<a name="ln380">               &amp;&amp; STRNCMP(buf, &quot;file:&quot;, 5) != 0</a>
<a name="ln381">               &amp;&amp; (STRNCMP(buf, &quot;timeout:&quot;, 8) != 0</a>
<a name="ln382">                   || (!ascii_isdigit(buf[8])</a>
<a name="ln383">                       &amp;&amp; !(buf[8] == '-' &amp;&amp; ascii_isdigit(buf[9]))))) {</a>
<a name="ln384">      f = -1;</a>
<a name="ln385">    }</a>
<a name="ln386"> </a>
<a name="ln387">    if (f == -1 || (sps_flags != 0 &amp;&amp; f != 0)) {</a>
<a name="ln388">      sps_flags = SPS_BEST;</a>
<a name="ln389">      sps_limit = 9999;</a>
<a name="ln390">      return FAIL;</a>
<a name="ln391">    }</a>
<a name="ln392">    if (f != 0) {</a>
<a name="ln393">      sps_flags = f;</a>
<a name="ln394">    }</a>
<a name="ln395">  }</a>
<a name="ln396"> </a>
<a name="ln397">  if (sps_flags == 0) {</a>
<a name="ln398">    sps_flags = SPS_BEST;</a>
<a name="ln399">  }</a>
<a name="ln400"> </a>
<a name="ln401">  return OK;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">/// &quot;z=&quot;: Find badly spelled word under or after the cursor.</a>
<a name="ln405">/// Give suggestions for the properly spelled word.</a>
<a name="ln406">/// In Visual mode use the highlighted word as the bad word.</a>
<a name="ln407">/// When &quot;count&quot; is non-zero use that suggestion.</a>
<a name="ln408">void spell_suggest(int count)</a>
<a name="ln409">{</a>
<a name="ln410">  char *line;</a>
<a name="ln411">  pos_T prev_cursor = curwin-&gt;w_cursor;</a>
<a name="ln412">  char_u wcopy[MAXWLEN + 2];</a>
<a name="ln413">  char_u *p;</a>
<a name="ln414">  int c;</a>
<a name="ln415">  suginfo_T sug;</a>
<a name="ln416">  suggest_T *stp;</a>
<a name="ln417">  int mouse_used;</a>
<a name="ln418">  int need_cap;</a>
<a name="ln419">  int limit;</a>
<a name="ln420">  int selected = count;</a>
<a name="ln421">  int badlen = 0;</a>
<a name="ln422">  int msg_scroll_save = msg_scroll;</a>
<a name="ln423">  const int wo_spell_save = curwin-&gt;w_p_spell;</a>
<a name="ln424"> </a>
<a name="ln425">  if (!curwin-&gt;w_p_spell) {</a>
<a name="ln426">    did_set_spelllang(curwin);</a>
<a name="ln427">    curwin-&gt;w_p_spell = true;</a>
<a name="ln428">  }</a>
<a name="ln429"> </a>
<a name="ln430">  if (*curwin-&gt;w_s-&gt;b_p_spl == NUL) {</a>
<a name="ln431">    emsg(_(e_no_spell));</a>
<a name="ln432">    return;</a>
<a name="ln433">  }</a>
<a name="ln434"> </a>
<a name="ln435">  if (VIsual_active) {</a>
<a name="ln436">    // Use the Visually selected text as the bad word.  But reject</a>
<a name="ln437">    // a multi-line selection.</a>
<a name="ln438">    if (curwin-&gt;w_cursor.lnum != VIsual.lnum) {</a>
<a name="ln439">      vim_beep(BO_SPELL);</a>
<a name="ln440">      return;</a>
<a name="ln441">    }</a>
<a name="ln442">    badlen = (int)curwin-&gt;w_cursor.col - (int)VIsual.col;</a>
<a name="ln443">    if (badlen &lt; 0) {</a>
<a name="ln444">      badlen = -badlen;</a>
<a name="ln445">    } else {</a>
<a name="ln446">      curwin-&gt;w_cursor.col = VIsual.col;</a>
<a name="ln447">    }</a>
<a name="ln448">    badlen++;</a>
<a name="ln449">    end_visual_mode();</a>
<a name="ln450">    // Find the start of the badly spelled word.</a>
<a name="ln451">  } else if (spell_move_to(curwin, FORWARD, true, true, NULL) == 0</a>
<a name="ln452">             || curwin-&gt;w_cursor.col &gt; prev_cursor.col) {</a>
<a name="ln453">    // No bad word or it starts after the cursor: use the word under the</a>
<a name="ln454">    // cursor.</a>
<a name="ln455">    curwin-&gt;w_cursor = prev_cursor;</a>
<a name="ln456">    line = get_cursor_line_ptr();</a>
<a name="ln457">    p = (char_u *)line + curwin-&gt;w_cursor.col;</a>
<a name="ln458">    // Backup to before start of word.</a>
<a name="ln459">    while (p &gt; (char_u *)line &amp;&amp; spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln460">      MB_PTR_BACK(line, p);</a>
<a name="ln461">    }</a>
<a name="ln462">    // Forward to start of word.</a>
<a name="ln463">    while (*p != NUL &amp;&amp; !spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln464">      MB_PTR_ADV(p);</a>
<a name="ln465">    }</a>
<a name="ln466"> </a>
<a name="ln467">    if (!spell_iswordp_nmw(p, curwin)) {                // No word found.</a>
<a name="ln468">      beep_flush();</a>
<a name="ln469">      return;</a>
<a name="ln470">    }</a>
<a name="ln471">    curwin-&gt;w_cursor.col = (colnr_T)(p - (char_u *)line);</a>
<a name="ln472">  }</a>
<a name="ln473"> </a>
<a name="ln474">  // Get the word and its length.</a>
<a name="ln475"> </a>
<a name="ln476">  // Figure out if the word should be capitalised.</a>
<a name="ln477">  need_cap = check_need_cap(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col);</a>
<a name="ln478"> </a>
<a name="ln479">  // Make a copy of current line since autocommands may free the line.</a>
<a name="ln480">  line = xstrdup(get_cursor_line_ptr());</a>
<a name="ln481">  spell_suggest_timeout = 5000;</a>
<a name="ln482"> </a>
<a name="ln483">  // Get the list of suggestions.  Limit to 'lines' - 2 or the number in</a>
<a name="ln484">  // 'spellsuggest', whatever is smaller.</a>
<a name="ln485">  if (sps_limit &gt; Rows - 2) {</a>
<a name="ln486">    limit = Rows - 2;</a>
<a name="ln487">  } else {</a>
<a name="ln488">    limit = sps_limit;</a>
<a name="ln489">  }</a>
<a name="ln490">  spell_find_suggest((char_u *)line + curwin-&gt;w_cursor.col, badlen, &amp;sug, limit,</a>
<a name="ln491">                     true, need_cap, true);</a>
<a name="ln492"> </a>
<a name="ln493">  if (GA_EMPTY(&amp;sug.su_ga)) {</a>
<a name="ln494">    msg(_(&quot;Sorry, no suggestions&quot;));</a>
<a name="ln495">  } else if (count &gt; 0) {</a>
<a name="ln496">    if (count &gt; sug.su_ga.ga_len) {</a>
<a name="ln497">      smsg(_(&quot;Sorry, only %&quot; PRId64 &quot; suggestions&quot;),</a>
<a name="ln498">           (int64_t)sug.su_ga.ga_len);</a>
<a name="ln499">    }</a>
<a name="ln500">  } else {</a>
<a name="ln501">    // When 'rightleft' is set the list is drawn right-left.</a>
<a name="ln502">    cmdmsg_rl = curwin-&gt;w_p_rl;</a>
<a name="ln503">    if (cmdmsg_rl) {</a>
<a name="ln504">      msg_col = Columns - 1;</a>
<a name="ln505">    }</a>
<a name="ln506"> </a>
<a name="ln507">    // List the suggestions.</a>
<a name="ln508">    msg_start();</a>
<a name="ln509">    msg_row = Rows - 1;         // for when 'cmdheight' &gt; 1</a>
<a name="ln510">    lines_left = Rows;          // avoid more prompt</a>
<a name="ln511">    vim_snprintf((char *)IObuff, IOSIZE, _(&quot;Change \&quot;%.*s\&quot; to:&quot;),</a>
<a name="ln512">                 sug.su_badlen, sug.su_badptr);</a>
<a name="ln513">    if (cmdmsg_rl &amp;&amp; STRNCMP(IObuff, &quot;Change&quot;, 6) == 0) {</a>
<a name="ln514">      // And now the rabbit from the high hat: Avoid showing the</a>
<a name="ln515">      // untranslated message rightleft.</a>
<a name="ln516">      vim_snprintf((char *)IObuff, IOSIZE, &quot;:ot \&quot;%.*s\&quot; egnahC&quot;,</a>
<a name="ln517">                   sug.su_badlen, sug.su_badptr);</a>
<a name="ln518">    }</a>
<a name="ln519">    msg_puts((const char *)IObuff);</a>
<a name="ln520">    msg_clr_eos();</a>
<a name="ln521">    msg_putchar('\n');</a>
<a name="ln522"> </a>
<a name="ln523">    msg_scroll = true;</a>
<a name="ln524">    for (int i = 0; i &lt; sug.su_ga.ga_len; i++) {</a>
<a name="ln525">      stp = &amp;SUG(sug.su_ga, i);</a>
<a name="ln526"> </a>
<a name="ln527">      // The suggested word may replace only part of the bad word, add</a>
<a name="ln528">      // the not replaced part.  But only when it's not getting too long.</a>
<a name="ln529">      STRLCPY(wcopy, stp-&gt;st_word, MAXWLEN + 1);</a>
<a name="ln530">      int el = sug.su_badlen - stp-&gt;st_orglen;</a>
<a name="ln531">      if (el &gt; 0 &amp;&amp; stp-&gt;st_wordlen + el &lt;= MAXWLEN) {</a>
<a name="ln532">        STRLCPY(wcopy + stp-&gt;st_wordlen, sug.su_badptr + stp-&gt;st_orglen, el + 1);</a>
<a name="ln533">      }</a>
<a name="ln534">      vim_snprintf((char *)IObuff, IOSIZE, &quot;%2d&quot;, i + 1);</a>
<a name="ln535">      if (cmdmsg_rl) {</a>
<a name="ln536">        rl_mirror(IObuff);</a>
<a name="ln537">      }</a>
<a name="ln538">      msg_puts((const char *)IObuff);</a>
<a name="ln539"> </a>
<a name="ln540">      vim_snprintf((char *)IObuff, IOSIZE, &quot; \&quot;%s\&quot;&quot;, wcopy);</a>
<a name="ln541">      msg_puts((const char *)IObuff);</a>
<a name="ln542"> </a>
<a name="ln543">      // The word may replace more than &quot;su_badlen&quot;.</a>
<a name="ln544">      if (sug.su_badlen &lt; stp-&gt;st_orglen) {</a>
<a name="ln545">        vim_snprintf((char *)IObuff, IOSIZE, _(&quot; &lt; \&quot;%.*s\&quot;&quot;),</a>
<a name="ln546">                     stp-&gt;st_orglen, sug.su_badptr);</a>
<a name="ln547">        msg_puts((const char *)IObuff);</a>
<a name="ln548">      }</a>
<a name="ln549"> </a>
<a name="ln550">      if (p_verbose &gt; 0) {</a>
<a name="ln551">        // Add the score.</a>
<a name="ln552">        if (sps_flags &amp; (SPS_DOUBLE | SPS_BEST)) {</a>
<a name="ln553">          vim_snprintf((char *)IObuff, IOSIZE, &quot; (%s%d - %d)&quot;,</a>
<a name="ln554">                       stp-&gt;st_salscore ? &quot;s &quot; : &quot;&quot;,</a>
<a name="ln555">                       stp-&gt;st_score, stp-&gt;st_altscore);</a>
<a name="ln556">        } else {</a>
<a name="ln557">          vim_snprintf((char *)IObuff, IOSIZE, &quot; (%d)&quot;,</a>
<a name="ln558">                       stp-&gt;st_score);</a>
<a name="ln559">        }</a>
<a name="ln560">        if (cmdmsg_rl) {</a>
<a name="ln561">          // Mirror the numbers, but keep the leading space.</a>
<a name="ln562">          rl_mirror(IObuff + 1);</a>
<a name="ln563">        }</a>
<a name="ln564">        msg_advance(30);</a>
<a name="ln565">        msg_puts((const char *)IObuff);</a>
<a name="ln566">      }</a>
<a name="ln567">      msg_putchar('\n');</a>
<a name="ln568">    }</a>
<a name="ln569"> </a>
<a name="ln570">    cmdmsg_rl = false;</a>
<a name="ln571">    msg_col = 0;</a>
<a name="ln572">    // Ask for choice.</a>
<a name="ln573">    selected = prompt_for_number(&amp;mouse_used);</a>
<a name="ln574"> </a>
<a name="ln575">    if (ui_has(kUIMessages)) {</a>
<a name="ln576">      ui_call_msg_clear();</a>
<a name="ln577">    }</a>
<a name="ln578"> </a>
<a name="ln579">    if (mouse_used) {</a>
<a name="ln580">      selected -= lines_left;</a>
<a name="ln581">    }</a>
<a name="ln582">    lines_left = Rows;                  // avoid more prompt</a>
<a name="ln583">    // don't delay for 'smd' in normal_cmd()</a>
<a name="ln584">    msg_scroll = msg_scroll_save;</a>
<a name="ln585">  }</a>
<a name="ln586"> </a>
<a name="ln587">  if (selected &gt; 0 &amp;&amp; selected &lt;= sug.su_ga.ga_len &amp;&amp; u_save_cursor() == OK) {</a>
<a name="ln588">    // Save the from and to text for :spellrepall.</a>
<a name="ln589">    XFREE_CLEAR(repl_from);</a>
<a name="ln590">    XFREE_CLEAR(repl_to);</a>
<a name="ln591"> </a>
<a name="ln592">    stp = &amp;SUG(sug.su_ga, selected - 1);</a>
<a name="ln593">    if (sug.su_badlen &gt; stp-&gt;st_orglen) {</a>
<a name="ln594">      // Replacing less than &quot;su_badlen&quot;, append the remainder to</a>
<a name="ln595">      // repl_to.</a>
<a name="ln596">      repl_from = xstrnsave((char *)sug.su_badptr, (size_t)sug.su_badlen);</a>
<a name="ln597">      vim_snprintf((char *)IObuff, IOSIZE, &quot;%s%.*s&quot;, stp-&gt;st_word,</a>
<a name="ln598">                   sug.su_badlen - stp-&gt;st_orglen,</a>
<a name="ln599">                   sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln600">      repl_to = xstrdup((char *)IObuff);</a>
<a name="ln601">    } else {</a>
<a name="ln602">      // Replacing su_badlen or more, use the whole word.</a>
<a name="ln603">      repl_from = xstrnsave((char *)sug.su_badptr, (size_t)stp-&gt;st_orglen);</a>
<a name="ln604">      repl_to = xstrdup(stp-&gt;st_word);</a>
<a name="ln605">    }</a>
<a name="ln606"> </a>
<a name="ln607">    // Replace the word.</a>
<a name="ln608">    p = xmalloc(STRLEN(line) - (size_t)stp-&gt;st_orglen + (size_t)stp-&gt;st_wordlen + 1);</a>
<a name="ln609">    c = (int)(sug.su_badptr - (char_u *)line);</a>
<a name="ln610">    memmove(p, line, (size_t)c);</a>
<a name="ln611">    STRCPY(p + c, stp-&gt;st_word);</a>
<a name="ln612">    STRCAT(p, sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln613"> </a>
<a name="ln614">    // For redo we use a change-word command.</a>
<a name="ln615">    ResetRedobuff();</a>
<a name="ln616">    AppendToRedobuff(&quot;ciw&quot;);</a>
<a name="ln617">    AppendToRedobuffLit((char *)p + c,</a>
<a name="ln618">                        stp-&gt;st_wordlen + sug.su_badlen - stp-&gt;st_orglen);</a>
<a name="ln619">    AppendCharToRedobuff(ESC);</a>
<a name="ln620"> </a>
<a name="ln621">    // &quot;p&quot; may be freed here</a>
<a name="ln622">    ml_replace(curwin-&gt;w_cursor.lnum, (char *)p, false);</a>
<a name="ln623">    curwin-&gt;w_cursor.col = c;</a>
<a name="ln624"> </a>
<a name="ln625">    inserted_bytes(curwin-&gt;w_cursor.lnum, c, stp-&gt;st_orglen, stp-&gt;st_wordlen);</a>
<a name="ln626">  } else {</a>
<a name="ln627">    curwin-&gt;w_cursor = prev_cursor;</a>
<a name="ln628">  }</a>
<a name="ln629"> </a>
<a name="ln630">  spell_find_cleanup(&amp;sug);</a>
<a name="ln631">  xfree(line);</a>
<a name="ln632">  curwin-&gt;w_p_spell = wo_spell_save;</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">/// Find spell suggestions for &quot;word&quot;.  Return them in the growarray &quot;*gap&quot; as</a>
<a name="ln636">/// a list of allocated strings.</a>
<a name="ln637">///</a>
<a name="ln638">/// @param maxcount  maximum nr of suggestions</a>
<a name="ln639">/// @param need_cap  'spellcapcheck' matched</a>
<a name="ln640">void spell_suggest_list(garray_T *gap, char_u *word, int maxcount, bool need_cap, bool interactive)</a>
<a name="ln641">{</a>
<a name="ln642">  suginfo_T sug;</a>
<a name="ln643">  suggest_T *stp;</a>
<a name="ln644">  char_u *wcopy;</a>
<a name="ln645"> </a>
<a name="ln646">  spell_find_suggest(word, 0, &amp;sug, maxcount, false, need_cap, interactive);</a>
<a name="ln647"> </a>
<a name="ln648">  // Make room in &quot;gap&quot;.</a>
<a name="ln649">  ga_init(gap, sizeof(char_u *), sug.su_ga.ga_len + 1);</a>
<a name="ln650">  ga_grow(gap, sug.su_ga.ga_len);</a>
<a name="ln651">  for (int i = 0; i &lt; sug.su_ga.ga_len; i++) {</a>
<a name="ln652">    stp = &amp;SUG(sug.su_ga, i);</a>
<a name="ln653"> </a>
<a name="ln654">    // The suggested word may replace only part of &quot;word&quot;, add the not</a>
<a name="ln655">    // replaced part.</a>
<a name="ln656">    wcopy = xmalloc((size_t)stp-&gt;st_wordlen + STRLEN(sug.su_badptr + stp-&gt;st_orglen) + 1);</a>
<a name="ln657">    STRCPY(wcopy, stp-&gt;st_word);</a>
<a name="ln658">    STRCPY(wcopy + stp-&gt;st_wordlen, sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln659">    ((char_u **)gap-&gt;ga_data)[gap-&gt;ga_len++] = wcopy;</a>
<a name="ln660">  }</a>
<a name="ln661"> </a>
<a name="ln662">  spell_find_cleanup(&amp;sug);</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">/// Find spell suggestions for the word at the start of &quot;badptr&quot;.</a>
<a name="ln666">/// Return the suggestions in &quot;su-&gt;su_ga&quot;.</a>
<a name="ln667">/// The maximum number of suggestions is &quot;maxcount&quot;.</a>
<a name="ln668">/// Note: does use info for the current window.</a>
<a name="ln669">/// This is based on the mechanisms of Aspell, but completely reimplemented.</a>
<a name="ln670">///</a>
<a name="ln671">/// @param badlen  length of bad word or 0 if unknown</a>
<a name="ln672">/// @param banbadword  don't include badword in suggestions</a>
<a name="ln673">/// @param need_cap  word should start with capital</a>
<a name="ln674">static void spell_find_suggest(char_u *badptr, int badlen, suginfo_T *su, int maxcount,</a>
<a name="ln675">                               bool banbadword, bool need_cap, bool interactive)</a>
<a name="ln676">{</a>
<a name="ln677">  hlf_T attr = HLF_COUNT;</a>
<a name="ln678">  char_u buf[MAXPATHL];</a>
<a name="ln679">  char *p;</a>
<a name="ln680">  bool do_combine = false;</a>
<a name="ln681">  char *sps_copy;</a>
<a name="ln682">  static bool expr_busy = false;</a>
<a name="ln683">  int c;</a>
<a name="ln684">  langp_T *lp;</a>
<a name="ln685">  bool did_intern = false;</a>
<a name="ln686"> </a>
<a name="ln687">  // Set the info in &quot;*su&quot;.</a>
<a name="ln688">  CLEAR_POINTER(su);</a>
<a name="ln689">  ga_init(&amp;su-&gt;su_ga, (int)sizeof(suggest_T), 10);</a>
<a name="ln690">  ga_init(&amp;su-&gt;su_sga, (int)sizeof(suggest_T), 10);</a>
<a name="ln691">  if (*badptr == NUL) {</a>
<a name="ln692">    return;</a>
<a name="ln693">  }</a>
<a name="ln694">  hash_init(&amp;su-&gt;su_banned);</a>
<a name="ln695"> </a>
<a name="ln696">  su-&gt;su_badptr = badptr;</a>
<a name="ln697">  if (badlen != 0) {</a>
<a name="ln698">    su-&gt;su_badlen = badlen;</a>
<a name="ln699">  } else {</a>
<a name="ln700">    size_t tmplen = spell_check(curwin, su-&gt;su_badptr, &amp;attr, NULL, false);</a>
<a name="ln701">    assert(tmplen &lt;= INT_MAX);</a>
<a name="ln702">    su-&gt;su_badlen = (int)tmplen;</a>
<a name="ln703">  }</a>
<a name="ln704">  su-&gt;su_maxcount = maxcount;</a>
<a name="ln705">  su-&gt;su_maxscore = SCORE_MAXINIT;</a>
<a name="ln706"> </a>
<a name="ln707">  if (su-&gt;su_badlen &gt;= MAXWLEN) {</a>
<a name="ln708">    su-&gt;su_badlen = MAXWLEN - 1;        // just in case</a>
<a name="ln709">  }</a>
<a name="ln710">  STRLCPY(su-&gt;su_badword, su-&gt;su_badptr, su-&gt;su_badlen + 1);</a>
<a name="ln711">  (void)spell_casefold(curwin, su-&gt;su_badptr, su-&gt;su_badlen, su-&gt;su_fbadword,</a>
<a name="ln712">                       MAXWLEN);</a>
<a name="ln713"> </a>
<a name="ln714">  // TODO(vim): make this work if the case-folded text is longer than the</a>
<a name="ln715">  // original text. Currently an illegal byte causes wrong pointer</a>
<a name="ln716">  // computations.</a>
<a name="ln717">  su-&gt;su_fbadword[su-&gt;su_badlen] = NUL;</a>
<a name="ln718"> </a>
<a name="ln719">  // get caps flags for bad word</a>
<a name="ln720">  su-&gt;su_badflags = badword_captype(su-&gt;su_badptr,</a>
<a name="ln721">                                    su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln722">  if (need_cap) {</a>
<a name="ln723">    su-&gt;su_badflags |= WF_ONECAP;</a>
<a name="ln724">  }</a>
<a name="ln725"> </a>
<a name="ln726">  // Find the default language for sound folding.  We simply use the first</a>
<a name="ln727">  // one in 'spelllang' that supports sound folding.  That's good for when</a>
<a name="ln728">  // using multiple files for one language, it's not that bad when mixing</a>
<a name="ln729">  // languages (e.g., &quot;pl,en&quot;).</a>
<a name="ln730">  for (int i = 0; i &lt; curbuf-&gt;b_s.b_langp.ga_len; i++) {</a>
<a name="ln731">    lp = LANGP_ENTRY(curbuf-&gt;b_s.b_langp, i);</a>
<a name="ln732">    if (lp-&gt;lp_sallang != NULL) {</a>
<a name="ln733">      su-&gt;su_sallang = lp-&gt;lp_sallang;</a>
<a name="ln734">      break;</a>
<a name="ln735">    }</a>
<a name="ln736">  }</a>
<a name="ln737"> </a>
<a name="ln738">  // Soundfold the bad word with the default sound folding, so that we don't</a>
<a name="ln739">  // have to do this many times.</a>
<a name="ln740">  if (su-&gt;su_sallang != NULL) {</a>
<a name="ln741">    spell_soundfold(su-&gt;su_sallang, su-&gt;su_fbadword, true,</a>
<a name="ln742">                    su-&gt;su_sal_badword);</a>
<a name="ln743">  }</a>
<a name="ln744"> </a>
<a name="ln745">  // If the word is not capitalised and spell_check() doesn't consider the</a>
<a name="ln746">  // word to be bad then it might need to be capitalised.  Add a suggestion</a>
<a name="ln747">  // for that.</a>
<a name="ln748">  c = utf_ptr2char((char *)su-&gt;su_badptr);</a>
<a name="ln749">  if (!SPELL_ISUPPER(c) &amp;&amp; attr == HLF_COUNT) {</a>
<a name="ln750">    make_case_word(su-&gt;su_badword, buf, WF_ONECAP);</a>
<a name="ln751">    add_suggestion(su, &amp;su-&gt;su_ga, (char *)buf, su-&gt;su_badlen, SCORE_ICASE,</a>
<a name="ln752">                   0, true, su-&gt;su_sallang, false);</a>
<a name="ln753">  }</a>
<a name="ln754"> </a>
<a name="ln755">  // Ban the bad word itself.  It may appear in another region.</a>
<a name="ln756">  if (banbadword) {</a>
<a name="ln757">    add_banned(su, su-&gt;su_badword);</a>
<a name="ln758">  }</a>
<a name="ln759"> </a>
<a name="ln760">  // Make a copy of 'spellsuggest', because the expression may change it.</a>
<a name="ln761">  sps_copy = xstrdup(p_sps);</a>
<a name="ln762"> </a>
<a name="ln763">  // Loop over the items in 'spellsuggest'.</a>
<a name="ln764">  for (p = sps_copy; *p != NUL;) {</a>
<a name="ln765">    copy_option_part(&amp;p, (char *)buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln766"> </a>
<a name="ln767">    if (STRNCMP(buf, &quot;expr:&quot;, 5) == 0) {</a>
<a name="ln768">      // Evaluate an expression.  Skip this when called recursively,</a>
<a name="ln769">      // when using spellsuggest() in the expression.</a>
<a name="ln770">      if (!expr_busy) {</a>
<a name="ln771">        expr_busy = true;</a>
<a name="ln772">        spell_suggest_expr(su, buf + 5);</a>
<a name="ln773">        expr_busy = false;</a>
<a name="ln774">      }</a>
<a name="ln775">    } else if (STRNCMP(buf, &quot;file:&quot;, 5) == 0) {</a>
<a name="ln776">      // Use list of suggestions in a file.</a>
<a name="ln777">      spell_suggest_file(su, buf + 5);</a>
<a name="ln778">    } else if (STRNCMP(buf, &quot;timeout:&quot;, 8) == 0) {</a>
<a name="ln779">      // Limit the time searching for suggestions.</a>
<a name="ln780">      spell_suggest_timeout = atol((char *)buf + 8);</a>
<a name="ln781">    } else if (!did_intern) {</a>
<a name="ln782">      // Use internal method once.</a>
<a name="ln783">      spell_suggest_intern(su, interactive);</a>
<a name="ln784">      if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln785">        do_combine = true;</a>
<a name="ln786">      }</a>
<a name="ln787">      did_intern = true;</a>
<a name="ln788">    }</a>
<a name="ln789">  }</a>
<a name="ln790"> </a>
<a name="ln791">  xfree(sps_copy);</a>
<a name="ln792"> </a>
<a name="ln793">  if (do_combine) {</a>
<a name="ln794">    // Combine the two list of suggestions.  This must be done last,</a>
<a name="ln795">    // because sorting changes the order again.</a>
<a name="ln796">    score_combine(su);</a>
<a name="ln797">  }</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800">/// Find suggestions by evaluating expression &quot;expr&quot;.</a>
<a name="ln801">static void spell_suggest_expr(suginfo_T *su, char_u *expr)</a>
<a name="ln802">{</a>
<a name="ln803">  int score;</a>
<a name="ln804">  const char *p;</a>
<a name="ln805"> </a>
<a name="ln806">  // The work is split up in a few parts to avoid having to export</a>
<a name="ln807">  // suginfo_T.</a>
<a name="ln808">  // First evaluate the expression and get the resulting list.</a>
<a name="ln809">  list_T *const list = eval_spell_expr((char *)su-&gt;su_badword, (char *)expr);</a>
<a name="ln810">  if (list != NULL) {</a>
<a name="ln811">    // Loop over the items in the list.</a>
<a name="ln812">    TV_LIST_ITER(list, li, {</a>
<a name="ln813">      if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_LIST) {</a>
<a name="ln814">        // Get the word and the score from the items.</a>
<a name="ln815">        score = get_spellword(TV_LIST_ITEM_TV(li)-&gt;vval.v_list, &amp;p);</a>
<a name="ln816">        if (score &gt;= 0 &amp;&amp; score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln817">          add_suggestion(su, &amp;su-&gt;su_ga, p, su-&gt;su_badlen,</a>
<a name="ln818">                         score, 0, true, su-&gt;su_sallang, false);</a>
<a name="ln819">        }</a>
<a name="ln820">      }</a>
<a name="ln821">    });</a>
<a name="ln822">    tv_list_unref(list);</a>
<a name="ln823">  }</a>
<a name="ln824"> </a>
<a name="ln825">  // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln826">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln827">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln828">}</a>
<a name="ln829"> </a>
<a name="ln830">/// Find suggestions in file &quot;fname&quot;.  Used for &quot;file:&quot; in 'spellsuggest'.</a>
<a name="ln831">static void spell_suggest_file(suginfo_T *su, char_u *fname)</a>
<a name="ln832">{</a>
<a name="ln833">  FILE *fd;</a>
<a name="ln834">  char_u line[MAXWLEN * 2];</a>
<a name="ln835">  char_u *p;</a>
<a name="ln836">  int len;</a>
<a name="ln837">  char_u cword[MAXWLEN];</a>
<a name="ln838"> </a>
<a name="ln839">  // Open the file.</a>
<a name="ln840">  fd = os_fopen((char *)fname, &quot;r&quot;);</a>
<a name="ln841">  if (fd == NULL) {</a>
<a name="ln842">    semsg(_(e_notopen), fname);</a>
<a name="ln843">    return;</a>
<a name="ln844">  }</a>
<a name="ln845"> </a>
<a name="ln846">  // Read it line by line.</a>
<a name="ln847">  while (!vim_fgets(line, MAXWLEN * 2, fd) &amp;&amp; !got_int) {</a>
<a name="ln848">    line_breakcheck();</a>
<a name="ln849"> </a>
<a name="ln850">    p = (char_u *)vim_strchr((char *)line, '/');</a>
<a name="ln851">    if (p == NULL) {</a>
<a name="ln852">      continue;             // No Tab found, just skip the line.</a>
<a name="ln853">    }</a>
<a name="ln854">    *p++ = NUL;</a>
<a name="ln855">    if (STRICMP(su-&gt;su_badword, line) == 0) {</a>
<a name="ln856">      // Match!  Isolate the good word, until CR or NL.</a>
<a name="ln857">      for (len = 0; p[len] &gt;= ' '; len++) {}</a>
<a name="ln858">      p[len] = NUL;</a>
<a name="ln859"> </a>
<a name="ln860">      // If the suggestion doesn't have specific case duplicate the case</a>
<a name="ln861">      // of the bad word.</a>
<a name="ln862">      if (captype(p, NULL) == 0) {</a>
<a name="ln863">        make_case_word(p, cword, su-&gt;su_badflags);</a>
<a name="ln864">        p = cword;</a>
<a name="ln865">      }</a>
<a name="ln866"> </a>
<a name="ln867">      add_suggestion(su, &amp;su-&gt;su_ga, (char *)p, su-&gt;su_badlen,</a>
<a name="ln868">                     SCORE_FILE, 0, true, su-&gt;su_sallang, false);</a>
<a name="ln869">    }</a>
<a name="ln870">  }</a>
<a name="ln871"> </a>
<a name="ln872">  fclose(fd);</a>
<a name="ln873"> </a>
<a name="ln874">  // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln875">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln876">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln877">}</a>
<a name="ln878"> </a>
<a name="ln879">/// Find suggestions for the internal method indicated by &quot;sps_flags&quot;.</a>
<a name="ln880">static void spell_suggest_intern(suginfo_T *su, bool interactive)</a>
<a name="ln881">{</a>
<a name="ln882">  // Load the .sug file(s) that are available and not done yet.</a>
<a name="ln883">  suggest_load_files();</a>
<a name="ln884"> </a>
<a name="ln885">  // 1. Try special cases, such as repeating a word: &quot;the the&quot; -&gt; &quot;the&quot;.</a>
<a name="ln886">  //</a>
<a name="ln887">  // Set a maximum score to limit the combination of operations that is</a>
<a name="ln888">  // tried.</a>
<a name="ln889">  suggest_try_special(su);</a>
<a name="ln890"> </a>
<a name="ln891">  // 2. Try inserting/deleting/swapping/changing a letter, use REP entries</a>
<a name="ln892">  //    from the .aff file and inserting a space (split the word).</a>
<a name="ln893">  suggest_try_change(su);</a>
<a name="ln894"> </a>
<a name="ln895">  // For the resulting top-scorers compute the sound-a-like score.</a>
<a name="ln896">  if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln897">    score_comp_sal(su);</a>
<a name="ln898">  }</a>
<a name="ln899"> </a>
<a name="ln900">  // 3. Try finding sound-a-like words.</a>
<a name="ln901">  if ((sps_flags &amp; SPS_FAST) == 0) {</a>
<a name="ln902">    if (sps_flags &amp; SPS_BEST) {</a>
<a name="ln903">      // Adjust the word score for the suggestions found so far for how</a>
<a name="ln904">      // they sounds like.</a>
<a name="ln905">      rescore_suggestions(su);</a>
<a name="ln906">    }</a>
<a name="ln907"> </a>
<a name="ln908">    // While going through the soundfold tree &quot;su_maxscore&quot; is the score</a>
<a name="ln909">    // for the soundfold word, limits the changes that are being tried,</a>
<a name="ln910">    // and &quot;su_sfmaxscore&quot; the rescored score, which is set by</a>
<a name="ln911">    // cleanup_suggestions().</a>
<a name="ln912">    // First find words with a small edit distance, because this is much</a>
<a name="ln913">    // faster and often already finds the top-N suggestions.  If we didn't</a>
<a name="ln914">    // find many suggestions try again with a higher edit distance.</a>
<a name="ln915">    // &quot;sl_sounddone&quot; is used to avoid doing the same word twice.</a>
<a name="ln916">    suggest_try_soundalike_prep();</a>
<a name="ln917">    su-&gt;su_maxscore = SCORE_SFMAX1;</a>
<a name="ln918">    su-&gt;su_sfmaxscore = SCORE_MAXINIT * 3;</a>
<a name="ln919">    suggest_try_soundalike(su);</a>
<a name="ln920">    if (su-&gt;su_ga.ga_len &lt; SUG_CLEAN_COUNT(su)) {</a>
<a name="ln921">      // We didn't find enough matches, try again, allowing more</a>
<a name="ln922">      // changes to the soundfold word.</a>
<a name="ln923">      su-&gt;su_maxscore = SCORE_SFMAX2;</a>
<a name="ln924">      suggest_try_soundalike(su);</a>
<a name="ln925">      if (su-&gt;su_ga.ga_len &lt; SUG_CLEAN_COUNT(su)) {</a>
<a name="ln926">        // Still didn't find enough matches, try again, allowing even</a>
<a name="ln927">        // more changes to the soundfold word.</a>
<a name="ln928">        su-&gt;su_maxscore = SCORE_SFMAX3;</a>
<a name="ln929">        suggest_try_soundalike(su);</a>
<a name="ln930">      }</a>
<a name="ln931">    }</a>
<a name="ln932">    su-&gt;su_maxscore = su-&gt;su_sfmaxscore;</a>
<a name="ln933">    suggest_try_soundalike_finish();</a>
<a name="ln934">  }</a>
<a name="ln935"> </a>
<a name="ln936">  // When CTRL-C was hit while searching do show the results.  Only clear</a>
<a name="ln937">  // got_int when using a command, not for spellsuggest().</a>
<a name="ln938">  os_breakcheck();</a>
<a name="ln939">  if (interactive &amp;&amp; got_int) {</a>
<a name="ln940">    (void)vgetc();</a>
<a name="ln941">    got_int = false;</a>
<a name="ln942">  }</a>
<a name="ln943"> </a>
<a name="ln944">  if ((sps_flags &amp; SPS_DOUBLE) == 0 &amp;&amp; su-&gt;su_ga.ga_len != 0) {</a>
<a name="ln945">    if (sps_flags &amp; SPS_BEST) {</a>
<a name="ln946">      // Adjust the word score for how it sounds like.</a>
<a name="ln947">      rescore_suggestions(su);</a>
<a name="ln948">    }</a>
<a name="ln949"> </a>
<a name="ln950">    // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln951">    check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln952">    (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln953">  }</a>
<a name="ln954">}</a>
<a name="ln955"> </a>
<a name="ln956">/// Free the info put in &quot;*su&quot; by spell_find_suggest().</a>
<a name="ln957">static void spell_find_cleanup(suginfo_T *su)</a>
<a name="ln958">{</a>
<a name="ln959">#define FREE_SUG_WORD(sug) xfree((sug)-&gt;st_word)</a>
<a name="ln960">  // Free the suggestions.</a>
<a name="ln961">  GA_DEEP_CLEAR(&amp;su-&gt;su_ga, suggest_T, FREE_SUG_WORD);</a>
<a name="ln962">  GA_DEEP_CLEAR(&amp;su-&gt;su_sga, suggest_T, FREE_SUG_WORD);</a>
<a name="ln963"> </a>
<a name="ln964">  // Free the banned words.</a>
<a name="ln965">  hash_clear_all(&amp;su-&gt;su_banned, 0);</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968">/// Try finding suggestions by recognizing specific situations.</a>
<a name="ln969">static void suggest_try_special(suginfo_T *su)</a>
<a name="ln970">{</a>
<a name="ln971">  int c;</a>
<a name="ln972">  char_u word[MAXWLEN];</a>
<a name="ln973"> </a>
<a name="ln974">  // Recognize a word that is repeated: &quot;the the&quot;.</a>
<a name="ln975">  char_u *p = (char_u *)skiptowhite((char *)su-&gt;su_fbadword);</a>
<a name="ln976">  size_t len = (size_t)(p - su-&gt;su_fbadword);</a>
<a name="ln977">  p = (char_u *)skipwhite((char *)p);</a>
<a name="ln978">  if (STRLEN(p) == len &amp;&amp; STRNCMP(su-&gt;su_fbadword, p, len) == 0) {</a>
<a name="ln979">    // Include badflags: if the badword is onecap or allcap</a>
<a name="ln980">    // use that for the goodword too: &quot;The the&quot; -&gt; &quot;The&quot;.</a>
<a name="ln981">    c = su-&gt;su_fbadword[len];</a>
<a name="ln982">    su-&gt;su_fbadword[len] = NUL;</a>
<a name="ln983">    make_case_word(su-&gt;su_fbadword, word, su-&gt;su_badflags);</a>
<a name="ln984">    su-&gt;su_fbadword[len] = (char_u)c;</a>
<a name="ln985"> </a>
<a name="ln986">    // Give a soundalike score of 0, compute the score as if deleting one</a>
<a name="ln987">    // character.</a>
<a name="ln988">    add_suggestion(su, &amp;su-&gt;su_ga, (char *)word, su-&gt;su_badlen,</a>
<a name="ln989">                   RESCORE(SCORE_REP, 0), 0, true, su-&gt;su_sallang, false);</a>
<a name="ln990">  }</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993">// Measure how much time is spent in each state.</a>
<a name="ln994">// Output is dumped in &quot;suggestprof&quot;.</a>
<a name="ln995"> </a>
<a name="ln996">#ifdef SUGGEST_PROFILE</a>
<a name="ln997">proftime_T current;</a>
<a name="ln998">proftime_T total;</a>
<a name="ln999">proftime_T times[STATE_FINAL + 1];</a>
<a name="ln1000">long counts[STATE_FINAL + 1];</a>
<a name="ln1001"> </a>
<a name="ln1002">static void prof_init(void)</a>
<a name="ln1003">{</a>
<a name="ln1004">  for (int i = 0; i &lt;= STATE_FINAL; i++) {</a>
<a name="ln1005">    profile_zero(&amp;times[i]);</a>
<a name="ln1006">    counts[i] = 0;</a>
<a name="ln1007">  }</a>
<a name="ln1008">  profile_start(&amp;current);</a>
<a name="ln1009">  profile_start(&amp;total);</a>
<a name="ln1010">}</a>
<a name="ln1011"> </a>
<a name="ln1012">/// call before changing state</a>
<a name="ln1013">static void prof_store(state_T state)</a>
<a name="ln1014">{</a>
<a name="ln1015">  profile_end(&amp;current);</a>
<a name="ln1016">  profile_add(&amp;times[state], &amp;current);</a>
<a name="ln1017">  counts[state]++;</a>
<a name="ln1018">  profile_start(&amp;current);</a>
<a name="ln1019">}</a>
<a name="ln1020"># define PROF_STORE(state) prof_store(state);</a>
<a name="ln1021"> </a>
<a name="ln1022">static void prof_report(char *name)</a>
<a name="ln1023">{</a>
<a name="ln1024">  FILE *fd = fopen(&quot;suggestprof&quot;, &quot;a&quot;);</a>
<a name="ln1025"> </a>
<a name="ln1026">  profile_end(&amp;total);</a>
<a name="ln1027">  fprintf(fd, &quot;-----------------------\n&quot;);</a>
<a name="ln1028">  fprintf(fd, &quot;%s: %s\n&quot;, name, profile_msg(&amp;total));</a>
<a name="ln1029">  for (int i = 0; i &lt;= STATE_FINAL; i++) {</a>
<a name="ln1030">    fprintf(fd, &quot;%d: %s (&quot;%&quot; PRId64)\n&quot;, i, profile_msg(&amp;times[i]), counts[i]);</a>
<a name="ln1031">  }</a>
<a name="ln1032">  fclose(fd);</a>
<a name="ln1033">}</a>
<a name="ln1034">#else</a>
<a name="ln1035"># define PROF_STORE(state)</a>
<a name="ln1036">#endif</a>
<a name="ln1037"> </a>
<a name="ln1038">/// Try finding suggestions by adding/removing/swapping letters.</a>
<a name="ln1039">static void suggest_try_change(suginfo_T *su)</a>
<a name="ln1040">{</a>
<a name="ln1041">  char_u fword[MAXWLEN];            // copy of the bad word, case-folded</a>
<a name="ln1042">  int n;</a>
<a name="ln1043">  char_u *p;</a>
<a name="ln1044">  langp_T *lp;</a>
<a name="ln1045"> </a>
<a name="ln1046">  // We make a copy of the case-folded bad word, so that we can modify it</a>
<a name="ln1047">  // to find matches (esp. REP items).  Append some more text, changing</a>
<a name="ln1048">  // chars after the bad word may help.</a>
<a name="ln1049">  STRCPY(fword, su-&gt;su_fbadword);</a>
<a name="ln1050">  n = (int)STRLEN(fword);</a>
<a name="ln1051">  p = su-&gt;su_badptr + su-&gt;su_badlen;</a>
<a name="ln1052">  (void)spell_casefold(curwin, p, (int)STRLEN(p), fword + n, MAXWLEN - n);</a>
<a name="ln1053"> </a>
<a name="ln1054">  // Make sure the resulting text is not longer than the original text.</a>
<a name="ln1055">  n = (int)STRLEN(su-&gt;su_badptr);</a>
<a name="ln1056">  if (n &lt; MAXWLEN) {</a>
<a name="ln1057">    fword[n] = NUL;</a>
<a name="ln1058">  }</a>
<a name="ln1059"> </a>
<a name="ln1060">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln1061">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln1062"> </a>
<a name="ln1063">    // If reloading a spell file fails it's still in the list but</a>
<a name="ln1064">    // everything has been cleared.</a>
<a name="ln1065">    if (lp-&gt;lp_slang-&gt;sl_fbyts == NULL) {</a>
<a name="ln1066">      continue;</a>
<a name="ln1067">    }</a>
<a name="ln1068"> </a>
<a name="ln1069">    // Try it for this language.  Will add possible suggestions.</a>
<a name="ln1070">#ifdef SUGGEST_PROFILE</a>
<a name="ln1071">    prof_init();</a>
<a name="ln1072">#endif</a>
<a name="ln1073">    suggest_trie_walk(su, lp, fword, false);</a>
<a name="ln1074">#ifdef SUGGEST_PROFILE</a>
<a name="ln1075">    prof_report(&quot;try_change&quot;);</a>
<a name="ln1076">#endif</a>
<a name="ln1077">  }</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">// Check the maximum score, if we go over it we won't try this change.</a>
<a name="ln1081">#define TRY_DEEPER(su, stack, depth, add) \</a>
<a name="ln1082">  ((depth) &lt; MAXWLEN - 1 &amp;&amp; (stack)[depth].ts_score + (add) &lt; (su)-&gt;su_maxscore)</a>
<a name="ln1083"> </a>
<a name="ln1084">/// Try finding suggestions by adding/removing/swapping letters.</a>
<a name="ln1085">///</a>
<a name="ln1086">/// This uses a state machine.  At each node in the tree we try various</a>
<a name="ln1087">/// operations.  When trying if an operation works &quot;depth&quot; is increased and the</a>
<a name="ln1088">/// stack[] is used to store info.  This allows combinations, thus insert one</a>
<a name="ln1089">/// character, replace one and delete another.  The number of changes is</a>
<a name="ln1090">/// limited by su-&gt;su_maxscore.</a>
<a name="ln1091">///</a>
<a name="ln1092">/// After implementing this I noticed an article by Kemal Oflazer that</a>
<a name="ln1093">/// describes something similar: &quot;Error-tolerant Finite State Recognition with</a>
<a name="ln1094">/// Applications to Morphological Analysis and Spelling Correction&quot; (1996).</a>
<a name="ln1095">/// The implementation in the article is simplified and requires a stack of</a>
<a name="ln1096">/// unknown depth.  The implementation here only needs a stack depth equal to</a>
<a name="ln1097">/// the length of the word.</a>
<a name="ln1098">///</a>
<a name="ln1099">/// This is also used for the sound-folded word, &quot;soundfold&quot; is true then.</a>
<a name="ln1100">/// The mechanism is the same, but we find a match with a sound-folded word</a>
<a name="ln1101">/// that comes from one or more original words.  Each of these words may be</a>
<a name="ln1102">/// added, this is done by add_sound_suggest().</a>
<a name="ln1103">/// Don't use:</a>
<a name="ln1104">///      the prefix tree or the keep-case tree</a>
<a name="ln1105">///      &quot;su-&gt;su_badlen&quot;</a>
<a name="ln1106">///      anything to do with upper and lower case</a>
<a name="ln1107">///      anything to do with word or non-word characters (&quot;spell_iswordp()&quot;)</a>
<a name="ln1108">///      banned words</a>
<a name="ln1109">///      word flags (rare, region, compounding)</a>
<a name="ln1110">///      word splitting for now</a>
<a name="ln1111">///      &quot;similar_chars()&quot;</a>
<a name="ln1112">///      use &quot;slang-&gt;sl_repsal&quot; instead of &quot;lp-&gt;lp_replang-&gt;sl_rep&quot;</a>
<a name="ln1113">static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool soundfold)</a>
<a name="ln1114">{</a>
<a name="ln1115">  char_u tword[MAXWLEN];            // good word collected so far</a>
<a name="ln1116">  trystate_T stack[MAXWLEN];</a>
<a name="ln1117">  char preword[MAXWLEN * 3] = { 0 };  // word found with proper case;</a>
<a name="ln1118">  // concatenation of prefix compound</a>
<a name="ln1119">  // words and split word.  NUL terminated</a>
<a name="ln1120">  // when going deeper but not when coming</a>
<a name="ln1121">  // back.</a>
<a name="ln1122">  char_u compflags[MAXWLEN];        // compound flags, one for each word</a>
<a name="ln1123">  trystate_T *sp;</a>
<a name="ln1124">  int newscore;</a>
<a name="ln1125">  int score;</a>
<a name="ln1126">  char_u *byts, *fbyts, *pbyts;</a>
<a name="ln1127">  idx_T *idxs, *fidxs, *pidxs;</a>
<a name="ln1128">  int depth;</a>
<a name="ln1129">  int c, c2, c3;</a>
<a name="ln1130">  int n = 0;</a>
<a name="ln1131">  int flags;</a>
<a name="ln1132">  garray_T *gap;</a>
<a name="ln1133">  idx_T arridx;</a>
<a name="ln1134">  int len;</a>
<a name="ln1135">  char_u *p;</a>
<a name="ln1136">  fromto_T *ftp;</a>
<a name="ln1137">  int fl = 0, tl;</a>
<a name="ln1138">  int repextra = 0;                 // extra bytes in fword[] from REP item</a>
<a name="ln1139">  slang_T *slang = lp-&gt;lp_slang;</a>
<a name="ln1140">  int fword_ends;</a>
<a name="ln1141">  bool goodword_ends;</a>
<a name="ln1142">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1143">  // Stores the name of the change made at each level.</a>
<a name="ln1144">  char_u changename[MAXWLEN][80];</a>
<a name="ln1145">#endif</a>
<a name="ln1146">  int breakcheckcount = 1000;</a>
<a name="ln1147">  bool compound_ok;</a>
<a name="ln1148"> </a>
<a name="ln1149">  // Go through the whole case-fold tree, try changes at each node.</a>
<a name="ln1150">  // &quot;tword[]&quot; contains the word collected from nodes in the tree.</a>
<a name="ln1151">  // &quot;fword[]&quot; the word we are trying to match with (initially the bad</a>
<a name="ln1152">  // word).</a>
<a name="ln1153">  depth = 0;</a>
<a name="ln1154">  sp = &amp;stack[0];</a>
<a name="ln1155">  CLEAR_POINTER(sp);  // -V1068</a>
<a name="ln1156">  sp-&gt;ts_curi = 1;</a>
<a name="ln1157"> </a>
<a name="ln1158">  if (soundfold) {</a>
<a name="ln1159">    // Going through the soundfold tree.</a>
<a name="ln1160">    byts = fbyts = slang-&gt;sl_sbyts;</a>
<a name="ln1161">    idxs = fidxs = slang-&gt;sl_sidxs;</a>
<a name="ln1162">    pbyts = NULL;</a>
<a name="ln1163">    pidxs = NULL;</a>
<a name="ln1164">    sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln1165">    sp-&gt;ts_state = STATE_START;</a>
<a name="ln1166">  } else {</a>
<a name="ln1167">    // When there are postponed prefixes we need to use these first.  At</a>
<a name="ln1168">    // the end of the prefix we continue in the case-fold tree.</a>
<a name="ln1169">    fbyts = slang-&gt;sl_fbyts;</a>
<a name="ln1170">    fidxs = slang-&gt;sl_fidxs;</a>
<a name="ln1171">    pbyts = slang-&gt;sl_pbyts;</a>
<a name="ln1172">    pidxs = slang-&gt;sl_pidxs;</a>
<a name="ln1173">    if (pbyts != NULL) {</a>
<a name="ln1174">      byts = pbyts;</a>
<a name="ln1175">      idxs = pidxs;</a>
<a name="ln1176">      sp-&gt;ts_prefixdepth = PFD_PREFIXTREE;</a>
<a name="ln1177">      sp-&gt;ts_state = STATE_NOPREFIX;            // try without prefix first</a>
<a name="ln1178">    } else {</a>
<a name="ln1179">      byts = fbyts;</a>
<a name="ln1180">      idxs = fidxs;</a>
<a name="ln1181">      sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln1182">      sp-&gt;ts_state = STATE_START;</a>
<a name="ln1183">    }</a>
<a name="ln1184">  }</a>
<a name="ln1185"> </a>
<a name="ln1186">  // The loop may take an indefinite amount of time. Break out after some</a>
<a name="ln1187">  // time.</a>
<a name="ln1188">  proftime_T time_limit;</a>
<a name="ln1189">  if (spell_suggest_timeout &gt; 0) {</a>
<a name="ln1190">    time_limit = profile_setlimit(spell_suggest_timeout);</a>
<a name="ln1191">  }</a>
<a name="ln1192"> </a>
<a name="ln1193">  // Loop to find all suggestions.  At each round we either:</a>
<a name="ln1194">  // - For the current state try one operation, advance &quot;ts_curi&quot;,</a>
<a name="ln1195">  //   increase &quot;depth&quot;.</a>
<a name="ln1196">  // - When a state is done go to the next, set &quot;ts_state&quot;.</a>
<a name="ln1197">  // - When all states are tried decrease &quot;depth&quot;.</a>
<a name="ln1198">  while (depth &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln1199">    sp = &amp;stack[depth];</a>
<a name="ln1200">    switch (sp-&gt;ts_state) {</a>
<a name="ln1201">    case STATE_START:</a>
<a name="ln1202">    case STATE_NOPREFIX:</a>
<a name="ln1203">      // Start of node: Deal with NUL bytes, which means</a>
<a name="ln1204">      // tword[] may end here.</a>
<a name="ln1205">      arridx = sp-&gt;ts_arridx;               // current node in the tree</a>
<a name="ln1206">      len = byts[arridx];                   // bytes in this node</a>
<a name="ln1207">      arridx += sp-&gt;ts_curi;                // index of current byte</a>
<a name="ln1208"> </a>
<a name="ln1209">      if (sp-&gt;ts_prefixdepth == PFD_PREFIXTREE) {</a>
<a name="ln1210">        // Skip over the NUL bytes, we use them later.</a>
<a name="ln1211">        for (n = 0; n &lt; len &amp;&amp; byts[arridx + n] == 0; n++) {}</a>
<a name="ln1212">        sp-&gt;ts_curi = (int16_t)(sp-&gt;ts_curi + n);</a>
<a name="ln1213"> </a>
<a name="ln1214">        // Always past NUL bytes now.</a>
<a name="ln1215">        n = (int)sp-&gt;ts_state;</a>
<a name="ln1216">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1217">        sp-&gt;ts_state = STATE_ENDNUL;</a>
<a name="ln1218">        sp-&gt;ts_save_badflags = (char_u)su-&gt;su_badflags;</a>
<a name="ln1219"> </a>
<a name="ln1220">        // At end of a prefix or at start of prefixtree: check for</a>
<a name="ln1221">        // following word.</a>
<a name="ln1222">        if (depth &lt; MAXWLEN - 1 &amp;&amp; (byts[arridx] == 0 || n == STATE_NOPREFIX)) {</a>
<a name="ln1223">          // Set su-&gt;su_badflags to the caps type at this position.</a>
<a name="ln1224">          // Use the caps type until here for the prefix itself.</a>
<a name="ln1225">          n = nofold_len(fword, sp-&gt;ts_fidx, su-&gt;su_badptr);</a>
<a name="ln1226">          flags = badword_captype(su-&gt;su_badptr, su-&gt;su_badptr + n);</a>
<a name="ln1227">          su-&gt;su_badflags = badword_captype(su-&gt;su_badptr + n,</a>
<a name="ln1228">                                            su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln1229">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1230">          sprintf(changename[depth], &quot;prefix&quot;);  // NOLINT(runtime/printf)</a>
<a name="ln1231">#endif</a>
<a name="ln1232">          go_deeper(stack, depth, 0);</a>
<a name="ln1233">          depth++;</a>
<a name="ln1234">          sp = &amp;stack[depth];</a>
<a name="ln1235">          sp-&gt;ts_prefixdepth = (char_u)(depth - 1);</a>
<a name="ln1236">          byts = fbyts;</a>
<a name="ln1237">          idxs = fidxs;</a>
<a name="ln1238">          sp-&gt;ts_arridx = 0;</a>
<a name="ln1239"> </a>
<a name="ln1240">          // Move the prefix to preword[] with the right case</a>
<a name="ln1241">          // and make find_keepcap_word() works.</a>
<a name="ln1242">          tword[sp-&gt;ts_twordlen] = NUL;</a>
<a name="ln1243">          make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln1244">                         (char_u *)preword + sp-&gt;ts_prewordlen, flags);</a>
<a name="ln1245">          sp-&gt;ts_prewordlen = (char_u)STRLEN(preword);</a>
<a name="ln1246">          sp-&gt;ts_splitoff = sp-&gt;ts_twordlen;</a>
<a name="ln1247">        }</a>
<a name="ln1248">        break;</a>
<a name="ln1249">      }</a>
<a name="ln1250"> </a>
<a name="ln1251">      if (sp-&gt;ts_curi &gt; len || byts[arridx] != 0) {</a>
<a name="ln1252">        // Past bytes in node and/or past NUL bytes.</a>
<a name="ln1253">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1254">        sp-&gt;ts_state = STATE_ENDNUL;</a>
<a name="ln1255">        sp-&gt;ts_save_badflags = (char_u)su-&gt;su_badflags;</a>
<a name="ln1256">        break;</a>
<a name="ln1257">      }</a>
<a name="ln1258"> </a>
<a name="ln1259">      // End of word in tree.</a>
<a name="ln1260">      sp-&gt;ts_curi++;                    // eat one NUL byte</a>
<a name="ln1261"> </a>
<a name="ln1262">      flags = (int)idxs[arridx];</a>
<a name="ln1263"> </a>
<a name="ln1264">      // Skip words with the NOSUGGEST flag.</a>
<a name="ln1265">      if (flags &amp; WF_NOSUGGEST) {</a>
<a name="ln1266">        break;</a>
<a name="ln1267">      }</a>
<a name="ln1268"> </a>
<a name="ln1269">      fword_ends = (fword[sp-&gt;ts_fidx] == NUL</a>
<a name="ln1270">                    || (soundfold</a>
<a name="ln1271">                        ? ascii_iswhite(fword[sp-&gt;ts_fidx])</a>
<a name="ln1272">                        : !spell_iswordp(fword + sp-&gt;ts_fidx, curwin)));</a>
<a name="ln1273">      tword[sp-&gt;ts_twordlen] = NUL;</a>
<a name="ln1274"> </a>
<a name="ln1275">      if (sp-&gt;ts_prefixdepth &lt;= PFD_NOTSPECIAL</a>
<a name="ln1276">          &amp;&amp; (sp-&gt;ts_flags &amp; TSF_PREFIXOK) == 0</a>
<a name="ln1277">          &amp;&amp; pbyts != NULL) {</a>
<a name="ln1278">        // There was a prefix before the word.  Check that the prefix</a>
<a name="ln1279">        // can be used with this word.</a>
<a name="ln1280">        // Count the length of the NULs in the prefix.  If there are</a>
<a name="ln1281">        // none this must be the first try without a prefix.</a>
<a name="ln1282">        n = stack[sp-&gt;ts_prefixdepth].ts_arridx;</a>
<a name="ln1283">        len = pbyts[n++];</a>
<a name="ln1284">        for (c = 0; c &lt; len &amp;&amp; pbyts[n + c] == 0; c++) {}</a>
<a name="ln1285">        if (c &gt; 0) {</a>
<a name="ln1286">          c = valid_word_prefix(c, n, flags,</a>
<a name="ln1287">                                tword + sp-&gt;ts_splitoff, slang, false);</a>
<a name="ln1288">          if (c == 0) {</a>
<a name="ln1289">            break;</a>
<a name="ln1290">          }</a>
<a name="ln1291"> </a>
<a name="ln1292">          // Use the WF_RARE flag for a rare prefix.</a>
<a name="ln1293">          if (c &amp; WF_RAREPFX) {</a>
<a name="ln1294">            flags |= WF_RARE;</a>
<a name="ln1295">          }</a>
<a name="ln1296"> </a>
<a name="ln1297">          // Tricky: when checking for both prefix and compounding</a>
<a name="ln1298">          // we run into the prefix flag first.</a>
<a name="ln1299">          // Remember that it's OK, so that we accept the prefix</a>
<a name="ln1300">          // when arriving at a compound flag.</a>
<a name="ln1301">          sp-&gt;ts_flags |= TSF_PREFIXOK;</a>
<a name="ln1302">        }</a>
<a name="ln1303">      }</a>
<a name="ln1304"> </a>
<a name="ln1305">      // Check NEEDCOMPOUND: can't use word without compounding.  Do try</a>
<a name="ln1306">      // appending another compound word below.</a>
<a name="ln1307">      if (sp-&gt;ts_complen == sp-&gt;ts_compsplit &amp;&amp; fword_ends</a>
<a name="ln1308">          &amp;&amp; (flags &amp; WF_NEEDCOMP)) {</a>
<a name="ln1309">        goodword_ends = false;</a>
<a name="ln1310">      } else {</a>
<a name="ln1311">        goodword_ends = true;</a>
<a name="ln1312">      }</a>
<a name="ln1313"> </a>
<a name="ln1314">      p = NULL;</a>
<a name="ln1315">      compound_ok = true;</a>
<a name="ln1316">      if (sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit) {</a>
<a name="ln1317">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln1318">          // There was a word before this word.  When there was no</a>
<a name="ln1319">          // change in this word (it was correct) add the first word</a>
<a name="ln1320">          // as a suggestion.  If this word was corrected too, we</a>
<a name="ln1321">          // need to check if a correct word follows.</a>
<a name="ln1322">          if (sp-&gt;ts_fidx - sp-&gt;ts_splitfidx</a>
<a name="ln1323">              == sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln1324">              &amp;&amp; STRNCMP(fword + sp-&gt;ts_splitfidx,</a>
<a name="ln1325">                         tword + sp-&gt;ts_splitoff,</a>
<a name="ln1326">                         sp-&gt;ts_fidx - sp-&gt;ts_splitfidx) == 0) {</a>
<a name="ln1327">            preword[sp-&gt;ts_prewordlen] = NUL;</a>
<a name="ln1328">            newscore = score_wordcount_adj(slang, sp-&gt;ts_score,</a>
<a name="ln1329">                                           (char_u *)preword + sp-&gt;ts_prewordlen,</a>
<a name="ln1330">                                           sp-&gt;ts_prewordlen &gt; 0);</a>
<a name="ln1331">            // Add the suggestion if the score isn't too bad.</a>
<a name="ln1332">            if (newscore &lt;= su-&gt;su_maxscore) {</a>
<a name="ln1333">              add_suggestion(su, &amp;su-&gt;su_ga, (char *)preword,</a>
<a name="ln1334">                             sp-&gt;ts_splitfidx - repextra,</a>
<a name="ln1335">                             newscore, 0, false,</a>
<a name="ln1336">                             lp-&gt;lp_sallang, false);</a>
<a name="ln1337">            }</a>
<a name="ln1338">            break;</a>
<a name="ln1339">          }</a>
<a name="ln1340">        } else {</a>
<a name="ln1341">          // There was a compound word before this word.  If this</a>
<a name="ln1342">          // word does not support compounding then give up</a>
<a name="ln1343">          // (splitting is tried for the word without compound</a>
<a name="ln1344">          // flag).</a>
<a name="ln1345">          if (((unsigned)flags &gt;&gt; 24) == 0</a>
<a name="ln1346">              || sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln1347">              &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln1348">            break;</a>
<a name="ln1349">          }</a>
<a name="ln1350">          // For multi-byte chars check character length against</a>
<a name="ln1351">          // COMPOUNDMIN.</a>
<a name="ln1352">          if (slang-&gt;sl_compminlen &gt; 0</a>
<a name="ln1353">              &amp;&amp; mb_charlen(tword + sp-&gt;ts_splitoff)</a>
<a name="ln1354">              &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln1355">            break;</a>
<a name="ln1356">          }</a>
<a name="ln1357"> </a>
<a name="ln1358">          compflags[sp-&gt;ts_complen] = (char_u)((unsigned)flags &gt;&gt; 24);</a>
<a name="ln1359">          compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln1360">          STRLCPY(preword + sp-&gt;ts_prewordlen,</a>
<a name="ln1361">                  tword + sp-&gt;ts_splitoff,</a>
<a name="ln1362">                  sp-&gt;ts_twordlen - sp-&gt;ts_splitoff + 1);</a>
<a name="ln1363"> </a>
<a name="ln1364">          // Verify CHECKCOMPOUNDPATTERN  rules.</a>
<a name="ln1365">          if (match_checkcompoundpattern((char_u *)preword,  sp-&gt;ts_prewordlen,</a>
<a name="ln1366">                                         &amp;slang-&gt;sl_comppat)) {</a>
<a name="ln1367">            compound_ok = false;</a>
<a name="ln1368">          }</a>
<a name="ln1369"> </a>
<a name="ln1370">          if (compound_ok) {</a>
<a name="ln1371">            p = (char_u *)preword;</a>
<a name="ln1372">            while (*skiptowhite((char *)p) != NUL) {</a>
<a name="ln1373">              p = (char_u *)skipwhite(skiptowhite((char *)p));</a>
<a name="ln1374">            }</a>
<a name="ln1375">            if (fword_ends &amp;&amp; !can_compound(slang, p,</a>
<a name="ln1376">                                            compflags + sp-&gt;ts_compsplit)) {</a>
<a name="ln1377">              // Compound is not allowed.  But it may still be</a>
<a name="ln1378">              // possible if we add another (short) word.</a>
<a name="ln1379">              compound_ok = false;</a>
<a name="ln1380">            }</a>
<a name="ln1381">          }</a>
<a name="ln1382"> </a>
<a name="ln1383">          // Get pointer to last char of previous word.</a>
<a name="ln1384">          p = (char_u *)preword + sp-&gt;ts_prewordlen;</a>
<a name="ln1385">          MB_PTR_BACK(preword, p);</a>
<a name="ln1386">        }</a>
<a name="ln1387">      }</a>
<a name="ln1388"> </a>
<a name="ln1389">      // Form the word with proper case in preword.</a>
<a name="ln1390">      // If there is a word from a previous split, append.</a>
<a name="ln1391">      // For the soundfold tree don't change the case, simply append.</a>
<a name="ln1392">      if (soundfold) {</a>
<a name="ln1393">        STRCPY(preword + sp-&gt;ts_prewordlen, tword + sp-&gt;ts_splitoff);</a>
<a name="ln1394">      } else if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln1395">        // Must find the word in the keep-case tree.</a>
<a name="ln1396">        find_keepcap_word(slang, tword + sp-&gt;ts_splitoff,</a>
<a name="ln1397">                          (char_u *)preword + sp-&gt;ts_prewordlen);</a>
<a name="ln1398">      } else {</a>
<a name="ln1399">        // Include badflags: If the badword is onecap or allcap</a>
<a name="ln1400">        // use that for the goodword too.  But if the badword is</a>
<a name="ln1401">        // allcap and it's only one char long use onecap.</a>
<a name="ln1402">        c = su-&gt;su_badflags;</a>
<a name="ln1403">        if ((c &amp; WF_ALLCAP)</a>
<a name="ln1404">            &amp;&amp; su-&gt;su_badlen ==</a>
<a name="ln1405">            utfc_ptr2len((char *)su-&gt;su_badptr)) {</a>
<a name="ln1406">          c = WF_ONECAP;</a>
<a name="ln1407">        }</a>
<a name="ln1408">        c |= flags;</a>
<a name="ln1409"> </a>
<a name="ln1410">        // When appending a compound word after a word character don't</a>
<a name="ln1411">        // use Onecap.</a>
<a name="ln1412">        if (p != NULL &amp;&amp; spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln1413">          c &amp;= ~WF_ONECAP;</a>
<a name="ln1414">        }</a>
<a name="ln1415">        make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln1416">                       (char_u *)preword + sp-&gt;ts_prewordlen, c);</a>
<a name="ln1417">      }</a>
<a name="ln1418"> </a>
<a name="ln1419">      if (!soundfold) {</a>
<a name="ln1420">        // Don't use a banned word.  It may appear again as a good</a>
<a name="ln1421">        // word, thus remember it.</a>
<a name="ln1422">        if (flags &amp; WF_BANNED) {</a>
<a name="ln1423">          add_banned(su, (char_u *)preword + sp-&gt;ts_prewordlen);</a>
<a name="ln1424">          break;</a>
<a name="ln1425">        }</a>
<a name="ln1426">        if ((sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln1427">             &amp;&amp; WAS_BANNED(su, (char *)preword + sp-&gt;ts_prewordlen))</a>
<a name="ln1428">            || WAS_BANNED(su, (char *)preword)) {</a>
<a name="ln1429">          if (slang-&gt;sl_compprog == NULL) {</a>
<a name="ln1430">            break;</a>
<a name="ln1431">          }</a>
<a name="ln1432">          // the word so far was banned but we may try compounding</a>
<a name="ln1433">          goodword_ends = false;</a>
<a name="ln1434">        }</a>
<a name="ln1435">      }</a>
<a name="ln1436"> </a>
<a name="ln1437">      newscore = 0;</a>
<a name="ln1438">      if (!soundfold) {         // soundfold words don't have flags</a>
<a name="ln1439">        if ((flags &amp; WF_REGION)</a>
<a name="ln1440">            &amp;&amp; (((unsigned)flags &gt;&gt; 16) &amp; (unsigned)lp-&gt;lp_region) == 0) {</a>
<a name="ln1441">          newscore += SCORE_REGION;</a>
<a name="ln1442">        }</a>
<a name="ln1443">        if (flags &amp; WF_RARE) {</a>
<a name="ln1444">          newscore += SCORE_RARE;</a>
<a name="ln1445">        }</a>
<a name="ln1446"> </a>
<a name="ln1447">        if (!spell_valid_case(su-&gt;su_badflags,</a>
<a name="ln1448">                              captype((char_u *)preword + sp-&gt;ts_prewordlen, NULL))) {</a>
<a name="ln1449">          newscore += SCORE_ICASE;</a>
<a name="ln1450">        }</a>
<a name="ln1451">      }</a>
<a name="ln1452"> </a>
<a name="ln1453">      // TODO(vim): how about splitting in the soundfold tree?</a>
<a name="ln1454">      if (fword_ends</a>
<a name="ln1455">          &amp;&amp; goodword_ends</a>
<a name="ln1456">          &amp;&amp; sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry</a>
<a name="ln1457">          &amp;&amp; compound_ok) {</a>
<a name="ln1458">        // The badword also ends: add suggestions.</a>
<a name="ln1459">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1460">        if (soundfold &amp;&amp; strcmp(preword, &quot;smwrd&quot;) == 0) {</a>
<a name="ln1461">          int j;</a>
<a name="ln1462"> </a>
<a name="ln1463">          // print the stack of changes that brought us here</a>
<a name="ln1464">          smsg(&quot;------ %s -------&quot;, fword);</a>
<a name="ln1465">          for (j = 0; j &lt; depth; j++) {</a>
<a name="ln1466">            smsg(&quot;%s&quot;, changename[j]);</a>
<a name="ln1467">          }</a>
<a name="ln1468">        }</a>
<a name="ln1469">#endif</a>
<a name="ln1470">        if (soundfold) {</a>
<a name="ln1471">          // For soundfolded words we need to find the original</a>
<a name="ln1472">          // words, the edit distance and then add them.</a>
<a name="ln1473">          add_sound_suggest(su, (char_u *)preword, sp-&gt;ts_score, lp);</a>
<a name="ln1474">        } else if (sp-&gt;ts_fidx &gt; 0) {</a>
<a name="ln1475">          // Give a penalty when changing non-word char to word</a>
<a name="ln1476">          // char, e.g., &quot;thes,&quot; -&gt; &quot;these&quot;.</a>
<a name="ln1477">          p = fword + sp-&gt;ts_fidx;</a>
<a name="ln1478">          MB_PTR_BACK(fword, p);</a>
<a name="ln1479">          if (!spell_iswordp(p, curwin) &amp;&amp; *preword != NUL) {</a>
<a name="ln1480">            p = (char_u *)preword + STRLEN(preword);</a>
<a name="ln1481">            MB_PTR_BACK(preword, p);</a>
<a name="ln1482">            if (spell_iswordp(p, curwin)) {</a>
<a name="ln1483">              newscore += SCORE_NONWORD;</a>
<a name="ln1484">            }</a>
<a name="ln1485">          }</a>
<a name="ln1486"> </a>
<a name="ln1487">          // Give a bonus to words seen before.</a>
<a name="ln1488">          score = score_wordcount_adj(slang,</a>
<a name="ln1489">                                      sp-&gt;ts_score + newscore,</a>
<a name="ln1490">                                      (char_u *)preword + sp-&gt;ts_prewordlen,</a>
<a name="ln1491">                                      sp-&gt;ts_prewordlen &gt; 0);</a>
<a name="ln1492"> </a>
<a name="ln1493">          // Add the suggestion if the score isn't too bad.</a>
<a name="ln1494">          if (score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln1495">            add_suggestion(su, &amp;su-&gt;su_ga, (char *)preword,</a>
<a name="ln1496">                           sp-&gt;ts_fidx - repextra,</a>
<a name="ln1497">                           score, 0, false, lp-&gt;lp_sallang, false);</a>
<a name="ln1498"> </a>
<a name="ln1499">            if (su-&gt;su_badflags &amp; WF_MIXCAP) {</a>
<a name="ln1500">              // We really don't know if the word should be</a>
<a name="ln1501">              // upper or lower case, add both.</a>
<a name="ln1502">              c = captype((char_u *)preword, NULL);</a>
<a name="ln1503">              if (c == 0 || c == WF_ALLCAP) {</a>
<a name="ln1504">                make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln1505">                               (char_u *)preword + sp-&gt;ts_prewordlen,</a>
<a name="ln1506">                               c == 0 ? WF_ALLCAP : 0);</a>
<a name="ln1507"> </a>
<a name="ln1508">                add_suggestion(su, &amp;su-&gt;su_ga, (char *)preword,</a>
<a name="ln1509">                               sp-&gt;ts_fidx - repextra,</a>
<a name="ln1510">                               score + SCORE_ICASE, 0, false,</a>
<a name="ln1511">                               lp-&gt;lp_sallang, false);</a>
<a name="ln1512">              }</a>
<a name="ln1513">            }</a>
<a name="ln1514">          }</a>
<a name="ln1515">        }</a>
<a name="ln1516">      }</a>
<a name="ln1517"> </a>
<a name="ln1518">      // Try word split and/or compounding.</a>
<a name="ln1519">      if ((sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry || fword_ends)</a>
<a name="ln1520">          // Don't split in the middle of a character</a>
<a name="ln1521">          &amp;&amp; (sp-&gt;ts_tcharlen == 0)) {</a>
<a name="ln1522">        bool try_compound;</a>
<a name="ln1523">        int try_split;</a>
<a name="ln1524"> </a>
<a name="ln1525">        // If past the end of the bad word don't try a split.</a>
<a name="ln1526">        // Otherwise try changing the next word.  E.g., find</a>
<a name="ln1527">        // suggestions for &quot;the the&quot; where the second &quot;the&quot; is</a>
<a name="ln1528">        // different.  It's done like a split.</a>
<a name="ln1529">        // TODO(vim): word split for soundfold words</a>
<a name="ln1530">        try_split = (sp-&gt;ts_fidx - repextra &lt; su-&gt;su_badlen)</a>
<a name="ln1531">                    &amp;&amp; !soundfold;</a>
<a name="ln1532"> </a>
<a name="ln1533">        // Get here in several situations:</a>
<a name="ln1534">        // 1. The word in the tree ends:</a>
<a name="ln1535">        //    If the word allows compounding try that.  Otherwise try</a>
<a name="ln1536">        //    a split by inserting a space.  For both check that a</a>
<a name="ln1537">        //    valid words starts at fword[sp-&gt;ts_fidx].</a>
<a name="ln1538">        //    For NOBREAK do like compounding to be able to check if</a>
<a name="ln1539">        //    the next word is valid.</a>
<a name="ln1540">        // 2. The badword does end, but it was due to a change (e.g.,</a>
<a name="ln1541">        //    a swap).  No need to split, but do check that the</a>
<a name="ln1542">        //    following word is valid.</a>
<a name="ln1543">        // 3. The badword and the word in the tree end.  It may still</a>
<a name="ln1544">        //    be possible to compound another (short) word.</a>
<a name="ln1545">        try_compound = false;</a>
<a name="ln1546">        if (!soundfold</a>
<a name="ln1547">            &amp;&amp; !slang-&gt;sl_nocompoundsugs</a>
<a name="ln1548">            &amp;&amp; slang-&gt;sl_compprog != NULL</a>
<a name="ln1549">            &amp;&amp; ((unsigned)flags &gt;&gt; 24) != 0</a>
<a name="ln1550">            &amp;&amp; sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln1551">            &gt;= slang-&gt;sl_compminlen</a>
<a name="ln1552">            &amp;&amp; (slang-&gt;sl_compminlen == 0</a>
<a name="ln1553">                || mb_charlen(tword + sp-&gt;ts_splitoff)</a>
<a name="ln1554">                &gt;= slang-&gt;sl_compminlen)</a>
<a name="ln1555">            &amp;&amp; (slang-&gt;sl_compsylmax &lt; MAXWLEN</a>
<a name="ln1556">                || sp-&gt;ts_complen + 1 - sp-&gt;ts_compsplit</a>
<a name="ln1557">                &lt; slang-&gt;sl_compmax)</a>
<a name="ln1558">            &amp;&amp; (can_be_compound(sp, slang, compflags, (int)((unsigned)flags &gt;&gt; 24)))) {</a>
<a name="ln1559">          try_compound = true;</a>
<a name="ln1560">          compflags[sp-&gt;ts_complen] = (char_u)((unsigned)flags &gt;&gt; 24);</a>
<a name="ln1561">          compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln1562">        }</a>
<a name="ln1563"> </a>
<a name="ln1564">        // For NOBREAK we never try splitting, it won't make any word</a>
<a name="ln1565">        // valid.</a>
<a name="ln1566">        if (slang-&gt;sl_nobreak &amp;&amp; !slang-&gt;sl_nocompoundsugs) {</a>
<a name="ln1567">          try_compound = true;</a>
<a name="ln1568">        } else if (!fword_ends</a>
<a name="ln1569">                   &amp;&amp; try_compound</a>
<a name="ln1570">                   &amp;&amp; (sp-&gt;ts_flags &amp; TSF_DIDSPLIT) == 0) {</a>
<a name="ln1571">          // If we could add a compound word, and it's also possible to</a>
<a name="ln1572">          // split at this point, do the split first and set</a>
<a name="ln1573">          // TSF_DIDSPLIT to avoid doing it again.</a>
<a name="ln1574">          try_compound = false;</a>
<a name="ln1575">          sp-&gt;ts_flags |= TSF_DIDSPLIT;</a>
<a name="ln1576">          sp-&gt;ts_curi--;                    // do the same NUL again</a>
<a name="ln1577">          compflags[sp-&gt;ts_complen] = NUL;</a>
<a name="ln1578">        } else {</a>
<a name="ln1579">          sp-&gt;ts_flags &amp;= (char_u) ~TSF_DIDSPLIT;</a>
<a name="ln1580">        }</a>
<a name="ln1581"> </a>
<a name="ln1582">        if (try_split || try_compound) {</a>
<a name="ln1583">          if (!try_compound &amp;&amp; (!fword_ends || !goodword_ends)) {</a>
<a name="ln1584">            // If we're going to split need to check that the</a>
<a name="ln1585">            // words so far are valid for compounding.  If there</a>
<a name="ln1586">            // is only one word it must not have the NEEDCOMPOUND</a>
<a name="ln1587">            // flag.</a>
<a name="ln1588">            if (sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln1589">                &amp;&amp; (flags &amp; WF_NEEDCOMP)) {</a>
<a name="ln1590">              break;</a>
<a name="ln1591">            }</a>
<a name="ln1592">            p = (char_u *)preword;</a>
<a name="ln1593">            while (*skiptowhite((char *)p) != NUL) {</a>
<a name="ln1594">              p = (char_u *)skipwhite(skiptowhite((char *)p));</a>
<a name="ln1595">            }</a>
<a name="ln1596">            if (sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit</a>
<a name="ln1597">                &amp;&amp; !can_compound(slang, p,</a>
<a name="ln1598">                                 compflags + sp-&gt;ts_compsplit)) {</a>
<a name="ln1599">              break;</a>
<a name="ln1600">            }</a>
<a name="ln1601"> </a>
<a name="ln1602">            if (slang-&gt;sl_nosplitsugs) {</a>
<a name="ln1603">              newscore += SCORE_SPLIT_NO;</a>
<a name="ln1604">            } else {</a>
<a name="ln1605">              newscore += SCORE_SPLIT;</a>
<a name="ln1606">            }</a>
<a name="ln1607"> </a>
<a name="ln1608">            // Give a bonus to words seen before.</a>
<a name="ln1609">            newscore = score_wordcount_adj(slang, newscore,</a>
<a name="ln1610">                                           (char_u *)preword + sp-&gt;ts_prewordlen, true);</a>
<a name="ln1611">          }</a>
<a name="ln1612"> </a>
<a name="ln1613">          if (TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln1614">            go_deeper(stack, depth, newscore);</a>
<a name="ln1615">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1616">            if (!try_compound &amp;&amp; !fword_ends) {</a>
<a name="ln1617">              sprintf(changename[depth], &quot;%.*s-%s: split&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln1618">                      sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx);</a>
<a name="ln1619">            } else {</a>
<a name="ln1620">              sprintf(changename[depth], &quot;%.*s-%s: compound&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln1621">                      sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx);</a>
<a name="ln1622">            }</a>
<a name="ln1623">#endif</a>
<a name="ln1624">            // Save things to be restored at STATE_SPLITUNDO.</a>
<a name="ln1625">            sp-&gt;ts_save_badflags = (char_u)su-&gt;su_badflags;</a>
<a name="ln1626">            PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1627">            sp-&gt;ts_state = STATE_SPLITUNDO;</a>
<a name="ln1628"> </a>
<a name="ln1629">            depth++;</a>
<a name="ln1630">            sp = &amp;stack[depth];</a>
<a name="ln1631"> </a>
<a name="ln1632">            // Append a space to preword when splitting.</a>
<a name="ln1633">            if (!try_compound &amp;&amp; !fword_ends) {</a>
<a name="ln1634">              STRCAT(preword, &quot; &quot;);</a>
<a name="ln1635">            }</a>
<a name="ln1636">            sp-&gt;ts_prewordlen = (char_u)strlen(preword);</a>
<a name="ln1637">            sp-&gt;ts_splitoff = sp-&gt;ts_twordlen;</a>
<a name="ln1638">            sp-&gt;ts_splitfidx = sp-&gt;ts_fidx;</a>
<a name="ln1639"> </a>
<a name="ln1640">            // If the badword has a non-word character at this</a>
<a name="ln1641">            // position skip it.  That means replacing the</a>
<a name="ln1642">            // non-word character with a space.  Always skip a</a>
<a name="ln1643">            // character when the word ends.  But only when the</a>
<a name="ln1644">            // good word can end.</a>
<a name="ln1645">            if (((!try_compound &amp;&amp; !spell_iswordp_nmw(fword</a>
<a name="ln1646">                                                      + sp-&gt;ts_fidx,</a>
<a name="ln1647">                                                      curwin))</a>
<a name="ln1648">                 || fword_ends)</a>
<a name="ln1649">                &amp;&amp; fword[sp-&gt;ts_fidx] != NUL</a>
<a name="ln1650">                &amp;&amp; goodword_ends) {</a>
<a name="ln1651">              int l;</a>
<a name="ln1652"> </a>
<a name="ln1653">              l = utfc_ptr2len((char *)fword + sp-&gt;ts_fidx);</a>
<a name="ln1654">              if (fword_ends) {</a>
<a name="ln1655">                // Copy the skipped character to preword.</a>
<a name="ln1656">                memmove(preword + sp-&gt;ts_prewordlen, fword + sp-&gt;ts_fidx, (size_t)l);</a>
<a name="ln1657">                sp-&gt;ts_prewordlen = (char_u)(sp-&gt;ts_prewordlen + l);</a>
<a name="ln1658">                preword[sp-&gt;ts_prewordlen] = NUL;</a>
<a name="ln1659">              } else {</a>
<a name="ln1660">                sp-&gt;ts_score -= SCORE_SPLIT - SCORE_SUBST;</a>
<a name="ln1661">              }</a>
<a name="ln1662">              sp-&gt;ts_fidx = (char_u)(sp-&gt;ts_fidx + l);</a>
<a name="ln1663">            }</a>
<a name="ln1664"> </a>
<a name="ln1665">            // When compounding include compound flag in</a>
<a name="ln1666">            // compflags[] (already set above).  When splitting we</a>
<a name="ln1667">            // may start compounding over again.</a>
<a name="ln1668">            if (try_compound) {</a>
<a name="ln1669">              sp-&gt;ts_complen++;</a>
<a name="ln1670">            } else {</a>
<a name="ln1671">              sp-&gt;ts_compsplit = sp-&gt;ts_complen;</a>
<a name="ln1672">            }</a>
<a name="ln1673">            sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln1674"> </a>
<a name="ln1675">            // set su-&gt;su_badflags to the caps type at this</a>
<a name="ln1676">            // position</a>
<a name="ln1677">            n = nofold_len(fword, sp-&gt;ts_fidx, su-&gt;su_badptr);</a>
<a name="ln1678">            su-&gt;su_badflags = badword_captype(su-&gt;su_badptr + n,</a>
<a name="ln1679">                                              su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln1680"> </a>
<a name="ln1681">            // Restart at top of the tree.</a>
<a name="ln1682">            sp-&gt;ts_arridx = 0;</a>
<a name="ln1683"> </a>
<a name="ln1684">            // If there are postponed prefixes, try these too.</a>
<a name="ln1685">            if (pbyts != NULL) {</a>
<a name="ln1686">              byts = pbyts;</a>
<a name="ln1687">              idxs = pidxs;</a>
<a name="ln1688">              sp-&gt;ts_prefixdepth = PFD_PREFIXTREE;</a>
<a name="ln1689">              PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1690">              sp-&gt;ts_state = STATE_NOPREFIX;</a>
<a name="ln1691">            }</a>
<a name="ln1692">          }</a>
<a name="ln1693">        }</a>
<a name="ln1694">      }</a>
<a name="ln1695">      break;</a>
<a name="ln1696"> </a>
<a name="ln1697">    case STATE_SPLITUNDO:</a>
<a name="ln1698">      // Undo the changes done for word split or compound word.</a>
<a name="ln1699">      su-&gt;su_badflags = sp-&gt;ts_save_badflags;</a>
<a name="ln1700"> </a>
<a name="ln1701">      // Continue looking for NUL bytes.</a>
<a name="ln1702">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1703">      sp-&gt;ts_state = STATE_START;</a>
<a name="ln1704"> </a>
<a name="ln1705">      // In case we went into the prefix tree.</a>
<a name="ln1706">      byts = fbyts;</a>
<a name="ln1707">      idxs = fidxs;</a>
<a name="ln1708">      break;</a>
<a name="ln1709"> </a>
<a name="ln1710">    case STATE_ENDNUL:</a>
<a name="ln1711">      // Past the NUL bytes in the node.</a>
<a name="ln1712">      su-&gt;su_badflags = sp-&gt;ts_save_badflags;</a>
<a name="ln1713">      if (fword[sp-&gt;ts_fidx] == NUL</a>
<a name="ln1714">          &amp;&amp; sp-&gt;ts_tcharlen == 0) {</a>
<a name="ln1715">        // The badword ends, can't use STATE_PLAIN.</a>
<a name="ln1716">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1717">        sp-&gt;ts_state = STATE_DEL;</a>
<a name="ln1718">        break;</a>
<a name="ln1719">      }</a>
<a name="ln1720">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1721">      sp-&gt;ts_state = STATE_PLAIN;</a>
<a name="ln1722">      FALLTHROUGH;</a>
<a name="ln1723"> </a>
<a name="ln1724">    case STATE_PLAIN:</a>
<a name="ln1725">      // Go over all possible bytes at this node, add each to tword[]</a>
<a name="ln1726">      // and use child node.  &quot;ts_curi&quot; is the index.</a>
<a name="ln1727">      arridx = sp-&gt;ts_arridx;</a>
<a name="ln1728">      if (sp-&gt;ts_curi &gt; byts[arridx]) {</a>
<a name="ln1729">        // Done all bytes at this node, do next state.  When still at</a>
<a name="ln1730">        // already changed bytes skip the other tricks.</a>
<a name="ln1731">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1732">        if (sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry) {</a>
<a name="ln1733">          sp-&gt;ts_state = STATE_DEL;</a>
<a name="ln1734">        } else {</a>
<a name="ln1735">          sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln1736">        }</a>
<a name="ln1737">      } else {</a>
<a name="ln1738">        arridx += sp-&gt;ts_curi++;</a>
<a name="ln1739">        c = byts[arridx];</a>
<a name="ln1740"> </a>
<a name="ln1741">        // Normal byte, go one level deeper.  If it's not equal to the</a>
<a name="ln1742">        // byte in the bad word adjust the score.  But don't even try</a>
<a name="ln1743">        // when the byte was already changed.  And don't try when we</a>
<a name="ln1744">        // just deleted this byte, accepting it is always cheaper than</a>
<a name="ln1745">        // delete + substitute.</a>
<a name="ln1746">        if (c == fword[sp-&gt;ts_fidx]</a>
<a name="ln1747">            || (sp-&gt;ts_tcharlen &gt; 0</a>
<a name="ln1748">                &amp;&amp; sp-&gt;ts_isdiff != DIFF_NONE)) {</a>
<a name="ln1749">          newscore = 0;</a>
<a name="ln1750">        } else {</a>
<a name="ln1751">          newscore = SCORE_SUBST;</a>
<a name="ln1752">        }</a>
<a name="ln1753">        if ((newscore == 0</a>
<a name="ln1754">             || (sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry</a>
<a name="ln1755">                 &amp;&amp; ((sp-&gt;ts_flags &amp; TSF_DIDDEL) == 0</a>
<a name="ln1756">                     || c != fword[sp-&gt;ts_delidx])))</a>
<a name="ln1757">            &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln1758">          go_deeper(stack, depth, newscore);</a>
<a name="ln1759">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1760">          if (newscore &gt; 0) {</a>
<a name="ln1761">            sprintf(changename[depth], &quot;%.*s-%s: subst %c to %c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln1762">                    sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln1763">                    fword[sp-&gt;ts_fidx], c);</a>
<a name="ln1764">          } else {</a>
<a name="ln1765">            sprintf(changename[depth], &quot;%.*s-%s: accept %c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln1766">                    sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln1767">                    fword[sp-&gt;ts_fidx]);</a>
<a name="ln1768">          }</a>
<a name="ln1769">#endif</a>
<a name="ln1770">          depth++;</a>
<a name="ln1771">          sp = &amp;stack[depth];</a>
<a name="ln1772">          if (fword[sp-&gt;ts_fidx] != NUL) {</a>
<a name="ln1773">            sp-&gt;ts_fidx++;</a>
<a name="ln1774">          }</a>
<a name="ln1775">          tword[sp-&gt;ts_twordlen++] = (char_u)c;</a>
<a name="ln1776">          sp-&gt;ts_arridx = idxs[arridx];</a>
<a name="ln1777">          if (newscore == SCORE_SUBST) {</a>
<a name="ln1778">            sp-&gt;ts_isdiff = DIFF_YES;</a>
<a name="ln1779">          }</a>
<a name="ln1780">          // Multi-byte characters are a bit complicated to</a>
<a name="ln1781">          // handle: They differ when any of the bytes differ</a>
<a name="ln1782">          // and then their length may also differ.</a>
<a name="ln1783">          if (sp-&gt;ts_tcharlen == 0) {</a>
<a name="ln1784">            // First byte.</a>
<a name="ln1785">            sp-&gt;ts_tcharidx = 0;</a>
<a name="ln1786">            sp-&gt;ts_tcharlen = MB_BYTE2LEN(c);</a>
<a name="ln1787">            sp-&gt;ts_fcharstart = (char_u)(sp-&gt;ts_fidx - 1);</a>
<a name="ln1788">            sp-&gt;ts_isdiff = (newscore != 0)</a>
<a name="ln1789">                            ? DIFF_YES : DIFF_NONE;</a>
<a name="ln1790">          } else if (sp-&gt;ts_isdiff == DIFF_INSERT &amp;&amp; sp-&gt;ts_fidx &gt; 0) {</a>
<a name="ln1791">            // When inserting trail bytes don't advance in the</a>
<a name="ln1792">            // bad word.</a>
<a name="ln1793">            sp-&gt;ts_fidx--;</a>
<a name="ln1794">          }</a>
<a name="ln1795">          if (++sp-&gt;ts_tcharidx == sp-&gt;ts_tcharlen) {</a>
<a name="ln1796">            // Last byte of character.</a>
<a name="ln1797">            if (sp-&gt;ts_isdiff == DIFF_YES) {</a>
<a name="ln1798">              // Correct ts_fidx for the byte length of the</a>
<a name="ln1799">              // character (we didn't check that before).</a>
<a name="ln1800">              sp-&gt;ts_fidx = (char_u)(sp-&gt;ts_fcharstart</a>
<a name="ln1801">                                     + utfc_ptr2len((char *)fword + sp-&gt;ts_fcharstart));</a>
<a name="ln1802"> </a>
<a name="ln1803">              // For changing a composing character adjust</a>
<a name="ln1804">              // the score from SCORE_SUBST to</a>
<a name="ln1805">              // SCORE_SUBCOMP.</a>
<a name="ln1806">              if (utf_iscomposing(utf_ptr2char((char *)tword + sp-&gt;ts_twordlen</a>
<a name="ln1807">                                               - sp-&gt;ts_tcharlen))</a>
<a name="ln1808">                  &amp;&amp; utf_iscomposing(utf_ptr2char((char *)fword</a>
<a name="ln1809">                                                  + sp-&gt;ts_fcharstart))) {</a>
<a name="ln1810">                sp-&gt;ts_score -= SCORE_SUBST - SCORE_SUBCOMP;</a>
<a name="ln1811">              } else if (!soundfold</a>
<a name="ln1812">                         &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln1813">                         &amp;&amp; similar_chars(slang,</a>
<a name="ln1814">                                          utf_ptr2char((char *)tword + sp-&gt;ts_twordlen -</a>
<a name="ln1815">                                                       sp-&gt;ts_tcharlen),</a>
<a name="ln1816">                                          utf_ptr2char((char *)fword + sp-&gt;ts_fcharstart))) {</a>
<a name="ln1817">                // For a similar character adjust score from</a>
<a name="ln1818">                // SCORE_SUBST to SCORE_SIMILAR.</a>
<a name="ln1819">                sp-&gt;ts_score -= SCORE_SUBST - SCORE_SIMILAR;</a>
<a name="ln1820">              }</a>
<a name="ln1821">            } else if (sp-&gt;ts_isdiff == DIFF_INSERT</a>
<a name="ln1822">                       &amp;&amp; sp-&gt;ts_twordlen &gt; sp-&gt;ts_tcharlen) {</a>
<a name="ln1823">              p = tword + sp-&gt;ts_twordlen - sp-&gt;ts_tcharlen;</a>
<a name="ln1824">              c = utf_ptr2char((char *)p);</a>
<a name="ln1825">              if (utf_iscomposing(c)) {</a>
<a name="ln1826">                // Inserting a composing char doesn't</a>
<a name="ln1827">                // count that much.</a>
<a name="ln1828">                sp-&gt;ts_score -= SCORE_INS - SCORE_INSCOMP;</a>
<a name="ln1829">              } else {</a>
<a name="ln1830">                // If the previous character was the same,</a>
<a name="ln1831">                // thus doubling a character, give a bonus</a>
<a name="ln1832">                // to the score.  Also for the soundfold</a>
<a name="ln1833">                // tree (might seem illogical but does</a>
<a name="ln1834">                // give better scores).</a>
<a name="ln1835">                MB_PTR_BACK(tword, p);</a>
<a name="ln1836">                if (c == utf_ptr2char((char *)p)) {</a>
<a name="ln1837">                  sp-&gt;ts_score -= SCORE_INS - SCORE_INSDUP;</a>
<a name="ln1838">                }</a>
<a name="ln1839">              }</a>
<a name="ln1840">            }</a>
<a name="ln1841"> </a>
<a name="ln1842">            // Starting a new char, reset the length.</a>
<a name="ln1843">            sp-&gt;ts_tcharlen = 0;</a>
<a name="ln1844">          }</a>
<a name="ln1845">        }</a>
<a name="ln1846">      }</a>
<a name="ln1847">      break;</a>
<a name="ln1848"> </a>
<a name="ln1849">    case STATE_DEL:</a>
<a name="ln1850">      // When past the first byte of a multi-byte char don't try</a>
<a name="ln1851">      // delete/insert/swap a character.</a>
<a name="ln1852">      if (sp-&gt;ts_tcharlen &gt; 0) {</a>
<a name="ln1853">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1854">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln1855">        break;</a>
<a name="ln1856">      }</a>
<a name="ln1857">      // Try skipping one character in the bad word (delete it).</a>
<a name="ln1858">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1859">      sp-&gt;ts_state = STATE_INS_PREP;</a>
<a name="ln1860">      sp-&gt;ts_curi = 1;</a>
<a name="ln1861">      if (soundfold &amp;&amp; sp-&gt;ts_fidx == 0 &amp;&amp; fword[sp-&gt;ts_fidx] == '*') {</a>
<a name="ln1862">        // Deleting a vowel at the start of a word counts less, see</a>
<a name="ln1863">        // soundalike_score().</a>
<a name="ln1864">        newscore = 2 * SCORE_DEL / 3;</a>
<a name="ln1865">      } else {</a>
<a name="ln1866">        newscore = SCORE_DEL;</a>
<a name="ln1867">      }</a>
<a name="ln1868">      if (fword[sp-&gt;ts_fidx] != NUL</a>
<a name="ln1869">          &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln1870">        go_deeper(stack, depth, newscore);</a>
<a name="ln1871">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1872">        sprintf(changename[depth], &quot;%.*s-%s: delete %c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln1873">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln1874">                fword[sp-&gt;ts_fidx]);</a>
<a name="ln1875">#endif</a>
<a name="ln1876">        depth++;</a>
<a name="ln1877"> </a>
<a name="ln1878">        // Remember what character we deleted, so that we can avoid</a>
<a name="ln1879">        // inserting it again.</a>
<a name="ln1880">        stack[depth].ts_flags |= TSF_DIDDEL;</a>
<a name="ln1881">        stack[depth].ts_delidx = sp-&gt;ts_fidx;</a>
<a name="ln1882"> </a>
<a name="ln1883">        // Advance over the character in fword[].  Give a bonus to the</a>
<a name="ln1884">        // score if the same character is following &quot;nn&quot; -&gt; &quot;n&quot;.  It's</a>
<a name="ln1885">        // a bit illogical for soundfold tree but it does give better</a>
<a name="ln1886">        // results.</a>
<a name="ln1887">        c = utf_ptr2char((char *)fword + sp-&gt;ts_fidx);</a>
<a name="ln1888">        stack[depth].ts_fidx =</a>
<a name="ln1889">          (char_u)(stack[depth].ts_fidx + utfc_ptr2len((char *)fword + sp-&gt;ts_fidx));</a>
<a name="ln1890">        if (utf_iscomposing(c)) {</a>
<a name="ln1891">          stack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;</a>
<a name="ln1892">        } else if (c == utf_ptr2char((char *)fword + stack[depth].ts_fidx)) {</a>
<a name="ln1893">          stack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;</a>
<a name="ln1894">        }</a>
<a name="ln1895"> </a>
<a name="ln1896">        break;</a>
<a name="ln1897">      }</a>
<a name="ln1898">      FALLTHROUGH;</a>
<a name="ln1899"> </a>
<a name="ln1900">    case STATE_INS_PREP:</a>
<a name="ln1901">      if (sp-&gt;ts_flags &amp; TSF_DIDDEL) {</a>
<a name="ln1902">        // If we just deleted a byte then inserting won't make sense,</a>
<a name="ln1903">        // a substitute is always cheaper.</a>
<a name="ln1904">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1905">        sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln1906">        break;</a>
<a name="ln1907">      }</a>
<a name="ln1908"> </a>
<a name="ln1909">      // skip over NUL bytes</a>
<a name="ln1910">      n = sp-&gt;ts_arridx;</a>
<a name="ln1911">      for (;;) {</a>
<a name="ln1912">        if (sp-&gt;ts_curi &gt; byts[n]) {</a>
<a name="ln1913">          // Only NUL bytes at this node, go to next state.</a>
<a name="ln1914">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1915">          sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln1916">          break;</a>
<a name="ln1917">        }</a>
<a name="ln1918">        if (byts[n + sp-&gt;ts_curi] != NUL) {</a>
<a name="ln1919">          // Found a byte to insert.</a>
<a name="ln1920">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1921">          sp-&gt;ts_state = STATE_INS;</a>
<a name="ln1922">          break;</a>
<a name="ln1923">        }</a>
<a name="ln1924">        sp-&gt;ts_curi++;</a>
<a name="ln1925">      }</a>
<a name="ln1926">      break;</a>
<a name="ln1927"> </a>
<a name="ln1928">    case STATE_INS:</a>
<a name="ln1929">      // Insert one byte.  Repeat this for each possible byte at this</a>
<a name="ln1930">      // node.</a>
<a name="ln1931">      n = sp-&gt;ts_arridx;</a>
<a name="ln1932">      if (sp-&gt;ts_curi &gt; byts[n]) {</a>
<a name="ln1933">        // Done all bytes at this node, go to next state.</a>
<a name="ln1934">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1935">        sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln1936">        break;</a>
<a name="ln1937">      }</a>
<a name="ln1938"> </a>
<a name="ln1939">      // Do one more byte at this node, but:</a>
<a name="ln1940">      // - Skip NUL bytes.</a>
<a name="ln1941">      // - Skip the byte if it's equal to the byte in the word,</a>
<a name="ln1942">      //   accepting that byte is always better.</a>
<a name="ln1943">      n += sp-&gt;ts_curi++;</a>
<a name="ln1944">      c = byts[n];</a>
<a name="ln1945">      if (soundfold &amp;&amp; sp-&gt;ts_twordlen == 0 &amp;&amp; c == '*') {</a>
<a name="ln1946">        // Inserting a vowel at the start of a word counts less,</a>
<a name="ln1947">        // see soundalike_score().</a>
<a name="ln1948">        newscore = 2 * SCORE_INS / 3;</a>
<a name="ln1949">      } else {</a>
<a name="ln1950">        newscore = SCORE_INS;</a>
<a name="ln1951">      }</a>
<a name="ln1952">      if (c != fword[sp-&gt;ts_fidx]</a>
<a name="ln1953">          &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln1954">        go_deeper(stack, depth, newscore);</a>
<a name="ln1955">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1956">        sprintf(changename[depth], &quot;%.*s-%s: insert %c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln1957">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln1958">                c);</a>
<a name="ln1959">#endif</a>
<a name="ln1960">        depth++;</a>
<a name="ln1961">        sp = &amp;stack[depth];</a>
<a name="ln1962">        tword[sp-&gt;ts_twordlen++] = (char_u)c;</a>
<a name="ln1963">        sp-&gt;ts_arridx = idxs[n];</a>
<a name="ln1964">        fl = MB_BYTE2LEN(c);</a>
<a name="ln1965">        if (fl &gt; 1) {</a>
<a name="ln1966">          // There are following bytes for the same character.</a>
<a name="ln1967">          // We must find all bytes before trying</a>
<a name="ln1968">          // delete/insert/swap/etc.</a>
<a name="ln1969">          sp-&gt;ts_tcharlen = (char_u)fl;</a>
<a name="ln1970">          sp-&gt;ts_tcharidx = 1;</a>
<a name="ln1971">          sp-&gt;ts_isdiff = DIFF_INSERT;</a>
<a name="ln1972">        }</a>
<a name="ln1973">        if (fl == 1) {</a>
<a name="ln1974">          // If the previous character was the same, thus doubling a</a>
<a name="ln1975">          // character, give a bonus to the score.  Also for</a>
<a name="ln1976">          // soundfold words (illogical but does give a better</a>
<a name="ln1977">          // score).</a>
<a name="ln1978">          if (sp-&gt;ts_twordlen &gt;= 2</a>
<a name="ln1979">              &amp;&amp; tword[sp-&gt;ts_twordlen - 2] == c) {</a>
<a name="ln1980">            sp-&gt;ts_score -= SCORE_INS - SCORE_INSDUP;</a>
<a name="ln1981">          }</a>
<a name="ln1982">        }</a>
<a name="ln1983">      }</a>
<a name="ln1984">      break;</a>
<a name="ln1985"> </a>
<a name="ln1986">    case STATE_SWAP:</a>
<a name="ln1987">      // Swap two bytes in the bad word: &quot;12&quot; -&gt; &quot;21&quot;.</a>
<a name="ln1988">      // We change &quot;fword&quot; here, it's changed back afterwards at</a>
<a name="ln1989">      // STATE_UNSWAP.</a>
<a name="ln1990">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln1991">      c = *p;</a>
<a name="ln1992">      if (c == NUL) {</a>
<a name="ln1993">        // End of word, can't swap or replace.</a>
<a name="ln1994">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1995">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln1996">        break;</a>
<a name="ln1997">      }</a>
<a name="ln1998"> </a>
<a name="ln1999">      // Don't swap if the first character is not a word character.</a>
<a name="ln2000">      // SWAP3 etc. also don't make sense then.</a>
<a name="ln2001">      if (!soundfold &amp;&amp; !spell_iswordp(p, curwin)) {</a>
<a name="ln2002">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2003">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2004">        break;</a>
<a name="ln2005">      }</a>
<a name="ln2006"> </a>
<a name="ln2007">      n = utf_ptr2len((char *)p);</a>
<a name="ln2008">      c = utf_ptr2char((char *)p);</a>
<a name="ln2009">      if (p[n] == NUL) {</a>
<a name="ln2010">        c2 = NUL;</a>
<a name="ln2011">      } else if (!soundfold &amp;&amp; !spell_iswordp(p + n, curwin)) {</a>
<a name="ln2012">        c2 = c;  // don't swap non-word char</a>
<a name="ln2013">      } else {</a>
<a name="ln2014">        c2 = utf_ptr2char((char *)p + n);</a>
<a name="ln2015">      }</a>
<a name="ln2016"> </a>
<a name="ln2017">      // When the second character is NUL we can't swap.</a>
<a name="ln2018">      if (c2 == NUL) {</a>
<a name="ln2019">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2020">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2021">        break;</a>
<a name="ln2022">      }</a>
<a name="ln2023"> </a>
<a name="ln2024">      // When characters are identical, swap won't do anything.</a>
<a name="ln2025">      // Also get here if the second char is not a word character.</a>
<a name="ln2026">      if (c == c2) {</a>
<a name="ln2027">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2028">        sp-&gt;ts_state = STATE_SWAP3;</a>
<a name="ln2029">        break;</a>
<a name="ln2030">      }</a>
<a name="ln2031">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP)) {</a>
<a name="ln2032">        go_deeper(stack, depth, SCORE_SWAP);</a>
<a name="ln2033">#ifdef DEBUG_TRIEWALK</a>
<a name="ln2034">        snprintf(changename[depth], sizeof(changename[0]),</a>
<a name="ln2035">                 &quot;%.*s-%s: swap %c and %c&quot;,</a>
<a name="ln2036">                 sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln2037">                 c, c2);</a>
<a name="ln2038">#endif</a>
<a name="ln2039">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2040">        sp-&gt;ts_state = STATE_UNSWAP;</a>
<a name="ln2041">        depth++;</a>
<a name="ln2042">        fl = utf_char2len(c2);</a>
<a name="ln2043">        memmove(p, p + n, (size_t)fl);</a>
<a name="ln2044">        utf_char2bytes(c, (char *)p + fl);</a>
<a name="ln2045">        stack[depth].ts_fidxtry = (char_u)(sp-&gt;ts_fidx + n + fl);</a>
<a name="ln2046">      } else {</a>
<a name="ln2047">        // If this swap doesn't work then SWAP3 won't either.</a>
<a name="ln2048">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2049">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2050">      }</a>
<a name="ln2051">      break;</a>
<a name="ln2052"> </a>
<a name="ln2053">    case STATE_UNSWAP:</a>
<a name="ln2054">      // Undo the STATE_SWAP swap: &quot;21&quot; -&gt; &quot;12&quot;.</a>
<a name="ln2055">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2056">      n = utfc_ptr2len((char *)p);</a>
<a name="ln2057">      c = utf_ptr2char((char *)p + n);</a>
<a name="ln2058">      memmove(p + utfc_ptr2len((char *)p + n), p, (size_t)n);</a>
<a name="ln2059">      utf_char2bytes(c, (char *)p);</a>
<a name="ln2060"> </a>
<a name="ln2061">      FALLTHROUGH;</a>
<a name="ln2062"> </a>
<a name="ln2063">    case STATE_SWAP3:</a>
<a name="ln2064">      // Swap two bytes, skipping one: &quot;123&quot; -&gt; &quot;321&quot;.  We change</a>
<a name="ln2065">      // &quot;fword&quot; here, it's changed back afterwards at STATE_UNSWAP3.</a>
<a name="ln2066">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2067">      n = utf_ptr2len((char *)p);</a>
<a name="ln2068">      c = utf_ptr2char((char *)p);</a>
<a name="ln2069">      fl = utf_ptr2len((char *)p + n);</a>
<a name="ln2070">      c2 = utf_ptr2char((char *)p + n);</a>
<a name="ln2071">      if (!soundfold &amp;&amp; !spell_iswordp(p + n + fl, curwin)) {</a>
<a name="ln2072">        c3 = c;  // don't swap non-word char</a>
<a name="ln2073">      } else {</a>
<a name="ln2074">        c3 = utf_ptr2char((char *)p + n + fl);</a>
<a name="ln2075">      }</a>
<a name="ln2076"> </a>
<a name="ln2077">      // When characters are identical: &quot;121&quot; then SWAP3 result is</a>
<a name="ln2078">      // identical, ROT3L result is same as SWAP: &quot;211&quot;, ROT3L result is</a>
<a name="ln2079">      // same as SWAP on next char: &quot;112&quot;.  Thus skip all swapping.</a>
<a name="ln2080">      // Also skip when c3 is NUL.</a>
<a name="ln2081">      // Also get here when the third character is not a word character.</a>
<a name="ln2082">      // Second character may any char: &quot;a.b&quot; -&gt; &quot;b.a&quot;</a>
<a name="ln2083">      if (c == c3 || c3 == NUL) {</a>
<a name="ln2084">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2085">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2086">        break;</a>
<a name="ln2087">      }</a>
<a name="ln2088">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln2089">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln2090">#ifdef DEBUG_TRIEWALK</a>
<a name="ln2091">        sprintf(changename[depth], &quot;%.*s-%s: swap3 %c and %c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln2092">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln2093">                c, c3);</a>
<a name="ln2094">#endif</a>
<a name="ln2095">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2096">        sp-&gt;ts_state = STATE_UNSWAP3;</a>
<a name="ln2097">        depth++;</a>
<a name="ln2098">        tl = utf_char2len(c3);</a>
<a name="ln2099">        memmove(p, p + n + fl, (size_t)tl);</a>
<a name="ln2100">        utf_char2bytes(c2, (char *)p + tl);</a>
<a name="ln2101">        utf_char2bytes(c, (char *)p + fl + tl);</a>
<a name="ln2102">        stack[depth].ts_fidxtry = (char_u)(sp-&gt;ts_fidx + n + fl + tl);</a>
<a name="ln2103">      } else {</a>
<a name="ln2104">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2105">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2106">      }</a>
<a name="ln2107">      break;</a>
<a name="ln2108"> </a>
<a name="ln2109">    case STATE_UNSWAP3:</a>
<a name="ln2110">      // Undo STATE_SWAP3: &quot;321&quot; -&gt; &quot;123&quot;</a>
<a name="ln2111">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2112">      n = utfc_ptr2len((char *)p);</a>
<a name="ln2113">      c2 = utf_ptr2char((char *)p + n);</a>
<a name="ln2114">      fl = utfc_ptr2len((char *)p + n);</a>
<a name="ln2115">      c = utf_ptr2char((char *)p + n + fl);</a>
<a name="ln2116">      tl = utfc_ptr2len((char *)p + n + fl);</a>
<a name="ln2117">      memmove(p + fl + tl, p, (size_t)n);</a>
<a name="ln2118">      utf_char2bytes(c, (char *)p);</a>
<a name="ln2119">      utf_char2bytes(c2, (char *)p + tl);</a>
<a name="ln2120">      p = p + tl;</a>
<a name="ln2121"> </a>
<a name="ln2122">      if (!soundfold &amp;&amp; !spell_iswordp(p, curwin)) {</a>
<a name="ln2123">        // Middle char is not a word char, skip the rotate.  First and</a>
<a name="ln2124">        // third char were already checked at swap and swap3.</a>
<a name="ln2125">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2126">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2127">        break;</a>
<a name="ln2128">      }</a>
<a name="ln2129"> </a>
<a name="ln2130">      // Rotate three characters left: &quot;123&quot; -&gt; &quot;231&quot;.  We change</a>
<a name="ln2131">      // &quot;fword&quot; here, it's changed back afterwards at STATE_UNROT3L.</a>
<a name="ln2132">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln2133">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln2134">#ifdef DEBUG_TRIEWALK</a>
<a name="ln2135">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2136">        sprintf(changename[depth], &quot;%.*s-%s: rotate left %c%c%c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln2137">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln2138">                p[0], p[1], p[2]);</a>
<a name="ln2139">#endif</a>
<a name="ln2140">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2141">        sp-&gt;ts_state = STATE_UNROT3L;</a>
<a name="ln2142">        depth++;</a>
<a name="ln2143">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2144">        n = utf_ptr2len((char *)p);</a>
<a name="ln2145">        c = utf_ptr2char((char *)p);</a>
<a name="ln2146">        fl = utf_ptr2len((char *)p + n);</a>
<a name="ln2147">        fl += utf_ptr2len((char *)p + n + fl);</a>
<a name="ln2148">        memmove(p, p + n, (size_t)fl);</a>
<a name="ln2149">        utf_char2bytes(c, (char *)p + fl);</a>
<a name="ln2150">        stack[depth].ts_fidxtry = (char_u)(sp-&gt;ts_fidx + n + fl);</a>
<a name="ln2151">      } else {</a>
<a name="ln2152">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2153">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2154">      }</a>
<a name="ln2155">      break;</a>
<a name="ln2156"> </a>
<a name="ln2157">    case STATE_UNROT3L:</a>
<a name="ln2158">      // Undo ROT3L: &quot;231&quot; -&gt; &quot;123&quot;</a>
<a name="ln2159">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2160">      n = utfc_ptr2len((char *)p);</a>
<a name="ln2161">      n += utfc_ptr2len((char *)p + n);</a>
<a name="ln2162">      c = utf_ptr2char((char *)p + n);</a>
<a name="ln2163">      tl = utfc_ptr2len((char *)p + n);</a>
<a name="ln2164">      memmove(p + tl, p, (size_t)n);</a>
<a name="ln2165">      utf_char2bytes(c, (char *)p);</a>
<a name="ln2166"> </a>
<a name="ln2167">      // Rotate three bytes right: &quot;123&quot; -&gt; &quot;312&quot;.  We change &quot;fword&quot;</a>
<a name="ln2168">      // here, it's changed back afterwards at STATE_UNROT3R.</a>
<a name="ln2169">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln2170">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln2171">#ifdef DEBUG_TRIEWALK</a>
<a name="ln2172">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2173">        sprintf(changename[depth], &quot;%.*s-%s: rotate right %c%c%c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln2174">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln2175">                p[0], p[1], p[2]);</a>
<a name="ln2176">#endif</a>
<a name="ln2177">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2178">        sp-&gt;ts_state = STATE_UNROT3R;</a>
<a name="ln2179">        depth++;</a>
<a name="ln2180">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2181">        n = utf_ptr2len((char *)p);</a>
<a name="ln2182">        n += utf_ptr2len((char *)p + n);</a>
<a name="ln2183">        c = utf_ptr2char((char *)p + n);</a>
<a name="ln2184">        tl = utf_ptr2len((char *)p + n);</a>
<a name="ln2185">        memmove(p + tl, p, (size_t)n);</a>
<a name="ln2186">        utf_char2bytes(c, (char *)p);</a>
<a name="ln2187">        stack[depth].ts_fidxtry = (char_u)(sp-&gt;ts_fidx + n + tl);</a>
<a name="ln2188">      } else {</a>
<a name="ln2189">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2190">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2191">      }</a>
<a name="ln2192">      break;</a>
<a name="ln2193"> </a>
<a name="ln2194">    case STATE_UNROT3R:</a>
<a name="ln2195">      // Undo ROT3R: &quot;312&quot; -&gt; &quot;123&quot;</a>
<a name="ln2196">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2197">      c = utf_ptr2char((char *)p);</a>
<a name="ln2198">      tl = utfc_ptr2len((char *)p);</a>
<a name="ln2199">      n = utfc_ptr2len((char *)p + tl);</a>
<a name="ln2200">      n += utfc_ptr2len((char *)p + tl + n);</a>
<a name="ln2201">      memmove(p, p + tl, (size_t)n);</a>
<a name="ln2202">      utf_char2bytes(c, (char *)p + n);</a>
<a name="ln2203"> </a>
<a name="ln2204">      FALLTHROUGH;</a>
<a name="ln2205"> </a>
<a name="ln2206">    case STATE_REP_INI:</a>
<a name="ln2207">      // Check if matching with REP items from the .aff file would work.</a>
<a name="ln2208">      // Quickly skip if:</a>
<a name="ln2209">      // - there are no REP items and we are not in the soundfold trie</a>
<a name="ln2210">      // - the score is going to be too high anyway</a>
<a name="ln2211">      // - already applied a REP item or swapped here</a>
<a name="ln2212">      if ((lp-&gt;lp_replang == NULL &amp;&amp; !soundfold)</a>
<a name="ln2213">          || sp-&gt;ts_score + SCORE_REP &gt;= su-&gt;su_maxscore</a>
<a name="ln2214">          || sp-&gt;ts_fidx &lt; sp-&gt;ts_fidxtry) {</a>
<a name="ln2215">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2216">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln2217">        break;</a>
<a name="ln2218">      }</a>
<a name="ln2219"> </a>
<a name="ln2220">      // Use the first byte to quickly find the first entry that may</a>
<a name="ln2221">      // match.  If the index is -1 there is none.</a>
<a name="ln2222">      if (soundfold) {</a>
<a name="ln2223">        sp-&gt;ts_curi = slang-&gt;sl_repsal_first[fword[sp-&gt;ts_fidx]];</a>
<a name="ln2224">      } else {</a>
<a name="ln2225">        sp-&gt;ts_curi = lp-&gt;lp_replang-&gt;sl_rep_first[fword[sp-&gt;ts_fidx]];</a>
<a name="ln2226">      }</a>
<a name="ln2227"> </a>
<a name="ln2228">      if (sp-&gt;ts_curi &lt; 0) {</a>
<a name="ln2229">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2230">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln2231">        break;</a>
<a name="ln2232">      }</a>
<a name="ln2233"> </a>
<a name="ln2234">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2235">      sp-&gt;ts_state = STATE_REP;</a>
<a name="ln2236">      FALLTHROUGH;</a>
<a name="ln2237"> </a>
<a name="ln2238">    case STATE_REP:</a>
<a name="ln2239">      // Try matching with REP items from the .aff file.  For each match</a>
<a name="ln2240">      // replace the characters and check if the resulting word is</a>
<a name="ln2241">      // valid.</a>
<a name="ln2242">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2243"> </a>
<a name="ln2244">      if (soundfold) {</a>
<a name="ln2245">        gap = &amp;slang-&gt;sl_repsal;</a>
<a name="ln2246">      } else {</a>
<a name="ln2247">        gap = &amp;lp-&gt;lp_replang-&gt;sl_rep;</a>
<a name="ln2248">      }</a>
<a name="ln2249">      while (sp-&gt;ts_curi &lt; gap-&gt;ga_len) {</a>
<a name="ln2250">        ftp = (fromto_T *)gap-&gt;ga_data + sp-&gt;ts_curi++;</a>
<a name="ln2251">        if (*ftp-&gt;ft_from != *p) {</a>
<a name="ln2252">          // past possible matching entries</a>
<a name="ln2253">          sp-&gt;ts_curi = (char_u)gap-&gt;ga_len;</a>
<a name="ln2254">          break;</a>
<a name="ln2255">        }</a>
<a name="ln2256">        if (STRNCMP(ftp-&gt;ft_from, p, STRLEN(ftp-&gt;ft_from)) == 0</a>
<a name="ln2257">            &amp;&amp; TRY_DEEPER(su, stack, depth, SCORE_REP)) {</a>
<a name="ln2258">          go_deeper(stack, depth, SCORE_REP);</a>
<a name="ln2259">#ifdef DEBUG_TRIEWALK</a>
<a name="ln2260">          sprintf(changename[depth], &quot;%.*s-%s: replace %s with %s&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln2261">                  sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln2262">                  ftp-&gt;ft_from, ftp-&gt;ft_to);</a>
<a name="ln2263">#endif</a>
<a name="ln2264">          // Need to undo this afterwards.</a>
<a name="ln2265">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2266">          sp-&gt;ts_state = STATE_REP_UNDO;</a>
<a name="ln2267"> </a>
<a name="ln2268">          // Change the &quot;from&quot; to the &quot;to&quot; string.</a>
<a name="ln2269">          depth++;</a>
<a name="ln2270">          fl = (int)STRLEN(ftp-&gt;ft_from);</a>
<a name="ln2271">          tl = (int)STRLEN(ftp-&gt;ft_to);</a>
<a name="ln2272">          if (fl != tl) {</a>
<a name="ln2273">            STRMOVE(p + tl, p + fl);</a>
<a name="ln2274">            repextra += tl - fl;</a>
<a name="ln2275">          }</a>
<a name="ln2276">          memmove(p, ftp-&gt;ft_to, (size_t)tl);</a>
<a name="ln2277">          stack[depth].ts_fidxtry = (char_u)(sp-&gt;ts_fidx + tl);</a>
<a name="ln2278">          stack[depth].ts_tcharlen = 0;</a>
<a name="ln2279">          break;</a>
<a name="ln2280">        }</a>
<a name="ln2281">      }</a>
<a name="ln2282"> </a>
<a name="ln2283">      if (sp-&gt;ts_curi &gt;= gap-&gt;ga_len &amp;&amp; sp-&gt;ts_state == STATE_REP) {</a>
<a name="ln2284">        // No (more) matches.</a>
<a name="ln2285">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2286">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln2287">      }</a>
<a name="ln2288"> </a>
<a name="ln2289">      break;</a>
<a name="ln2290"> </a>
<a name="ln2291">    case STATE_REP_UNDO:</a>
<a name="ln2292">      // Undo a REP replacement and continue with the next one.</a>
<a name="ln2293">      if (soundfold) {</a>
<a name="ln2294">        gap = &amp;slang-&gt;sl_repsal;</a>
<a name="ln2295">      } else {</a>
<a name="ln2296">        gap = &amp;lp-&gt;lp_replang-&gt;sl_rep;</a>
<a name="ln2297">      }</a>
<a name="ln2298">      ftp = (fromto_T *)gap-&gt;ga_data + sp-&gt;ts_curi - 1;</a>
<a name="ln2299">      fl = (int)STRLEN(ftp-&gt;ft_from);</a>
<a name="ln2300">      tl = (int)STRLEN(ftp-&gt;ft_to);</a>
<a name="ln2301">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2302">      if (fl != tl) {</a>
<a name="ln2303">        STRMOVE(p + fl, p + tl);</a>
<a name="ln2304">        repextra -= tl - fl;</a>
<a name="ln2305">      }</a>
<a name="ln2306">      memmove(p, ftp-&gt;ft_from, (size_t)fl);</a>
<a name="ln2307">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2308">      sp-&gt;ts_state = STATE_REP;</a>
<a name="ln2309">      break;</a>
<a name="ln2310"> </a>
<a name="ln2311">    default:</a>
<a name="ln2312">      // Did all possible states at this level, go up one level.</a>
<a name="ln2313">      depth--;</a>
<a name="ln2314"> </a>
<a name="ln2315">      if (depth &gt;= 0 &amp;&amp; stack[depth].ts_prefixdepth == PFD_PREFIXTREE) {</a>
<a name="ln2316">        // Continue in or go back to the prefix tree.</a>
<a name="ln2317">        byts = pbyts;</a>
<a name="ln2318">        idxs = pidxs;</a>
<a name="ln2319">      }</a>
<a name="ln2320"> </a>
<a name="ln2321">      // Don't check for CTRL-C too often, it takes time.</a>
<a name="ln2322">      if (--breakcheckcount == 0) {</a>
<a name="ln2323">        os_breakcheck();</a>
<a name="ln2324">        breakcheckcount = 1000;</a>
<a name="ln2325">        if (spell_suggest_timeout &gt; 0 &amp;&amp; profile_passed_limit(time_limit)) {</a>
<a name="ln2326">          got_int = true;</a>
<a name="ln2327">        }</a>
<a name="ln2328">      }</a>
<a name="ln2329">    }</a>
<a name="ln2330">  }</a>
<a name="ln2331">}</a>
<a name="ln2332"> </a>
<a name="ln2333">/// Go one level deeper in the tree.</a>
<a name="ln2334">static void go_deeper(trystate_T *stack, int depth, int score_add)</a>
<a name="ln2335">{</a>
<a name="ln2336">  stack[depth + 1] = stack[depth];</a>
<a name="ln2337">  stack[depth + 1].ts_state = STATE_START;</a>
<a name="ln2338">  stack[depth + 1].ts_score = stack[depth].ts_score + score_add;</a>
<a name="ln2339">  stack[depth + 1].ts_curi = 1;         // start just after length byte</a>
<a name="ln2340">  stack[depth + 1].ts_flags = 0;</a>
<a name="ln2341">}</a>
<a name="ln2342"> </a>
<a name="ln2343">/// &quot;fword&quot; is a good word with case folded.  Find the matching keep-case</a>
<a name="ln2344">/// words and put it in &quot;kword&quot;.</a>
<a name="ln2345">/// Theoretically there could be several keep-case words that result in the</a>
<a name="ln2346">/// same case-folded word, but we only find one...</a>
<a name="ln2347">static void find_keepcap_word(slang_T *slang, char_u *fword, char_u *kword)</a>
<a name="ln2348">{</a>
<a name="ln2349">  char_u uword[MAXWLEN];                // &quot;fword&quot; in upper-case</a>
<a name="ln2350">  int depth;</a>
<a name="ln2351">  idx_T tryidx;</a>
<a name="ln2352"> </a>
<a name="ln2353">  // The following arrays are used at each depth in the tree.</a>
<a name="ln2354">  idx_T arridx[MAXWLEN];</a>
<a name="ln2355">  int round[MAXWLEN];</a>
<a name="ln2356">  int fwordidx[MAXWLEN];</a>
<a name="ln2357">  int uwordidx[MAXWLEN];</a>
<a name="ln2358">  int kwordlen[MAXWLEN];</a>
<a name="ln2359"> </a>
<a name="ln2360">  int flen, ulen;</a>
<a name="ln2361">  int l;</a>
<a name="ln2362">  int len;</a>
<a name="ln2363">  int c;</a>
<a name="ln2364">  idx_T lo, hi, m;</a>
<a name="ln2365">  char_u *p;</a>
<a name="ln2366">  char_u *byts = slang-&gt;sl_kbyts;      // array with bytes of the words</a>
<a name="ln2367">  idx_T *idxs = slang-&gt;sl_kidxs;      // array with indexes</a>
<a name="ln2368"> </a>
<a name="ln2369">  if (byts == NULL) {</a>
<a name="ln2370">    // array is empty: &quot;cannot happen&quot;</a>
<a name="ln2371">    *kword = NUL;</a>
<a name="ln2372">    return;</a>
<a name="ln2373">  }</a>
<a name="ln2374"> </a>
<a name="ln2375">  // Make an all-cap version of &quot;fword&quot;.</a>
<a name="ln2376">  allcap_copy(fword, uword);</a>
<a name="ln2377"> </a>
<a name="ln2378">  // Each character needs to be tried both case-folded and upper-case.</a>
<a name="ln2379">  // All this gets very complicated if we keep in mind that changing case</a>
<a name="ln2380">  // may change the byte length of a multi-byte character...</a>
<a name="ln2381">  depth = 0;</a>
<a name="ln2382">  arridx[0] = 0;</a>
<a name="ln2383">  round[0] = 0;</a>
<a name="ln2384">  fwordidx[0] = 0;</a>
<a name="ln2385">  uwordidx[0] = 0;</a>
<a name="ln2386">  kwordlen[0] = 0;</a>
<a name="ln2387">  while (depth &gt;= 0) {</a>
<a name="ln2388">    if (fword[fwordidx[depth]] == NUL) {</a>
<a name="ln2389">      // We are at the end of &quot;fword&quot;.  If the tree allows a word to end</a>
<a name="ln2390">      // here we have found a match.</a>
<a name="ln2391">      if (byts[arridx[depth] + 1] == 0) {</a>
<a name="ln2392">        kword[kwordlen[depth]] = NUL;</a>
<a name="ln2393">        return;</a>
<a name="ln2394">      }</a>
<a name="ln2395"> </a>
<a name="ln2396">      // kword is getting too long, continue one level up</a>
<a name="ln2397">      depth--;</a>
<a name="ln2398">    } else if (++round[depth] &gt; 2) {</a>
<a name="ln2399">      // tried both fold-case and upper-case character, continue one</a>
<a name="ln2400">      // level up</a>
<a name="ln2401">      depth--;</a>
<a name="ln2402">    } else {</a>
<a name="ln2403">      // round[depth] == 1: Try using the folded-case character.</a>
<a name="ln2404">      // round[depth] == 2: Try using the upper-case character.</a>
<a name="ln2405">      flen = utf_ptr2len((char *)fword + fwordidx[depth]);</a>
<a name="ln2406">      ulen = utf_ptr2len((char *)uword + uwordidx[depth]);</a>
<a name="ln2407">      if (round[depth] == 1) {</a>
<a name="ln2408">        p = fword + fwordidx[depth];</a>
<a name="ln2409">        l = flen;</a>
<a name="ln2410">      } else {</a>
<a name="ln2411">        p = uword + uwordidx[depth];</a>
<a name="ln2412">        l = ulen;</a>
<a name="ln2413">      }</a>
<a name="ln2414"> </a>
<a name="ln2415">      for (tryidx = arridx[depth]; l &gt; 0; l--) {</a>
<a name="ln2416">        // Perform a binary search in the list of accepted bytes.</a>
<a name="ln2417">        len = byts[tryidx++];</a>
<a name="ln2418">        c = *p++;</a>
<a name="ln2419">        lo = tryidx;</a>
<a name="ln2420">        hi = tryidx + len - 1;</a>
<a name="ln2421">        while (lo &lt; hi) {</a>
<a name="ln2422">          m = (lo + hi) / 2;</a>
<a name="ln2423">          if (byts[m] &gt; c) {</a>
<a name="ln2424">            hi = m - 1;</a>
<a name="ln2425">          } else if (byts[m] &lt; c) {</a>
<a name="ln2426">            lo = m + 1;</a>
<a name="ln2427">          } else {</a>
<a name="ln2428">            lo = hi = m;</a>
<a name="ln2429">            break;</a>
<a name="ln2430">          }</a>
<a name="ln2431">        }</a>
<a name="ln2432"> </a>
<a name="ln2433">        // Stop if there is no matching byte.</a>
<a name="ln2434">        if (hi &lt; lo || byts[lo] != c) {</a>
<a name="ln2435">          break;</a>
<a name="ln2436">        }</a>
<a name="ln2437"> </a>
<a name="ln2438">        // Continue at the child (if there is one).</a>
<a name="ln2439">        tryidx = idxs[lo];</a>
<a name="ln2440">      }</a>
<a name="ln2441"> </a>
<a name="ln2442">      if (l == 0) {</a>
<a name="ln2443">        // Found the matching char.  Copy it to &quot;kword&quot; and go a</a>
<a name="ln2444">        // level deeper.</a>
<a name="ln2445">        if (round[depth] == 1) {</a>
<a name="ln2446">          STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],  // NOLINT(runtime/printf)</a>
<a name="ln2447">                  flen);</a>
<a name="ln2448">          kwordlen[depth + 1] = kwordlen[depth] + flen;</a>
<a name="ln2449">        } else {</a>
<a name="ln2450">          STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],  // NOLINT(runtime/printf)</a>
<a name="ln2451">                  ulen);</a>
<a name="ln2452">          kwordlen[depth + 1] = kwordlen[depth] + ulen;</a>
<a name="ln2453">        }</a>
<a name="ln2454">        fwordidx[depth + 1] = fwordidx[depth] + flen;</a>
<a name="ln2455">        uwordidx[depth + 1] = uwordidx[depth] + ulen;</a>
<a name="ln2456"> </a>
<a name="ln2457">        depth++;</a>
<a name="ln2458">        arridx[depth] = tryidx;</a>
<a name="ln2459">        round[depth] = 0;</a>
<a name="ln2460">      }</a>
<a name="ln2461">    }</a>
<a name="ln2462">  }</a>
<a name="ln2463"> </a>
<a name="ln2464">  // Didn't find it: &quot;cannot happen&quot;.</a>
<a name="ln2465">  *kword = NUL;</a>
<a name="ln2466">}</a>
<a name="ln2467"> </a>
<a name="ln2468">/// Compute the sound-a-like score for suggestions in su-&gt;su_ga and add them to</a>
<a name="ln2469">/// su-&gt;su_sga.</a>
<a name="ln2470">static void score_comp_sal(suginfo_T *su)</a>
<a name="ln2471">{</a>
<a name="ln2472">  langp_T *lp;</a>
<a name="ln2473">  char_u badsound[MAXWLEN];</a>
<a name="ln2474">  int i;</a>
<a name="ln2475">  suggest_T *stp;</a>
<a name="ln2476">  suggest_T *sstp;</a>
<a name="ln2477">  int score;</a>
<a name="ln2478"> </a>
<a name="ln2479">  ga_grow(&amp;su-&gt;su_sga, su-&gt;su_ga.ga_len);</a>
<a name="ln2480"> </a>
<a name="ln2481">  // Use the sound-folding of the first language that supports it.</a>
<a name="ln2482">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln2483">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln2484">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln2485">      // soundfold the bad word</a>
<a name="ln2486">      spell_soundfold(lp-&gt;lp_slang, su-&gt;su_fbadword, true, badsound);</a>
<a name="ln2487"> </a>
<a name="ln2488">      for (i = 0; i &lt; su-&gt;su_ga.ga_len; i++) {</a>
<a name="ln2489">        stp = &amp;SUG(su-&gt;su_ga, i);</a>
<a name="ln2490"> </a>
<a name="ln2491">        // Case-fold the suggested word, sound-fold it and compute the</a>
<a name="ln2492">        // sound-a-like score.</a>
<a name="ln2493">        score = stp_sal_score(stp, su, lp-&gt;lp_slang, badsound);</a>
<a name="ln2494">        if (score &lt; SCORE_MAXMAX) {</a>
<a name="ln2495">          // Add the suggestion.</a>
<a name="ln2496">          sstp = &amp;SUG(su-&gt;su_sga, su-&gt;su_sga.ga_len);</a>
<a name="ln2497">          sstp-&gt;st_word = xstrdup(stp-&gt;st_word);</a>
<a name="ln2498">          sstp-&gt;st_wordlen = stp-&gt;st_wordlen;</a>
<a name="ln2499">          sstp-&gt;st_score = score;</a>
<a name="ln2500">          sstp-&gt;st_altscore = 0;</a>
<a name="ln2501">          sstp-&gt;st_orglen = stp-&gt;st_orglen;</a>
<a name="ln2502">          su-&gt;su_sga.ga_len++;</a>
<a name="ln2503">        }</a>
<a name="ln2504">      }</a>
<a name="ln2505">      break;</a>
<a name="ln2506">    }</a>
<a name="ln2507">  }</a>
<a name="ln2508">}</a>
<a name="ln2509"> </a>
<a name="ln2510">/// Combine the list of suggestions in su-&gt;su_ga and su-&gt;su_sga.</a>
<a name="ln2511">/// They are entwined.</a>
<a name="ln2512">static void score_combine(suginfo_T *su)</a>
<a name="ln2513">{</a>
<a name="ln2514">  garray_T ga;</a>
<a name="ln2515">  garray_T *gap;</a>
<a name="ln2516">  langp_T *lp;</a>
<a name="ln2517">  suggest_T *stp;</a>
<a name="ln2518">  char *p;</a>
<a name="ln2519">  char badsound[MAXWLEN];</a>
<a name="ln2520">  int round;</a>
<a name="ln2521">  slang_T *slang = NULL;</a>
<a name="ln2522"> </a>
<a name="ln2523">  // Add the alternate score to su_ga.</a>
<a name="ln2524">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln2525">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln2526">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln2527">      // soundfold the bad word</a>
<a name="ln2528">      slang = lp-&gt;lp_slang;</a>
<a name="ln2529">      spell_soundfold(slang, su-&gt;su_fbadword, true, (char_u *)badsound);</a>
<a name="ln2530"> </a>
<a name="ln2531">      for (int i = 0; i &lt; su-&gt;su_ga.ga_len; i++) {</a>
<a name="ln2532">        stp = &amp;SUG(su-&gt;su_ga, i);</a>
<a name="ln2533">        stp-&gt;st_altscore = stp_sal_score(stp, su, slang, (char_u *)badsound);</a>
<a name="ln2534">        if (stp-&gt;st_altscore == SCORE_MAXMAX) {</a>
<a name="ln2535">          stp-&gt;st_score = (stp-&gt;st_score * 3 + SCORE_BIG) / 4;</a>
<a name="ln2536">        } else {</a>
<a name="ln2537">          stp-&gt;st_score = (stp-&gt;st_score * 3 + stp-&gt;st_altscore) / 4;</a>
<a name="ln2538">        }</a>
<a name="ln2539">        stp-&gt;st_salscore = false;</a>
<a name="ln2540">      }</a>
<a name="ln2541">      break;</a>
<a name="ln2542">    }</a>
<a name="ln2543">  }</a>
<a name="ln2544"> </a>
<a name="ln2545">  if (slang == NULL) {  // Using &quot;double&quot; without sound folding.</a>
<a name="ln2546">    (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore,</a>
<a name="ln2547">                              su-&gt;su_maxcount);</a>
<a name="ln2548">    return;</a>
<a name="ln2549">  }</a>
<a name="ln2550"> </a>
<a name="ln2551">  // Add the alternate score to su_sga.</a>
<a name="ln2552">  for (int i = 0; i &lt; su-&gt;su_sga.ga_len; i++) {</a>
<a name="ln2553">    stp = &amp;SUG(su-&gt;su_sga, i);</a>
<a name="ln2554">    stp-&gt;st_altscore = spell_edit_score(slang, su-&gt;su_badword, (char_u *)stp-&gt;st_word);</a>
<a name="ln2555">    if (stp-&gt;st_score == SCORE_MAXMAX) {</a>
<a name="ln2556">      stp-&gt;st_score = (SCORE_BIG * 7 + stp-&gt;st_altscore) / 8;</a>
<a name="ln2557">    } else {</a>
<a name="ln2558">      stp-&gt;st_score = (stp-&gt;st_score * 7 + stp-&gt;st_altscore) / 8;</a>
<a name="ln2559">    }</a>
<a name="ln2560">    stp-&gt;st_salscore = true;</a>
<a name="ln2561">  }</a>
<a name="ln2562"> </a>
<a name="ln2563">  // Remove bad suggestions, sort the suggestions and truncate at &quot;maxcount&quot;</a>
<a name="ln2564">  // for both lists.</a>
<a name="ln2565">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln2566">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln2567">  check_suggestions(su, &amp;su-&gt;su_sga);</a>
<a name="ln2568">  (void)cleanup_suggestions(&amp;su-&gt;su_sga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln2569"> </a>
<a name="ln2570">  ga_init(&amp;ga, (int)sizeof(suginfo_T), 1);</a>
<a name="ln2571">  ga_grow(&amp;ga, su-&gt;su_ga.ga_len + su-&gt;su_sga.ga_len);</a>
<a name="ln2572"> </a>
<a name="ln2573">  stp = &amp;SUG(ga, 0);</a>
<a name="ln2574">  for (int i = 0; i &lt; su-&gt;su_ga.ga_len || i &lt; su-&gt;su_sga.ga_len; i++) {</a>
<a name="ln2575">    // round 1: get a suggestion from su_ga</a>
<a name="ln2576">    // round 2: get a suggestion from su_sga</a>
<a name="ln2577">    for (round = 1; round &lt;= 2; round++) {</a>
<a name="ln2578">      gap = round == 1 ? &amp;su-&gt;su_ga : &amp;su-&gt;su_sga;</a>
<a name="ln2579">      if (i &lt; gap-&gt;ga_len) {</a>
<a name="ln2580">        // Don't add a word if it's already there.</a>
<a name="ln2581">        p = SUG(*gap, i).st_word;</a>
<a name="ln2582">        int j;</a>
<a name="ln2583">        for (j = 0; j &lt; ga.ga_len; j++) {</a>
<a name="ln2584">          if (strcmp(stp[j].st_word, p) == 0) {</a>
<a name="ln2585">            break;</a>
<a name="ln2586">          }</a>
<a name="ln2587">        }</a>
<a name="ln2588">        if (j == ga.ga_len) {</a>
<a name="ln2589">          stp[ga.ga_len++] = SUG(*gap, i);</a>
<a name="ln2590">        } else {</a>
<a name="ln2591">          xfree(p);</a>
<a name="ln2592">        }</a>
<a name="ln2593">      }</a>
<a name="ln2594">    }</a>
<a name="ln2595">  }</a>
<a name="ln2596"> </a>
<a name="ln2597">  ga_clear(&amp;su-&gt;su_ga);</a>
<a name="ln2598">  ga_clear(&amp;su-&gt;su_sga);</a>
<a name="ln2599"> </a>
<a name="ln2600">  // Truncate the list to the number of suggestions that will be displayed.</a>
<a name="ln2601">  if (ga.ga_len &gt; su-&gt;su_maxcount) {</a>
<a name="ln2602">    for (int i = su-&gt;su_maxcount; i &lt; ga.ga_len; i++) {</a>
<a name="ln2603">      xfree(stp[i].st_word);</a>
<a name="ln2604">    }</a>
<a name="ln2605">    ga.ga_len = su-&gt;su_maxcount;</a>
<a name="ln2606">  }</a>
<a name="ln2607"> </a>
<a name="ln2608">  su-&gt;su_ga = ga;</a>
<a name="ln2609">}</a>
<a name="ln2610"> </a>
<a name="ln2611">/// For the goodword in &quot;stp&quot; compute the soundalike score compared to the</a>
<a name="ln2612">/// badword.</a>
<a name="ln2613">///</a>
<a name="ln2614">/// @param badsound  sound-folded badword</a>
<a name="ln2615">static int stp_sal_score(suggest_T *stp, suginfo_T *su, slang_T *slang, char_u *badsound)</a>
<a name="ln2616">{</a>
<a name="ln2617">  char_u *p;</a>
<a name="ln2618">  char_u *pbad;</a>
<a name="ln2619">  char_u *pgood;</a>
<a name="ln2620">  char_u badsound2[MAXWLEN];</a>
<a name="ln2621">  char_u fword[MAXWLEN];</a>
<a name="ln2622">  char_u goodsound[MAXWLEN];</a>
<a name="ln2623">  char_u goodword[MAXWLEN];</a>
<a name="ln2624">  int lendiff;</a>
<a name="ln2625"> </a>
<a name="ln2626">  lendiff = su-&gt;su_badlen - stp-&gt;st_orglen;</a>
<a name="ln2627">  if (lendiff &gt;= 0) {</a>
<a name="ln2628">    pbad = badsound;</a>
<a name="ln2629">  } else {</a>
<a name="ln2630">    // soundfold the bad word with more characters following</a>
<a name="ln2631">    (void)spell_casefold(curwin, su-&gt;su_badptr, stp-&gt;st_orglen, fword, MAXWLEN);</a>
<a name="ln2632"> </a>
<a name="ln2633">    // When joining two words the sound often changes a lot.  E.g., &quot;t he&quot;</a>
<a name="ln2634">    // sounds like &quot;t h&quot; while &quot;the&quot; sounds like &quot;@&quot;.  Avoid that by</a>
<a name="ln2635">    // removing the space.  Don't do it when the good word also contains a</a>
<a name="ln2636">    // space.</a>
<a name="ln2637">    if (ascii_iswhite(su-&gt;su_badptr[su-&gt;su_badlen])</a>
<a name="ln2638">        &amp;&amp; *skiptowhite(stp-&gt;st_word) == NUL) {</a>
<a name="ln2639">      for (p = fword; *(p = (char_u *)skiptowhite((char *)p)) != NUL;) {</a>
<a name="ln2640">        STRMOVE(p, p + 1);</a>
<a name="ln2641">      }</a>
<a name="ln2642">    }</a>
<a name="ln2643"> </a>
<a name="ln2644">    spell_soundfold(slang, fword, true, badsound2);</a>
<a name="ln2645">    pbad = badsound2;</a>
<a name="ln2646">  }</a>
<a name="ln2647"> </a>
<a name="ln2648">  if (lendiff &gt; 0 &amp;&amp; stp-&gt;st_wordlen + lendiff &lt; MAXWLEN) {</a>
<a name="ln2649">    // Add part of the bad word to the good word, so that we soundfold</a>
<a name="ln2650">    // what replaces the bad word.</a>
<a name="ln2651">    STRCPY(goodword, stp-&gt;st_word);</a>
<a name="ln2652">    STRLCPY(goodword + stp-&gt;st_wordlen,</a>
<a name="ln2653">            su-&gt;su_badptr + su-&gt;su_badlen - lendiff, lendiff + 1);</a>
<a name="ln2654">    pgood = goodword;</a>
<a name="ln2655">  } else {</a>
<a name="ln2656">    pgood = (char_u *)stp-&gt;st_word;</a>
<a name="ln2657">  }</a>
<a name="ln2658"> </a>
<a name="ln2659">  // Sound-fold the word and compute the score for the difference.</a>
<a name="ln2660">  spell_soundfold(slang, pgood, false, goodsound);</a>
<a name="ln2661"> </a>
<a name="ln2662">  return soundalike_score((char *)goodsound, (char *)pbad);</a>
<a name="ln2663">}</a>
<a name="ln2664"> </a>
<a name="ln2665">/// structure used to store soundfolded words that add_sound_suggest() has</a>
<a name="ln2666">/// handled already.</a>
<a name="ln2667">typedef struct {</a>
<a name="ln2668">  int16_t sft_score;   ///&lt; lowest score used</a>
<a name="ln2669">  char_u sft_word[1];  ///&lt; soundfolded word, actually longer</a>
<a name="ln2670">} sftword_T;</a>
<a name="ln2671"> </a>
<a name="ln2672">static sftword_T dumsft;</a>
<a name="ln2673">#define HIKEY2SFT(p)  ((sftword_T *)((p) - (dumsft.sft_word - (char_u *)&amp;dumsft)))</a>
<a name="ln2674">#define HI2SFT(hi)     HIKEY2SFT((hi)-&gt;hi_key)</a>
<a name="ln2675"> </a>
<a name="ln2676">/// Prepare for calling suggest_try_soundalike().</a>
<a name="ln2677">static void suggest_try_soundalike_prep(void)</a>
<a name="ln2678">{</a>
<a name="ln2679">  langp_T *lp;</a>
<a name="ln2680">  slang_T *slang;</a>
<a name="ln2681"> </a>
<a name="ln2682">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln2683">  // .sug file has been loaded.</a>
<a name="ln2684">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln2685">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln2686">    slang = lp-&gt;lp_slang;</a>
<a name="ln2687">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln2688">      // prepare the hashtable used by add_sound_suggest()</a>
<a name="ln2689">      hash_init(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln2690">    }</a>
<a name="ln2691">  }</a>
<a name="ln2692">}</a>
<a name="ln2693"> </a>
<a name="ln2694">/// Find suggestions by comparing the word in a sound-a-like form.</a>
<a name="ln2695">/// Note: This doesn't support postponed prefixes.</a>
<a name="ln2696">static void suggest_try_soundalike(suginfo_T *su)</a>
<a name="ln2697">{</a>
<a name="ln2698">  char_u salword[MAXWLEN];</a>
<a name="ln2699">  langp_T *lp;</a>
<a name="ln2700">  slang_T *slang;</a>
<a name="ln2701"> </a>
<a name="ln2702">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln2703">  // .sug file has been loaded.</a>
<a name="ln2704">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln2705">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln2706">    slang = lp-&gt;lp_slang;</a>
<a name="ln2707">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln2708">      // soundfold the bad word</a>
<a name="ln2709">      spell_soundfold(slang, su-&gt;su_fbadword, true, salword);</a>
<a name="ln2710"> </a>
<a name="ln2711">      // try all kinds of inserts/deletes/swaps/etc.</a>
<a name="ln2712">      // TODO(vim): also soundfold the next words, so that we can try joining</a>
<a name="ln2713">      // and splitting</a>
<a name="ln2714">#ifdef SUGGEST_PROFILE</a>
<a name="ln2715">      prof_init();</a>
<a name="ln2716">#endif</a>
<a name="ln2717">      suggest_trie_walk(su, lp, salword, true);</a>
<a name="ln2718">#ifdef SUGGEST_PROFILE</a>
<a name="ln2719">      prof_report(&quot;soundalike&quot;);</a>
<a name="ln2720">#endif</a>
<a name="ln2721">    }</a>
<a name="ln2722">  }</a>
<a name="ln2723">}</a>
<a name="ln2724"> </a>
<a name="ln2725">/// Finish up after calling suggest_try_soundalike().</a>
<a name="ln2726">static void suggest_try_soundalike_finish(void)</a>
<a name="ln2727">{</a>
<a name="ln2728">  langp_T *lp;</a>
<a name="ln2729">  slang_T *slang;</a>
<a name="ln2730">  int todo;</a>
<a name="ln2731">  hashitem_T *hi;</a>
<a name="ln2732"> </a>
<a name="ln2733">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln2734">  // .sug file has been loaded.</a>
<a name="ln2735">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln2736">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln2737">    slang = lp-&gt;lp_slang;</a>
<a name="ln2738">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln2739">      // Free the info about handled words.</a>
<a name="ln2740">      todo = (int)slang-&gt;sl_sounddone.ht_used;</a>
<a name="ln2741">      for (hi = slang-&gt;sl_sounddone.ht_array; todo &gt; 0; hi++) {</a>
<a name="ln2742">        if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln2743">          xfree(HI2SFT(hi));</a>
<a name="ln2744">          todo--;</a>
<a name="ln2745">        }</a>
<a name="ln2746">      }</a>
<a name="ln2747"> </a>
<a name="ln2748">      // Clear the hashtable, it may also be used by another region.</a>
<a name="ln2749">      hash_clear(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln2750">      hash_init(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln2751">    }</a>
<a name="ln2752">  }</a>
<a name="ln2753">}</a>
<a name="ln2754"> </a>
<a name="ln2755">/// A match with a soundfolded word is found.  Add the good word(s) that</a>
<a name="ln2756">/// produce this soundfolded word.</a>
<a name="ln2757">///</a>
<a name="ln2758">/// @param score  soundfold score</a>
<a name="ln2759">static void add_sound_suggest(suginfo_T *su, char_u *goodword, int score, langp_T *lp)</a>
<a name="ln2760">{</a>
<a name="ln2761">  slang_T *slang = lp-&gt;lp_slang;    // language for sound folding</a>
<a name="ln2762">  int sfwordnr;</a>
<a name="ln2763">  char_u *nrline;</a>
<a name="ln2764">  int orgnr;</a>
<a name="ln2765">  char_u theword[MAXWLEN];</a>
<a name="ln2766">  int i;</a>
<a name="ln2767">  int wlen;</a>
<a name="ln2768">  char_u *byts;</a>
<a name="ln2769">  idx_T *idxs;</a>
<a name="ln2770">  int n;</a>
<a name="ln2771">  int wordcount;</a>
<a name="ln2772">  int wc;</a>
<a name="ln2773">  int goodscore;</a>
<a name="ln2774">  hash_T hash;</a>
<a name="ln2775">  hashitem_T *hi;</a>
<a name="ln2776">  sftword_T *sft;</a>
<a name="ln2777">  int bc, gc;</a>
<a name="ln2778">  int limit;</a>
<a name="ln2779"> </a>
<a name="ln2780">  // It's very well possible that the same soundfold word is found several</a>
<a name="ln2781">  // times with different scores.  Since the following is quite slow only do</a>
<a name="ln2782">  // the words that have a better score than before.  Use a hashtable to</a>
<a name="ln2783">  // remember the words that have been done.</a>
<a name="ln2784">  hash = hash_hash(goodword);</a>
<a name="ln2785">  const size_t goodword_len = STRLEN(goodword);</a>
<a name="ln2786">  hi = hash_lookup(&amp;slang-&gt;sl_sounddone, (const char *)goodword, goodword_len,</a>
<a name="ln2787">                   hash);</a>
<a name="ln2788">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln2789">    sft = xmalloc(sizeof(sftword_T) + goodword_len);</a>
<a name="ln2790">    sft-&gt;sft_score = (int16_t)score;</a>
<a name="ln2791">    memcpy(sft-&gt;sft_word, goodword, goodword_len + 1);</a>
<a name="ln2792">    hash_add_item(&amp;slang-&gt;sl_sounddone, hi, sft-&gt;sft_word, hash);</a>
<a name="ln2793">  } else {</a>
<a name="ln2794">    sft = HI2SFT(hi);</a>
<a name="ln2795">    if (score &gt;= sft-&gt;sft_score) {</a>
<a name="ln2796">      return;</a>
<a name="ln2797">    }</a>
<a name="ln2798">    sft-&gt;sft_score = (int16_t)score;</a>
<a name="ln2799">  }</a>
<a name="ln2800"> </a>
<a name="ln2801">  // Find the word nr in the soundfold tree.</a>
<a name="ln2802">  sfwordnr = soundfold_find(slang, goodword);</a>
<a name="ln2803">  if (sfwordnr &lt; 0) {</a>
<a name="ln2804">    internal_error(&quot;add_sound_suggest()&quot;);</a>
<a name="ln2805">    return;</a>
<a name="ln2806">  }</a>
<a name="ln2807"> </a>
<a name="ln2808">  // Go over the list of good words that produce this soundfold word</a>
<a name="ln2809">  nrline = (char_u *)ml_get_buf(slang-&gt;sl_sugbuf, (linenr_T)sfwordnr + 1, false);</a>
<a name="ln2810">  orgnr = 0;</a>
<a name="ln2811">  while (*nrline != NUL) {</a>
<a name="ln2812">    // The wordnr was stored in a minimal nr of bytes as an offset to the</a>
<a name="ln2813">    // previous wordnr.</a>
<a name="ln2814">    orgnr += bytes2offset(&amp;nrline);</a>
<a name="ln2815"> </a>
<a name="ln2816">    byts = slang-&gt;sl_fbyts;</a>
<a name="ln2817">    idxs = slang-&gt;sl_fidxs;</a>
<a name="ln2818"> </a>
<a name="ln2819">    // Lookup the word &quot;orgnr&quot; one of the two tries.</a>
<a name="ln2820">    n = 0;</a>
<a name="ln2821">    wordcount = 0;</a>
<a name="ln2822">    for (wlen = 0; wlen &lt; MAXWLEN - 3; wlen++) {</a>
<a name="ln2823">      i = 1;</a>
<a name="ln2824">      if (wordcount == orgnr &amp;&amp; byts[n + 1] == NUL) {</a>
<a name="ln2825">        break;          // found end of word</a>
<a name="ln2826">      }</a>
<a name="ln2827">      if (byts[n + 1] == NUL) {</a>
<a name="ln2828">        wordcount++;</a>
<a name="ln2829">      }</a>
<a name="ln2830"> </a>
<a name="ln2831">      // skip over the NUL bytes</a>
<a name="ln2832">      for (; byts[n + i] == NUL; i++) {</a>
<a name="ln2833">        if (i &gt; byts[n]) {              // safety check</a>
<a name="ln2834">          STRCPY(theword + wlen, &quot;BAD&quot;);</a>
<a name="ln2835">          wlen += 3;</a>
<a name="ln2836">          goto badword;</a>
<a name="ln2837">        }</a>
<a name="ln2838">      }</a>
<a name="ln2839"> </a>
<a name="ln2840">      // One of the siblings must have the word.</a>
<a name="ln2841">      for (; i &lt; byts[n]; i++) {</a>
<a name="ln2842">        wc = idxs[idxs[n + i]];         // nr of words under this byte</a>
<a name="ln2843">        if (wordcount + wc &gt; orgnr) {</a>
<a name="ln2844">          break;</a>
<a name="ln2845">        }</a>
<a name="ln2846">        wordcount += wc;</a>
<a name="ln2847">      }</a>
<a name="ln2848"> </a>
<a name="ln2849">      theword[wlen] = byts[n + i];</a>
<a name="ln2850">      n = idxs[n + i];</a>
<a name="ln2851">    }</a>
<a name="ln2852">badword:</a>
<a name="ln2853">    theword[wlen] = NUL;</a>
<a name="ln2854"> </a>
<a name="ln2855">    // Go over the possible flags and regions.</a>
<a name="ln2856">    for (; i &lt;= byts[n] &amp;&amp; byts[n + i] == NUL; i++) {</a>
<a name="ln2857">      char_u cword[MAXWLEN];</a>
<a name="ln2858">      char_u *p;</a>
<a name="ln2859">      int flags = (int)idxs[n + i];</a>
<a name="ln2860"> </a>
<a name="ln2861">      // Skip words with the NOSUGGEST flag</a>
<a name="ln2862">      if (flags &amp; WF_NOSUGGEST) {</a>
<a name="ln2863">        continue;</a>
<a name="ln2864">      }</a>
<a name="ln2865"> </a>
<a name="ln2866">      if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln2867">        // Must find the word in the keep-case tree.</a>
<a name="ln2868">        find_keepcap_word(slang, theword, cword);</a>
<a name="ln2869">        p = cword;</a>
<a name="ln2870">      } else {</a>
<a name="ln2871">        flags |= su-&gt;su_badflags;</a>
<a name="ln2872">        if ((flags &amp; WF_CAPMASK) != 0) {</a>
<a name="ln2873">          // Need to fix case according to &quot;flags&quot;.</a>
<a name="ln2874">          make_case_word(theword, cword, flags);</a>
<a name="ln2875">          p = cword;</a>
<a name="ln2876">        } else {</a>
<a name="ln2877">          p = theword;</a>
<a name="ln2878">        }</a>
<a name="ln2879">      }</a>
<a name="ln2880"> </a>
<a name="ln2881">      // Add the suggestion.</a>
<a name="ln2882">      if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln2883">        // Add the suggestion if the score isn't too bad.</a>
<a name="ln2884">        if (score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln2885">          add_suggestion(su, &amp;su-&gt;su_sga, (char *)p, su-&gt;su_badlen,</a>
<a name="ln2886">                         score, 0, false, slang, false);</a>
<a name="ln2887">        }</a>
<a name="ln2888">      } else {</a>
<a name="ln2889">        // Add a penalty for words in another region.</a>
<a name="ln2890">        if ((flags &amp; WF_REGION)</a>
<a name="ln2891">            &amp;&amp; (((unsigned)flags &gt;&gt; 16) &amp; (unsigned)lp-&gt;lp_region) == 0) {</a>
<a name="ln2892">          goodscore = SCORE_REGION;</a>
<a name="ln2893">        } else {</a>
<a name="ln2894">          goodscore = 0;</a>
<a name="ln2895">        }</a>
<a name="ln2896"> </a>
<a name="ln2897">        // Add a small penalty for changing the first letter from</a>
<a name="ln2898">        // lower to upper case.  Helps for &quot;tath&quot; -&gt; &quot;Kath&quot;, which is</a>
<a name="ln2899">        // less common than &quot;tath&quot; -&gt; &quot;path&quot;.  Don't do it when the</a>
<a name="ln2900">        // letter is the same, that has already been counted.</a>
<a name="ln2901">        gc = utf_ptr2char((char *)p);</a>
<a name="ln2902">        if (SPELL_ISUPPER(gc)) {</a>
<a name="ln2903">          bc = utf_ptr2char((char *)su-&gt;su_badword);</a>
<a name="ln2904">          if (!SPELL_ISUPPER(bc)</a>
<a name="ln2905">              &amp;&amp; SPELL_TOFOLD(bc) != SPELL_TOFOLD(gc)) {</a>
<a name="ln2906">            goodscore += SCORE_ICASE / 2;</a>
<a name="ln2907">          }</a>
<a name="ln2908">        }</a>
<a name="ln2909"> </a>
<a name="ln2910">        // Compute the score for the good word.  This only does letter</a>
<a name="ln2911">        // insert/delete/swap/replace.  REP items are not considered,</a>
<a name="ln2912">        // which may make the score a bit higher.</a>
<a name="ln2913">        // Use a limit for the score to make it work faster.  Use</a>
<a name="ln2914">        // MAXSCORE(), because RESCORE() will change the score.</a>
<a name="ln2915">        // If the limit is very high then the iterative method is</a>
<a name="ln2916">        // inefficient, using an array is quicker.</a>
<a name="ln2917">        limit = MAXSCORE(su-&gt;su_sfmaxscore - goodscore, score);</a>
<a name="ln2918">        if (limit &gt; SCORE_LIMITMAX) {</a>
<a name="ln2919">          goodscore += spell_edit_score(slang, su-&gt;su_badword, p);</a>
<a name="ln2920">        } else {</a>
<a name="ln2921">          goodscore += spell_edit_score_limit(slang, su-&gt;su_badword,</a>
<a name="ln2922">                                              p, limit);</a>
<a name="ln2923">        }</a>
<a name="ln2924"> </a>
<a name="ln2925">        // When going over the limit don't bother to do the rest.</a>
<a name="ln2926">        if (goodscore &lt; SCORE_MAXMAX) {</a>
<a name="ln2927">          // Give a bonus to words seen before.</a>
<a name="ln2928">          goodscore = score_wordcount_adj(slang, goodscore, p, false);</a>
<a name="ln2929"> </a>
<a name="ln2930">          // Add the suggestion if the score isn't too bad.</a>
<a name="ln2931">          goodscore = RESCORE(goodscore, score);</a>
<a name="ln2932">          if (goodscore &lt;= su-&gt;su_sfmaxscore) {</a>
<a name="ln2933">            add_suggestion(su, &amp;su-&gt;su_ga, (char *)p, su-&gt;su_badlen,</a>
<a name="ln2934">                           goodscore, score, true, slang, true);</a>
<a name="ln2935">          }</a>
<a name="ln2936">        }</a>
<a name="ln2937">      }</a>
<a name="ln2938">    }</a>
<a name="ln2939">  }</a>
<a name="ln2940">}</a>
<a name="ln2941"> </a>
<a name="ln2942">/// Find word &quot;word&quot; in fold-case tree for &quot;slang&quot; and return the word number.</a>
<a name="ln2943">static int soundfold_find(slang_T *slang, char_u *word)</a>
<a name="ln2944">{</a>
<a name="ln2945">  idx_T arridx = 0;</a>
<a name="ln2946">  int len;</a>
<a name="ln2947">  int wlen = 0;</a>
<a name="ln2948">  int c;</a>
<a name="ln2949">  char_u *ptr = word;</a>
<a name="ln2950">  char_u *byts;</a>
<a name="ln2951">  idx_T *idxs;</a>
<a name="ln2952">  int wordnr = 0;</a>
<a name="ln2953"> </a>
<a name="ln2954">  byts = slang-&gt;sl_sbyts;</a>
<a name="ln2955">  idxs = slang-&gt;sl_sidxs;</a>
<a name="ln2956"> </a>
<a name="ln2957">  for (;;) {</a>
<a name="ln2958">    // First byte is the number of possible bytes.</a>
<a name="ln2959">    len = byts[arridx++];</a>
<a name="ln2960"> </a>
<a name="ln2961">    // If the first possible byte is a zero the word could end here.</a>
<a name="ln2962">    // If the word ends we found the word.  If not skip the NUL bytes.</a>
<a name="ln2963">    c = ptr[wlen];</a>
<a name="ln2964">    if (byts[arridx] == NUL) {</a>
<a name="ln2965">      if (c == NUL) {</a>
<a name="ln2966">        break;</a>
<a name="ln2967">      }</a>
<a name="ln2968"> </a>
<a name="ln2969">      // Skip over the zeros, there can be several.</a>
<a name="ln2970">      while (len &gt; 0 &amp;&amp; byts[arridx] == NUL) {</a>
<a name="ln2971">        arridx++;</a>
<a name="ln2972">        len--;</a>
<a name="ln2973">      }</a>
<a name="ln2974">      if (len == 0) {</a>
<a name="ln2975">        return -1;            // no children, word should have ended here</a>
<a name="ln2976">      }</a>
<a name="ln2977">      wordnr++;</a>
<a name="ln2978">    }</a>
<a name="ln2979"> </a>
<a name="ln2980">    // If the word ends we didn't find it.</a>
<a name="ln2981">    if (c == NUL) {</a>
<a name="ln2982">      return -1;</a>
<a name="ln2983">    }</a>
<a name="ln2984"> </a>
<a name="ln2985">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln2986">    if (c == TAB) {         // &lt;Tab&gt; is handled like &lt;Space&gt;</a>
<a name="ln2987">      c = ' ';</a>
<a name="ln2988">    }</a>
<a name="ln2989">    while (byts[arridx] &lt; c) {</a>
<a name="ln2990">      // The word count is in the first idxs[] entry of the child.</a>
<a name="ln2991">      wordnr += idxs[idxs[arridx]];</a>
<a name="ln2992">      arridx++;</a>
<a name="ln2993">      if (--len == 0) {         // end of the bytes, didn't find it</a>
<a name="ln2994">        return -1;</a>
<a name="ln2995">      }</a>
<a name="ln2996">    }</a>
<a name="ln2997">    if (byts[arridx] != c) {    // didn't find the byte</a>
<a name="ln2998">      return -1;</a>
<a name="ln2999">    }</a>
<a name="ln3000"> </a>
<a name="ln3001">    // Continue at the child (if there is one).</a>
<a name="ln3002">    arridx = idxs[arridx];</a>
<a name="ln3003">    wlen++;</a>
<a name="ln3004"> </a>
<a name="ln3005">    // One space in the good word may stand for several spaces in the</a>
<a name="ln3006">    // checked word.</a>
<a name="ln3007">    if (c == ' ') {</a>
<a name="ln3008">      while (ptr[wlen] == ' ' || ptr[wlen] == TAB) {</a>
<a name="ln3009">        wlen++;</a>
<a name="ln3010">      }</a>
<a name="ln3011">    }</a>
<a name="ln3012">  }</a>
<a name="ln3013"> </a>
<a name="ln3014">  return wordnr;</a>
<a name="ln3015">}</a>
<a name="ln3016"> </a>
<a name="ln3017">/// Returns true if &quot;c1&quot; and &quot;c2&quot; are similar characters according to the MAP</a>
<a name="ln3018">/// lines in the .aff file.</a>
<a name="ln3019">static bool similar_chars(slang_T *slang, int c1, int c2)</a>
<a name="ln3020">{</a>
<a name="ln3021">  int m1, m2;</a>
<a name="ln3022">  char buf[MB_MAXBYTES + 1];</a>
<a name="ln3023">  hashitem_T *hi;</a>
<a name="ln3024"> </a>
<a name="ln3025">  if (c1 &gt;= 256) {</a>
<a name="ln3026">    buf[utf_char2bytes(c1, (char *)buf)] = 0;</a>
<a name="ln3027">    hi = hash_find(&amp;slang-&gt;sl_map_hash, buf);</a>
<a name="ln3028">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln3029">      m1 = 0;</a>
<a name="ln3030">    } else {</a>
<a name="ln3031">      m1 = utf_ptr2char((char *)hi-&gt;hi_key + STRLEN(hi-&gt;hi_key) + 1);</a>
<a name="ln3032">    }</a>
<a name="ln3033">  } else {</a>
<a name="ln3034">    m1 = slang-&gt;sl_map_array[c1];</a>
<a name="ln3035">  }</a>
<a name="ln3036">  if (m1 == 0) {</a>
<a name="ln3037">    return false;</a>
<a name="ln3038">  }</a>
<a name="ln3039"> </a>
<a name="ln3040">  if (c2 &gt;= 256) {</a>
<a name="ln3041">    buf[utf_char2bytes(c2, (char *)buf)] = 0;</a>
<a name="ln3042">    hi = hash_find(&amp;slang-&gt;sl_map_hash, buf);</a>
<a name="ln3043">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln3044">      m2 = 0;</a>
<a name="ln3045">    } else {</a>
<a name="ln3046">      m2 = utf_ptr2char((char *)hi-&gt;hi_key + STRLEN(hi-&gt;hi_key) + 1);</a>
<a name="ln3047">    }</a>
<a name="ln3048">  } else {</a>
<a name="ln3049">    m2 = slang-&gt;sl_map_array[c2];</a>
<a name="ln3050">  }</a>
<a name="ln3051"> </a>
<a name="ln3052">  return m1 == m2;</a>
<a name="ln3053">}</a>
<a name="ln3054"> </a>
<a name="ln3055">/// Adds a suggestion to the list of suggestions.</a>
<a name="ln3056">/// For a suggestion that is already in the list the lowest score is remembered.</a>
<a name="ln3057">///</a>
<a name="ln3058">/// @param gap  either su_ga or su_sga</a>
<a name="ln3059">/// @param badlenarg  len of bad word replaced with &quot;goodword&quot;</a>
<a name="ln3060">/// @param had_bonus  value for st_had_bonus</a>
<a name="ln3061">/// @param slang  language for sound folding</a>
<a name="ln3062">/// @param maxsf  su_maxscore applies to soundfold score, su_sfmaxscore to the total score.</a>
<a name="ln3063">static void add_suggestion(suginfo_T *su, garray_T *gap, const char *goodword, int badlenarg,</a>
<a name="ln3064">                           int score, int altscore, bool had_bonus, slang_T *slang, bool maxsf)</a>
<a name="ln3065">{</a>
<a name="ln3066">  int goodlen;                  // len of goodword changed</a>
<a name="ln3067">  int badlen;                   // len of bad word changed</a>
<a name="ln3068">  suggest_T *stp;</a>
<a name="ln3069">  suggest_T new_sug;</a>
<a name="ln3070"> </a>
<a name="ln3071">  // Minimize &quot;badlen&quot; for consistency.  Avoids that changing &quot;the the&quot; to</a>
<a name="ln3072">  // &quot;thee the&quot; is added next to changing the first &quot;the&quot; the &quot;thee&quot;.</a>
<a name="ln3073">  const char *pgood = goodword + strlen(goodword);</a>
<a name="ln3074">  char_u *pbad = su-&gt;su_badptr + badlenarg;</a>
<a name="ln3075">  for (;;) {</a>
<a name="ln3076">    goodlen = (int)(pgood - goodword);</a>
<a name="ln3077">    badlen = (int)(pbad - su-&gt;su_badptr);</a>
<a name="ln3078">    if (goodlen &lt;= 0 || badlen &lt;= 0) {</a>
<a name="ln3079">      break;</a>
<a name="ln3080">    }</a>
<a name="ln3081">    MB_PTR_BACK(goodword, pgood);</a>
<a name="ln3082">    MB_PTR_BACK(su-&gt;su_badptr, pbad);</a>
<a name="ln3083">    if (utf_ptr2char((char *)pgood) != utf_ptr2char((char *)pbad)) {</a>
<a name="ln3084">      break;</a>
<a name="ln3085">    }</a>
<a name="ln3086">  }</a>
<a name="ln3087"> </a>
<a name="ln3088">  if (badlen == 0 &amp;&amp; goodlen == 0) {</a>
<a name="ln3089">    // goodword doesn't change anything; may happen for &quot;the the&quot; changing</a>
<a name="ln3090">    // the first &quot;the&quot; to itself.</a>
<a name="ln3091">    return;</a>
<a name="ln3092">  }</a>
<a name="ln3093"> </a>
<a name="ln3094">  int i;</a>
<a name="ln3095">  if (GA_EMPTY(gap)) {</a>
<a name="ln3096">    i = -1;</a>
<a name="ln3097">  } else {</a>
<a name="ln3098">    // Check if the word is already there.  Also check the length that is</a>
<a name="ln3099">    // being replaced &quot;thes,&quot; -&gt; &quot;these&quot; is a different suggestion from</a>
<a name="ln3100">    // &quot;thes&quot; -&gt; &quot;these&quot;.</a>
<a name="ln3101">    stp = &amp;SUG(*gap, 0);</a>
<a name="ln3102">    for (i = gap-&gt;ga_len; --i &gt;= 0; stp++) {</a>
<a name="ln3103">      if (stp-&gt;st_wordlen == goodlen</a>
<a name="ln3104">          &amp;&amp; stp-&gt;st_orglen == badlen</a>
<a name="ln3105">          &amp;&amp; STRNCMP(stp-&gt;st_word, goodword, goodlen) == 0) {</a>
<a name="ln3106">        // Found it.  Remember the word with the lowest score.</a>
<a name="ln3107">        if (stp-&gt;st_slang == NULL) {</a>
<a name="ln3108">          stp-&gt;st_slang = slang;</a>
<a name="ln3109">        }</a>
<a name="ln3110"> </a>
<a name="ln3111">        new_sug.st_score = score;</a>
<a name="ln3112">        new_sug.st_altscore = altscore;</a>
<a name="ln3113">        new_sug.st_had_bonus = had_bonus;</a>
<a name="ln3114"> </a>
<a name="ln3115">        if (stp-&gt;st_had_bonus != had_bonus) {</a>
<a name="ln3116">          // Only one of the two had the soundalike score computed.</a>
<a name="ln3117">          // Need to do that for the other one now, otherwise the</a>
<a name="ln3118">          // scores can't be compared.  This happens because</a>
<a name="ln3119">          // suggest_try_change() doesn't compute the soundalike</a>
<a name="ln3120">          // word to keep it fast, while some special methods set</a>
<a name="ln3121">          // the soundalike score to zero.</a>
<a name="ln3122">          if (had_bonus) {</a>
<a name="ln3123">            rescore_one(su, stp);</a>
<a name="ln3124">          } else {</a>
<a name="ln3125">            new_sug.st_word = stp-&gt;st_word;</a>
<a name="ln3126">            new_sug.st_wordlen = stp-&gt;st_wordlen;</a>
<a name="ln3127">            new_sug.st_slang = stp-&gt;st_slang;</a>
<a name="ln3128">            new_sug.st_orglen = badlen;</a>
<a name="ln3129">            rescore_one(su, &amp;new_sug);</a>
<a name="ln3130">          }</a>
<a name="ln3131">        }</a>
<a name="ln3132"> </a>
<a name="ln3133">        if (stp-&gt;st_score &gt; new_sug.st_score) {</a>
<a name="ln3134">          stp-&gt;st_score = new_sug.st_score;</a>
<a name="ln3135">          stp-&gt;st_altscore = new_sug.st_altscore;</a>
<a name="ln3136">          stp-&gt;st_had_bonus = new_sug.st_had_bonus;</a>
<a name="ln3137">        }</a>
<a name="ln3138">        break;</a>
<a name="ln3139">      }</a>
<a name="ln3140">    }</a>
<a name="ln3141">  }</a>
<a name="ln3142"> </a>
<a name="ln3143">  if (i &lt; 0) {</a>
<a name="ln3144">    // Add a suggestion.</a>
<a name="ln3145">    stp = GA_APPEND_VIA_PTR(suggest_T, gap);</a>
<a name="ln3146">    stp-&gt;st_word = xstrnsave(goodword, (size_t)goodlen);</a>
<a name="ln3147">    stp-&gt;st_wordlen = goodlen;</a>
<a name="ln3148">    stp-&gt;st_score = score;</a>
<a name="ln3149">    stp-&gt;st_altscore = altscore;</a>
<a name="ln3150">    stp-&gt;st_had_bonus = had_bonus;</a>
<a name="ln3151">    stp-&gt;st_orglen = badlen;</a>
<a name="ln3152">    stp-&gt;st_slang = slang;</a>
<a name="ln3153"> </a>
<a name="ln3154">    // If we have too many suggestions now, sort the list and keep</a>
<a name="ln3155">    // the best suggestions.</a>
<a name="ln3156">    if (gap-&gt;ga_len &gt; SUG_MAX_COUNT(su)) {</a>
<a name="ln3157">      if (maxsf) {</a>
<a name="ln3158">        su-&gt;su_sfmaxscore = cleanup_suggestions(gap,</a>
<a name="ln3159">                                                su-&gt;su_sfmaxscore, SUG_CLEAN_COUNT(su));</a>
<a name="ln3160">      } else {</a>
<a name="ln3161">        su-&gt;su_maxscore = cleanup_suggestions(gap,</a>
<a name="ln3162">                                              su-&gt;su_maxscore, SUG_CLEAN_COUNT(su));</a>
<a name="ln3163">      }</a>
<a name="ln3164">    }</a>
<a name="ln3165">  }</a>
<a name="ln3166">}</a>
<a name="ln3167"> </a>
<a name="ln3168">/// Suggestions may in fact be flagged as errors.  Esp. for banned words and</a>
<a name="ln3169">/// for split words, such as &quot;the the&quot;.  Remove these from the list here.</a>
<a name="ln3170">///</a>
<a name="ln3171">/// @param gap  either su_ga or su_sga</a>
<a name="ln3172">static void check_suggestions(suginfo_T *su, garray_T *gap)</a>
<a name="ln3173">{</a>
<a name="ln3174">  suggest_T *stp;</a>
<a name="ln3175">  char_u longword[MAXWLEN + 1];</a>
<a name="ln3176">  int len;</a>
<a name="ln3177">  hlf_T attr;</a>
<a name="ln3178"> </a>
<a name="ln3179">  if (gap-&gt;ga_len == 0) {</a>
<a name="ln3180">    return;</a>
<a name="ln3181">  }</a>
<a name="ln3182">  stp = &amp;SUG(*gap, 0);</a>
<a name="ln3183">  for (int i = gap-&gt;ga_len - 1; i &gt;= 0; i--) {</a>
<a name="ln3184">    // Need to append what follows to check for &quot;the the&quot;.</a>
<a name="ln3185">    STRLCPY(longword, stp[i].st_word, MAXWLEN + 1);</a>
<a name="ln3186">    len = stp[i].st_wordlen;</a>
<a name="ln3187">    STRLCPY(longword + len, su-&gt;su_badptr + stp[i].st_orglen,</a>
<a name="ln3188">            MAXWLEN - len + 1);</a>
<a name="ln3189">    attr = HLF_COUNT;</a>
<a name="ln3190">    (void)spell_check(curwin, longword, &amp;attr, NULL, false);</a>
<a name="ln3191">    if (attr != HLF_COUNT) {</a>
<a name="ln3192">      // Remove this entry.</a>
<a name="ln3193">      xfree(stp[i].st_word);</a>
<a name="ln3194">      gap-&gt;ga_len--;</a>
<a name="ln3195">      if (i &lt; gap-&gt;ga_len) {</a>
<a name="ln3196">        memmove(stp + i, stp + i + 1, sizeof(suggest_T) * (size_t)(gap-&gt;ga_len - i));</a>
<a name="ln3197">      }</a>
<a name="ln3198">    }</a>
<a name="ln3199">  }</a>
<a name="ln3200">}</a>
<a name="ln3201"> </a>
<a name="ln3202">/// Add a word to be banned.</a>
<a name="ln3203">static void add_banned(suginfo_T *su, char_u *word)</a>
<a name="ln3204">{</a>
<a name="ln3205">  char_u *s;</a>
<a name="ln3206">  hash_T hash;</a>
<a name="ln3207">  hashitem_T *hi;</a>
<a name="ln3208"> </a>
<a name="ln3209">  hash = hash_hash(word);</a>
<a name="ln3210">  const size_t word_len = STRLEN(word);</a>
<a name="ln3211">  hi = hash_lookup(&amp;su-&gt;su_banned, (const char *)word, word_len, hash);</a>
<a name="ln3212">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln3213">    s = xmemdupz(word, word_len);</a>
<a name="ln3214">    hash_add_item(&amp;su-&gt;su_banned, hi, s, hash);</a>
<a name="ln3215">  }</a>
<a name="ln3216">}</a>
<a name="ln3217"> </a>
<a name="ln3218">/// Recompute the score for all suggestions if sound-folding is possible.  This</a>
<a name="ln3219">/// is slow, thus only done for the final results.</a>
<a name="ln3220">static void rescore_suggestions(suginfo_T *su)</a>
<a name="ln3221">{</a>
<a name="ln3222">  if (su-&gt;su_sallang != NULL) {</a>
<a name="ln3223">    for (int i = 0; i &lt; su-&gt;su_ga.ga_len; i++) {</a>
<a name="ln3224">      rescore_one(su, &amp;SUG(su-&gt;su_ga, i));</a>
<a name="ln3225">    }</a>
<a name="ln3226">  }</a>
<a name="ln3227">}</a>
<a name="ln3228"> </a>
<a name="ln3229">/// Recompute the score for one suggestion if sound-folding is possible.</a>
<a name="ln3230">static void rescore_one(suginfo_T *su, suggest_T *stp)</a>
<a name="ln3231">{</a>
<a name="ln3232">  slang_T *slang = stp-&gt;st_slang;</a>
<a name="ln3233">  char_u sal_badword[MAXWLEN];</a>
<a name="ln3234">  char_u *p;</a>
<a name="ln3235"> </a>
<a name="ln3236">  // Only rescore suggestions that have no sal score yet and do have a</a>
<a name="ln3237">  // language.</a>
<a name="ln3238">  if (slang != NULL &amp;&amp; !GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; !stp-&gt;st_had_bonus) {</a>
<a name="ln3239">    if (slang == su-&gt;su_sallang) {</a>
<a name="ln3240">      p = su-&gt;su_sal_badword;</a>
<a name="ln3241">    } else {</a>
<a name="ln3242">      spell_soundfold(slang, su-&gt;su_fbadword, true, sal_badword);</a>
<a name="ln3243">      p = sal_badword;</a>
<a name="ln3244">    }</a>
<a name="ln3245"> </a>
<a name="ln3246">    stp-&gt;st_altscore = stp_sal_score(stp, su, slang, p);</a>
<a name="ln3247">    if (stp-&gt;st_altscore == SCORE_MAXMAX) {</a>
<a name="ln3248">      stp-&gt;st_altscore = SCORE_BIG;</a>
<a name="ln3249">    }</a>
<a name="ln3250">    stp-&gt;st_score = RESCORE(stp-&gt;st_score, stp-&gt;st_altscore);</a>
<a name="ln3251">    stp-&gt;st_had_bonus = true;</a>
<a name="ln3252">  }</a>
<a name="ln3253">}</a>
<a name="ln3254"> </a>
<a name="ln3255">/// Function given to qsort() to sort the suggestions on st_score.</a>
<a name="ln3256">/// First on &quot;st_score&quot;, then &quot;st_altscore&quot; then alphabetically.</a>
<a name="ln3257">static int sug_compare(const void *s1, const void *s2)</a>
<a name="ln3258">{</a>
<a name="ln3259">  suggest_T *p1 = (suggest_T *)s1;</a>
<a name="ln3260">  suggest_T *p2 = (suggest_T *)s2;</a>
<a name="ln3261">  int n = p1-&gt;st_score - p2-&gt;st_score;</a>
<a name="ln3262"> </a>
<a name="ln3263">  if (n == 0) {</a>
<a name="ln3264">    n = p1-&gt;st_altscore - p2-&gt;st_altscore;</a>
<a name="ln3265">    if (n == 0) {</a>
<a name="ln3266">      n = STRICMP(p1-&gt;st_word, p2-&gt;st_word);</a>
<a name="ln3267">    }</a>
<a name="ln3268">  }</a>
<a name="ln3269">  return n;</a>
<a name="ln3270">}</a>
<a name="ln3271"> </a>
<a name="ln3272">/// Cleanup the suggestions:</a>
<a name="ln3273">/// - Sort on score.</a>
<a name="ln3274">/// - Remove words that won't be displayed.</a>
<a name="ln3275">///</a>
<a name="ln3276">/// @param keep  nr of suggestions to keep</a>
<a name="ln3277">///</a>
<a name="ln3278">/// @return  the maximum score in the list or &quot;maxscore&quot; unmodified.</a>
<a name="ln3279">static int cleanup_suggestions(garray_T *gap, int maxscore, int keep)</a>
<a name="ln3280">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3281">{</a>
<a name="ln3282">  if (gap-&gt;ga_len &gt; 0) {</a>
<a name="ln3283">    // Sort the list.</a>
<a name="ln3284">    qsort(gap-&gt;ga_data, (size_t)gap-&gt;ga_len, sizeof(suggest_T), sug_compare);</a>
<a name="ln3285"> </a>
<a name="ln3286">    // Truncate the list to the number of suggestions that will be displayed.</a>
<a name="ln3287">    if (gap-&gt;ga_len &gt; keep) {</a>
<a name="ln3288">      suggest_T *const stp = &amp;SUG(*gap, 0);</a>
<a name="ln3289"> </a>
<a name="ln3290">      for (int i = keep; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln3291">        xfree(stp[i].st_word);</a>
<a name="ln3292">      }</a>
<a name="ln3293">      gap-&gt;ga_len = keep;</a>
<a name="ln3294">      if (keep &gt;= 1) {</a>
<a name="ln3295">        return stp[keep - 1].st_score;</a>
<a name="ln3296">      }</a>
<a name="ln3297">    }</a>
<a name="ln3298">  }</a>
<a name="ln3299">  return maxscore;</a>
<a name="ln3300">}</a>
<a name="ln3301"> </a>
<a name="ln3302">/// Compute a score for two sound-a-like words.</a>
<a name="ln3303">/// This permits up to two inserts/deletes/swaps/etc. to keep things fast.</a>
<a name="ln3304">/// Instead of a generic loop we write out the code.  That keeps it fast by</a>
<a name="ln3305">/// avoiding checks that will not be possible.</a>
<a name="ln3306">///</a>
<a name="ln3307">/// @param goodstart  sound-folded good word</a>
<a name="ln3308">/// @param badstart  sound-folded bad word</a>
<a name="ln3309">static int soundalike_score(char *goodstart, char *badstart)</a>
<a name="ln3310">{</a>
<a name="ln3311">  char *goodsound = goodstart;</a>
<a name="ln3312">  char *badsound = badstart;</a>
<a name="ln3313">  int goodlen;</a>
<a name="ln3314">  int badlen;</a>
<a name="ln3315">  int n;</a>
<a name="ln3316">  char *pl, *ps;</a>
<a name="ln3317">  char *pl2, *ps2;</a>
<a name="ln3318">  int score = 0;</a>
<a name="ln3319"> </a>
<a name="ln3320">  // Adding/inserting &quot;*&quot; at the start (word starts with vowel) shouldn't be</a>
<a name="ln3321">  // counted so much, vowels in the middle of the word aren't counted at all.</a>
<a name="ln3322">  if ((*badsound == '*' || *goodsound == '*') &amp;&amp; *badsound != *goodsound) {</a>
<a name="ln3323">    if ((badsound[0] == NUL &amp;&amp; goodsound[1] == NUL)</a>
<a name="ln3324">        || (goodsound[0] == NUL &amp;&amp; badsound[1] == NUL)) {</a>
<a name="ln3325">      // changing word with vowel to word without a sound</a>
<a name="ln3326">      return SCORE_DEL;</a>
<a name="ln3327">    }</a>
<a name="ln3328">    if (badsound[0] == NUL || goodsound[0] == NUL) {</a>
<a name="ln3329">      // more than two changes</a>
<a name="ln3330">      return SCORE_MAXMAX;</a>
<a name="ln3331">    }</a>
<a name="ln3332"> </a>
<a name="ln3333">    if (badsound[1] == goodsound[1]</a>
<a name="ln3334">        || (badsound[1] != NUL</a>
<a name="ln3335">            &amp;&amp; goodsound[1] != NUL</a>
<a name="ln3336">            &amp;&amp; badsound[2] == goodsound[2])) {</a>
<a name="ln3337">      // handle like a substitute</a>
<a name="ln3338">    } else {</a>
<a name="ln3339">      score = 2 * SCORE_DEL / 3;</a>
<a name="ln3340">      if (*badsound == '*') {</a>
<a name="ln3341">        badsound++;</a>
<a name="ln3342">      } else {</a>
<a name="ln3343">        goodsound++;</a>
<a name="ln3344">      }</a>
<a name="ln3345">    }</a>
<a name="ln3346">  }</a>
<a name="ln3347"> </a>
<a name="ln3348">  goodlen = (int)strlen(goodsound);</a>
<a name="ln3349">  badlen = (int)strlen(badsound);</a>
<a name="ln3350"> </a>
<a name="ln3351">  // Return quickly if the lengths are too different to be fixed by two</a>
<a name="ln3352">  // changes.</a>
<a name="ln3353">  n = goodlen - badlen;</a>
<a name="ln3354">  if (n &lt; -2 || n &gt; 2) {</a>
<a name="ln3355">    return SCORE_MAXMAX;</a>
<a name="ln3356">  }</a>
<a name="ln3357"> </a>
<a name="ln3358">  if (n &gt; 0) {</a>
<a name="ln3359">    pl = goodsound;         // goodsound is longest</a>
<a name="ln3360">    ps = badsound;</a>
<a name="ln3361">  } else {</a>
<a name="ln3362">    pl = badsound;          // badsound is longest</a>
<a name="ln3363">    ps = goodsound;</a>
<a name="ln3364">  }</a>
<a name="ln3365"> </a>
<a name="ln3366">  // Skip over the identical part.</a>
<a name="ln3367">  while (*pl == *ps &amp;&amp; *pl != NUL) {</a>
<a name="ln3368">    pl++;</a>
<a name="ln3369">    ps++;</a>
<a name="ln3370">  }</a>
<a name="ln3371"> </a>
<a name="ln3372">  switch (n) {</a>
<a name="ln3373">  case -2:</a>
<a name="ln3374">  case 2:</a>
<a name="ln3375">    // Must delete two characters from &quot;pl&quot;.</a>
<a name="ln3376">    pl++;               // first delete</a>
<a name="ln3377">    while (*pl == *ps) {</a>
<a name="ln3378">      pl++;</a>
<a name="ln3379">      ps++;</a>
<a name="ln3380">    }</a>
<a name="ln3381">    // strings must be equal after second delete</a>
<a name="ln3382">    if (strcmp(pl + 1, ps) == 0) {</a>
<a name="ln3383">      return score + SCORE_DEL * 2;</a>
<a name="ln3384">    }</a>
<a name="ln3385"> </a>
<a name="ln3386">    // Failed to compare.</a>
<a name="ln3387">    break;</a>
<a name="ln3388"> </a>
<a name="ln3389">  case -1:</a>
<a name="ln3390">  case 1:</a>
<a name="ln3391">    // Minimal one delete from &quot;pl&quot; required.</a>
<a name="ln3392"> </a>
<a name="ln3393">    // 1: delete</a>
<a name="ln3394">    pl2 = pl + 1;</a>
<a name="ln3395">    ps2 = ps;</a>
<a name="ln3396">    while (*pl2 == *ps2) {</a>
<a name="ln3397">      if (*pl2 == NUL) {                // reached the end</a>
<a name="ln3398">        return score + SCORE_DEL;</a>
<a name="ln3399">      }</a>
<a name="ln3400">      pl2++;</a>
<a name="ln3401">      ps2++;</a>
<a name="ln3402">    }</a>
<a name="ln3403"> </a>
<a name="ln3404">    // 2: delete then swap, then rest must be equal</a>
<a name="ln3405">    if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln3406">        &amp;&amp; strcmp(pl2 + 2, ps2 + 2) == 0) {</a>
<a name="ln3407">      return score + SCORE_DEL + SCORE_SWAP;</a>
<a name="ln3408">    }</a>
<a name="ln3409"> </a>
<a name="ln3410">    // 3: delete then substitute, then the rest must be equal</a>
<a name="ln3411">    if (strcmp(pl2 + 1, ps2 + 1) == 0) {</a>
<a name="ln3412">      return score + SCORE_DEL + SCORE_SUBST;</a>
<a name="ln3413">    }</a>
<a name="ln3414"> </a>
<a name="ln3415">    // 4: first swap then delete</a>
<a name="ln3416">    if (pl[0] == ps[1] &amp;&amp; pl[1] == ps[0]) {</a>
<a name="ln3417">      pl2 = pl + 2;                 // swap, skip two chars</a>
<a name="ln3418">      ps2 = ps + 2;</a>
<a name="ln3419">      while (*pl2 == *ps2) {</a>
<a name="ln3420">        pl2++;</a>
<a name="ln3421">        ps2++;</a>
<a name="ln3422">      }</a>
<a name="ln3423">      // delete a char and then strings must be equal</a>
<a name="ln3424">      if (strcmp(pl2 + 1, ps2) == 0) {</a>
<a name="ln3425">        return score + SCORE_SWAP + SCORE_DEL;</a>
<a name="ln3426">      }</a>
<a name="ln3427">    }</a>
<a name="ln3428"> </a>
<a name="ln3429">    // 5: first substitute then delete</a>
<a name="ln3430">    pl2 = pl + 1;                   // substitute, skip one char</a>
<a name="ln3431">    ps2 = ps + 1;</a>
<a name="ln3432">    while (*pl2 == *ps2) {</a>
<a name="ln3433">      pl2++;</a>
<a name="ln3434">      ps2++;</a>
<a name="ln3435">    }</a>
<a name="ln3436">    // delete a char and then strings must be equal</a>
<a name="ln3437">    if (strcmp(pl2 + 1, ps2) == 0) {</a>
<a name="ln3438">      return score + SCORE_SUBST + SCORE_DEL;</a>
<a name="ln3439">    }</a>
<a name="ln3440"> </a>
<a name="ln3441">    // Failed to compare.</a>
<a name="ln3442">    break;</a>
<a name="ln3443"> </a>
<a name="ln3444">  case 0:</a>
<a name="ln3445">    // Lengths are equal, thus changes must result in same length: An</a>
<a name="ln3446">    // insert is only possible in combination with a delete.</a>
<a name="ln3447">    // 1: check if for identical strings</a>
<a name="ln3448">    if (*pl == NUL) {</a>
<a name="ln3449">      return score;</a>
<a name="ln3450">    }</a>
<a name="ln3451"> </a>
<a name="ln3452">    // 2: swap</a>
<a name="ln3453">    if (pl[0] == ps[1] &amp;&amp; pl[1] == ps[0]) {</a>
<a name="ln3454">      pl2 = pl + 2;                 // swap, skip two chars</a>
<a name="ln3455">      ps2 = ps + 2;</a>
<a name="ln3456">      while (*pl2 == *ps2) {</a>
<a name="ln3457">        if (*pl2 == NUL) {              // reached the end</a>
<a name="ln3458">          return score + SCORE_SWAP;</a>
<a name="ln3459">        }</a>
<a name="ln3460">        pl2++;</a>
<a name="ln3461">        ps2++;</a>
<a name="ln3462">      }</a>
<a name="ln3463">      // 3: swap and swap again</a>
<a name="ln3464">      if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln3465">          &amp;&amp; strcmp(pl2 + 2, ps2 + 2) == 0) {</a>
<a name="ln3466">        return score + SCORE_SWAP + SCORE_SWAP;</a>
<a name="ln3467">      }</a>
<a name="ln3468"> </a>
<a name="ln3469">      // 4: swap and substitute</a>
<a name="ln3470">      if (strcmp(pl2 + 1, ps2 + 1) == 0) {</a>
<a name="ln3471">        return score + SCORE_SWAP + SCORE_SUBST;</a>
<a name="ln3472">      }</a>
<a name="ln3473">    }</a>
<a name="ln3474"> </a>
<a name="ln3475">    // 5: substitute</a>
<a name="ln3476">    pl2 = pl + 1;</a>
<a name="ln3477">    ps2 = ps + 1;</a>
<a name="ln3478">    while (*pl2 == *ps2) {</a>
<a name="ln3479">      if (*pl2 == NUL) {                // reached the end</a>
<a name="ln3480">        return score + SCORE_SUBST;</a>
<a name="ln3481">      }</a>
<a name="ln3482">      pl2++;</a>
<a name="ln3483">      ps2++;</a>
<a name="ln3484">    }</a>
<a name="ln3485"> </a>
<a name="ln3486">    // 6: substitute and swap</a>
<a name="ln3487">    if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln3488">        &amp;&amp; strcmp(pl2 + 2, ps2 + 2) == 0) {</a>
<a name="ln3489">      return score + SCORE_SUBST + SCORE_SWAP;</a>
<a name="ln3490">    }</a>
<a name="ln3491"> </a>
<a name="ln3492">    // 7: substitute and substitute</a>
<a name="ln3493">    if (strcmp(pl2 + 1, ps2 + 1) == 0) {</a>
<a name="ln3494">      return score + SCORE_SUBST + SCORE_SUBST;</a>
<a name="ln3495">    }</a>
<a name="ln3496"> </a>
<a name="ln3497">    // 8: insert then delete</a>
<a name="ln3498">    pl2 = pl;</a>
<a name="ln3499">    ps2 = ps + 1;</a>
<a name="ln3500">    while (*pl2 == *ps2) {</a>
<a name="ln3501">      pl2++;</a>
<a name="ln3502">      ps2++;</a>
<a name="ln3503">    }</a>
<a name="ln3504">    if (strcmp(pl2 + 1, ps2) == 0) {</a>
<a name="ln3505">      return score + SCORE_INS + SCORE_DEL;</a>
<a name="ln3506">    }</a>
<a name="ln3507"> </a>
<a name="ln3508">    // 9: delete then insert</a>
<a name="ln3509">    pl2 = pl + 1;</a>
<a name="ln3510">    ps2 = ps;</a>
<a name="ln3511">    while (*pl2 == *ps2) {</a>
<a name="ln3512">      pl2++;</a>
<a name="ln3513">      ps2++;</a>
<a name="ln3514">    }</a>
<a name="ln3515">    if (strcmp(pl2, ps2 + 1) == 0) {</a>
<a name="ln3516">      return score + SCORE_INS + SCORE_DEL;</a>
<a name="ln3517">    }</a>
<a name="ln3518"> </a>
<a name="ln3519">    // Failed to compare.</a>
<a name="ln3520">    break;</a>
<a name="ln3521">  }</a>
<a name="ln3522"> </a>
<a name="ln3523">  return SCORE_MAXMAX;</a>
<a name="ln3524">}</a>
<a name="ln3525"> </a>
<a name="ln3526">/// Compute the &quot;edit distance&quot; to turn &quot;badword&quot; into &quot;goodword&quot;.  The less</a>
<a name="ln3527">/// deletes/inserts/substitutes/swaps are required the lower the score.</a>
<a name="ln3528">///</a>
<a name="ln3529">/// The algorithm is described by Du and Chang, 1992.</a>
<a name="ln3530">/// The implementation of the algorithm comes from Aspell editdist.cpp,</a>
<a name="ln3531">/// edit_distance().  It has been converted from C++ to C and modified to</a>
<a name="ln3532">/// support multi-byte characters.</a>
<a name="ln3533">static int spell_edit_score(slang_T *slang, const char_u *badword, const char_u *goodword)</a>
<a name="ln3534">{</a>
<a name="ln3535">  int *cnt;</a>
<a name="ln3536">  int j, i;</a>
<a name="ln3537">  int t;</a>
<a name="ln3538">  int bc, gc;</a>
<a name="ln3539">  int pbc, pgc;</a>
<a name="ln3540">  int wbadword[MAXWLEN];</a>
<a name="ln3541">  int wgoodword[MAXWLEN];</a>
<a name="ln3542"> </a>
<a name="ln3543">  // Lengths with NUL.</a>
<a name="ln3544">  int badlen;</a>
<a name="ln3545">  int goodlen;</a>
<a name="ln3546">  {</a>
<a name="ln3547">    // Get the characters from the multi-byte strings and put them in an</a>
<a name="ln3548">    // int array for easy access.</a>
<a name="ln3549">    badlen = 0;</a>
<a name="ln3550">    for (const char_u *p = badword; *p != NUL;) {</a>
<a name="ln3551">      wbadword[badlen++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln3552">    }</a>
<a name="ln3553">    wbadword[badlen++] = 0;</a>
<a name="ln3554">    goodlen = 0;</a>
<a name="ln3555">    for (const char_u *p = goodword; *p != NUL;) {</a>
<a name="ln3556">      wgoodword[goodlen++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln3557">    }</a>
<a name="ln3558">    wgoodword[goodlen++] = 0;</a>
<a name="ln3559">  }</a>
<a name="ln3560"> </a>
<a name="ln3561">  // We use &quot;cnt&quot; as an array: CNT(badword_idx, goodword_idx).</a>
<a name="ln3562">#define CNT(a, b)   cnt[(a) + (b) * (badlen + 1)]</a>
<a name="ln3563">  cnt = xmalloc(sizeof(int) * ((size_t)badlen + 1) * ((size_t)goodlen + 1));</a>
<a name="ln3564"> </a>
<a name="ln3565">  CNT(0, 0) = 0;</a>
<a name="ln3566">  for (j = 1; j &lt;= goodlen; j++) {</a>
<a name="ln3567">    CNT(0, j) = CNT(0, j - 1) + SCORE_INS;</a>
<a name="ln3568">  }</a>
<a name="ln3569"> </a>
<a name="ln3570">  for (i = 1; i &lt;= badlen; i++) {</a>
<a name="ln3571">    CNT(i, 0) = CNT(i - 1, 0) + SCORE_DEL;</a>
<a name="ln3572">    for (j = 1; j &lt;= goodlen; j++) {</a>
<a name="ln3573">      bc = wbadword[i - 1];</a>
<a name="ln3574">      gc = wgoodword[j - 1];</a>
<a name="ln3575">      if (bc == gc) {</a>
<a name="ln3576">        CNT(i, j) = CNT(i - 1, j - 1);</a>
<a name="ln3577">      } else {</a>
<a name="ln3578">        // Use a better score when there is only a case difference.</a>
<a name="ln3579">        if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc)) {</a>
<a name="ln3580">          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);</a>
<a name="ln3581">        } else {</a>
<a name="ln3582">          // For a similar character use SCORE_SIMILAR.</a>
<a name="ln3583">          if (slang != NULL</a>
<a name="ln3584">              &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln3585">              &amp;&amp; similar_chars(slang, gc, bc)) {</a>
<a name="ln3586">            CNT(i, j) = SCORE_SIMILAR + CNT(i - 1, j - 1);</a>
<a name="ln3587">          } else {</a>
<a name="ln3588">            CNT(i, j) = SCORE_SUBST + CNT(i - 1, j - 1);</a>
<a name="ln3589">          }</a>
<a name="ln3590">        }</a>
<a name="ln3591"> </a>
<a name="ln3592">        if (i &gt; 1 &amp;&amp; j &gt; 1) {</a>
<a name="ln3593">          pbc = wbadword[i - 2];</a>
<a name="ln3594">          pgc = wgoodword[j - 2];</a>
<a name="ln3595">          if (bc == pgc &amp;&amp; pbc == gc) {</a>
<a name="ln3596">            t = SCORE_SWAP + CNT(i - 2, j - 2);</a>
<a name="ln3597">            if (t &lt; CNT(i, j)) {</a>
<a name="ln3598">              CNT(i, j) = t;</a>
<a name="ln3599">            }</a>
<a name="ln3600">          }</a>
<a name="ln3601">        }</a>
<a name="ln3602">        t = SCORE_DEL + CNT(i - 1, j);</a>
<a name="ln3603">        if (t &lt; CNT(i, j)) {</a>
<a name="ln3604">          CNT(i, j) = t;</a>
<a name="ln3605">        }</a>
<a name="ln3606">        t = SCORE_INS + CNT(i, j - 1);</a>
<a name="ln3607">        if (t &lt; CNT(i, j)) {</a>
<a name="ln3608">          CNT(i, j) = t;</a>
<a name="ln3609">        }</a>
<a name="ln3610">      }</a>
<a name="ln3611">    }</a>
<a name="ln3612">  }</a>
<a name="ln3613"> </a>
<a name="ln3614">  i = CNT(badlen - 1, goodlen - 1);</a>
<a name="ln3615">  xfree(cnt);</a>
<a name="ln3616">  return i;</a>
<a name="ln3617">}</a>
<a name="ln3618"> </a>
<a name="ln3619">typedef struct {</a>
<a name="ln3620">  int badi;</a>
<a name="ln3621">  int goodi;</a>
<a name="ln3622">  int score;</a>
<a name="ln3623">} limitscore_T;</a>
<a name="ln3624"> </a>
<a name="ln3625">/// Like spell_edit_score(), but with a limit on the score to make it faster.</a>
<a name="ln3626">/// May return SCORE_MAXMAX when the score is higher than &quot;limit&quot;.</a>
<a name="ln3627">///</a>
<a name="ln3628">/// This uses a stack for the edits still to be tried.</a>
<a name="ln3629">/// The idea comes from Aspell leditdist.cpp.  Rewritten in C and added support</a>
<a name="ln3630">/// for multi-byte characters.</a>
<a name="ln3631">static int spell_edit_score_limit(slang_T *slang, char_u *badword, char_u *goodword, int limit)</a>
<a name="ln3632">{</a>
<a name="ln3633">  return spell_edit_score_limit_w(slang, badword, goodword, limit);</a>
<a name="ln3634">}</a>
<a name="ln3635"> </a>
<a name="ln3636">/// Multi-byte version of spell_edit_score_limit().</a>
<a name="ln3637">/// Keep it in sync with the above!</a>
<a name="ln3638">static int spell_edit_score_limit_w(slang_T *slang, const char_u *badword, const char_u *goodword,</a>
<a name="ln3639">                                    int limit)</a>
<a name="ln3640">{</a>
<a name="ln3641">  limitscore_T stack[10];               // allow for over 3 * 2 edits</a>
<a name="ln3642">  int stackidx;</a>
<a name="ln3643">  int bi, gi;</a>
<a name="ln3644">  int bi2, gi2;</a>
<a name="ln3645">  int bc, gc;</a>
<a name="ln3646">  int score;</a>
<a name="ln3647">  int score_off;</a>
<a name="ln3648">  int minscore;</a>
<a name="ln3649">  int round;</a>
<a name="ln3650">  int wbadword[MAXWLEN];</a>
<a name="ln3651">  int wgoodword[MAXWLEN];</a>
<a name="ln3652"> </a>
<a name="ln3653">  // Get the characters from the multi-byte strings and put them in an</a>
<a name="ln3654">  // int array for easy access.</a>
<a name="ln3655">  bi = 0;</a>
<a name="ln3656">  for (const char_u *p = badword; *p != NUL;) {</a>
<a name="ln3657">    wbadword[bi++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln3658">  }</a>
<a name="ln3659">  wbadword[bi++] = 0;</a>
<a name="ln3660">  gi = 0;</a>
<a name="ln3661">  for (const char_u *p = goodword; *p != NUL;) {</a>
<a name="ln3662">    wgoodword[gi++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln3663">  }</a>
<a name="ln3664">  wgoodword[gi++] = 0;</a>
<a name="ln3665"> </a>
<a name="ln3666">  // The idea is to go from start to end over the words.  So long as</a>
<a name="ln3667">  // characters are equal just continue, this always gives the lowest score.</a>
<a name="ln3668">  // When there is a difference try several alternatives.  Each alternative</a>
<a name="ln3669">  // increases &quot;score&quot; for the edit distance.  Some of the alternatives are</a>
<a name="ln3670">  // pushed unto a stack and tried later, some are tried right away.  At the</a>
<a name="ln3671">  // end of the word the score for one alternative is known.  The lowest</a>
<a name="ln3672">  // possible score is stored in &quot;minscore&quot;.</a>
<a name="ln3673">  stackidx = 0;</a>
<a name="ln3674">  bi = 0;</a>
<a name="ln3675">  gi = 0;</a>
<a name="ln3676">  score = 0;</a>
<a name="ln3677">  minscore = limit + 1;</a>
<a name="ln3678"> </a>
<a name="ln3679">  for (;;) {</a>
<a name="ln3680">    // Skip over an equal part, score remains the same.</a>
<a name="ln3681">    for (;;) {</a>
<a name="ln3682">      bc = wbadword[bi];</a>
<a name="ln3683">      gc = wgoodword[gi];</a>
<a name="ln3684"> </a>
<a name="ln3685">      if (bc != gc) {           // stop at a char that's different</a>
<a name="ln3686">        break;</a>
<a name="ln3687">      }</a>
<a name="ln3688">      if (bc == NUL) {          // both words end</a>
<a name="ln3689">        if (score &lt; minscore) {</a>
<a name="ln3690">          minscore = score;</a>
<a name="ln3691">        }</a>
<a name="ln3692">        goto pop;               // do next alternative</a>
<a name="ln3693">      }</a>
<a name="ln3694">      bi++;</a>
<a name="ln3695">      gi++;</a>
<a name="ln3696">    }</a>
<a name="ln3697"> </a>
<a name="ln3698">    if (gc == NUL) {      // goodword ends, delete badword chars</a>
<a name="ln3699">      do {</a>
<a name="ln3700">        if ((score += SCORE_DEL) &gt;= minscore) {</a>
<a name="ln3701">          goto pop;                 // do next alternative</a>
<a name="ln3702">        }</a>
<a name="ln3703">      } while (wbadword[++bi] != NUL);</a>
<a name="ln3704">      minscore = score;</a>
<a name="ln3705">    } else if (bc == NUL) {   // badword ends, insert badword chars</a>
<a name="ln3706">      do {</a>
<a name="ln3707">        if ((score += SCORE_INS) &gt;= minscore) {</a>
<a name="ln3708">          goto pop;                 // do next alternative</a>
<a name="ln3709">        }</a>
<a name="ln3710">      } while (wgoodword[++gi] != NUL);</a>
<a name="ln3711">      minscore = score;</a>
<a name="ln3712">    } else {                  // both words continue</a>
<a name="ln3713">      // If not close to the limit, perform a change.  Only try changes</a>
<a name="ln3714">      // that may lead to a lower score than &quot;minscore&quot;.</a>
<a name="ln3715">      // round 0: try deleting a char from badword</a>
<a name="ln3716">      // round 1: try inserting a char in badword</a>
<a name="ln3717">      for (round = 0; round &lt;= 1; round++) {</a>
<a name="ln3718">        score_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);</a>
<a name="ln3719">        if (score_off &lt; minscore) {</a>
<a name="ln3720">          if (score_off + SCORE_EDIT_MIN &gt;= minscore) {</a>
<a name="ln3721">            // Near the limit, rest of the words must match.  We</a>
<a name="ln3722">            // can check that right now, no need to push an item</a>
<a name="ln3723">            // onto the stack.</a>
<a name="ln3724">            bi2 = bi + 1 - round;</a>
<a name="ln3725">            gi2 = gi + round;</a>
<a name="ln3726">            while (wgoodword[gi2] == wbadword[bi2]) {</a>
<a name="ln3727">              if (wgoodword[gi2] == NUL) {</a>
<a name="ln3728">                minscore = score_off;</a>
<a name="ln3729">                break;</a>
<a name="ln3730">              }</a>
<a name="ln3731">              bi2++;</a>
<a name="ln3732">              gi2++;</a>
<a name="ln3733">            }</a>
<a name="ln3734">          } else {</a>
<a name="ln3735">            // try deleting a character from badword later</a>
<a name="ln3736">            stack[stackidx].badi = bi + 1 - round;</a>
<a name="ln3737">            stack[stackidx].goodi = gi + round;</a>
<a name="ln3738">            stack[stackidx].score = score_off;</a>
<a name="ln3739">            stackidx++;</a>
<a name="ln3740">          }</a>
<a name="ln3741">        }</a>
<a name="ln3742">      }</a>
<a name="ln3743"> </a>
<a name="ln3744">      if (score + SCORE_SWAP &lt; minscore) {</a>
<a name="ln3745">        // If swapping two characters makes a match then the</a>
<a name="ln3746">        // substitution is more expensive, thus there is no need to</a>
<a name="ln3747">        // try both.</a>
<a name="ln3748">        if (gc == wbadword[bi + 1] &amp;&amp; bc == wgoodword[gi + 1]) {</a>
<a name="ln3749">          // Swap two characters, that is: skip them.</a>
<a name="ln3750">          gi += 2;</a>
<a name="ln3751">          bi += 2;</a>
<a name="ln3752">          score += SCORE_SWAP;</a>
<a name="ln3753">          continue;</a>
<a name="ln3754">        }</a>
<a name="ln3755">      }</a>
<a name="ln3756"> </a>
<a name="ln3757">      // Substitute one character for another which is the same</a>
<a name="ln3758">      // thing as deleting a character from both goodword and badword.</a>
<a name="ln3759">      // Use a better score when there is only a case difference.</a>
<a name="ln3760">      if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc)) {</a>
<a name="ln3761">        score += SCORE_ICASE;</a>
<a name="ln3762">      } else {</a>
<a name="ln3763">        // For a similar character use SCORE_SIMILAR.</a>
<a name="ln3764">        if (slang != NULL</a>
<a name="ln3765">            &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln3766">            &amp;&amp; similar_chars(slang, gc, bc)) {</a>
<a name="ln3767">          score += SCORE_SIMILAR;</a>
<a name="ln3768">        } else {</a>
<a name="ln3769">          score += SCORE_SUBST;</a>
<a name="ln3770">        }</a>
<a name="ln3771">      }</a>
<a name="ln3772"> </a>
<a name="ln3773">      if (score &lt; minscore) {</a>
<a name="ln3774">        // Do the substitution.</a>
<a name="ln3775">        gi++;</a>
<a name="ln3776">        bi++;</a>
<a name="ln3777">        continue;</a>
<a name="ln3778">      }</a>
<a name="ln3779">    }</a>
<a name="ln3780">pop:</a>
<a name="ln3781">    // Get here to try the next alternative, pop it from the stack.</a>
<a name="ln3782">    if (stackidx == 0) {                // stack is empty, finished</a>
<a name="ln3783">      break;</a>
<a name="ln3784">    }</a>
<a name="ln3785"> </a>
<a name="ln3786">    // pop an item from the stack</a>
<a name="ln3787">    stackidx--;</a>
<a name="ln3788">    gi = stack[stackidx].goodi;</a>
<a name="ln3789">    bi = stack[stackidx].badi;</a>
<a name="ln3790">    score = stack[stackidx].score;</a>
<a name="ln3791">  }</a>
<a name="ln3792"> </a>
<a name="ln3793">  // When the score goes over &quot;limit&quot; it may actually be much higher.</a>
<a name="ln3794">  // Return a very large number to avoid going below the limit when giving a</a>
<a name="ln3795">  // bonus.</a>
<a name="ln3796">  if (minscore &gt; limit) {</a>
<a name="ln3797">    return SCORE_MAXMAX;</a>
<a name="ln3798">  }</a>
<a name="ln3799">  return minscore;</a>
<a name="ln3800">}</a>
</code></pre>
<div class="balloon" rel="1155"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1086/" target="_blank">V1086</a> A call of the 'memset' function will lead to underflow of the buffer 'sp'.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>