<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ops.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// ops.c: implementation of various operators: op_shift, op_delete, op_tilde,</a>
<a name="ln5">//        op_change, op_yank, do_put, do_join</a>
<a name="ln6"> </a>
<a name="ln7">#include &lt;assert.h&gt;</a>
<a name="ln8">#include &lt;inttypes.h&gt;</a>
<a name="ln9">#include &lt;stdbool.h&gt;</a>
<a name="ln10">#include &lt;string.h&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;klib/kvec.h&quot;</a>
<a name="ln13">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln14">#include &quot;nvim/assert.h&quot;</a>
<a name="ln15">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln16">#include &quot;nvim/change.h&quot;</a>
<a name="ln17">#include &quot;nvim/charset.h&quot;</a>
<a name="ln18">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln19">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln20">#include &quot;nvim/edit.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln23">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln26">#include &quot;nvim/extmark.h&quot;</a>
<a name="ln27">#include &quot;nvim/fold.h&quot;</a>
<a name="ln28">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln29">#include &quot;nvim/globals.h&quot;</a>
<a name="ln30">#include &quot;nvim/indent.h&quot;</a>
<a name="ln31">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln32">#include &quot;nvim/log.h&quot;</a>
<a name="ln33">#include &quot;nvim/macros.h&quot;</a>
<a name="ln34">#include &quot;nvim/mark.h&quot;</a>
<a name="ln35">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln36">#include &quot;nvim/memline.h&quot;</a>
<a name="ln37">#include &quot;nvim/memory.h&quot;</a>
<a name="ln38">#include &quot;nvim/message.h&quot;</a>
<a name="ln39">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln40">#include &quot;nvim/move.h&quot;</a>
<a name="ln41">#include &quot;nvim/normal.h&quot;</a>
<a name="ln42">#include &quot;nvim/ops.h&quot;</a>
<a name="ln43">#include &quot;nvim/option.h&quot;</a>
<a name="ln44">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln45">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln46">#include &quot;nvim/path.h&quot;</a>
<a name="ln47">#include &quot;nvim/plines.h&quot;</a>
<a name="ln48">#include &quot;nvim/search.h&quot;</a>
<a name="ln49">#include &quot;nvim/state.h&quot;</a>
<a name="ln50">#include &quot;nvim/strings.h&quot;</a>
<a name="ln51">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln52">#include &quot;nvim/textformat.h&quot;</a>
<a name="ln53">#include &quot;nvim/ui.h&quot;</a>
<a name="ln54">#include &quot;nvim/undo.h&quot;</a>
<a name="ln55">#include &quot;nvim/vim.h&quot;</a>
<a name="ln56">#include &quot;nvim/window.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">static yankreg_T y_regs[NUM_REGISTERS] = { 0 };</a>
<a name="ln59"> </a>
<a name="ln60">static yankreg_T *y_previous = NULL;  // ptr to last written yankreg</a>
<a name="ln61"> </a>
<a name="ln62">// for behavior between start_batch_changes() and end_batch_changes())</a>
<a name="ln63">static int batch_change_count = 0;           // inside a script</a>
<a name="ln64">static bool clipboard_delay_update = false;  // delay clipboard update</a>
<a name="ln65">static bool clipboard_needs_update = false;  // clipboard was updated</a>
<a name="ln66">static bool clipboard_didwarn = false;</a>
<a name="ln67"> </a>
<a name="ln68">// structure used by block_prep, op_delete and op_yank for blockwise operators</a>
<a name="ln69">// also op_change, op_shift, op_insert, op_replace - AKelly</a>
<a name="ln70">struct block_def {</a>
<a name="ln71">  int startspaces;              // 'extra' cols before first char</a>
<a name="ln72">  int endspaces;                // 'extra' cols after last char</a>
<a name="ln73">  int textlen;                  // chars in block</a>
<a name="ln74">  char_u *textstart;       // pointer to 1st char (partially) in block</a>
<a name="ln75">  colnr_T textcol;              // index of chars (partially) in block</a>
<a name="ln76">  colnr_T start_vcol;           // start col of 1st char wholly inside block</a>
<a name="ln77">  colnr_T end_vcol;             // start col of 1st char wholly after block</a>
<a name="ln78">  int is_short;                 // true if line is too short to fit in block</a>
<a name="ln79">  int is_MAX;                   // true if curswant==MAXCOL when starting</a>
<a name="ln80">  int is_oneChar;               // true if block within one character</a>
<a name="ln81">  int pre_whitesp;              // screen cols of ws before block</a>
<a name="ln82">  int pre_whitesp_c;            // chars of ws before block</a>
<a name="ln83">  colnr_T end_char_vcols;       // number of vcols of post-block char</a>
<a name="ln84">  colnr_T start_char_vcols;       // number of vcols of pre-block char</a>
<a name="ln85">};</a>
<a name="ln86"> </a>
<a name="ln87">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln88"># include &quot;ops.c.generated.h&quot;</a>
<a name="ln89">#endif</a>
<a name="ln90"> </a>
<a name="ln91">// Flags for third item in &quot;opchars&quot;.</a>
<a name="ln92">#define OPF_LINES  1  // operator always works on lines</a>
<a name="ln93">#define OPF_CHANGE 2  // operator changes text</a>
<a name="ln94"> </a>
<a name="ln95">// The names of operators.</a>
<a name="ln96">// IMPORTANT: Index must correspond with defines in vim.h!!!</a>
<a name="ln97">// The third field indicates whether the operator always works on lines.</a>
<a name="ln98">static char opchars[][3] =</a>
<a name="ln99">{</a>
<a name="ln100">  { NUL, NUL, 0 },                       // OP_NOP</a>
<a name="ln101">  { 'd', NUL, OPF_CHANGE },              // OP_DELETE</a>
<a name="ln102">  { 'y', NUL, 0 },                       // OP_YANK</a>
<a name="ln103">  { 'c', NUL, OPF_CHANGE },              // OP_CHANGE</a>
<a name="ln104">  { '&lt;', NUL, OPF_LINES | OPF_CHANGE },  // OP_LSHIFT</a>
<a name="ln105">  { '&gt;', NUL, OPF_LINES | OPF_CHANGE },  // OP_RSHIFT</a>
<a name="ln106">  { '!', NUL, OPF_LINES | OPF_CHANGE },  // OP_FILTER</a>
<a name="ln107">  { 'g', '~', OPF_CHANGE },              // OP_TILDE</a>
<a name="ln108">  { '=', NUL, OPF_LINES | OPF_CHANGE },  // OP_INDENT</a>
<a name="ln109">  { 'g', 'q', OPF_LINES | OPF_CHANGE },  // OP_FORMAT</a>
<a name="ln110">  { ':', NUL, OPF_LINES },               // OP_COLON</a>
<a name="ln111">  { 'g', 'U', OPF_CHANGE },              // OP_UPPER</a>
<a name="ln112">  { 'g', 'u', OPF_CHANGE },              // OP_LOWER</a>
<a name="ln113">  { 'J', NUL, OPF_LINES | OPF_CHANGE },  // DO_JOIN</a>
<a name="ln114">  { 'g', 'J', OPF_LINES | OPF_CHANGE },  // DO_JOIN_NS</a>
<a name="ln115">  { 'g', '?', OPF_CHANGE },              // OP_ROT13</a>
<a name="ln116">  { 'r', NUL, OPF_CHANGE },              // OP_REPLACE</a>
<a name="ln117">  { 'I', NUL, OPF_CHANGE },              // OP_INSERT</a>
<a name="ln118">  { 'A', NUL, OPF_CHANGE },              // OP_APPEND</a>
<a name="ln119">  { 'z', 'f', 0         },               // OP_FOLD</a>
<a name="ln120">  { 'z', 'o', OPF_LINES },               // OP_FOLDOPEN</a>
<a name="ln121">  { 'z', 'O', OPF_LINES },               // OP_FOLDOPENREC</a>
<a name="ln122">  { 'z', 'c', OPF_LINES },               // OP_FOLDCLOSE</a>
<a name="ln123">  { 'z', 'C', OPF_LINES },               // OP_FOLDCLOSEREC</a>
<a name="ln124">  { 'z', 'd', OPF_LINES },               // OP_FOLDDEL</a>
<a name="ln125">  { 'z', 'D', OPF_LINES },               // OP_FOLDDELREC</a>
<a name="ln126">  { 'g', 'w', OPF_LINES | OPF_CHANGE },  // OP_FORMAT2</a>
<a name="ln127">  { 'g', '@', OPF_CHANGE },              // OP_FUNCTION</a>
<a name="ln128">  { Ctrl_A, NUL, OPF_CHANGE },           // OP_NR_ADD</a>
<a name="ln129">  { Ctrl_X, NUL, OPF_CHANGE },           // OP_NR_SUB</a>
<a name="ln130">};</a>
<a name="ln131"> </a>
<a name="ln132">yankreg_T *get_y_previous(void)</a>
<a name="ln133">{</a>
<a name="ln134">  return y_previous;</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">void set_y_previous(yankreg_T *yreg)</a>
<a name="ln138">{</a>
<a name="ln139">  y_previous = yreg;</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">/// Translate a command name into an operator type.</a>
<a name="ln143">/// Must only be called with a valid operator name!</a>
<a name="ln144">int get_op_type(int char1, int char2)</a>
<a name="ln145">{</a>
<a name="ln146">  int i;</a>
<a name="ln147"> </a>
<a name="ln148">  if (char1 == 'r') {</a>
<a name="ln149">    // ignore second character</a>
<a name="ln150">    return OP_REPLACE;</a>
<a name="ln151">  }</a>
<a name="ln152">  if (char1 == '~') {</a>
<a name="ln153">    // when tilde is an operator</a>
<a name="ln154">    return OP_TILDE;</a>
<a name="ln155">  }</a>
<a name="ln156">  if (char1 == 'g' &amp;&amp; char2 == Ctrl_A) {</a>
<a name="ln157">    // add</a>
<a name="ln158">    return OP_NR_ADD;</a>
<a name="ln159">  }</a>
<a name="ln160">  if (char1 == 'g' &amp;&amp; char2 == Ctrl_X) {</a>
<a name="ln161">    // subtract</a>
<a name="ln162">    return OP_NR_SUB;</a>
<a name="ln163">  }</a>
<a name="ln164">  if (char1 == 'z' &amp;&amp; char2 == 'y') {  // OP_YANK</a>
<a name="ln165">    return OP_YANK;</a>
<a name="ln166">  }</a>
<a name="ln167">  for (i = 0;; i++) {</a>
<a name="ln168">    if (opchars[i][0] == char1 &amp;&amp; opchars[i][1] == char2) {</a>
<a name="ln169">      break;</a>
<a name="ln170">    }</a>
<a name="ln171">    if (i == (int)(ARRAY_SIZE(opchars) - 1)) {</a>
<a name="ln172">      internal_error(&quot;get_op_type()&quot;);</a>
<a name="ln173">      break;</a>
<a name="ln174">    }</a>
<a name="ln175">  }</a>
<a name="ln176">  return i;</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">/// @return  true if operator &quot;op&quot; always works on whole lines.</a>
<a name="ln180">int op_on_lines(int op)</a>
<a name="ln181">{</a>
<a name="ln182">  return opchars[op][2] &amp; OPF_LINES;</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">/// @return  true if operator &quot;op&quot; changes text.</a>
<a name="ln186">int op_is_change(int op)</a>
<a name="ln187">{</a>
<a name="ln188">  return opchars[op][2] &amp; OPF_CHANGE;</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">/// Get first operator command character.</a>
<a name="ln192">///</a>
<a name="ln193">/// @return  'g' or 'z' if there is another command character.</a>
<a name="ln194">int get_op_char(int optype)</a>
<a name="ln195">{</a>
<a name="ln196">  return opchars[optype][0];</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">/// Get second operator command character.</a>
<a name="ln200">int get_extra_op_char(int optype)</a>
<a name="ln201">{</a>
<a name="ln202">  return opchars[optype][1];</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">/// handle a shift operation</a>
<a name="ln206">void op_shift(oparg_T *oap, int curs_top, int amount)</a>
<a name="ln207">{</a>
<a name="ln208">  long i;</a>
<a name="ln209">  int first_char;</a>
<a name="ln210">  int block_col = 0;</a>
<a name="ln211"> </a>
<a name="ln212">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln213">             (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln214">    return;</a>
<a name="ln215">  }</a>
<a name="ln216"> </a>
<a name="ln217">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln218">    block_col = curwin-&gt;w_cursor.col;</a>
<a name="ln219">  }</a>
<a name="ln220"> </a>
<a name="ln221">  for (i = oap-&gt;line_count - 1; i &gt;= 0; i--) {</a>
<a name="ln222">    first_char = (uint8_t)(*get_cursor_line_ptr());</a>
<a name="ln223">    if (first_char == NUL) {  // empty line</a>
<a name="ln224">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln225">    } else if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln226">      shift_block(oap, amount);</a>
<a name="ln227">    } else if (first_char != '#' || !preprocs_left()) {</a>
<a name="ln228">      // Move the line right if it doesn't start with '#', 'smartindent'</a>
<a name="ln229">      // isn't set or 'cindent' isn't set or '#' isn't in 'cino'.</a>
<a name="ln230">      shift_line(oap-&gt;op_type == OP_LSHIFT, p_sr, amount, false);</a>
<a name="ln231">    }</a>
<a name="ln232">    curwin-&gt;w_cursor.lnum++;</a>
<a name="ln233">  }</a>
<a name="ln234"> </a>
<a name="ln235">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln236">    curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln237">    curwin-&gt;w_cursor.col = block_col;</a>
<a name="ln238">  } else if (curs_top) {  // put cursor on first line, for &quot;&gt;&gt;&quot;</a>
<a name="ln239">    curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln240">    beginline(BL_SOL | BL_FIX);       // shift_line() may have set cursor.col</a>
<a name="ln241">  } else {</a>
<a name="ln242">    curwin-&gt;w_cursor.lnum--;            // put cursor on last line, for &quot;:&gt;&quot;</a>
<a name="ln243">  }</a>
<a name="ln244">  // The cursor line is not in a closed fold</a>
<a name="ln245">  foldOpenCursor();</a>
<a name="ln246"> </a>
<a name="ln247">  if (oap-&gt;line_count &gt; p_report) {</a>
<a name="ln248">    char *op;</a>
<a name="ln249">    if (oap-&gt;op_type == OP_RSHIFT) {</a>
<a name="ln250">      op = &quot;&gt;&quot;;</a>
<a name="ln251">    } else {</a>
<a name="ln252">      op = &quot;&lt;&quot;;</a>
<a name="ln253">    }</a>
<a name="ln254"> </a>
<a name="ln255">    char *msg_line_single = NGETTEXT(&quot;%&quot; PRId64 &quot; line %sed %d time&quot;,</a>
<a name="ln256">                                     &quot;%&quot; PRId64 &quot; line %sed %d times&quot;, amount);</a>
<a name="ln257">    char *msg_line_plural = NGETTEXT(&quot;%&quot; PRId64 &quot; lines %sed %d time&quot;,</a>
<a name="ln258">                                     &quot;%&quot; PRId64 &quot; lines %sed %d times&quot;, amount);</a>
<a name="ln259">    vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln260">                 NGETTEXT(msg_line_single, msg_line_plural, oap-&gt;line_count),</a>
<a name="ln261">                 (int64_t)oap-&gt;line_count, op, amount);</a>
<a name="ln262">    msg_attr_keep((char *)IObuff, 0, true, false);</a>
<a name="ln263">  }</a>
<a name="ln264"> </a>
<a name="ln265">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln266">    // Set &quot;'[&quot; and &quot;']&quot; marks.</a>
<a name="ln267">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln268">    curbuf-&gt;b_op_end.lnum = oap-&gt;end.lnum;</a>
<a name="ln269">    curbuf-&gt;b_op_end.col = (colnr_T)strlen(ml_get(oap-&gt;end.lnum));</a>
<a name="ln270">    if (curbuf-&gt;b_op_end.col &gt; 0) {</a>
<a name="ln271">      curbuf-&gt;b_op_end.col--;</a>
<a name="ln272">    }</a>
<a name="ln273">  }</a>
<a name="ln274"> </a>
<a name="ln275">  changed_lines(oap-&gt;start.lnum, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">/// Shift the current line one shiftwidth left (if left != 0) or right</a>
<a name="ln279">/// leaves cursor on first blank in the line.</a>
<a name="ln280">///</a>
<a name="ln281">/// @param call_changed_bytes  call changed_bytes()</a>
<a name="ln282">void shift_line(int left, int round, int amount, int call_changed_bytes)</a>
<a name="ln283">{</a>
<a name="ln284">  int count;</a>
<a name="ln285">  int i, j;</a>
<a name="ln286">  const int sw_val = (int)get_sw_value_indent(curbuf);</a>
<a name="ln287"> </a>
<a name="ln288">  count = get_indent();  // get current indent</a>
<a name="ln289"> </a>
<a name="ln290">  if (round) {  // round off indent</a>
<a name="ln291">    i = count / sw_val;  // number of 'shiftwidth' rounded down</a>
<a name="ln292">    j = count % sw_val;  // extra spaces</a>
<a name="ln293">    if (j &amp;&amp; left) {  // first remove extra spaces</a>
<a name="ln294">      amount--;</a>
<a name="ln295">    }</a>
<a name="ln296">    if (left) {</a>
<a name="ln297">      i -= amount;</a>
<a name="ln298">      if (i &lt; 0) {</a>
<a name="ln299">        i = 0;</a>
<a name="ln300">      }</a>
<a name="ln301">    } else {</a>
<a name="ln302">      i += amount;</a>
<a name="ln303">    }</a>
<a name="ln304">    count = i * sw_val;</a>
<a name="ln305">  } else {  // original vi indent</a>
<a name="ln306">    if (left) {</a>
<a name="ln307">      count -= sw_val * amount;</a>
<a name="ln308">      if (count &lt; 0) {</a>
<a name="ln309">        count = 0;</a>
<a name="ln310">      }</a>
<a name="ln311">    } else {</a>
<a name="ln312">      count += sw_val * amount;</a>
<a name="ln313">    }</a>
<a name="ln314">  }</a>
<a name="ln315"> </a>
<a name="ln316">  // Set new indent</a>
<a name="ln317">  if (State &amp; VREPLACE_FLAG) {</a>
<a name="ln318">    change_indent(INDENT_SET, count, false, NUL, call_changed_bytes);</a>
<a name="ln319">  } else {</a>
<a name="ln320">    (void)set_indent(count, call_changed_bytes ? SIN_CHANGED : 0);</a>
<a name="ln321">  }</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">/// Shift one line of the current block one shiftwidth right or left.</a>
<a name="ln325">/// Leaves cursor on first character in block.</a>
<a name="ln326">static void shift_block(oparg_T *oap, int amount)</a>
<a name="ln327">{</a>
<a name="ln328">  const bool left = (oap-&gt;op_type == OP_LSHIFT);</a>
<a name="ln329">  const int oldstate = State;</a>
<a name="ln330">  char_u *newp;</a>
<a name="ln331">  const int oldcol = curwin-&gt;w_cursor.col;</a>
<a name="ln332">  const int sw_val = (int)get_sw_value_indent(curbuf);</a>
<a name="ln333">  const int ts_val = (int)curbuf-&gt;b_p_ts;</a>
<a name="ln334">  struct block_def bd;</a>
<a name="ln335">  int incr;</a>
<a name="ln336">  int i = 0, j = 0;</a>
<a name="ln337">  const int old_p_ri = p_ri;</a>
<a name="ln338"> </a>
<a name="ln339">  p_ri = 0;                     // don't want revins in indent</a>
<a name="ln340"> </a>
<a name="ln341">  State = MODE_INSERT;          // don't want MODE_REPLACE for State</a>
<a name="ln342">  block_prep(oap, &amp;bd, curwin-&gt;w_cursor.lnum, true);</a>
<a name="ln343">  if (bd.is_short) {</a>
<a name="ln344">    return;</a>
<a name="ln345">  }</a>
<a name="ln346"> </a>
<a name="ln347">  // total is number of screen columns to be inserted/removed</a>
<a name="ln348">  int total = (int)((unsigned)amount * (unsigned)sw_val);</a>
<a name="ln349">  if ((total / sw_val) != amount) {</a>
<a name="ln350">    return;   // multiplication overflow</a>
<a name="ln351">  }</a>
<a name="ln352"> </a>
<a name="ln353">  char_u *const oldp = (char_u *)get_cursor_line_ptr();</a>
<a name="ln354"> </a>
<a name="ln355">  int startcol, oldlen, newlen;</a>
<a name="ln356"> </a>
<a name="ln357">  if (!left) {</a>
<a name="ln358">    //  1. Get start vcol</a>
<a name="ln359">    //  2. Total ws vcols</a>
<a name="ln360">    //  3. Divvy into TABs &amp; spp</a>
<a name="ln361">    //  4. Construct new string</a>
<a name="ln362">    total += bd.pre_whitesp;    // all virtual WS up to &amp; incl a split TAB</a>
<a name="ln363">    colnr_T ws_vcol = bd.start_vcol - bd.pre_whitesp;</a>
<a name="ln364">    char_u *old_textstart = bd.textstart;</a>
<a name="ln365">    if (bd.startspaces) {</a>
<a name="ln366">      if (utfc_ptr2len((char *)bd.textstart) == 1) {</a>
<a name="ln367">        bd.textstart++;</a>
<a name="ln368">      } else {</a>
<a name="ln369">        ws_vcol = 0;</a>
<a name="ln370">        bd.startspaces = 0;</a>
<a name="ln371">      }</a>
<a name="ln372">    }</a>
<a name="ln373"> </a>
<a name="ln374">    // TODO(vim): is passing bd.textstart for start of the line OK?</a>
<a name="ln375">    chartabsize_T cts;</a>
<a name="ln376">    init_chartabsize_arg(&amp;cts, curwin, curwin-&gt;w_cursor.lnum,</a>
<a name="ln377">                         bd.start_vcol, (char *)bd.textstart, (char *)bd.textstart);</a>
<a name="ln378">    while (ascii_iswhite(*cts.cts_ptr)) {</a>
<a name="ln379">      incr = lbr_chartabsize_adv(&amp;cts);</a>
<a name="ln380">      total += incr;</a>
<a name="ln381">      cts.cts_vcol += incr;</a>
<a name="ln382">    }</a>
<a name="ln383">    bd.textstart = (char_u *)cts.cts_ptr;</a>
<a name="ln384">    bd.start_vcol = cts.cts_vcol;</a>
<a name="ln385">    clear_chartabsize_arg(&amp;cts);</a>
<a name="ln386"> </a>
<a name="ln387">    // OK, now total=all the VWS reqd, and textstart points at the 1st</a>
<a name="ln388">    // non-ws char in the block.</a>
<a name="ln389">    if (!curbuf-&gt;b_p_et) {</a>
<a name="ln390">      tabstop_fromto(ws_vcol, ws_vcol + total, ts_val, curbuf-&gt;b_p_vts_array, &amp;i, &amp;j);</a>
<a name="ln391">    } else {</a>
<a name="ln392">      j = total;</a>
<a name="ln393">    }</a>
<a name="ln394"> </a>
<a name="ln395">    // if we're splitting a TAB, allow for it</a>
<a name="ln396">    int col_pre = bd.pre_whitesp_c - (bd.startspaces != 0);</a>
<a name="ln397">    bd.textcol -= col_pre;</a>
<a name="ln398">    const int len = (int)STRLEN(bd.textstart) + 1;</a>
<a name="ln399">    int col = bd.textcol + i + j + len;</a>
<a name="ln400">    assert(col &gt;= 0);</a>
<a name="ln401">    newp = (char_u *)xmalloc((size_t)col);</a>
<a name="ln402">    memset(newp, NUL, (size_t)col);</a>
<a name="ln403">    memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln404">    startcol = bd.textcol;</a>
<a name="ln405">    oldlen = (int)(bd.textstart - old_textstart) + col_pre;</a>
<a name="ln406">    newlen = i + j;</a>
<a name="ln407">    memset(newp + bd.textcol, TAB, (size_t)i);</a>
<a name="ln408">    memset(newp + bd.textcol + i, ' ', (size_t)j);</a>
<a name="ln409">    // the end</a>
<a name="ln410">    memmove(newp + bd.textcol + i + j, bd.textstart, (size_t)len);</a>
<a name="ln411">  } else {  // left</a>
<a name="ln412">    colnr_T destination_col;      // column to which text in block will</a>
<a name="ln413">                                  // be shifted</a>
<a name="ln414">    char_u *verbatim_copy_end;    // end of the part of the line which is</a>
<a name="ln415">                                  // copied verbatim</a>
<a name="ln416">    colnr_T verbatim_copy_width;  // the (displayed) width of this part</a>
<a name="ln417">                                  // of line</a>
<a name="ln418">    size_t fill;                  // nr of spaces that replace a TAB</a>
<a name="ln419">    size_t new_line_len;          // the length of the line after the</a>
<a name="ln420">                                  // block shift</a>
<a name="ln421">    char_u *non_white = bd.textstart;</a>
<a name="ln422"> </a>
<a name="ln423">    // Firstly, let's find the first non-whitespace character that is</a>
<a name="ln424">    // displayed after the block's start column and the character's column</a>
<a name="ln425">    // number. Also, let's calculate the width of all the whitespace</a>
<a name="ln426">    // characters that are displayed in the block and precede the searched</a>
<a name="ln427">    // non-whitespace character.</a>
<a name="ln428"> </a>
<a name="ln429">    // If &quot;bd.startspaces&quot; is set, &quot;bd.textstart&quot; points to the character,</a>
<a name="ln430">    // the part of which is displayed at the block's beginning. Let's start</a>
<a name="ln431">    // searching from the next character.</a>
<a name="ln432">    if (bd.startspaces) {</a>
<a name="ln433">      MB_PTR_ADV(non_white);</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">    // The character's column is in &quot;bd.start_vcol&quot;.</a>
<a name="ln437">    colnr_T non_white_col = bd.start_vcol;</a>
<a name="ln438"> </a>
<a name="ln439">    chartabsize_T cts;</a>
<a name="ln440">    init_chartabsize_arg(&amp;cts, curwin, curwin-&gt;w_cursor.lnum,</a>
<a name="ln441">                         non_white_col, (char *)bd.textstart, (char *)non_white);</a>
<a name="ln442">    while (ascii_iswhite(*cts.cts_ptr)) {</a>
<a name="ln443">      incr = lbr_chartabsize_adv(&amp;cts);</a>
<a name="ln444">      cts.cts_vcol += incr;</a>
<a name="ln445">    }</a>
<a name="ln446">    non_white_col = cts.cts_vcol;</a>
<a name="ln447">    non_white = (char_u *)cts.cts_ptr;</a>
<a name="ln448">    clear_chartabsize_arg(&amp;cts);</a>
<a name="ln449"> </a>
<a name="ln450">    const colnr_T block_space_width = non_white_col - oap-&gt;start_vcol;</a>
<a name="ln451">    // We will shift by &quot;total&quot; or &quot;block_space_width&quot;, whichever is less.</a>
<a name="ln452">    const colnr_T shift_amount = block_space_width &lt; total</a>
<a name="ln453">        ? block_space_width</a>
<a name="ln454">        : total;</a>
<a name="ln455">    // The column to which we will shift the text.</a>
<a name="ln456">    destination_col = non_white_col - shift_amount;</a>
<a name="ln457"> </a>
<a name="ln458">    // Now let's find out how much of the beginning of the line we can</a>
<a name="ln459">    // reuse without modification.</a>
<a name="ln460">    verbatim_copy_end = bd.textstart;</a>
<a name="ln461">    verbatim_copy_width = bd.start_vcol;</a>
<a name="ln462"> </a>
<a name="ln463">    // If &quot;bd.startspaces&quot; is set, &quot;bd.textstart&quot; points to the character</a>
<a name="ln464">    // preceding the block. We have to subtract its width to obtain its</a>
<a name="ln465">    // column number.</a>
<a name="ln466">    if (bd.startspaces) {</a>
<a name="ln467">      verbatim_copy_width -= bd.start_char_vcols;</a>
<a name="ln468">    }</a>
<a name="ln469">    init_chartabsize_arg(&amp;cts, curwin, 0, verbatim_copy_width,</a>
<a name="ln470">                         (char *)bd.textstart, (char *)verbatim_copy_end);</a>
<a name="ln471">    while (cts.cts_vcol &lt; destination_col) {</a>
<a name="ln472">      incr = lbr_chartabsize(&amp;cts);</a>
<a name="ln473">      if (cts.cts_vcol + incr &gt; destination_col) {</a>
<a name="ln474">        break;</a>
<a name="ln475">      }</a>
<a name="ln476">      cts.cts_vcol += incr;</a>
<a name="ln477">      MB_PTR_ADV(cts.cts_ptr);</a>
<a name="ln478">    }</a>
<a name="ln479">    verbatim_copy_width = cts.cts_vcol;</a>
<a name="ln480">    verbatim_copy_end = (char_u *)cts.cts_ptr;</a>
<a name="ln481">    clear_chartabsize_arg(&amp;cts);</a>
<a name="ln482"> </a>
<a name="ln483">    // If &quot;destination_col&quot; is different from the width of the initial</a>
<a name="ln484">    // part of the line that will be copied, it means we encountered a tab</a>
<a name="ln485">    // character, which we will have to partly replace with spaces.</a>
<a name="ln486">    assert(destination_col - verbatim_copy_width &gt;= 0);</a>
<a name="ln487">    fill = (size_t)(destination_col - verbatim_copy_width);</a>
<a name="ln488"> </a>
<a name="ln489">    assert(verbatim_copy_end - oldp &gt;= 0);</a>
<a name="ln490">    const size_t verbatim_diff = (size_t)(verbatim_copy_end - oldp);</a>
<a name="ln491">    // The replacement line will consist of:</a>
<a name="ln492">    // - the beginning of the original line up to &quot;verbatim_copy_end&quot;,</a>
<a name="ln493">    // - &quot;fill&quot; number of spaces,</a>
<a name="ln494">    // - the rest of the line, pointed to by non_white.</a>
<a name="ln495">    new_line_len = verbatim_diff + fill + STRLEN(non_white) + 1;</a>
<a name="ln496"> </a>
<a name="ln497">    newp = (char_u *)xmalloc(new_line_len);</a>
<a name="ln498">    startcol = (int)verbatim_diff;</a>
<a name="ln499">    oldlen = bd.textcol + (int)(non_white - bd.textstart) - (int)verbatim_diff;</a>
<a name="ln500">    newlen = (int)fill;</a>
<a name="ln501">    memmove(newp, oldp, verbatim_diff);</a>
<a name="ln502">    memset(newp + verbatim_diff, ' ', fill);</a>
<a name="ln503">    STRMOVE(newp + verbatim_diff + fill, non_white);</a>
<a name="ln504">  }</a>
<a name="ln505">  // replace the line</a>
<a name="ln506">  ml_replace(curwin-&gt;w_cursor.lnum, (char *)newp, false);</a>
<a name="ln507">  changed_bytes(curwin-&gt;w_cursor.lnum, bd.textcol);</a>
<a name="ln508">  extmark_splice_cols(curbuf, (int)curwin-&gt;w_cursor.lnum - 1, startcol,</a>
<a name="ln509">                      oldlen, newlen,</a>
<a name="ln510">                      kExtmarkUndo);</a>
<a name="ln511">  State = oldstate;</a>
<a name="ln512">  curwin-&gt;w_cursor.col = oldcol;</a>
<a name="ln513">  p_ri = old_p_ri;</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">/// Insert string &quot;s&quot; (b_insert ? before : after) block :AKelly</a>
<a name="ln517">/// Caller must prepare for undo.</a>
<a name="ln518">static void block_insert(oparg_T *oap, char_u *s, int b_insert, struct block_def *bdp)</a>
<a name="ln519">{</a>
<a name="ln520">  int ts_val;</a>
<a name="ln521">  int count = 0;                // extra spaces to replace a cut TAB</a>
<a name="ln522">  int spaces = 0;               // non-zero if cutting a TAB</a>
<a name="ln523">  colnr_T offset;               // pointer along new line</a>
<a name="ln524">  size_t s_len = STRLEN(s);</a>
<a name="ln525">  char_u *newp, *oldp;     // new, old lines</a>
<a name="ln526">  linenr_T lnum;                // loop var</a>
<a name="ln527">  int oldstate = State;</a>
<a name="ln528">  State = MODE_INSERT;          // don't want MODE_REPLACE for State</a>
<a name="ln529"> </a>
<a name="ln530">  for (lnum = oap-&gt;start.lnum + 1; lnum &lt;= oap-&gt;end.lnum; lnum++) {</a>
<a name="ln531">    block_prep(oap, bdp, lnum, true);</a>
<a name="ln532">    if (bdp-&gt;is_short &amp;&amp; b_insert) {</a>
<a name="ln533">      continue;  // OP_INSERT, line ends before block start</a>
<a name="ln534">    }</a>
<a name="ln535"> </a>
<a name="ln536">    oldp = (char_u *)ml_get(lnum);</a>
<a name="ln537"> </a>
<a name="ln538">    if (b_insert) {</a>
<a name="ln539">      ts_val = bdp-&gt;start_char_vcols;</a>
<a name="ln540">      spaces = bdp-&gt;startspaces;</a>
<a name="ln541">      if (spaces != 0) {</a>
<a name="ln542">        count = ts_val - 1;         // we're cutting a TAB</a>
<a name="ln543">      }</a>
<a name="ln544">      offset = bdp-&gt;textcol;</a>
<a name="ln545">    } else {  // append</a>
<a name="ln546">      ts_val = bdp-&gt;end_char_vcols;</a>
<a name="ln547">      if (!bdp-&gt;is_short) {     // spaces = padding after block</a>
<a name="ln548">        spaces = (bdp-&gt;endspaces ? ts_val - bdp-&gt;endspaces : 0);</a>
<a name="ln549">        if (spaces != 0) {</a>
<a name="ln550">          count = ts_val - 1;           // we're cutting a TAB</a>
<a name="ln551">        }</a>
<a name="ln552">        offset = bdp-&gt;textcol + bdp-&gt;textlen - (spaces != 0);</a>
<a name="ln553">      } else {  // spaces = padding to block edge</a>
<a name="ln554">                // if $ used, just append to EOL (ie spaces==0)</a>
<a name="ln555">        if (!bdp-&gt;is_MAX) {</a>
<a name="ln556">          spaces = (oap-&gt;end_vcol - bdp-&gt;end_vcol) + 1;</a>
<a name="ln557">        }</a>
<a name="ln558">        count = spaces;</a>
<a name="ln559">        offset = bdp-&gt;textcol + bdp-&gt;textlen;</a>
<a name="ln560">      }</a>
<a name="ln561">    }</a>
<a name="ln562"> </a>
<a name="ln563">    if (spaces &gt; 0) {</a>
<a name="ln564">      // avoid copying part of a multi-byte character</a>
<a name="ln565">      offset -= utf_head_off((char *)oldp, (char *)oldp + offset);</a>
<a name="ln566">    }</a>
<a name="ln567">    if (spaces &lt; 0) {  // can happen when the cursor was moved</a>
<a name="ln568">      spaces = 0;</a>
<a name="ln569">    }</a>
<a name="ln570"> </a>
<a name="ln571">    assert(count &gt;= 0);</a>
<a name="ln572">    // Make sure the allocated size matches what is actually copied below.</a>
<a name="ln573">    newp = xmalloc(STRLEN(oldp) + (size_t)spaces + s_len</a>
<a name="ln574">                   + (spaces &gt; 0 &amp;&amp; !bdp-&gt;is_short ? (size_t)ts_val - (size_t)spaces : 0)</a>
<a name="ln575">                   + (size_t)count + 1);</a>
<a name="ln576"> </a>
<a name="ln577">    // copy up to shifted part</a>
<a name="ln578">    memmove(newp, oldp, (size_t)offset);</a>
<a name="ln579">    oldp += offset;</a>
<a name="ln580">    int startcol = offset;</a>
<a name="ln581"> </a>
<a name="ln582">    // insert pre-padding</a>
<a name="ln583">    memset(newp + offset, ' ', (size_t)spaces);</a>
<a name="ln584"> </a>
<a name="ln585">    // copy the new text</a>
<a name="ln586">    memmove(newp + offset + spaces, s, s_len);</a>
<a name="ln587">    offset += (int)s_len;</a>
<a name="ln588"> </a>
<a name="ln589">    int skipped = 0;</a>
<a name="ln590">    if (spaces &gt; 0 &amp;&amp; !bdp-&gt;is_short) {</a>
<a name="ln591">      if (*oldp == TAB) {</a>
<a name="ln592">        // insert post-padding</a>
<a name="ln593">        memset(newp + offset + spaces, ' ', (size_t)(ts_val - spaces));</a>
<a name="ln594">        // We're splitting a TAB, don't copy it.</a>
<a name="ln595">        oldp++;</a>
<a name="ln596">        // We allowed for that TAB, remember this now</a>
<a name="ln597">        count++;</a>
<a name="ln598">        skipped = 1;</a>
<a name="ln599">      } else {</a>
<a name="ln600">        // Not a TAB, no extra spaces</a>
<a name="ln601">        count = spaces;</a>
<a name="ln602">      }</a>
<a name="ln603">    }</a>
<a name="ln604"> </a>
<a name="ln605">    if (spaces &gt; 0) {</a>
<a name="ln606">      offset += count;</a>
<a name="ln607">    }</a>
<a name="ln608">    STRMOVE(newp + offset, oldp);</a>
<a name="ln609"> </a>
<a name="ln610">    ml_replace(lnum, (char *)newp, false);</a>
<a name="ln611">    extmark_splice_cols(curbuf, (int)lnum - 1, startcol,</a>
<a name="ln612">                        skipped, offset - startcol, kExtmarkUndo);</a>
<a name="ln613"> </a>
<a name="ln614">    if (lnum == oap-&gt;end.lnum) {</a>
<a name="ln615">      // Set &quot;']&quot; mark to the end of the block instead of the end of</a>
<a name="ln616">      // the insert in the first line.</a>
<a name="ln617">      curbuf-&gt;b_op_end.lnum = oap-&gt;end.lnum;</a>
<a name="ln618">      curbuf-&gt;b_op_end.col = offset;</a>
<a name="ln619">    }</a>
<a name="ln620">  }   // for all lnum</a>
<a name="ln621"> </a>
<a name="ln622">  changed_lines(oap-&gt;start.lnum + 1, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln623"> </a>
<a name="ln624">  State = oldstate;</a>
<a name="ln625">}</a>
<a name="ln626"> </a>
<a name="ln627">/// Handle reindenting a block of lines.</a>
<a name="ln628">void op_reindent(oparg_T *oap, Indenter how)</a>
<a name="ln629">{</a>
<a name="ln630">  long i = 0;</a>
<a name="ln631">  char_u *l;</a>
<a name="ln632">  int amount;</a>
<a name="ln633">  linenr_T first_changed = 0;</a>
<a name="ln634">  linenr_T last_changed = 0;</a>
<a name="ln635">  linenr_T start_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln636"> </a>
<a name="ln637">  // Don't even try when 'modifiable' is off.</a>
<a name="ln638">  if (!MODIFIABLE(curbuf)) {</a>
<a name="ln639">    emsg(_(e_modifiable));</a>
<a name="ln640">    return;</a>
<a name="ln641">  }</a>
<a name="ln642"> </a>
<a name="ln643">  // Save for undo.  Do this once for all lines, much faster than doing this</a>
<a name="ln644">  // for each line separately, especially when undoing.</a>
<a name="ln645">  if (u_savecommon(curbuf, start_lnum - 1, start_lnum + (linenr_T)oap-&gt;line_count,</a>
<a name="ln646">                   start_lnum + (linenr_T)oap-&gt;line_count, false) == OK) {</a>
<a name="ln647">    for (i = oap-&gt;line_count - 1; i &gt;= 0 &amp;&amp; !got_int; i--) {</a>
<a name="ln648">      // it's a slow thing to do, so give feedback so there's no worry</a>
<a name="ln649">      // that the computer's just hung.</a>
<a name="ln650"> </a>
<a name="ln651">      if (i &gt; 1</a>
<a name="ln652">          &amp;&amp; (i % 50 == 0 || i == oap-&gt;line_count - 1)</a>
<a name="ln653">          &amp;&amp; oap-&gt;line_count &gt; p_report) {</a>
<a name="ln654">        smsg(_(&quot;%&quot; PRId64 &quot; lines to indent... &quot;), (int64_t)i);</a>
<a name="ln655">      }</a>
<a name="ln656"> </a>
<a name="ln657">      // Be vi-compatible: For lisp indenting the first line is not</a>
<a name="ln658">      // indented, unless there is only one line.</a>
<a name="ln659">      if (i != oap-&gt;line_count - 1 || oap-&gt;line_count == 1</a>
<a name="ln660">          || how != get_lisp_indent) {</a>
<a name="ln661">        l = (char_u *)skipwhite(get_cursor_line_ptr());</a>
<a name="ln662">        if (*l == NUL) {                      // empty or blank line</a>
<a name="ln663">          amount = 0;</a>
<a name="ln664">        } else {</a>
<a name="ln665">          amount = how();                     // get the indent for this line</a>
<a name="ln666">        }</a>
<a name="ln667">        if (amount &gt;= 0 &amp;&amp; set_indent(amount, 0)) {</a>
<a name="ln668">          // did change the indent, call changed_lines() later</a>
<a name="ln669">          if (first_changed == 0) {</a>
<a name="ln670">            first_changed = curwin-&gt;w_cursor.lnum;</a>
<a name="ln671">          }</a>
<a name="ln672">          last_changed = curwin-&gt;w_cursor.lnum;</a>
<a name="ln673">        }</a>
<a name="ln674">      }</a>
<a name="ln675">      curwin-&gt;w_cursor.lnum++;</a>
<a name="ln676">      curwin-&gt;w_cursor.col = 0;      // make sure it's valid</a>
<a name="ln677">    }</a>
<a name="ln678">  }</a>
<a name="ln679"> </a>
<a name="ln680">  // put cursor on first non-blank of indented line</a>
<a name="ln681">  curwin-&gt;w_cursor.lnum = start_lnum;</a>
<a name="ln682">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln683"> </a>
<a name="ln684">  // Mark changed lines so that they will be redrawn.  When Visual</a>
<a name="ln685">  // highlighting was present, need to continue until the last line.  When</a>
<a name="ln686">  // there is no change still need to remove the Visual highlighting.</a>
<a name="ln687">  if (last_changed != 0) {</a>
<a name="ln688">    changed_lines(first_changed, 0,</a>
<a name="ln689">                  oap-&gt;is_VIsual ? start_lnum + (linenr_T)oap-&gt;line_count :</a>
<a name="ln690">                  last_changed + 1, 0L, true);</a>
<a name="ln691">  } else if (oap-&gt;is_VIsual) {</a>
<a name="ln692">    redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln693">  }</a>
<a name="ln694"> </a>
<a name="ln695">  if (oap-&gt;line_count &gt; p_report) {</a>
<a name="ln696">    i = oap-&gt;line_count - (i + 1);</a>
<a name="ln697">    smsg(NGETTEXT(&quot;%&quot; PRId64 &quot; line indented &quot;,</a>
<a name="ln698">                  &quot;%&quot; PRId64 &quot; lines indented &quot;, i),</a>
<a name="ln699">         (int64_t)i);</a>
<a name="ln700">  }</a>
<a name="ln701">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln702">    // set '[ and '] marks</a>
<a name="ln703">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln704">    curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln705">  }</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708">// Keep the last expression line here, for repeating.</a>
<a name="ln709">static char_u *expr_line = NULL;</a>
<a name="ln710"> </a>
<a name="ln711">/// Get an expression for the &quot;\&quot;=expr1&quot; or &quot;CTRL-R =expr1&quot;</a>
<a name="ln712">///</a>
<a name="ln713">/// @return  '=' when OK, NUL otherwise.</a>
<a name="ln714">int get_expr_register(void)</a>
<a name="ln715">{</a>
<a name="ln716">  char_u *new_line;</a>
<a name="ln717"> </a>
<a name="ln718">  new_line = getcmdline('=', 0L, 0, true);</a>
<a name="ln719">  if (new_line == NULL) {</a>
<a name="ln720">    return NUL;</a>
<a name="ln721">  }</a>
<a name="ln722">  if (*new_line == NUL) {  // use previous line</a>
<a name="ln723">    xfree(new_line);</a>
<a name="ln724">  } else {</a>
<a name="ln725">    set_expr_line((char *)new_line);</a>
<a name="ln726">  }</a>
<a name="ln727">  return '=';</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730">/// Set the expression for the '=' register.</a>
<a name="ln731">/// Argument must be an allocated string.</a>
<a name="ln732">void set_expr_line(char *new_line)</a>
<a name="ln733">{</a>
<a name="ln734">  xfree(expr_line);</a>
<a name="ln735">  expr_line = (char_u *)new_line;</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738">/// Get the result of the '=' register expression.</a>
<a name="ln739">///</a>
<a name="ln740">/// @return  a pointer to allocated memory, or NULL for failure.</a>
<a name="ln741">char *get_expr_line(void)</a>
<a name="ln742">{</a>
<a name="ln743">  char *expr_copy;</a>
<a name="ln744">  char *rv;</a>
<a name="ln745">  static int nested = 0;</a>
<a name="ln746"> </a>
<a name="ln747">  if (expr_line == NULL) {</a>
<a name="ln748">    return NULL;</a>
<a name="ln749">  }</a>
<a name="ln750"> </a>
<a name="ln751">  // Make a copy of the expression, because evaluating it may cause it to be</a>
<a name="ln752">  // changed.</a>
<a name="ln753">  expr_copy = xstrdup((char *)expr_line);</a>
<a name="ln754"> </a>
<a name="ln755">  // When we are invoked recursively limit the evaluation to 10 levels.</a>
<a name="ln756">  // Then return the string as-is.</a>
<a name="ln757">  if (nested &gt;= 10) {</a>
<a name="ln758">    return expr_copy;</a>
<a name="ln759">  }</a>
<a name="ln760"> </a>
<a name="ln761">  nested++;</a>
<a name="ln762">  rv = eval_to_string(expr_copy, NULL, true);</a>
<a name="ln763">  nested--;</a>
<a name="ln764">  xfree(expr_copy);</a>
<a name="ln765">  return rv;</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768">/// Get the '=' register expression itself, without evaluating it.</a>
<a name="ln769">char *get_expr_line_src(void)</a>
<a name="ln770">{</a>
<a name="ln771">  if (expr_line == NULL) {</a>
<a name="ln772">    return NULL;</a>
<a name="ln773">  }</a>
<a name="ln774">  return xstrdup((char *)expr_line);</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">/// @return  whether `regname` is a valid name of a yank register.</a>
<a name="ln778">///</a>
<a name="ln779">/// @note: There is no check for 0 (default register), caller should do this.</a>
<a name="ln780">/// The black hole register '_' is regarded as valid.</a>
<a name="ln781">///</a>
<a name="ln782">/// @param regname name of register</a>
<a name="ln783">/// @param writing allow only writable registers</a>
<a name="ln784">bool valid_yank_reg(int regname, bool writing)</a>
<a name="ln785">{</a>
<a name="ln786">  if ((regname &gt; 0 &amp;&amp; ASCII_ISALNUM(regname))</a>
<a name="ln787">      || (!writing &amp;&amp; vim_strchr(&quot;/.%:=&quot;, regname) != NULL)</a>
<a name="ln788">      || regname == '#'</a>
<a name="ln789">      || regname == '&quot;'</a>
<a name="ln790">      || regname == '-'</a>
<a name="ln791">      || regname == '_'</a>
<a name="ln792">      || regname == '*'</a>
<a name="ln793">      || regname == '+') {</a>
<a name="ln794">    return true;</a>
<a name="ln795">  }</a>
<a name="ln796">  return false;</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799">/// @return yankreg_T to use, according to the value of `regname`.</a>
<a name="ln800">/// Cannot handle the '_' (black hole) register.</a>
<a name="ln801">/// Must only be called with a valid register name!</a>
<a name="ln802">///</a>
<a name="ln803">/// @param regname The name of the register used or 0 for the unnamed register</a>
<a name="ln804">/// @param mode One of the following three flags:</a>
<a name="ln805">///</a>
<a name="ln806">/// `YREG_PASTE`:</a>
<a name="ln807">/// Prepare for pasting the register `regname`. With no regname specified,</a>
<a name="ln808">/// read from last written register, or from unnamed clipboard (depending on the</a>
<a name="ln809">/// `clipboard=unnamed` option). Queries the clipboard provider if necessary.</a>
<a name="ln810">///</a>
<a name="ln811">/// `YREG_YANK`:</a>
<a name="ln812">/// Preparare for yanking into `regname`. With no regname specified,</a>
<a name="ln813">/// yank into `&quot;0` register. Update `y_previous` for next unnamed paste.</a>
<a name="ln814">///</a>
<a name="ln815">/// `YREG_PUT`:</a>
<a name="ln816">/// Obtain the location that would be read when pasting `regname`.</a>
<a name="ln817">yankreg_T *get_yank_register(int regname, int mode)</a>
<a name="ln818">{</a>
<a name="ln819">  yankreg_T *reg;</a>
<a name="ln820"> </a>
<a name="ln821">  if (mode == YREG_PASTE &amp;&amp; get_clipboard(regname, &amp;reg, false)) {</a>
<a name="ln822">    // reg is set to clipboard contents.</a>
<a name="ln823">    return reg;</a>
<a name="ln824">  } else if (mode != YREG_YANK</a>
<a name="ln825">             &amp;&amp; (regname == 0 || regname == '&quot;' || regname == '*' || regname == '+')</a>
<a name="ln826">             &amp;&amp; y_previous != NULL) {</a>
<a name="ln827">    // in case clipboard not available, paste from previous used register</a>
<a name="ln828">    return y_previous;</a>
<a name="ln829">  }</a>
<a name="ln830"> </a>
<a name="ln831">  int i = op_reg_index(regname);</a>
<a name="ln832">  // when not 0-9, a-z, A-Z or '-'/'+'/'*': use register 0</a>
<a name="ln833">  if (i == -1) {</a>
<a name="ln834">    i = 0;</a>
<a name="ln835">  }</a>
<a name="ln836">  reg = &amp;y_regs[i];</a>
<a name="ln837"> </a>
<a name="ln838">  if (mode == YREG_YANK) {</a>
<a name="ln839">    // remember the written register for unnamed paste</a>
<a name="ln840">    y_previous = reg;</a>
<a name="ln841">  }</a>
<a name="ln842">  return reg;</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">static bool is_append_register(int regname)</a>
<a name="ln846">{</a>
<a name="ln847">  return ASCII_ISUPPER(regname);</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">/// @see get_yank_register</a>
<a name="ln851">/// @returns true when register should be inserted literally</a>
<a name="ln852">/// (selection or clipboard)</a>
<a name="ln853">static inline bool is_literal_register(int regname)</a>
<a name="ln854">  FUNC_ATTR_CONST</a>
<a name="ln855">{</a>
<a name="ln856">  return regname == '*' || regname == '+';</a>
<a name="ln857">}</a>
<a name="ln858"> </a>
<a name="ln859">/// @return  a copy of contents in register `name` for use in do_put. Should be</a>
<a name="ln860">///          freed by caller.</a>
<a name="ln861">yankreg_T *copy_register(int name)</a>
<a name="ln862">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln863">{</a>
<a name="ln864">  yankreg_T *reg = get_yank_register(name, YREG_PASTE);</a>
<a name="ln865"> </a>
<a name="ln866">  yankreg_T *copy = xmalloc(sizeof(yankreg_T));</a>
<a name="ln867">  *copy = *reg;</a>
<a name="ln868">  if (copy-&gt;y_size == 0) {</a>
<a name="ln869">    copy-&gt;y_array = NULL;</a>
<a name="ln870">  } else {</a>
<a name="ln871">    copy-&gt;y_array = xcalloc(copy-&gt;y_size, sizeof(char *));</a>
<a name="ln872">    for (size_t i = 0; i &lt; copy-&gt;y_size; i++) {</a>
<a name="ln873">      copy-&gt;y_array[i] = xstrdup(reg-&gt;y_array[i]);</a>
<a name="ln874">    }</a>
<a name="ln875">  }</a>
<a name="ln876">  return copy;</a>
<a name="ln877">}</a>
<a name="ln878"> </a>
<a name="ln879">/// Check if the current yank register has kMTLineWise register type</a>
<a name="ln880">bool yank_register_mline(int regname)</a>
<a name="ln881">{</a>
<a name="ln882">  if (regname != 0 &amp;&amp; !valid_yank_reg(regname, false)) {</a>
<a name="ln883">    return false;</a>
<a name="ln884">  }</a>
<a name="ln885">  if (regname == '_') {  // black hole is always empty</a>
<a name="ln886">    return false;</a>
<a name="ln887">  }</a>
<a name="ln888">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln889">  return reg-&gt;y_type == kMTLineWise;</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892">/// Start or stop recording into a yank register.</a>
<a name="ln893">///</a>
<a name="ln894">/// @return  FAIL for failure, OK otherwise.</a>
<a name="ln895">int do_record(int c)</a>
<a name="ln896">{</a>
<a name="ln897">  char_u *p;</a>
<a name="ln898">  static int regname;</a>
<a name="ln899">  yankreg_T *old_y_previous;</a>
<a name="ln900">  int retval;</a>
<a name="ln901"> </a>
<a name="ln902">  if (reg_recording == 0) {</a>
<a name="ln903">    // start recording</a>
<a name="ln904">    // registers 0-9, a-z and &quot; are allowed</a>
<a name="ln905">    if (c &lt; 0 || (!ASCII_ISALNUM(c) &amp;&amp; c != '&quot;')) {</a>
<a name="ln906">      retval = FAIL;</a>
<a name="ln907">    } else {</a>
<a name="ln908">      reg_recording = c;</a>
<a name="ln909">      // TODO(bfredl): showmode based messaging is currently missing with cmdheight=0</a>
<a name="ln910">      showmode();</a>
<a name="ln911">      regname = c;</a>
<a name="ln912">      retval = OK;</a>
<a name="ln913"> </a>
<a name="ln914">      apply_autocmds(EVENT_RECORDINGENTER, NULL, NULL, false, curbuf);</a>
<a name="ln915">    }</a>
<a name="ln916">  } else {  // stop recording</a>
<a name="ln917">    save_v_event_T save_v_event;</a>
<a name="ln918">    // Set the v:event dictionary with information about the recording.</a>
<a name="ln919">    dict_T *dict = get_v_event(&amp;save_v_event);</a>
<a name="ln920"> </a>
<a name="ln921">    // The recorded text contents.</a>
<a name="ln922">    p = get_recorded();</a>
<a name="ln923">    if (p != NULL) {</a>
<a name="ln924">      // Remove escaping for K_SPECIAL in multi-byte chars.</a>
<a name="ln925">      vim_unescape_ks(p);</a>
<a name="ln926">      (void)tv_dict_add_str(dict, S_LEN(&quot;regcontents&quot;), (const char *)p);</a>
<a name="ln927">    }</a>
<a name="ln928"> </a>
<a name="ln929">    // Name of requested register, or empty string for unnamed operation.</a>
<a name="ln930">    char buf[NUMBUFLEN + 2];</a>
<a name="ln931">    buf[0] = (char)regname;</a>
<a name="ln932">    buf[1] = NUL;</a>
<a name="ln933">    (void)tv_dict_add_str(dict, S_LEN(&quot;regname&quot;), buf);</a>
<a name="ln934">    tv_dict_set_keys_readonly(dict);</a>
<a name="ln935"> </a>
<a name="ln936">    // Get the recorded key hits.  K_SPECIAL will be escaped, this</a>
<a name="ln937">    // needs to be removed again to put it in a register.  exec_reg then</a>
<a name="ln938">    // adds the escaping back later.</a>
<a name="ln939">    apply_autocmds(EVENT_RECORDINGLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln940">    restore_v_event(dict, &amp;save_v_event);</a>
<a name="ln941">    reg_recorded = reg_recording;</a>
<a name="ln942">    reg_recording = 0;</a>
<a name="ln943">    if (p_ch == 0 || ui_has(kUIMessages)) {</a>
<a name="ln944">      showmode();</a>
<a name="ln945">    } else {</a>
<a name="ln946">      msg(&quot;&quot;);</a>
<a name="ln947">    }</a>
<a name="ln948">    if (p == NULL) {</a>
<a name="ln949">      retval = FAIL;</a>
<a name="ln950">    } else {</a>
<a name="ln951">      // We don't want to change the default register here, so save and</a>
<a name="ln952">      // restore the current register name.</a>
<a name="ln953">      old_y_previous = y_previous;</a>
<a name="ln954"> </a>
<a name="ln955">      retval = stuff_yank(regname, p);</a>
<a name="ln956"> </a>
<a name="ln957">      y_previous = old_y_previous;</a>
<a name="ln958">    }</a>
<a name="ln959">  }</a>
<a name="ln960">  return retval;</a>
<a name="ln961">}</a>
<a name="ln962"> </a>
<a name="ln963">static void set_yreg_additional_data(yankreg_T *reg, dict_T *additional_data)</a>
<a name="ln964">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln965">{</a>
<a name="ln966">  if (reg-&gt;additional_data == additional_data) {</a>
<a name="ln967">    return;</a>
<a name="ln968">  }</a>
<a name="ln969">  tv_dict_unref(reg-&gt;additional_data);</a>
<a name="ln970">  reg-&gt;additional_data = additional_data;</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973">/// Stuff string &quot;p&quot; into yank register &quot;regname&quot; as a single line (append if</a>
<a name="ln974">/// uppercase). &quot;p&quot; must have been allocated.</a>
<a name="ln975">///</a>
<a name="ln976">/// @return  FAIL for failure, OK otherwise</a>
<a name="ln977">static int stuff_yank(int regname, char_u *p)</a>
<a name="ln978">{</a>
<a name="ln979">  // check for read-only register</a>
<a name="ln980">  if (regname != 0 &amp;&amp; !valid_yank_reg(regname, true)) {</a>
<a name="ln981">    xfree(p);</a>
<a name="ln982">    return FAIL;</a>
<a name="ln983">  }</a>
<a name="ln984">  if (regname == '_') {             // black hole: don't do anything</a>
<a name="ln985">    xfree(p);</a>
<a name="ln986">    return OK;</a>
<a name="ln987">  }</a>
<a name="ln988">  yankreg_T *reg = get_yank_register(regname, YREG_YANK);</a>
<a name="ln989">  if (is_append_register(regname) &amp;&amp; reg-&gt;y_array != NULL) {</a>
<a name="ln990">    char **pp = &amp;(reg-&gt;y_array[reg-&gt;y_size - 1]);</a>
<a name="ln991">    char_u *lp = xmalloc(strlen(*pp) + STRLEN(p) + 1);</a>
<a name="ln992">    STRCPY(lp, *pp);</a>
<a name="ln993">    // TODO(philix): use xstpcpy() in stuff_yank()</a>
<a name="ln994">    STRCAT(lp, p);</a>
<a name="ln995">    xfree(p);</a>
<a name="ln996">    xfree(*pp);</a>
<a name="ln997">    *pp = (char *)lp;</a>
<a name="ln998">  } else {</a>
<a name="ln999">    free_register(reg);</a>
<a name="ln1000">    set_yreg_additional_data(reg, NULL);</a>
<a name="ln1001">    reg-&gt;y_array = xmalloc(sizeof(char_u *));</a>
<a name="ln1002">    reg-&gt;y_array[0] = (char *)p;</a>
<a name="ln1003">    reg-&gt;y_size = 1;</a>
<a name="ln1004">    reg-&gt;y_type = kMTCharWise;</a>
<a name="ln1005">  }</a>
<a name="ln1006">  reg-&gt;timestamp = os_time();</a>
<a name="ln1007">  return OK;</a>
<a name="ln1008">}</a>
<a name="ln1009"> </a>
<a name="ln1010">static int execreg_lastc = NUL;</a>
<a name="ln1011"> </a>
<a name="ln1012">/// When executing a register as a series of ex-commands, if the</a>
<a name="ln1013">/// line-continuation character is used for a line, then join it with one or</a>
<a name="ln1014">/// more previous lines. Note that lines are processed backwards starting from</a>
<a name="ln1015">/// the last line in the register.</a>
<a name="ln1016">///</a>
<a name="ln1017">/// @param lines list of lines in the register</a>
<a name="ln1018">/// @param idx   index of the line starting with \ or &quot;\. Join this line with all the immediate</a>
<a name="ln1019">///              predecessor lines that start with a \ and the first line that doesn't start</a>
<a name="ln1020">///              with a \. Lines that start with a comment &quot;\ character are ignored.</a>
<a name="ln1021">/// @returns the concatenated line. The index of the line that should be</a>
<a name="ln1022">///          processed next is returned in idx.</a>
<a name="ln1023">static char_u *execreg_line_continuation(char **lines, size_t *idx)</a>
<a name="ln1024">{</a>
<a name="ln1025">  size_t i = *idx;</a>
<a name="ln1026">  assert(i &gt; 0);</a>
<a name="ln1027">  const size_t cmd_end = i;</a>
<a name="ln1028"> </a>
<a name="ln1029">  garray_T ga;</a>
<a name="ln1030">  ga_init(&amp;ga, (int)sizeof(char_u), 400);</a>
<a name="ln1031"> </a>
<a name="ln1032">  char_u *p;</a>
<a name="ln1033"> </a>
<a name="ln1034">  // search backwards to find the first line of this command.</a>
<a name="ln1035">  // Any line not starting with \ or &quot;\ is the start of the</a>
<a name="ln1036">  // command.</a>
<a name="ln1037">  while (--i &gt; 0) {</a>
<a name="ln1038">    p = (char_u *)skipwhite(lines[i]);</a>
<a name="ln1039">    if (*p != '\\' &amp;&amp; (p[0] != '&quot;' || p[1] != '\\' || p[2] != ' ')) {</a>
<a name="ln1040">      break;</a>
<a name="ln1041">    }</a>
<a name="ln1042">  }</a>
<a name="ln1043">  const size_t cmd_start = i;</a>
<a name="ln1044"> </a>
<a name="ln1045">  // join all the lines</a>
<a name="ln1046">  ga_concat(&amp;ga, lines[cmd_start]);</a>
<a name="ln1047">  for (size_t j = cmd_start + 1; j &lt;= cmd_end; j++) {</a>
<a name="ln1048">    p = (char_u *)skipwhite(lines[j]);</a>
<a name="ln1049">    if (*p == '\\') {</a>
<a name="ln1050">      // Adjust the growsize to the current length to</a>
<a name="ln1051">      // speed up concatenating many lines.</a>
<a name="ln1052">      if (ga.ga_len &gt; 400) {</a>
<a name="ln1053">        ga_set_growsize(&amp;ga, MIN(ga.ga_len, 8000));</a>
<a name="ln1054">      }</a>
<a name="ln1055">      ga_concat(&amp;ga, (char *)(p + 1));</a>
<a name="ln1056">    }</a>
<a name="ln1057">  }</a>
<a name="ln1058">  ga_append(&amp;ga, NUL);</a>
<a name="ln1059">  char *str = xstrdup(ga.ga_data);</a>
<a name="ln1060">  ga_clear(&amp;ga);</a>
<a name="ln1061"> </a>
<a name="ln1062">  *idx = i;</a>
<a name="ln1063">  return (char_u *)str;</a>
<a name="ln1064">}</a>
<a name="ln1065"> </a>
<a name="ln1066">/// Execute a yank register: copy it into the stuff buffer</a>
<a name="ln1067">///</a>
<a name="ln1068">/// @param colon   insert ':' before each line</a>
<a name="ln1069">/// @param addcr   always add '\n' to end of line</a>
<a name="ln1070">/// @param silent  set &quot;silent&quot; flag in typeahead buffer</a>
<a name="ln1071">///</a>
<a name="ln1072">/// @return FAIL for failure, OK otherwise</a>
<a name="ln1073">int do_execreg(int regname, int colon, int addcr, int silent)</a>
<a name="ln1074">{</a>
<a name="ln1075">  char_u *p;</a>
<a name="ln1076">  int retval = OK;</a>
<a name="ln1077"> </a>
<a name="ln1078">  if (regname == '@') {                 // repeat previous one</a>
<a name="ln1079">    if (execreg_lastc == NUL) {</a>
<a name="ln1080">      emsg(_(&quot;E748: No previously used register&quot;));</a>
<a name="ln1081">      return FAIL;</a>
<a name="ln1082">    }</a>
<a name="ln1083">    regname = execreg_lastc;</a>
<a name="ln1084">  }</a>
<a name="ln1085">  // check for valid regname</a>
<a name="ln1086">  if (regname == '%' || regname == '#' || !valid_yank_reg(regname, false)) {</a>
<a name="ln1087">    emsg_invreg(regname);</a>
<a name="ln1088">    return FAIL;</a>
<a name="ln1089">  }</a>
<a name="ln1090">  execreg_lastc = regname;</a>
<a name="ln1091"> </a>
<a name="ln1092">  if (regname == '_') {                 // black hole: don't stuff anything</a>
<a name="ln1093">    return OK;</a>
<a name="ln1094">  }</a>
<a name="ln1095"> </a>
<a name="ln1096">  if (regname == ':') {                 // use last command line</a>
<a name="ln1097">    if (last_cmdline == NULL) {</a>
<a name="ln1098">      emsg(_(e_nolastcmd));</a>
<a name="ln1099">      return FAIL;</a>
<a name="ln1100">    }</a>
<a name="ln1101">    // don't keep the cmdline containing @:</a>
<a name="ln1102">    XFREE_CLEAR(new_last_cmdline);</a>
<a name="ln1103">    // Escape all control characters with a CTRL-V</a>
<a name="ln1104">    p = vim_strsave_escaped_ext((char_u *)last_cmdline,</a>
<a name="ln1105">                                (char_u *)&quot;\001\002\003\004\005\006\007&quot;</a>
<a name="ln1106">                                &quot;\010\011\012\013\014\015\016\017&quot;</a>
<a name="ln1107">                                &quot;\020\021\022\023\024\025\026\027&quot;</a>
<a name="ln1108">                                &quot;\030\031\032\033\034\035\036\037&quot;,</a>
<a name="ln1109">                                Ctrl_V, false);</a>
<a name="ln1110">    // When in Visual mode &quot;'&lt;,'&gt;&quot; will be prepended to the command.</a>
<a name="ln1111">    // Remove it when it's already there.</a>
<a name="ln1112">    if (VIsual_active &amp;&amp; STRNCMP(p, &quot;'&lt;,'&gt;&quot;, 5) == 0) {</a>
<a name="ln1113">      retval = put_in_typebuf(p + 5, true, true, silent);</a>
<a name="ln1114">    } else {</a>
<a name="ln1115">      retval = put_in_typebuf(p, true, true, silent);</a>
<a name="ln1116">    }</a>
<a name="ln1117">    xfree(p);</a>
<a name="ln1118">  } else if (regname == '=') {</a>
<a name="ln1119">    p = (char_u *)get_expr_line();</a>
<a name="ln1120">    if (p == NULL) {</a>
<a name="ln1121">      return FAIL;</a>
<a name="ln1122">    }</a>
<a name="ln1123">    retval = put_in_typebuf(p, true, colon, silent);</a>
<a name="ln1124">    xfree(p);</a>
<a name="ln1125">  } else if (regname == '.') {        // use last inserted text</a>
<a name="ln1126">    p = get_last_insert_save();</a>
<a name="ln1127">    if (p == NULL) {</a>
<a name="ln1128">      emsg(_(e_noinstext));</a>
<a name="ln1129">      return FAIL;</a>
<a name="ln1130">    }</a>
<a name="ln1131">    retval = put_in_typebuf(p, false, colon, silent);</a>
<a name="ln1132">    xfree(p);</a>
<a name="ln1133">  } else {</a>
<a name="ln1134">    yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln1135">    if (reg-&gt;y_array == NULL) {</a>
<a name="ln1136">      return FAIL;</a>
<a name="ln1137">    }</a>
<a name="ln1138"> </a>
<a name="ln1139">    // Disallow remapping for &quot;:@r&quot;.</a>
<a name="ln1140">    int remap = colon ? REMAP_NONE : REMAP_YES;</a>
<a name="ln1141"> </a>
<a name="ln1142">    // Insert lines into typeahead buffer, from last one to first one.</a>
<a name="ln1143">    put_reedit_in_typebuf(silent);</a>
<a name="ln1144">    char *escaped;</a>
<a name="ln1145">    for (size_t i = reg-&gt;y_size; i-- &gt; 0;) {  // from y_size - 1 to 0 included</a>
<a name="ln1146">      // insert NL between lines and after last line if type is kMTLineWise</a>
<a name="ln1147">      if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1 || addcr) {</a>
<a name="ln1148">        if (ins_typebuf(&quot;\n&quot;, remap, 0, true, silent) == FAIL) {</a>
<a name="ln1149">          return FAIL;</a>
<a name="ln1150">        }</a>
<a name="ln1151">      }</a>
<a name="ln1152"> </a>
<a name="ln1153">      // Handle line-continuation for :@&lt;register&gt;</a>
<a name="ln1154">      char_u *str = (char_u *)reg-&gt;y_array[i];</a>
<a name="ln1155">      bool free_str = false;</a>
<a name="ln1156">      if (colon &amp;&amp; i &gt; 0) {</a>
<a name="ln1157">        p = (char_u *)skipwhite((char *)str);</a>
<a name="ln1158">        if (*p == '\\' || (p[0] == '&quot;' &amp;&amp; p[1] == '\\' &amp;&amp; p[2] == ' ')) {</a>
<a name="ln1159">          str = execreg_line_continuation(reg-&gt;y_array, &amp;i);</a>
<a name="ln1160">          free_str = true;</a>
<a name="ln1161">        }</a>
<a name="ln1162">      }</a>
<a name="ln1163">      escaped = vim_strsave_escape_ks((char *)str);</a>
<a name="ln1164">      if (free_str) {</a>
<a name="ln1165">        xfree(str);</a>
<a name="ln1166">      }</a>
<a name="ln1167">      retval = ins_typebuf(escaped, remap, 0, true, silent);</a>
<a name="ln1168">      xfree(escaped);</a>
<a name="ln1169">      if (retval == FAIL) {</a>
<a name="ln1170">        return FAIL;</a>
<a name="ln1171">      }</a>
<a name="ln1172">      if (colon</a>
<a name="ln1173">          &amp;&amp; ins_typebuf(&quot;:&quot;, remap, 0, true, silent) == FAIL) {</a>
<a name="ln1174">        return FAIL;</a>
<a name="ln1175">      }</a>
<a name="ln1176">    }</a>
<a name="ln1177">    reg_executing = regname == 0 ? '&quot;' : regname;  // disable the 'q' command</a>
<a name="ln1178">  }</a>
<a name="ln1179">  return retval;</a>
<a name="ln1180">}</a>
<a name="ln1181"> </a>
<a name="ln1182">/// If &quot;restart_edit&quot; is not zero, put it in the typeahead buffer, so that it's</a>
<a name="ln1183">/// used only after other typeahead has been processed.</a>
<a name="ln1184">static void put_reedit_in_typebuf(int silent)</a>
<a name="ln1185">{</a>
<a name="ln1186">  char_u buf[3];</a>
<a name="ln1187"> </a>
<a name="ln1188">  if (restart_edit != NUL) {</a>
<a name="ln1189">    if (restart_edit == 'V') {</a>
<a name="ln1190">      buf[0] = 'g';</a>
<a name="ln1191">      buf[1] = 'R';</a>
<a name="ln1192">      buf[2] = NUL;</a>
<a name="ln1193">    } else {</a>
<a name="ln1194">      buf[0] = (char_u)(restart_edit == 'I' ? 'i' : restart_edit);</a>
<a name="ln1195">      buf[1] = NUL;</a>
<a name="ln1196">    }</a>
<a name="ln1197">    if (ins_typebuf((char *)buf, REMAP_NONE, 0, true, silent) == OK) {</a>
<a name="ln1198">      restart_edit = NUL;</a>
<a name="ln1199">    }</a>
<a name="ln1200">  }</a>
<a name="ln1201">}</a>
<a name="ln1202"> </a>
<a name="ln1203">/// Insert register contents &quot;s&quot; into the typeahead buffer, so that it will be</a>
<a name="ln1204">/// executed again.</a>
<a name="ln1205">///</a>
<a name="ln1206">/// @param esc    when true then it is to be taken literally: Escape K_SPECIAL</a>
<a name="ln1207">///               characters and no remapping.</a>
<a name="ln1208">/// @param colon  add ':' before the line</a>
<a name="ln1209">static int put_in_typebuf(char_u *s, bool esc, bool colon, int silent)</a>
<a name="ln1210">{</a>
<a name="ln1211">  int retval = OK;</a>
<a name="ln1212"> </a>
<a name="ln1213">  put_reedit_in_typebuf(silent);</a>
<a name="ln1214">  if (colon) {</a>
<a name="ln1215">    retval = ins_typebuf(&quot;\n&quot;, REMAP_NONE, 0, true, silent);</a>
<a name="ln1216">  }</a>
<a name="ln1217">  if (retval == OK) {</a>
<a name="ln1218">    char *p;</a>
<a name="ln1219"> </a>
<a name="ln1220">    if (esc) {</a>
<a name="ln1221">      p = vim_strsave_escape_ks((char *)s);</a>
<a name="ln1222">    } else {</a>
<a name="ln1223">      p = (char *)s;</a>
<a name="ln1224">    }</a>
<a name="ln1225">    if (p == NULL) {</a>
<a name="ln1226">      retval = FAIL;</a>
<a name="ln1227">    } else {</a>
<a name="ln1228">      retval = ins_typebuf(p, esc ? REMAP_NONE : REMAP_YES, 0, true, silent);</a>
<a name="ln1229">    }</a>
<a name="ln1230">    if (esc) {</a>
<a name="ln1231">      xfree(p);</a>
<a name="ln1232">    }</a>
<a name="ln1233">  }</a>
<a name="ln1234">  if (colon &amp;&amp; retval == OK) {</a>
<a name="ln1235">    retval = ins_typebuf(&quot;:&quot;, REMAP_NONE, 0, true, silent);</a>
<a name="ln1236">  }</a>
<a name="ln1237">  return retval;</a>
<a name="ln1238">}</a>
<a name="ln1239"> </a>
<a name="ln1240">/// Insert a yank register: copy it into the Read buffer.</a>
<a name="ln1241">/// Used by CTRL-R command and middle mouse button in insert mode.</a>
<a name="ln1242">///</a>
<a name="ln1243">/// @param literally_arg  insert literally, not as if typed</a>
<a name="ln1244">///</a>
<a name="ln1245">/// @return FAIL for failure, OK otherwise</a>
<a name="ln1246">int insert_reg(int regname, bool literally_arg)</a>
<a name="ln1247">{</a>
<a name="ln1248">  int retval = OK;</a>
<a name="ln1249">  bool allocated;</a>
<a name="ln1250">  const bool literally = literally_arg || is_literal_register(regname);</a>
<a name="ln1251"> </a>
<a name="ln1252">  // It is possible to get into an endless loop by having CTRL-R a in</a>
<a name="ln1253">  // register a and then, in insert mode, doing CTRL-R a.</a>
<a name="ln1254">  // If you hit CTRL-C, the loop will be broken here.</a>
<a name="ln1255">  os_breakcheck();</a>
<a name="ln1256">  if (got_int) {</a>
<a name="ln1257">    return FAIL;</a>
<a name="ln1258">  }</a>
<a name="ln1259"> </a>
<a name="ln1260">  // check for valid regname</a>
<a name="ln1261">  if (regname != NUL &amp;&amp; !valid_yank_reg(regname, false)) {</a>
<a name="ln1262">    return FAIL;</a>
<a name="ln1263">  }</a>
<a name="ln1264"> </a>
<a name="ln1265">  char *arg;</a>
<a name="ln1266">  if (regname == '.') {  // Insert last inserted text.</a>
<a name="ln1267">    retval = stuff_inserted(NUL, 1L, true);</a>
<a name="ln1268">  } else if (get_spec_reg(regname, &amp;arg, &amp;allocated, true)) {</a>
<a name="ln1269">    if (arg == NULL) {</a>
<a name="ln1270">      return FAIL;</a>
<a name="ln1271">    }</a>
<a name="ln1272">    stuffescaped((const char *)arg, literally);</a>
<a name="ln1273">    if (allocated) {</a>
<a name="ln1274">      xfree(arg);</a>
<a name="ln1275">    }</a>
<a name="ln1276">  } else {  // Name or number register.</a>
<a name="ln1277">    yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln1278">    if (reg-&gt;y_array == NULL) {</a>
<a name="ln1279">      retval = FAIL;</a>
<a name="ln1280">    } else {</a>
<a name="ln1281">      for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln1282">        if (regname == '-') {</a>
<a name="ln1283">          AppendCharToRedobuff(Ctrl_R);</a>
<a name="ln1284">          AppendCharToRedobuff(regname);</a>
<a name="ln1285">          do_put(regname, NULL, BACKWARD, 1L, PUT_CURSEND);</a>
<a name="ln1286">        } else {</a>
<a name="ln1287">          stuffescaped((const char *)reg-&gt;y_array[i], literally);</a>
<a name="ln1288">        }</a>
<a name="ln1289">        // Insert a newline between lines and after last line if</a>
<a name="ln1290">        // y_type is kMTLineWise.</a>
<a name="ln1291">        if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1) {</a>
<a name="ln1292">          stuffcharReadbuff('\n');</a>
<a name="ln1293">        }</a>
<a name="ln1294">      }</a>
<a name="ln1295">    }</a>
<a name="ln1296">  }</a>
<a name="ln1297"> </a>
<a name="ln1298">  return retval;</a>
<a name="ln1299">}</a>
<a name="ln1300"> </a>
<a name="ln1301">/// If &quot;regname&quot; is a special register, return true and store a pointer to its</a>
<a name="ln1302">/// value in &quot;argp&quot;.</a>
<a name="ln1303">///</a>
<a name="ln1304">/// @param allocated  return: true when value was allocated</a>
<a name="ln1305">/// @param errmsg     give error message when failing</a>
<a name="ln1306">///</a>
<a name="ln1307">/// @return  true if &quot;regname&quot; is a special register,</a>
<a name="ln1308">bool get_spec_reg(int regname, char **argp, bool *allocated, bool errmsg)</a>
<a name="ln1309">{</a>
<a name="ln1310">  size_t cnt;</a>
<a name="ln1311"> </a>
<a name="ln1312">  *argp = NULL;</a>
<a name="ln1313">  *allocated = false;</a>
<a name="ln1314">  switch (regname) {</a>
<a name="ln1315">  case '%':                     // file name</a>
<a name="ln1316">    if (errmsg) {</a>
<a name="ln1317">      check_fname();            // will give emsg if not set</a>
<a name="ln1318">    }</a>
<a name="ln1319">    *argp = curbuf-&gt;b_fname;</a>
<a name="ln1320">    return true;</a>
<a name="ln1321"> </a>
<a name="ln1322">  case '#':                       // alternate file name</a>
<a name="ln1323">    *argp = getaltfname(errmsg);  // may give emsg if not set</a>
<a name="ln1324">    return true;</a>
<a name="ln1325"> </a>
<a name="ln1326">  case '=':                     // result of expression</a>
<a name="ln1327">    *argp = get_expr_line();</a>
<a name="ln1328">    *allocated = true;</a>
<a name="ln1329">    return true;</a>
<a name="ln1330"> </a>
<a name="ln1331">  case ':':                     // last command line</a>
<a name="ln1332">    if (last_cmdline == NULL &amp;&amp; errmsg) {</a>
<a name="ln1333">      emsg(_(e_nolastcmd));</a>
<a name="ln1334">    }</a>
<a name="ln1335">    *argp = last_cmdline;</a>
<a name="ln1336">    return true;</a>
<a name="ln1337"> </a>
<a name="ln1338">  case '/':                     // last search-pattern</a>
<a name="ln1339">    if (last_search_pat() == NULL &amp;&amp; errmsg) {</a>
<a name="ln1340">      emsg(_(e_noprevre));</a>
<a name="ln1341">    }</a>
<a name="ln1342">    *argp = (char *)last_search_pat();</a>
<a name="ln1343">    return true;</a>
<a name="ln1344"> </a>
<a name="ln1345">  case '.':                     // last inserted text</a>
<a name="ln1346">    *argp = (char *)get_last_insert_save();</a>
<a name="ln1347">    *allocated = true;</a>
<a name="ln1348">    if (*argp == NULL &amp;&amp; errmsg) {</a>
<a name="ln1349">      emsg(_(e_noinstext));</a>
<a name="ln1350">    }</a>
<a name="ln1351">    return true;</a>
<a name="ln1352"> </a>
<a name="ln1353">  case Ctrl_F:                  // Filename under cursor</a>
<a name="ln1354">  case Ctrl_P:                  // Path under cursor, expand via &quot;path&quot;</a>
<a name="ln1355">    if (!errmsg) {</a>
<a name="ln1356">      return false;</a>
<a name="ln1357">    }</a>
<a name="ln1358">    *argp</a>
<a name="ln1359">      = (char *)file_name_at_cursor(FNAME_MESS | FNAME_HYP | (regname == Ctrl_P ? FNAME_EXP : 0),</a>
<a name="ln1360">                                    1L, NULL);</a>
<a name="ln1361">    *allocated = true;</a>
<a name="ln1362">    return true;</a>
<a name="ln1363"> </a>
<a name="ln1364">  case Ctrl_W:                  // word under cursor</a>
<a name="ln1365">  case Ctrl_A:                  // WORD (mnemonic All) under cursor</a>
<a name="ln1366">    if (!errmsg) {</a>
<a name="ln1367">      return false;</a>
<a name="ln1368">    }</a>
<a name="ln1369">    cnt = find_ident_under_cursor(argp, (regname == Ctrl_W</a>
<a name="ln1370">                                         ? (FIND_IDENT|FIND_STRING)</a>
<a name="ln1371">                                         : FIND_STRING));</a>
<a name="ln1372">    *argp = cnt ? xstrnsave(*argp, cnt) : NULL;</a>
<a name="ln1373">    *allocated = true;</a>
<a name="ln1374">    return true;</a>
<a name="ln1375"> </a>
<a name="ln1376">  case Ctrl_L:                  // Line under cursor</a>
<a name="ln1377">    if (!errmsg) {</a>
<a name="ln1378">      return false;</a>
<a name="ln1379">    }</a>
<a name="ln1380"> </a>
<a name="ln1381">    *argp = ml_get_buf(curwin-&gt;w_buffer, curwin-&gt;w_cursor.lnum, false);</a>
<a name="ln1382">    return true;</a>
<a name="ln1383"> </a>
<a name="ln1384">  case '_':                     // black hole: always empty</a>
<a name="ln1385">    *argp = &quot;&quot;;</a>
<a name="ln1386">    return true;</a>
<a name="ln1387">  }</a>
<a name="ln1388"> </a>
<a name="ln1389">  return false;</a>
<a name="ln1390">}</a>
<a name="ln1391"> </a>
<a name="ln1392">/// Paste a yank register into the command line.</a>
<a name="ln1393">/// Only for non-special registers.</a>
<a name="ln1394">/// Used by CTRL-R in command-line mode.</a>
<a name="ln1395">/// insert_reg() can't be used here, because special characters from the</a>
<a name="ln1396">/// register contents will be interpreted as commands.</a>
<a name="ln1397">///</a>
<a name="ln1398">/// @param regname   Register name.</a>
<a name="ln1399">/// @param literally_arg Insert text literally instead of &quot;as typed&quot;.</a>
<a name="ln1400">/// @param remcr     When true, don't add CR characters.</a>
<a name="ln1401">///</a>
<a name="ln1402">/// @returns FAIL for failure, OK otherwise</a>
<a name="ln1403">bool cmdline_paste_reg(int regname, bool literally_arg, bool remcr)</a>
<a name="ln1404">{</a>
<a name="ln1405">  const bool literally = literally_arg || is_literal_register(regname);</a>
<a name="ln1406"> </a>
<a name="ln1407">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln1408">  if (reg-&gt;y_array == NULL) {</a>
<a name="ln1409">    return FAIL;</a>
<a name="ln1410">  }</a>
<a name="ln1411"> </a>
<a name="ln1412">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln1413">    cmdline_paste_str((char_u *)reg-&gt;y_array[i], literally);</a>
<a name="ln1414"> </a>
<a name="ln1415">    // Insert ^M between lines, unless `remcr` is true.</a>
<a name="ln1416">    if (i &lt; reg-&gt;y_size - 1 &amp;&amp; !remcr) {</a>
<a name="ln1417">      cmdline_paste_str((char_u *)&quot;\r&quot;, literally);</a>
<a name="ln1418">    }</a>
<a name="ln1419"> </a>
<a name="ln1420">    // Check for CTRL-C, in case someone tries to paste a few thousand</a>
<a name="ln1421">    // lines and gets bored.</a>
<a name="ln1422">    os_breakcheck();</a>
<a name="ln1423">    if (got_int) {</a>
<a name="ln1424">      return FAIL;</a>
<a name="ln1425">    }</a>
<a name="ln1426">  }</a>
<a name="ln1427">  return OK;</a>
<a name="ln1428">}</a>
<a name="ln1429"> </a>
<a name="ln1430">/// Shift the delete registers: &quot;9 is cleared, &quot;8 becomes &quot;9, etc.</a>
<a name="ln1431">static void shift_delete_registers(bool y_append)</a>
<a name="ln1432">{</a>
<a name="ln1433">  free_register(&amp;y_regs[9]);  // free register &quot;9</a>
<a name="ln1434">  for (int n = 9; n &gt; 1; n--) {</a>
<a name="ln1435">    y_regs[n] = y_regs[n - 1];</a>
<a name="ln1436">  }</a>
<a name="ln1437">  if (!y_append) {</a>
<a name="ln1438">    y_previous = &amp;y_regs[1];</a>
<a name="ln1439">  }</a>
<a name="ln1440">  y_regs[1].y_array = NULL;  // set register &quot;1 to empty</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443">/// Handle a delete operation.</a>
<a name="ln1444">///</a>
<a name="ln1445">/// @return  FAIL if undo failed, OK otherwise.</a>
<a name="ln1446">int op_delete(oparg_T *oap)</a>
<a name="ln1447">{</a>
<a name="ln1448">  int n;</a>
<a name="ln1449">  linenr_T lnum;</a>
<a name="ln1450">  char_u *ptr;</a>
<a name="ln1451">  char_u *newp, *oldp;</a>
<a name="ln1452">  struct block_def bd = { 0 };</a>
<a name="ln1453">  linenr_T old_lcount = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1454"> </a>
<a name="ln1455">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {  // nothing to do</a>
<a name="ln1456">    return OK;</a>
<a name="ln1457">  }</a>
<a name="ln1458"> </a>
<a name="ln1459">  // Nothing to delete, return here. Do prepare undo, for op_change().</a>
<a name="ln1460">  if (oap-&gt;empty) {</a>
<a name="ln1461">    return u_save_cursor();</a>
<a name="ln1462">  }</a>
<a name="ln1463"> </a>
<a name="ln1464">  if (!MODIFIABLE(curbuf)) {</a>
<a name="ln1465">    emsg(_(e_modifiable));</a>
<a name="ln1466">    return FAIL;</a>
<a name="ln1467">  }</a>
<a name="ln1468"> </a>
<a name="ln1469">  if (VIsual_select &amp;&amp; oap-&gt;is_VIsual) {</a>
<a name="ln1470">    // Use the register given with CTRL_R, defaults to zero</a>
<a name="ln1471">    oap-&gt;regname = VIsual_select_reg;</a>
<a name="ln1472">  }</a>
<a name="ln1473"> </a>
<a name="ln1474">  mb_adjust_opend(oap);</a>
<a name="ln1475"> </a>
<a name="ln1476">  // Imitate the strange Vi behaviour: If the delete spans more than one</a>
<a name="ln1477">  // line and motion_type == kMTCharWise and the result is a blank line, make the</a>
<a name="ln1478">  // delete linewise.  Don't do this for the change command or Visual mode.</a>
<a name="ln1479">  if (oap-&gt;motion_type == kMTCharWise</a>
<a name="ln1480">      &amp;&amp; !oap-&gt;is_VIsual</a>
<a name="ln1481">      &amp;&amp; oap-&gt;line_count &gt; 1</a>
<a name="ln1482">      &amp;&amp; oap-&gt;motion_force == NUL</a>
<a name="ln1483">      &amp;&amp; oap-&gt;op_type == OP_DELETE) {</a>
<a name="ln1484">    ptr = (char_u *)ml_get(oap-&gt;end.lnum) + oap-&gt;end.col;</a>
<a name="ln1485">    if (*ptr != NUL) {</a>
<a name="ln1486">      ptr += oap-&gt;inclusive;</a>
<a name="ln1487">    }</a>
<a name="ln1488">    ptr = (char_u *)skipwhite((char *)ptr);</a>
<a name="ln1489">    if (*ptr == NUL &amp;&amp; inindent(0)) {</a>
<a name="ln1490">      oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln1491">    }</a>
<a name="ln1492">  }</a>
<a name="ln1493"> </a>
<a name="ln1494">  // Check for trying to delete (e.g. &quot;D&quot;) in an empty line.</a>
<a name="ln1495">  // Note: For the change operator it is ok.</a>
<a name="ln1496">  if (oap-&gt;motion_type != kMTLineWise</a>
<a name="ln1497">      &amp;&amp; oap-&gt;line_count == 1</a>
<a name="ln1498">      &amp;&amp; oap-&gt;op_type == OP_DELETE</a>
<a name="ln1499">      &amp;&amp; *ml_get(oap-&gt;start.lnum) == NUL) {</a>
<a name="ln1500">    // It's an error to operate on an empty region, when 'E' included in</a>
<a name="ln1501">    // 'cpoptions' (Vi compatible).</a>
<a name="ln1502">    if (virtual_op) {</a>
<a name="ln1503">      // Virtual editing: Nothing gets deleted, but we set the '[ and ']</a>
<a name="ln1504">      // marks as if it happened.</a>
<a name="ln1505">      goto setmarks;</a>
<a name="ln1506">    }</a>
<a name="ln1507">    if (vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL) {</a>
<a name="ln1508">      beep_flush();</a>
<a name="ln1509">    }</a>
<a name="ln1510">    return OK;</a>
<a name="ln1511">  }</a>
<a name="ln1512"> </a>
<a name="ln1513">  // Do a yank of whatever we're about to delete.</a>
<a name="ln1514">  // If a yank register was specified, put the deleted text into that</a>
<a name="ln1515">  // register.  For the black hole register '_' don't yank anything.</a>
<a name="ln1516">  if (oap-&gt;regname != '_') {</a>
<a name="ln1517">    yankreg_T *reg = NULL;</a>
<a name="ln1518">    int did_yank = false;</a>
<a name="ln1519">    if (oap-&gt;regname != 0) {</a>
<a name="ln1520">      // check for read-only register</a>
<a name="ln1521">      if (!valid_yank_reg(oap-&gt;regname, true)) {</a>
<a name="ln1522">        beep_flush();</a>
<a name="ln1523">        return OK;</a>
<a name="ln1524">      }</a>
<a name="ln1525">      reg = get_yank_register(oap-&gt;regname, YREG_YANK);  // yank into specif'd reg</a>
<a name="ln1526">      op_yank_reg(oap, false, reg, is_append_register(oap-&gt;regname));  // yank without message</a>
<a name="ln1527">      did_yank = true;</a>
<a name="ln1528">    }</a>
<a name="ln1529"> </a>
<a name="ln1530">    // Put deleted text into register 1 and shift number registers if the</a>
<a name="ln1531">    // delete contains a line break, or when using a specific operator (Vi</a>
<a name="ln1532">    // compatible)</a>
<a name="ln1533"> </a>
<a name="ln1534">    if (oap-&gt;motion_type == kMTLineWise || oap-&gt;line_count &gt; 1 || oap-&gt;use_reg_one) {</a>
<a name="ln1535">      shift_delete_registers(is_append_register(oap-&gt;regname));</a>
<a name="ln1536">      reg = &amp;y_regs[1];</a>
<a name="ln1537">      op_yank_reg(oap, false, reg, false);</a>
<a name="ln1538">      did_yank = true;</a>
<a name="ln1539">    }</a>
<a name="ln1540"> </a>
<a name="ln1541">    // Yank into small delete register when no named register specified</a>
<a name="ln1542">    // and the delete is within one line.</a>
<a name="ln1543">    if (oap-&gt;regname == 0 &amp;&amp; oap-&gt;motion_type != kMTLineWise</a>
<a name="ln1544">        &amp;&amp; oap-&gt;line_count == 1) {</a>
<a name="ln1545">      reg = get_yank_register('-', YREG_YANK);</a>
<a name="ln1546">      op_yank_reg(oap, false, reg, false);</a>
<a name="ln1547">      did_yank = true;</a>
<a name="ln1548">    }</a>
<a name="ln1549"> </a>
<a name="ln1550">    if (did_yank || oap-&gt;regname == 0) {</a>
<a name="ln1551">      if (reg == NULL) {</a>
<a name="ln1552">        abort();</a>
<a name="ln1553">      }</a>
<a name="ln1554">      set_clipboard(oap-&gt;regname, reg);</a>
<a name="ln1555">      do_autocmd_textyankpost(oap, reg);</a>
<a name="ln1556">    }</a>
<a name="ln1557">  }</a>
<a name="ln1558"> </a>
<a name="ln1559">  // block mode delete</a>
<a name="ln1560">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln1561">    if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln1562">               (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln1563">      return FAIL;</a>
<a name="ln1564">    }</a>
<a name="ln1565"> </a>
<a name="ln1566">    for (lnum = curwin-&gt;w_cursor.lnum; lnum &lt;= oap-&gt;end.lnum; lnum++) {</a>
<a name="ln1567">      block_prep(oap, &amp;bd, lnum, true);</a>
<a name="ln1568">      if (bd.textlen == 0) {            // nothing to delete</a>
<a name="ln1569">        continue;</a>
<a name="ln1570">      }</a>
<a name="ln1571"> </a>
<a name="ln1572">      // Adjust cursor position for tab replaced by spaces and 'lbr'.</a>
<a name="ln1573">      if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln1574">        curwin-&gt;w_cursor.col = bd.textcol + bd.startspaces;</a>
<a name="ln1575">        curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln1576">      }</a>
<a name="ln1577"> </a>
<a name="ln1578">      // n == number of chars deleted</a>
<a name="ln1579">      // If we delete a TAB, it may be replaced by several characters.</a>
<a name="ln1580">      // Thus the number of characters may increase!</a>
<a name="ln1581">      n = bd.textlen - bd.startspaces - bd.endspaces;</a>
<a name="ln1582">      oldp = (char_u *)ml_get(lnum);</a>
<a name="ln1583">      newp = (char_u *)xmalloc(STRLEN(oldp) - (size_t)n + 1);</a>
<a name="ln1584">      // copy up to deleted part</a>
<a name="ln1585">      memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln1586">      // insert spaces</a>
<a name="ln1587">      memset(newp + bd.textcol, ' ', (size_t)bd.startspaces +</a>
<a name="ln1588">             (size_t)bd.endspaces);</a>
<a name="ln1589">      // copy the part after the deleted part</a>
<a name="ln1590">      oldp += bd.textcol + bd.textlen;</a>
<a name="ln1591">      STRMOVE(newp + bd.textcol + bd.startspaces + bd.endspaces, oldp);</a>
<a name="ln1592">      // replace the line</a>
<a name="ln1593">      ml_replace(lnum, (char *)newp, false);</a>
<a name="ln1594"> </a>
<a name="ln1595">      extmark_splice_cols(curbuf, (int)lnum - 1, bd.textcol,</a>
<a name="ln1596">                          bd.textlen, bd.startspaces + bd.endspaces,</a>
<a name="ln1597">                          kExtmarkUndo);</a>
<a name="ln1598">    }</a>
<a name="ln1599"> </a>
<a name="ln1600">    check_cursor_col();</a>
<a name="ln1601">    changed_lines(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col,</a>
<a name="ln1602">                  oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln1603">    oap-&gt;line_count = 0;  // no lines deleted</a>
<a name="ln1604">  } else if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln1605">    if (oap-&gt;op_type == OP_CHANGE) {</a>
<a name="ln1606">      // Delete the lines except the first one.  Temporarily move the</a>
<a name="ln1607">      // cursor to the next line.  Save the current line number, if the</a>
<a name="ln1608">      // last line is deleted it may be changed.</a>
<a name="ln1609"> </a>
<a name="ln1610">      if (oap-&gt;line_count &gt; 1) {</a>
<a name="ln1611">        lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1612">        curwin-&gt;w_cursor.lnum++;</a>
<a name="ln1613">        del_lines(oap-&gt;line_count - 1, true);</a>
<a name="ln1614">        curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln1615">      }</a>
<a name="ln1616">      if (u_save_cursor() == FAIL) {</a>
<a name="ln1617">        return FAIL;</a>
<a name="ln1618">      }</a>
<a name="ln1619">      if (curbuf-&gt;b_p_ai) {                 // don't delete indent</a>
<a name="ln1620">        beginline(BL_WHITE);                // cursor on first non-white</a>
<a name="ln1621">        did_ai = true;                      // delete the indent when ESC hit</a>
<a name="ln1622">        ai_col = curwin-&gt;w_cursor.col;</a>
<a name="ln1623">      } else {</a>
<a name="ln1624">        beginline(0);                       // cursor in column 0</a>
<a name="ln1625">      }</a>
<a name="ln1626"> </a>
<a name="ln1627">      int old_len = (int)strlen(ml_get(curwin-&gt;w_cursor.lnum));</a>
<a name="ln1628">      truncate_line(false);         // delete the rest of the line</a>
<a name="ln1629"> </a>
<a name="ln1630">      extmark_splice_cols(curbuf,</a>
<a name="ln1631">                          (int)curwin-&gt;w_cursor.lnum - 1, curwin-&gt;w_cursor.col,</a>
<a name="ln1632">                          old_len - curwin-&gt;w_cursor.col, 0, kExtmarkUndo);</a>
<a name="ln1633"> </a>
<a name="ln1634">      // leave cursor past last char in line</a>
<a name="ln1635">      if (oap-&gt;line_count &gt; 1) {</a>
<a name="ln1636">        u_clearline();              // &quot;U&quot; command not possible after &quot;2cc&quot;</a>
<a name="ln1637">      }</a>
<a name="ln1638">    } else {</a>
<a name="ln1639">      del_lines(oap-&gt;line_count, true);</a>
<a name="ln1640">      beginline(BL_WHITE | BL_FIX);</a>
<a name="ln1641">      u_clearline();            // &quot;U&quot; command not possible after &quot;dd&quot;</a>
<a name="ln1642">    }</a>
<a name="ln1643">  } else {</a>
<a name="ln1644">    if (virtual_op) {</a>
<a name="ln1645">      int endcol = 0;</a>
<a name="ln1646"> </a>
<a name="ln1647">      // For virtualedit: break the tabs that are partly included.</a>
<a name="ln1648">      if (gchar_pos(&amp;oap-&gt;start) == '\t') {</a>
<a name="ln1649">        if (u_save_cursor() == FAIL) {          // save first line for undo</a>
<a name="ln1650">          return FAIL;</a>
<a name="ln1651">        }</a>
<a name="ln1652">        if (oap-&gt;line_count == 1) {</a>
<a name="ln1653">          endcol = getviscol2(oap-&gt;end.col, oap-&gt;end.coladd);</a>
<a name="ln1654">        }</a>
<a name="ln1655">        coladvance_force(getviscol2(oap-&gt;start.col, oap-&gt;start.coladd));</a>
<a name="ln1656">        oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln1657">        if (oap-&gt;line_count == 1) {</a>
<a name="ln1658">          coladvance(endcol);</a>
<a name="ln1659">          oap-&gt;end.col = curwin-&gt;w_cursor.col;</a>
<a name="ln1660">          oap-&gt;end.coladd = curwin-&gt;w_cursor.coladd;</a>
<a name="ln1661">          curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln1662">        }</a>
<a name="ln1663">      }</a>
<a name="ln1664"> </a>
<a name="ln1665">      // Break a tab only when it's included in the area.</a>
<a name="ln1666">      if (gchar_pos(&amp;oap-&gt;end) == '\t'</a>
<a name="ln1667">          &amp;&amp; oap-&gt;end.coladd == 0</a>
<a name="ln1668">          &amp;&amp; oap-&gt;inclusive) {</a>
<a name="ln1669">        // save last line for undo</a>
<a name="ln1670">        if (u_save((linenr_T)(oap-&gt;end.lnum - 1),</a>
<a name="ln1671">                   (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln1672">          return FAIL;</a>
<a name="ln1673">        }</a>
<a name="ln1674">        curwin-&gt;w_cursor = oap-&gt;end;</a>
<a name="ln1675">        coladvance_force(getviscol2(oap-&gt;end.col, oap-&gt;end.coladd));</a>
<a name="ln1676">        oap-&gt;end = curwin-&gt;w_cursor;</a>
<a name="ln1677">        curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln1678">      }</a>
<a name="ln1679">      mb_adjust_opend(oap);</a>
<a name="ln1680">    }</a>
<a name="ln1681"> </a>
<a name="ln1682">    if (oap-&gt;line_count == 1) {         // delete characters within one line</a>
<a name="ln1683">      if (u_save_cursor() == FAIL) {            // save line for undo</a>
<a name="ln1684">        return FAIL;</a>
<a name="ln1685">      }</a>
<a name="ln1686"> </a>
<a name="ln1687">      // if 'cpoptions' contains '$', display '$' at end of change</a>
<a name="ln1688">      if (vim_strchr(p_cpo, CPO_DOLLAR) != NULL</a>
<a name="ln1689">          &amp;&amp; oap-&gt;op_type == OP_CHANGE</a>
<a name="ln1690">          &amp;&amp; oap-&gt;end.lnum == curwin-&gt;w_cursor.lnum</a>
<a name="ln1691">          &amp;&amp; !oap-&gt;is_VIsual) {</a>
<a name="ln1692">        display_dollar(oap-&gt;end.col - !oap-&gt;inclusive);</a>
<a name="ln1693">      }</a>
<a name="ln1694"> </a>
<a name="ln1695">      n = oap-&gt;end.col - oap-&gt;start.col + 1 - !oap-&gt;inclusive;</a>
<a name="ln1696"> </a>
<a name="ln1697">      if (virtual_op) {</a>
<a name="ln1698">        // fix up things for virtualedit-delete:</a>
<a name="ln1699">        // break the tabs which are going to get in our way</a>
<a name="ln1700">        char_u *curline = (char_u *)get_cursor_line_ptr();</a>
<a name="ln1701">        int len = (int)STRLEN(curline);</a>
<a name="ln1702"> </a>
<a name="ln1703">        if (oap-&gt;end.coladd != 0</a>
<a name="ln1704">            &amp;&amp; (int)oap-&gt;end.col &gt;= len - 1</a>
<a name="ln1705">            &amp;&amp; !(oap-&gt;start.coladd &amp;&amp; (int)oap-&gt;end.col &gt;= len - 1)) {</a>
<a name="ln1706">          n++;</a>
<a name="ln1707">        }</a>
<a name="ln1708">        // Delete at least one char (e.g, when on a control char).</a>
<a name="ln1709">        if (n == 0 &amp;&amp; oap-&gt;start.coladd != oap-&gt;end.coladd) {</a>
<a name="ln1710">          n = 1;</a>
<a name="ln1711">        }</a>
<a name="ln1712"> </a>
<a name="ln1713">        // When deleted a char in the line, reset coladd.</a>
<a name="ln1714">        if (gchar_cursor() != NUL) {</a>
<a name="ln1715">          curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln1716">        }</a>
<a name="ln1717">      }</a>
<a name="ln1718"> </a>
<a name="ln1719">      (void)del_bytes((colnr_T)n, !virtual_op,</a>
<a name="ln1720">                      oap-&gt;op_type == OP_DELETE &amp;&amp; !oap-&gt;is_VIsual);</a>
<a name="ln1721">    } else {</a>
<a name="ln1722">      // delete characters between lines</a>
<a name="ln1723">      pos_T curpos;</a>
<a name="ln1724"> </a>
<a name="ln1725">      // save deleted and changed lines for undo</a>
<a name="ln1726">      if (u_save((linenr_T)(curwin-&gt;w_cursor.lnum - 1),</a>
<a name="ln1727">                 (linenr_T)(curwin-&gt;w_cursor.lnum + oap-&gt;line_count)) == FAIL) {</a>
<a name="ln1728">        return FAIL;</a>
<a name="ln1729">      }</a>
<a name="ln1730"> </a>
<a name="ln1731">      curbuf_splice_pending++;</a>
<a name="ln1732">      pos_T startpos = curwin-&gt;w_cursor;  // start position for delete</a>
<a name="ln1733">      bcount_t deleted_bytes = get_region_bytecount(curbuf, startpos.lnum, oap-&gt;end.lnum,</a>
<a name="ln1734">                                                    startpos.col,</a>
<a name="ln1735">                                                    oap-&gt;end.col) + oap-&gt;inclusive;</a>
<a name="ln1736">      truncate_line(true);        // delete from cursor to end of line</a>
<a name="ln1737"> </a>
<a name="ln1738">      curpos = curwin-&gt;w_cursor;  // remember curwin-&gt;w_cursor</a>
<a name="ln1739">      curwin-&gt;w_cursor.lnum++;</a>
<a name="ln1740"> </a>
<a name="ln1741">      del_lines(oap-&gt;line_count - 2, false);</a>
<a name="ln1742"> </a>
<a name="ln1743">      // delete from start of line until op_end</a>
<a name="ln1744">      n = (oap-&gt;end.col + 1 - !oap-&gt;inclusive);</a>
<a name="ln1745">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1746">      (void)del_bytes((colnr_T)n, !virtual_op,</a>
<a name="ln1747">                      oap-&gt;op_type == OP_DELETE &amp;&amp; !oap-&gt;is_VIsual);</a>
<a name="ln1748">      curwin-&gt;w_cursor = curpos;  // restore curwin-&gt;w_cursor</a>
<a name="ln1749">      (void)do_join(2, false, false, false, false);</a>
<a name="ln1750">      curbuf_splice_pending--;</a>
<a name="ln1751">      extmark_splice(curbuf, (int)startpos.lnum - 1, startpos.col,</a>
<a name="ln1752">                     (int)oap-&gt;line_count - 1, n, deleted_bytes,</a>
<a name="ln1753">                     0, 0, 0, kExtmarkUndo);</a>
<a name="ln1754">    }</a>
<a name="ln1755">    if (oap-&gt;op_type == OP_DELETE) {</a>
<a name="ln1756">      auto_format(false, true);</a>
<a name="ln1757">    }</a>
<a name="ln1758">  }</a>
<a name="ln1759"> </a>
<a name="ln1760">  msgmore(curbuf-&gt;b_ml.ml_line_count - old_lcount);</a>
<a name="ln1761"> </a>
<a name="ln1762">setmarks:</a>
<a name="ln1763">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln1764">    if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln1765">      curbuf-&gt;b_op_end.lnum = oap-&gt;end.lnum;</a>
<a name="ln1766">      curbuf-&gt;b_op_end.col = oap-&gt;start.col;</a>
<a name="ln1767">    } else {</a>
<a name="ln1768">      curbuf-&gt;b_op_end = oap-&gt;start;</a>
<a name="ln1769">    }</a>
<a name="ln1770">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln1771">  }</a>
<a name="ln1772"> </a>
<a name="ln1773">  return OK;</a>
<a name="ln1774">}</a>
<a name="ln1775"> </a>
<a name="ln1776">/// Adjust end of operating area for ending on a multi-byte character.</a>
<a name="ln1777">/// Used for deletion.</a>
<a name="ln1778">static void mb_adjust_opend(oparg_T *oap)</a>
<a name="ln1779">{</a>
<a name="ln1780">  if (oap-&gt;inclusive) {</a>
<a name="ln1781">    char *p = ml_get(oap-&gt;end.lnum);</a>
<a name="ln1782">    oap-&gt;end.col += utf_cp_tail_off(p, p + oap-&gt;end.col);</a>
<a name="ln1783">  }</a>
<a name="ln1784">}</a>
<a name="ln1785"> </a>
<a name="ln1786">/// Put character 'c' at position 'lp'</a>
<a name="ln1787">static inline void pbyte(pos_T lp, int c)</a>
<a name="ln1788">{</a>
<a name="ln1789">  assert(c &lt;= UCHAR_MAX);</a>
<a name="ln1790">  *(ml_get_buf(curbuf, lp.lnum, true) + lp.col) = (char)c;</a>
<a name="ln1791">  if (!curbuf_splice_pending) {</a>
<a name="ln1792">    extmark_splice_cols(curbuf, (int)lp.lnum - 1, lp.col, 1, 1, kExtmarkUndo);</a>
<a name="ln1793">  }</a>
<a name="ln1794">}</a>
<a name="ln1795"> </a>
<a name="ln1796">/// Replace the character under the cursor with &quot;c&quot;.</a>
<a name="ln1797">/// This takes care of multi-byte characters.</a>
<a name="ln1798">static void replace_character(int c)</a>
<a name="ln1799">{</a>
<a name="ln1800">  const int n = State;</a>
<a name="ln1801"> </a>
<a name="ln1802">  State = MODE_REPLACE;</a>
<a name="ln1803">  ins_char(c);</a>
<a name="ln1804">  State = n;</a>
<a name="ln1805">  // Backup to the replaced character.</a>
<a name="ln1806">  dec_cursor();</a>
<a name="ln1807">}</a>
<a name="ln1808"> </a>
<a name="ln1809">/// Replace a whole area with one character.</a>
<a name="ln1810">static int op_replace(oparg_T *oap, int c)</a>
<a name="ln1811">{</a>
<a name="ln1812">  int n, numc;</a>
<a name="ln1813">  int num_chars;</a>
<a name="ln1814">  char_u *newp, *oldp;</a>
<a name="ln1815">  colnr_T oldlen;</a>
<a name="ln1816">  struct block_def bd;</a>
<a name="ln1817">  char_u *after_p = NULL;</a>
<a name="ln1818">  int had_ctrl_v_cr = false;</a>
<a name="ln1819"> </a>
<a name="ln1820">  if ((curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) || oap-&gt;empty) {</a>
<a name="ln1821">    return OK;              // nothing to do</a>
<a name="ln1822">  }</a>
<a name="ln1823">  if (c == REPLACE_CR_NCHAR) {</a>
<a name="ln1824">    had_ctrl_v_cr = true;</a>
<a name="ln1825">    c = CAR;</a>
<a name="ln1826">  } else if (c == REPLACE_NL_NCHAR) {</a>
<a name="ln1827">    had_ctrl_v_cr = true;</a>
<a name="ln1828">    c = NL;</a>
<a name="ln1829">  }</a>
<a name="ln1830"> </a>
<a name="ln1831">  mb_adjust_opend(oap);</a>
<a name="ln1832"> </a>
<a name="ln1833">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln1834">             (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln1835">    return FAIL;</a>
<a name="ln1836">  }</a>
<a name="ln1837"> </a>
<a name="ln1838">  // block mode replace</a>
<a name="ln1839">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln1840">    bd.is_MAX = (curwin-&gt;w_curswant == MAXCOL);</a>
<a name="ln1841">    for (; curwin-&gt;w_cursor.lnum &lt;= oap-&gt;end.lnum; curwin-&gt;w_cursor.lnum++) {</a>
<a name="ln1842">      curwin-&gt;w_cursor.col = 0;       // make sure cursor position is valid</a>
<a name="ln1843">      block_prep(oap, &amp;bd, curwin-&gt;w_cursor.lnum, true);</a>
<a name="ln1844">      if (bd.textlen == 0 &amp;&amp; (!virtual_op || bd.is_MAX)) {</a>
<a name="ln1845">        continue;                     // nothing to replace</a>
<a name="ln1846">      }</a>
<a name="ln1847"> </a>
<a name="ln1848">      // n == number of extra chars required</a>
<a name="ln1849">      // If we split a TAB, it may be replaced by several characters.</a>
<a name="ln1850">      // Thus the number of characters may increase!</a>
<a name="ln1851">      // If the range starts in virtual space, count the initial</a>
<a name="ln1852">      // coladd offset as part of &quot;startspaces&quot;</a>
<a name="ln1853">      if (virtual_op &amp;&amp; bd.is_short &amp;&amp; *bd.textstart == NUL) {</a>
<a name="ln1854">        pos_T vpos;</a>
<a name="ln1855"> </a>
<a name="ln1856">        vpos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1857">        getvpos(&amp;vpos, oap-&gt;start_vcol);</a>
<a name="ln1858">        bd.startspaces += vpos.coladd;</a>
<a name="ln1859">        n = bd.startspaces;</a>
<a name="ln1860">      } else {</a>
<a name="ln1861">        // allow for pre spaces</a>
<a name="ln1862">        n = (bd.startspaces ? bd.start_char_vcols - 1 : 0);</a>
<a name="ln1863">      }</a>
<a name="ln1864"> </a>
<a name="ln1865">      // allow for post spp</a>
<a name="ln1866">      n += (bd.endspaces</a>
<a name="ln1867">            &amp;&amp; !bd.is_oneChar</a>
<a name="ln1868">            &amp;&amp; bd.end_char_vcols &gt; 0) ? bd.end_char_vcols - 1 : 0;</a>
<a name="ln1869">      // Figure out how many characters to replace.</a>
<a name="ln1870">      numc = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln1871">      if (bd.is_short &amp;&amp; (!virtual_op || bd.is_MAX)) {</a>
<a name="ln1872">        numc -= (oap-&gt;end_vcol - bd.end_vcol) + 1;</a>
<a name="ln1873">      }</a>
<a name="ln1874"> </a>
<a name="ln1875">      // A double-wide character can be replaced only up to half the</a>
<a name="ln1876">      // times.</a>
<a name="ln1877">      if (utf_char2cells(c) &gt; 1) {</a>
<a name="ln1878">        if ((numc &amp; 1) &amp;&amp; !bd.is_short) {</a>
<a name="ln1879">          bd.endspaces++;</a>
<a name="ln1880">          n++;</a>
<a name="ln1881">        }</a>
<a name="ln1882">        numc = numc / 2;</a>
<a name="ln1883">      }</a>
<a name="ln1884"> </a>
<a name="ln1885">      // Compute bytes needed, move character count to num_chars.</a>
<a name="ln1886">      num_chars = numc;</a>
<a name="ln1887">      numc *= utf_char2len(c);</a>
<a name="ln1888"> </a>
<a name="ln1889">      oldp = (char_u *)get_cursor_line_ptr();</a>
<a name="ln1890">      oldlen = (int)STRLEN(oldp);</a>
<a name="ln1891"> </a>
<a name="ln1892">      size_t newp_size = (size_t)bd.textcol + (size_t)bd.startspaces;</a>
<a name="ln1893">      if (had_ctrl_v_cr || (c != '\r' &amp;&amp; c != '\n')) {</a>
<a name="ln1894">        newp_size += (size_t)numc;</a>
<a name="ln1895">        if (!bd.is_short) {</a>
<a name="ln1896">          newp_size += (size_t)(bd.endspaces + oldlen</a>
<a name="ln1897">                                - bd.textcol - bd.textlen);</a>
<a name="ln1898">        }</a>
<a name="ln1899">      }</a>
<a name="ln1900">      newp = xmallocz(newp_size);</a>
<a name="ln1901">      // copy up to deleted part</a>
<a name="ln1902">      memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln1903">      oldp += bd.textcol + bd.textlen;</a>
<a name="ln1904">      // insert pre-spaces</a>
<a name="ln1905">      memset(newp + bd.textcol, ' ', (size_t)bd.startspaces);</a>
<a name="ln1906">      // insert replacement chars CHECK FOR ALLOCATED SPACE</a>
<a name="ln1907">      // REPLACE_CR_NCHAR/REPLACE_NL_NCHAR is used for entering CR literally.</a>
<a name="ln1908">      size_t after_p_len = 0;</a>
<a name="ln1909">      int col = oldlen - bd.textcol - bd.textlen + 1;</a>
<a name="ln1910">      assert(col &gt;= 0);</a>
<a name="ln1911">      int newrows = 0, newcols = 0;</a>
<a name="ln1912">      if (had_ctrl_v_cr || (c != '\r' &amp;&amp; c != '\n')) {</a>
<a name="ln1913">        // strlen(newp) at this point</a>
<a name="ln1914">        int newp_len = bd.textcol + bd.startspaces;</a>
<a name="ln1915">        while (--num_chars &gt;= 0) {</a>
<a name="ln1916">          newp_len += utf_char2bytes(c, (char *)newp + newp_len);</a>
<a name="ln1917">        }</a>
<a name="ln1918">        if (!bd.is_short) {</a>
<a name="ln1919">          // insert post-spaces</a>
<a name="ln1920">          memset(newp + newp_len, ' ', (size_t)bd.endspaces);</a>
<a name="ln1921">          newp_len += bd.endspaces;</a>
<a name="ln1922">          // copy the part after the changed part</a>
<a name="ln1923">          memmove(newp + newp_len, oldp, (size_t)col);</a>
<a name="ln1924">        }</a>
<a name="ln1925">        newcols = newp_len - bd.textcol;</a>
<a name="ln1926">      } else {</a>
<a name="ln1927">        // Replacing with \r or \n means splitting the line.</a>
<a name="ln1928">        after_p_len = (size_t)col;</a>
<a name="ln1929">        after_p = (char_u *)xmalloc(after_p_len);</a>
<a name="ln1930">        memmove(after_p, oldp, after_p_len);</a>
<a name="ln1931">        newrows = 1;</a>
<a name="ln1932">      }</a>
<a name="ln1933">      // replace the line</a>
<a name="ln1934">      ml_replace(curwin-&gt;w_cursor.lnum, (char *)newp, false);</a>
<a name="ln1935">      curbuf_splice_pending++;</a>
<a name="ln1936">      linenr_T baselnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1937">      if (after_p != NULL) {</a>
<a name="ln1938">        ml_append(curwin-&gt;w_cursor.lnum++, (char *)after_p, (int)after_p_len, false);</a>
<a name="ln1939">        appended_lines_mark(curwin-&gt;w_cursor.lnum, 1L);</a>
<a name="ln1940">        oap-&gt;end.lnum++;</a>
<a name="ln1941">        xfree(after_p);</a>
<a name="ln1942">      }</a>
<a name="ln1943">      curbuf_splice_pending--;</a>
<a name="ln1944">      extmark_splice(curbuf, (int)baselnum - 1, bd.textcol,</a>
<a name="ln1945">                     0, bd.textlen, bd.textlen,</a>
<a name="ln1946">                     newrows, newcols, newrows + newcols, kExtmarkUndo);</a>
<a name="ln1947">    }</a>
<a name="ln1948">  } else {</a>
<a name="ln1949">    // Characterwise or linewise motion replace.</a>
<a name="ln1950">    if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln1951">      oap-&gt;start.col = 0;</a>
<a name="ln1952">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1953">      oap-&gt;end.col = (colnr_T)strlen(ml_get(oap-&gt;end.lnum));</a>
<a name="ln1954">      if (oap-&gt;end.col) {</a>
<a name="ln1955">        oap-&gt;end.col--;</a>
<a name="ln1956">      }</a>
<a name="ln1957">    } else if (!oap-&gt;inclusive) {</a>
<a name="ln1958">      dec(&amp;(oap-&gt;end));</a>
<a name="ln1959">    }</a>
<a name="ln1960"> </a>
<a name="ln1961">    // TODO(bfredl): we could batch all the splicing</a>
<a name="ln1962">    // done on the same line, at least</a>
<a name="ln1963">    while (ltoreq(curwin-&gt;w_cursor, oap-&gt;end)) {</a>
<a name="ln1964">      bool done = false;</a>
<a name="ln1965"> </a>
<a name="ln1966">      n = gchar_cursor();</a>
<a name="ln1967">      if (n != NUL) {</a>
<a name="ln1968">        int new_byte_len = utf_char2len(c);</a>
<a name="ln1969">        int old_byte_len = utfc_ptr2len(get_cursor_pos_ptr());</a>
<a name="ln1970"> </a>
<a name="ln1971">        if (new_byte_len &gt; 1 || old_byte_len &gt; 1) {</a>
<a name="ln1972">          // This is slow, but it handles replacing a single-byte</a>
<a name="ln1973">          // with a multi-byte and the other way around.</a>
<a name="ln1974">          if (curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum) {</a>
<a name="ln1975">            oap-&gt;end.col += new_byte_len - old_byte_len;</a>
<a name="ln1976">          }</a>
<a name="ln1977">          replace_character(c);</a>
<a name="ln1978">          done = true;</a>
<a name="ln1979">        } else {</a>
<a name="ln1980">          if (n == TAB) {</a>
<a name="ln1981">            int end_vcol = 0;</a>
<a name="ln1982"> </a>
<a name="ln1983">            if (curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum) {</a>
<a name="ln1984">              // oap-&gt;end has to be recalculated when</a>
<a name="ln1985">              // the tab breaks</a>
<a name="ln1986">              end_vcol = getviscol2(oap-&gt;end.col,</a>
<a name="ln1987">                                    oap-&gt;end.coladd);</a>
<a name="ln1988">            }</a>
<a name="ln1989">            coladvance_force(getviscol());</a>
<a name="ln1990">            if (curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum) {</a>
<a name="ln1991">              getvpos(&amp;oap-&gt;end, end_vcol);</a>
<a name="ln1992">            }</a>
<a name="ln1993">          }</a>
<a name="ln1994">          // with &quot;coladd&quot; set may move to just after a TAB</a>
<a name="ln1995">          if (gchar_cursor() != NUL) {</a>
<a name="ln1996">            pbyte(curwin-&gt;w_cursor, c);</a>
<a name="ln1997">            done = true;</a>
<a name="ln1998">          }</a>
<a name="ln1999">        }</a>
<a name="ln2000">      }</a>
<a name="ln2001">      if (!done &amp;&amp; virtual_op &amp;&amp; curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum) {</a>
<a name="ln2002">        int virtcols = oap-&gt;end.coladd;</a>
<a name="ln2003"> </a>
<a name="ln2004">        if (curwin-&gt;w_cursor.lnum == oap-&gt;start.lnum</a>
<a name="ln2005">            &amp;&amp; oap-&gt;start.col == oap-&gt;end.col &amp;&amp; oap-&gt;start.coladd) {</a>
<a name="ln2006">          virtcols -= oap-&gt;start.coladd;</a>
<a name="ln2007">        }</a>
<a name="ln2008"> </a>
<a name="ln2009">        // oap-&gt;end has been trimmed so it's effectively inclusive;</a>
<a name="ln2010">        // as a result an extra +1 must be counted so we don't</a>
<a name="ln2011">        // trample the NUL byte.</a>
<a name="ln2012">        coladvance_force(getviscol2(oap-&gt;end.col, oap-&gt;end.coladd) + 1);</a>
<a name="ln2013">        curwin-&gt;w_cursor.col -= (virtcols + 1);</a>
<a name="ln2014">        for (; virtcols &gt;= 0; virtcols--) {</a>
<a name="ln2015">          if (utf_char2len(c) &gt; 1) {</a>
<a name="ln2016">            replace_character(c);</a>
<a name="ln2017">          } else {</a>
<a name="ln2018">            pbyte(curwin-&gt;w_cursor, c);</a>
<a name="ln2019">          }</a>
<a name="ln2020">          if (inc(&amp;curwin-&gt;w_cursor) == -1) {</a>
<a name="ln2021">            break;</a>
<a name="ln2022">          }</a>
<a name="ln2023">        }</a>
<a name="ln2024">      }</a>
<a name="ln2025"> </a>
<a name="ln2026">      // Advance to next character, stop at the end of the file.</a>
<a name="ln2027">      if (inc_cursor() == -1) {</a>
<a name="ln2028">        break;</a>
<a name="ln2029">      }</a>
<a name="ln2030">    }</a>
<a name="ln2031">  }</a>
<a name="ln2032"> </a>
<a name="ln2033">  curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln2034">  check_cursor();</a>
<a name="ln2035">  changed_lines(oap-&gt;start.lnum, oap-&gt;start.col, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln2036"> </a>
<a name="ln2037">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln2038">    // Set &quot;'[&quot; and &quot;']&quot; marks.</a>
<a name="ln2039">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln2040">    curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln2041">  }</a>
<a name="ln2042"> </a>
<a name="ln2043">  return OK;</a>
<a name="ln2044">}</a>
<a name="ln2045"> </a>
<a name="ln2046">/// Handle the (non-standard vi) tilde operator.  Also for &quot;gu&quot;, &quot;gU&quot; and &quot;g?&quot;.</a>
<a name="ln2047">void op_tilde(oparg_T *oap)</a>
<a name="ln2048">{</a>
<a name="ln2049">  pos_T pos;</a>
<a name="ln2050">  struct block_def bd;</a>
<a name="ln2051">  int did_change = false;</a>
<a name="ln2052"> </a>
<a name="ln2053">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln2054">             (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln2055">    return;</a>
<a name="ln2056">  }</a>
<a name="ln2057"> </a>
<a name="ln2058">  pos = oap-&gt;start;</a>
<a name="ln2059">  if (oap-&gt;motion_type == kMTBlockWise) {  // Visual block mode</a>
<a name="ln2060">    for (; pos.lnum &lt;= oap-&gt;end.lnum; pos.lnum++) {</a>
<a name="ln2061">      int one_change;</a>
<a name="ln2062"> </a>
<a name="ln2063">      block_prep(oap, &amp;bd, pos.lnum, false);</a>
<a name="ln2064">      pos.col = bd.textcol;</a>
<a name="ln2065">      one_change = swapchars(oap-&gt;op_type, &amp;pos, bd.textlen);</a>
<a name="ln2066">      did_change |= one_change;</a>
<a name="ln2067">    }</a>
<a name="ln2068">    if (did_change) {</a>
<a name="ln2069">      changed_lines(oap-&gt;start.lnum, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln2070">    }</a>
<a name="ln2071">  } else {  // not block mode</a>
<a name="ln2072">    if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln2073">      oap-&gt;start.col = 0;</a>
<a name="ln2074">      pos.col = 0;</a>
<a name="ln2075">      oap-&gt;end.col = (colnr_T)strlen(ml_get(oap-&gt;end.lnum));</a>
<a name="ln2076">      if (oap-&gt;end.col) {</a>
<a name="ln2077">        oap-&gt;end.col--;</a>
<a name="ln2078">      }</a>
<a name="ln2079">    } else if (!oap-&gt;inclusive) {</a>
<a name="ln2080">      dec(&amp;(oap-&gt;end));</a>
<a name="ln2081">    }</a>
<a name="ln2082"> </a>
<a name="ln2083">    if (pos.lnum == oap-&gt;end.lnum) {</a>
<a name="ln2084">      did_change = swapchars(oap-&gt;op_type, &amp;pos,</a>
<a name="ln2085">                             oap-&gt;end.col - pos.col + 1);</a>
<a name="ln2086">    } else {</a>
<a name="ln2087">      for (;;) {</a>
<a name="ln2088">        did_change |= swapchars(oap-&gt;op_type, &amp;pos,</a>
<a name="ln2089">                                pos.lnum == oap-&gt;end.lnum ? oap-&gt;end.col + 1 :</a>
<a name="ln2090">                                (int)STRLEN(ml_get_pos(&amp;pos)));</a>
<a name="ln2091">        if (ltoreq(oap-&gt;end, pos) || inc(&amp;pos) == -1) {</a>
<a name="ln2092">          break;</a>
<a name="ln2093">        }</a>
<a name="ln2094">      }</a>
<a name="ln2095">    }</a>
<a name="ln2096">    if (did_change) {</a>
<a name="ln2097">      changed_lines(oap-&gt;start.lnum, oap-&gt;start.col, oap-&gt;end.lnum + 1,</a>
<a name="ln2098">                    0L, true);</a>
<a name="ln2099">    }</a>
<a name="ln2100">  }</a>
<a name="ln2101"> </a>
<a name="ln2102">  if (!did_change &amp;&amp; oap-&gt;is_VIsual) {</a>
<a name="ln2103">    // No change: need to remove the Visual selection</a>
<a name="ln2104">    redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln2105">  }</a>
<a name="ln2106"> </a>
<a name="ln2107">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln2108">    // Set '[ and '] marks.</a>
<a name="ln2109">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln2110">    curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln2111">  }</a>
<a name="ln2112"> </a>
<a name="ln2113">  if (oap-&gt;line_count &gt; p_report) {</a>
<a name="ln2114">    smsg(NGETTEXT(&quot;%&quot; PRId64 &quot; line changed&quot;,</a>
<a name="ln2115">                  &quot;%&quot; PRId64 &quot; lines changed&quot;, oap-&gt;line_count),</a>
<a name="ln2116">         (int64_t)oap-&gt;line_count);</a>
<a name="ln2117">  }</a>
<a name="ln2118">}</a>
<a name="ln2119"> </a>
<a name="ln2120">/// Invoke swapchar() on &quot;length&quot; bytes at position &quot;pos&quot;.</a>
<a name="ln2121">///</a>
<a name="ln2122">/// @param pos     is advanced to just after the changed characters.</a>
<a name="ln2123">/// @param length  is rounded up to include the whole last multi-byte character.</a>
<a name="ln2124">/// Also works correctly when the number of bytes changes.</a>
<a name="ln2125">///</a>
<a name="ln2126">/// @return  true if some character was changed.</a>
<a name="ln2127">static int swapchars(int op_type, pos_T *pos, int length)</a>
<a name="ln2128">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2129">{</a>
<a name="ln2130">  int did_change = 0;</a>
<a name="ln2131"> </a>
<a name="ln2132">  for (int todo = length; todo &gt; 0; todo--) {</a>
<a name="ln2133">    const int len = utfc_ptr2len((char *)ml_get_pos(pos));</a>
<a name="ln2134"> </a>
<a name="ln2135">    // we're counting bytes, not characters</a>
<a name="ln2136">    if (len &gt; 0) {</a>
<a name="ln2137">      todo -= len - 1;</a>
<a name="ln2138">    }</a>
<a name="ln2139">    did_change |= swapchar(op_type, pos);</a>
<a name="ln2140">    if (inc(pos) == -1) {      // at end of file</a>
<a name="ln2141">      break;</a>
<a name="ln2142">    }</a>
<a name="ln2143">  }</a>
<a name="ln2144">  return did_change;</a>
<a name="ln2145">}</a>
<a name="ln2146"> </a>
<a name="ln2147">/// @param op_type</a>
<a name="ln2148">///                 == OP_UPPER: make uppercase,</a>
<a name="ln2149">///                 == OP_LOWER: make lowercase,</a>
<a name="ln2150">///                 == OP_ROT13: do rot13 encoding,</a>
<a name="ln2151">///                 else swap case of character at 'pos'</a>
<a name="ln2152">///</a>
<a name="ln2153">/// @return  true when something actually changed.</a>
<a name="ln2154">bool swapchar(int op_type, pos_T *pos)</a>
<a name="ln2155">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln2156">{</a>
<a name="ln2157">  const int c = gchar_pos(pos);</a>
<a name="ln2158"> </a>
<a name="ln2159">  // Only do rot13 encoding for ASCII characters.</a>
<a name="ln2160">  if (c &gt;= 0x80 &amp;&amp; op_type == OP_ROT13) {</a>
<a name="ln2161">    return false;</a>
<a name="ln2162">  }</a>
<a name="ln2163"> </a>
<a name="ln2164">  if (op_type == OP_UPPER &amp;&amp; c == 0xdf) {</a>
<a name="ln2165">    pos_T sp = curwin-&gt;w_cursor;</a>
<a name="ln2166"> </a>
<a name="ln2167">    // Special handling of German sharp s: change to &quot;SS&quot;.</a>
<a name="ln2168">    curwin-&gt;w_cursor = *pos;</a>
<a name="ln2169">    del_char(false);</a>
<a name="ln2170">    ins_char('S');</a>
<a name="ln2171">    ins_char('S');</a>
<a name="ln2172">    curwin-&gt;w_cursor = sp;</a>
<a name="ln2173">    inc(pos);</a>
<a name="ln2174">  }</a>
<a name="ln2175"> </a>
<a name="ln2176">  int nc = c;</a>
<a name="ln2177">  if (mb_islower(c)) {</a>
<a name="ln2178">    if (op_type == OP_ROT13) {</a>
<a name="ln2179">      nc = ROT13(c, 'a');</a>
<a name="ln2180">    } else if (op_type != OP_LOWER) {</a>
<a name="ln2181">      nc = mb_toupper(c);</a>
<a name="ln2182">    }</a>
<a name="ln2183">  } else if (mb_isupper(c)) {</a>
<a name="ln2184">    if (op_type == OP_ROT13) {</a>
<a name="ln2185">      nc = ROT13(c, 'A');</a>
<a name="ln2186">    } else if (op_type != OP_UPPER) {</a>
<a name="ln2187">      nc = mb_tolower(c);</a>
<a name="ln2188">    }</a>
<a name="ln2189">  }</a>
<a name="ln2190">  if (nc != c) {</a>
<a name="ln2191">    if (c &gt;= 0x80 || nc &gt;= 0x80) {</a>
<a name="ln2192">      pos_T sp = curwin-&gt;w_cursor;</a>
<a name="ln2193"> </a>
<a name="ln2194">      curwin-&gt;w_cursor = *pos;</a>
<a name="ln2195">      // don't use del_char(), it also removes composing chars</a>
<a name="ln2196">      del_bytes(utf_ptr2len(get_cursor_pos_ptr()), false, false);</a>
<a name="ln2197">      ins_char(nc);</a>
<a name="ln2198">      curwin-&gt;w_cursor = sp;</a>
<a name="ln2199">    } else {</a>
<a name="ln2200">      pbyte(*pos, nc);</a>
<a name="ln2201">    }</a>
<a name="ln2202">    return true;</a>
<a name="ln2203">  }</a>
<a name="ln2204">  return false;</a>
<a name="ln2205">}</a>
<a name="ln2206"> </a>
<a name="ln2207">/// Insert and append operators for Visual mode.</a>
<a name="ln2208">void op_insert(oparg_T *oap, long count1)</a>
<a name="ln2209">{</a>
<a name="ln2210">  long ins_len, pre_textlen = 0;</a>
<a name="ln2211">  char *firstline, *ins_text;</a>
<a name="ln2212">  colnr_T ind_pre_col = 0, ind_post_col;</a>
<a name="ln2213">  int ind_pre_vcol = 0, ind_post_vcol = 0;</a>
<a name="ln2214">  struct block_def bd;</a>
<a name="ln2215">  int i;</a>
<a name="ln2216">  pos_T t1;</a>
<a name="ln2217"> </a>
<a name="ln2218">  // edit() changes this - record it for OP_APPEND</a>
<a name="ln2219">  bd.is_MAX = (curwin-&gt;w_curswant == MAXCOL);</a>
<a name="ln2220"> </a>
<a name="ln2221">  // vis block is still marked. Get rid of it now.</a>
<a name="ln2222">  curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln2223">  redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln2224">  update_screen();</a>
<a name="ln2225"> </a>
<a name="ln2226">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln2227">    // When 'virtualedit' is used, need to insert the extra spaces before</a>
<a name="ln2228">    // doing block_prep().  When only &quot;block&quot; is used, virtual edit is</a>
<a name="ln2229">    // already disabled, but still need it when calling</a>
<a name="ln2230">    // coladvance_force().</a>
<a name="ln2231">    // coladvance_force() uses get_ve_flags() to get the 'virtualedit'</a>
<a name="ln2232">    // state for the current window.  To override that state, we need to</a>
<a name="ln2233">    // set the window-local value of ve_flags rather than the global value.</a>
<a name="ln2234">    if (curwin-&gt;w_cursor.coladd &gt; 0) {</a>
<a name="ln2235">      unsigned old_ve_flags = curwin-&gt;w_ve_flags;</a>
<a name="ln2236"> </a>
<a name="ln2237">      if (u_save_cursor() == FAIL) {</a>
<a name="ln2238">        return;</a>
<a name="ln2239">      }</a>
<a name="ln2240">      curwin-&gt;w_ve_flags = VE_ALL;</a>
<a name="ln2241">      coladvance_force(oap-&gt;op_type == OP_APPEND</a>
<a name="ln2242">                       ? oap-&gt;end_vcol + 1 : getviscol());</a>
<a name="ln2243">      if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2244">        curwin-&gt;w_cursor.col--;</a>
<a name="ln2245">      }</a>
<a name="ln2246">      curwin-&gt;w_ve_flags = old_ve_flags;</a>
<a name="ln2247">    }</a>
<a name="ln2248">    // Get the info about the block before entering the text</a>
<a name="ln2249">    block_prep(oap, &amp;bd, oap-&gt;start.lnum, true);</a>
<a name="ln2250">    // Get indent information</a>
<a name="ln2251">    ind_pre_col = (colnr_T)getwhitecols_curline();</a>
<a name="ln2252">    ind_pre_vcol = get_indent();</a>
<a name="ln2253">    firstline = ml_get(oap-&gt;start.lnum) + bd.textcol;</a>
<a name="ln2254"> </a>
<a name="ln2255">    if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2256">      firstline += bd.textlen;</a>
<a name="ln2257">    }</a>
<a name="ln2258">    pre_textlen = (long)strlen(firstline);</a>
<a name="ln2259">  }</a>
<a name="ln2260"> </a>
<a name="ln2261">  if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2262">    if (oap-&gt;motion_type == kMTBlockWise</a>
<a name="ln2263">        &amp;&amp; curwin-&gt;w_cursor.coladd == 0) {</a>
<a name="ln2264">      // Move the cursor to the character right of the block.</a>
<a name="ln2265">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln2266">      while (*get_cursor_pos_ptr() != NUL</a>
<a name="ln2267">             &amp;&amp; (curwin-&gt;w_cursor.col &lt; bd.textcol + bd.textlen)) {</a>
<a name="ln2268">        curwin-&gt;w_cursor.col++;</a>
<a name="ln2269">      }</a>
<a name="ln2270">      if (bd.is_short &amp;&amp; !bd.is_MAX) {</a>
<a name="ln2271">        // First line was too short, make it longer and adjust the</a>
<a name="ln2272">        // values in &quot;bd&quot;.</a>
<a name="ln2273">        if (u_save_cursor() == FAIL) {</a>
<a name="ln2274">          return;</a>
<a name="ln2275">        }</a>
<a name="ln2276">        for (i = 0; i &lt; bd.endspaces; i++) {</a>
<a name="ln2277">          ins_char(' ');</a>
<a name="ln2278">        }</a>
<a name="ln2279">        bd.textlen += bd.endspaces;</a>
<a name="ln2280">      }</a>
<a name="ln2281">    } else {</a>
<a name="ln2282">      curwin-&gt;w_cursor = oap-&gt;end;</a>
<a name="ln2283">      check_cursor_col();</a>
<a name="ln2284"> </a>
<a name="ln2285">      // Works just like an 'i'nsert on the next character.</a>
<a name="ln2286">      if (!LINEEMPTY(curwin-&gt;w_cursor.lnum)</a>
<a name="ln2287">          &amp;&amp; oap-&gt;start_vcol != oap-&gt;end_vcol) {</a>
<a name="ln2288">        inc_cursor();</a>
<a name="ln2289">      }</a>
<a name="ln2290">    }</a>
<a name="ln2291">  }</a>
<a name="ln2292"> </a>
<a name="ln2293">  t1 = oap-&gt;start;</a>
<a name="ln2294">  const pos_T start_insert = curwin-&gt;w_cursor;</a>
<a name="ln2295">  (void)edit(NUL, false, (linenr_T)count1);</a>
<a name="ln2296"> </a>
<a name="ln2297">  // When a tab was inserted, and the characters in front of the tab</a>
<a name="ln2298">  // have been converted to a tab as well, the column of the cursor</a>
<a name="ln2299">  // might have actually been reduced, so need to adjust here.</a>
<a name="ln2300">  if (t1.lnum == curbuf-&gt;b_op_start_orig.lnum</a>
<a name="ln2301">      &amp;&amp; lt(curbuf-&gt;b_op_start_orig, t1)) {</a>
<a name="ln2302">    oap-&gt;start = curbuf-&gt;b_op_start_orig;</a>
<a name="ln2303">  }</a>
<a name="ln2304"> </a>
<a name="ln2305">  // If user has moved off this line, we don't know what to do, so do</a>
<a name="ln2306">  // nothing.</a>
<a name="ln2307">  // Also don't repeat the insert when Insert mode ended with CTRL-C.</a>
<a name="ln2308">  if (curwin-&gt;w_cursor.lnum != oap-&gt;start.lnum || got_int) {</a>
<a name="ln2309">    return;</a>
<a name="ln2310">  }</a>
<a name="ln2311"> </a>
<a name="ln2312">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln2313">    struct block_def bd2;</a>
<a name="ln2314">    bool did_indent = false;</a>
<a name="ln2315"> </a>
<a name="ln2316">    // if indent kicked in, the firstline might have changed</a>
<a name="ln2317">    // but only do that, if the indent actually increased</a>
<a name="ln2318">    ind_post_col = (colnr_T)getwhitecols_curline();</a>
<a name="ln2319">    if (curbuf-&gt;b_op_start.col &gt; ind_pre_col &amp;&amp; ind_post_col &gt; ind_pre_col) {</a>
<a name="ln2320">      bd.textcol += ind_post_col - ind_pre_col;</a>
<a name="ln2321">      ind_post_vcol = get_indent();</a>
<a name="ln2322">      bd.start_vcol += ind_post_vcol - ind_pre_vcol;</a>
<a name="ln2323">      did_indent = true;</a>
<a name="ln2324">    }</a>
<a name="ln2325"> </a>
<a name="ln2326">    // The user may have moved the cursor before inserting something, try</a>
<a name="ln2327">    // to adjust the block for that.  But only do it, if the difference</a>
<a name="ln2328">    // does not come from indent kicking in.</a>
<a name="ln2329">    if (oap-&gt;start.lnum == curbuf-&gt;b_op_start_orig.lnum &amp;&amp; !bd.is_MAX &amp;&amp; !did_indent) {</a>
<a name="ln2330">      const int t = getviscol2(curbuf-&gt;b_op_start_orig.col, curbuf-&gt;b_op_start_orig.coladd);</a>
<a name="ln2331"> </a>
<a name="ln2332">      if (oap-&gt;op_type == OP_INSERT</a>
<a name="ln2333">          &amp;&amp; oap-&gt;start.col + oap-&gt;start.coladd</a>
<a name="ln2334">          != curbuf-&gt;b_op_start_orig.col + curbuf-&gt;b_op_start_orig.coladd) {</a>
<a name="ln2335">        oap-&gt;start.col = curbuf-&gt;b_op_start_orig.col;</a>
<a name="ln2336">        pre_textlen -= t - oap-&gt;start_vcol;</a>
<a name="ln2337">        oap-&gt;start_vcol = t;</a>
<a name="ln2338">      } else if (oap-&gt;op_type == OP_APPEND</a>
<a name="ln2339">                 &amp;&amp; oap-&gt;start.col + oap-&gt;start.coladd</a>
<a name="ln2340">                 &gt;= curbuf-&gt;b_op_start_orig.col + curbuf-&gt;b_op_start_orig.coladd) {</a>
<a name="ln2341">        oap-&gt;start.col = curbuf-&gt;b_op_start_orig.col;</a>
<a name="ln2342">        // reset pre_textlen to the value of OP_INSERT</a>
<a name="ln2343">        pre_textlen += bd.textlen;</a>
<a name="ln2344">        pre_textlen -= t - oap-&gt;start_vcol;</a>
<a name="ln2345">        oap-&gt;start_vcol = t;</a>
<a name="ln2346">        oap-&gt;op_type = OP_INSERT;</a>
<a name="ln2347">      }</a>
<a name="ln2348">    }</a>
<a name="ln2349"> </a>
<a name="ln2350">    // Spaces and tabs in the indent may have changed to other spaces and</a>
<a name="ln2351">    // tabs.  Get the starting column again and correct the length.</a>
<a name="ln2352">    // Don't do this when &quot;$&quot; used, end-of-line will have changed.</a>
<a name="ln2353">    //</a>
<a name="ln2354">    // if indent was added and the inserted text was after the indent,</a>
<a name="ln2355">    // correct the selection for the new indent.</a>
<a name="ln2356">    if (did_indent &amp;&amp; bd.textcol - ind_post_col &gt; 0) {</a>
<a name="ln2357">      oap-&gt;start.col += ind_post_col - ind_pre_col;</a>
<a name="ln2358">      oap-&gt;start_vcol += ind_post_vcol - ind_pre_vcol;</a>
<a name="ln2359">      oap-&gt;end.col += ind_post_col - ind_pre_col;</a>
<a name="ln2360">      oap-&gt;end_vcol += ind_post_vcol - ind_pre_vcol;</a>
<a name="ln2361">    }</a>
<a name="ln2362">    block_prep(oap, &amp;bd2, oap-&gt;start.lnum, true);</a>
<a name="ln2363">    if (did_indent &amp;&amp; bd.textcol - ind_post_col &gt; 0) {</a>
<a name="ln2364">      // undo for where &quot;oap&quot; is used below</a>
<a name="ln2365">      oap-&gt;start.col -= ind_post_col - ind_pre_col;</a>
<a name="ln2366">      oap-&gt;start_vcol -= ind_post_vcol - ind_pre_vcol;</a>
<a name="ln2367">      oap-&gt;end.col -= ind_post_col - ind_pre_col;</a>
<a name="ln2368">      oap-&gt;end_vcol -= ind_post_vcol - ind_pre_vcol;</a>
<a name="ln2369">    }</a>
<a name="ln2370">    if (!bd.is_MAX || bd2.textlen &lt; bd.textlen) {</a>
<a name="ln2371">      if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2372">        pre_textlen += bd2.textlen - bd.textlen;</a>
<a name="ln2373">        if (bd2.endspaces) {</a>
<a name="ln2374">          bd2.textlen--;</a>
<a name="ln2375">        }</a>
<a name="ln2376">      }</a>
<a name="ln2377">      bd.textcol = bd2.textcol;</a>
<a name="ln2378">      bd.textlen = bd2.textlen;</a>
<a name="ln2379">    }</a>
<a name="ln2380"> </a>
<a name="ln2381">    // Subsequent calls to ml_get() flush the firstline data - take a</a>
<a name="ln2382">    // copy of the required string.</a>
<a name="ln2383">    firstline = ml_get(oap-&gt;start.lnum);</a>
<a name="ln2384">    const size_t len = strlen(firstline);</a>
<a name="ln2385">    colnr_T add = bd.textcol;</a>
<a name="ln2386">    colnr_T offset = 0;  // offset when cursor was moved in insert mode</a>
<a name="ln2387">    if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2388">      add += bd.textlen;</a>
<a name="ln2389">      // account for pressing cursor in insert mode when '$' was used</a>
<a name="ln2390">      if (bd.is_MAX &amp;&amp; start_insert.lnum == Insstart.lnum &amp;&amp; start_insert.col &gt; Insstart.col) {</a>
<a name="ln2391">        offset = start_insert.col - Insstart.col;</a>
<a name="ln2392">        add -= offset;</a>
<a name="ln2393">        if (oap-&gt;end_vcol &gt; offset) {</a>
<a name="ln2394">          oap-&gt;end_vcol -= offset + 1;</a>
<a name="ln2395">        } else {</a>
<a name="ln2396">          // moved outside of the visual block, what to do?</a>
<a name="ln2397">          return;</a>
<a name="ln2398">        }</a>
<a name="ln2399">      }</a>
<a name="ln2400">    }</a>
<a name="ln2401">    if ((size_t)add &gt; len) {</a>
<a name="ln2402">      firstline += len;  // short line, point to the NUL</a>
<a name="ln2403">    } else {</a>
<a name="ln2404">      firstline += add;</a>
<a name="ln2405">    }</a>
<a name="ln2406">    ins_len = (long)strlen(firstline) - pre_textlen - offset;</a>
<a name="ln2407">    if (pre_textlen &gt;= 0 &amp;&amp; ins_len &gt; 0) {</a>
<a name="ln2408">      ins_text = xstrnsave(firstline, (size_t)ins_len);</a>
<a name="ln2409">      // block handled here</a>
<a name="ln2410">      if (u_save(oap-&gt;start.lnum, (linenr_T)(oap-&gt;end.lnum + 1)) == OK) {</a>
<a name="ln2411">        block_insert(oap, (char_u *)ins_text, (oap-&gt;op_type == OP_INSERT), &amp;bd);</a>
<a name="ln2412">      }</a>
<a name="ln2413"> </a>
<a name="ln2414">      curwin-&gt;w_cursor.col = oap-&gt;start.col;</a>
<a name="ln2415">      check_cursor();</a>
<a name="ln2416">      xfree(ins_text);</a>
<a name="ln2417">    }</a>
<a name="ln2418">  }</a>
<a name="ln2419">}</a>
<a name="ln2420"> </a>
<a name="ln2421">/// handle a change operation</a>
<a name="ln2422">///</a>
<a name="ln2423">/// @return  true if edit() returns because of a CTRL-O command</a>
<a name="ln2424">int op_change(oparg_T *oap)</a>
<a name="ln2425">{</a>
<a name="ln2426">  colnr_T l;</a>
<a name="ln2427">  int retval;</a>
<a name="ln2428">  long offset;</a>
<a name="ln2429">  linenr_T linenr;</a>
<a name="ln2430">  long ins_len;</a>
<a name="ln2431">  long pre_textlen = 0;</a>
<a name="ln2432">  long pre_indent = 0;</a>
<a name="ln2433">  char_u *newp;</a>
<a name="ln2434">  char_u *firstline;</a>
<a name="ln2435">  char_u *ins_text;</a>
<a name="ln2436">  char_u *oldp;</a>
<a name="ln2437">  struct block_def bd;</a>
<a name="ln2438"> </a>
<a name="ln2439">  l = oap-&gt;start.col;</a>
<a name="ln2440">  if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln2441">    l = 0;</a>
<a name="ln2442">    can_si = may_do_si();  // Like opening a new line, do smart indent</a>
<a name="ln2443">  }</a>
<a name="ln2444"> </a>
<a name="ln2445">  // First delete the text in the region.  In an empty buffer only need to</a>
<a name="ln2446">  // save for undo</a>
<a name="ln2447">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln2448">    if (u_save_cursor() == FAIL) {</a>
<a name="ln2449">      return false;</a>
<a name="ln2450">    }</a>
<a name="ln2451">  } else if (op_delete(oap) == FAIL) {</a>
<a name="ln2452">    return false;</a>
<a name="ln2453">  }</a>
<a name="ln2454"> </a>
<a name="ln2455">  if ((l &gt; curwin-&gt;w_cursor.col) &amp;&amp; !LINEEMPTY(curwin-&gt;w_cursor.lnum)</a>
<a name="ln2456">      &amp;&amp; !virtual_op) {</a>
<a name="ln2457">    inc_cursor();</a>
<a name="ln2458">  }</a>
<a name="ln2459"> </a>
<a name="ln2460">  // check for still on same line (&lt;CR&gt; in inserted text meaningless)</a>
<a name="ln2461">  // skip blank lines too</a>
<a name="ln2462">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln2463">    // Add spaces before getting the current line length.</a>
<a name="ln2464">    if (virtual_op &amp;&amp; (curwin-&gt;w_cursor.coladd &gt; 0</a>
<a name="ln2465">                       || gchar_cursor() == NUL)) {</a>
<a name="ln2466">      coladvance_force(getviscol());</a>
<a name="ln2467">    }</a>
<a name="ln2468">    firstline = (char_u *)ml_get(oap-&gt;start.lnum);</a>
<a name="ln2469">    pre_textlen = (long)STRLEN(firstline);</a>
<a name="ln2470">    pre_indent = (long)getwhitecols((char *)firstline);</a>
<a name="ln2471">    bd.textcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2472">  }</a>
<a name="ln2473"> </a>
<a name="ln2474">  if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln2475">    fix_indent();</a>
<a name="ln2476">  }</a>
<a name="ln2477"> </a>
<a name="ln2478">  retval = edit(NUL, false, (linenr_T)1);</a>
<a name="ln2479"> </a>
<a name="ln2480">  // In Visual block mode, handle copying the new text to all lines of the</a>
<a name="ln2481">  // block.</a>
<a name="ln2482">  // Don't repeat the insert when Insert mode ended with CTRL-C.</a>
<a name="ln2483">  if (oap-&gt;motion_type == kMTBlockWise</a>
<a name="ln2484">      &amp;&amp; oap-&gt;start.lnum != oap-&gt;end.lnum &amp;&amp; !got_int) {</a>
<a name="ln2485">    // Auto-indenting may have changed the indent.  If the cursor was past</a>
<a name="ln2486">    // the indent, exclude that indent change from the inserted text.</a>
<a name="ln2487">    firstline = (char_u *)ml_get(oap-&gt;start.lnum);</a>
<a name="ln2488">    if (bd.textcol &gt; (colnr_T)pre_indent) {</a>
<a name="ln2489">      long new_indent = (long)getwhitecols((char *)firstline);</a>
<a name="ln2490"> </a>
<a name="ln2491">      pre_textlen += new_indent - pre_indent;</a>
<a name="ln2492">      bd.textcol += (colnr_T)(new_indent - pre_indent);</a>
<a name="ln2493">    }</a>
<a name="ln2494"> </a>
<a name="ln2495">    ins_len = (long)STRLEN(firstline) - pre_textlen;</a>
<a name="ln2496">    if (ins_len &gt; 0) {</a>
<a name="ln2497">      // Subsequent calls to ml_get() flush the firstline data - take a</a>
<a name="ln2498">      // copy of the inserted text.</a>
<a name="ln2499">      ins_text = (char_u *)xmalloc((size_t)(ins_len + 1));</a>
<a name="ln2500">      STRLCPY(ins_text, firstline + bd.textcol, ins_len + 1);</a>
<a name="ln2501">      for (linenr = oap-&gt;start.lnum + 1; linenr &lt;= oap-&gt;end.lnum;</a>
<a name="ln2502">           linenr++) {</a>
<a name="ln2503">        block_prep(oap, &amp;bd, linenr, true);</a>
<a name="ln2504">        if (!bd.is_short || virtual_op) {</a>
<a name="ln2505">          pos_T vpos;</a>
<a name="ln2506"> </a>
<a name="ln2507">          // If the block starts in virtual space, count the</a>
<a name="ln2508">          // initial coladd offset as part of &quot;startspaces&quot;</a>
<a name="ln2509">          if (bd.is_short) {</a>
<a name="ln2510">            vpos.lnum = linenr;</a>
<a name="ln2511">            (void)getvpos(&amp;vpos, oap-&gt;start_vcol);</a>
<a name="ln2512">          } else {</a>
<a name="ln2513">            vpos.coladd = 0;</a>
<a name="ln2514">          }</a>
<a name="ln2515">          oldp = (char_u *)ml_get(linenr);</a>
<a name="ln2516">          newp = xmalloc(STRLEN(oldp) + (size_t)vpos.coladd</a>
<a name="ln2517">                         + (size_t)ins_len + 1);</a>
<a name="ln2518">          // copy up to block start</a>
<a name="ln2519">          memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln2520">          offset = bd.textcol;</a>
<a name="ln2521">          memset(newp + offset, ' ', (size_t)vpos.coladd);</a>
<a name="ln2522">          offset += vpos.coladd;</a>
<a name="ln2523">          memmove(newp + offset, ins_text, (size_t)ins_len);</a>
<a name="ln2524">          offset += ins_len;</a>
<a name="ln2525">          oldp += bd.textcol;</a>
<a name="ln2526">          STRMOVE(newp + offset, oldp);</a>
<a name="ln2527">          ml_replace(linenr, (char *)newp, false);</a>
<a name="ln2528">          extmark_splice_cols(curbuf, (int)linenr - 1, bd.textcol,</a>
<a name="ln2529">                              0, vpos.coladd + (int)ins_len, kExtmarkUndo);</a>
<a name="ln2530">        }</a>
<a name="ln2531">      }</a>
<a name="ln2532">      check_cursor();</a>
<a name="ln2533">      changed_lines(oap-&gt;start.lnum + 1, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln2534">      xfree(ins_text);</a>
<a name="ln2535">    }</a>
<a name="ln2536">  }</a>
<a name="ln2537">  auto_format(false, true);</a>
<a name="ln2538"> </a>
<a name="ln2539">  return retval;</a>
<a name="ln2540">}</a>
<a name="ln2541"> </a>
<a name="ln2542">#if defined(EXITFREE)</a>
<a name="ln2543">void clear_registers(void)</a>
<a name="ln2544">{</a>
<a name="ln2545">  int i;</a>
<a name="ln2546"> </a>
<a name="ln2547">  for (i = 0; i &lt; NUM_REGISTERS; i++) {</a>
<a name="ln2548">    free_register(&amp;y_regs[i]);</a>
<a name="ln2549">  }</a>
<a name="ln2550">}</a>
<a name="ln2551"> </a>
<a name="ln2552">#endif</a>
<a name="ln2553"> </a>
<a name="ln2554">/// Free contents of yankreg `reg`.</a>
<a name="ln2555">/// Called for normal freeing and in case of error.</a>
<a name="ln2556">///</a>
<a name="ln2557">/// @param reg  must not be NULL (but `reg-&gt;y_array` might be)</a>
<a name="ln2558">void free_register(yankreg_T *reg)</a>
<a name="ln2559">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2560">{</a>
<a name="ln2561">  set_yreg_additional_data(reg, NULL);</a>
<a name="ln2562">  if (reg-&gt;y_array != NULL) {</a>
<a name="ln2563">    for (size_t i = reg-&gt;y_size; i-- &gt; 0;) {  // from y_size - 1 to 0 included</a>
<a name="ln2564">      xfree(reg-&gt;y_array[i]);</a>
<a name="ln2565">    }</a>
<a name="ln2566">    XFREE_CLEAR(reg-&gt;y_array);</a>
<a name="ln2567">  }</a>
<a name="ln2568">}</a>
<a name="ln2569"> </a>
<a name="ln2570">/// Yanks the text between &quot;oap-&gt;start&quot; and &quot;oap-&gt;end&quot; into a yank register.</a>
<a name="ln2571">/// If we are to append (uppercase register), we first yank into a new yank</a>
<a name="ln2572">/// register and then concatenate the old and the new one.</a>
<a name="ln2573">/// Do not call this from a delete operation. Use op_yank_reg() instead.</a>
<a name="ln2574">///</a>
<a name="ln2575">/// @param oap operator arguments</a>
<a name="ln2576">/// @param message show message when more than `&amp;report` lines are yanked.</a>
<a name="ln2577">/// @returns whether the operation register was writable.</a>
<a name="ln2578">bool op_yank(oparg_T *oap, bool message)</a>
<a name="ln2579">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2580">{</a>
<a name="ln2581">  // check for read-only register</a>
<a name="ln2582">  if (oap-&gt;regname != 0 &amp;&amp; !valid_yank_reg(oap-&gt;regname, true)) {</a>
<a name="ln2583">    beep_flush();</a>
<a name="ln2584">    return false;</a>
<a name="ln2585">  }</a>
<a name="ln2586">  if (oap-&gt;regname == '_') {</a>
<a name="ln2587">    return true;  // black hole: nothing to do</a>
<a name="ln2588">  }</a>
<a name="ln2589"> </a>
<a name="ln2590">  yankreg_T *reg = get_yank_register(oap-&gt;regname, YREG_YANK);</a>
<a name="ln2591">  op_yank_reg(oap, message, reg, is_append_register(oap-&gt;regname));</a>
<a name="ln2592">  set_clipboard(oap-&gt;regname, reg);</a>
<a name="ln2593">  do_autocmd_textyankpost(oap, reg);</a>
<a name="ln2594"> </a>
<a name="ln2595">  return true;</a>
<a name="ln2596">}</a>
<a name="ln2597"> </a>
<a name="ln2598">static void op_yank_reg(oparg_T *oap, bool message, yankreg_T *reg, bool append)</a>
<a name="ln2599">{</a>
<a name="ln2600">  yankreg_T newreg;  // new yank register when appending</a>
<a name="ln2601">  char **new_ptr;</a>
<a name="ln2602">  linenr_T lnum;     // current line number</a>
<a name="ln2603">  size_t j;</a>
<a name="ln2604">  MotionType yank_type = oap-&gt;motion_type;</a>
<a name="ln2605">  size_t yanklines = (size_t)oap-&gt;line_count;</a>
<a name="ln2606">  linenr_T yankendlnum = oap-&gt;end.lnum;</a>
<a name="ln2607">  char_u *p;</a>
<a name="ln2608">  char_u *pnew;</a>
<a name="ln2609">  struct block_def bd;</a>
<a name="ln2610"> </a>
<a name="ln2611">  yankreg_T *curr = reg;  // copy of current register</a>
<a name="ln2612">  // append to existing contents</a>
<a name="ln2613">  if (append &amp;&amp; reg-&gt;y_array != NULL) {</a>
<a name="ln2614">    reg = &amp;newreg;</a>
<a name="ln2615">  } else {</a>
<a name="ln2616">    free_register(reg);  // free previously yanked lines</a>
<a name="ln2617">  }</a>
<a name="ln2618"> </a>
<a name="ln2619">  // If the cursor was in column 1 before and after the movement, and the</a>
<a name="ln2620">  // operator is not inclusive, the yank is always linewise.</a>
<a name="ln2621">  if (oap-&gt;motion_type == kMTCharWise</a>
<a name="ln2622">      &amp;&amp; oap-&gt;start.col == 0</a>
<a name="ln2623">      &amp;&amp; !oap-&gt;inclusive</a>
<a name="ln2624">      &amp;&amp; (!oap-&gt;is_VIsual || *p_sel == 'o')</a>
<a name="ln2625">      &amp;&amp; oap-&gt;end.col == 0</a>
<a name="ln2626">      &amp;&amp; yanklines &gt; 1) {</a>
<a name="ln2627">    yank_type = kMTLineWise;</a>
<a name="ln2628">    yankendlnum--;</a>
<a name="ln2629">    yanklines--;</a>
<a name="ln2630">  }</a>
<a name="ln2631"> </a>
<a name="ln2632">  reg-&gt;y_size = yanklines;</a>
<a name="ln2633">  reg-&gt;y_type = yank_type;  // set the yank register type</a>
<a name="ln2634">  reg-&gt;y_width = 0;</a>
<a name="ln2635">  reg-&gt;y_array = xcalloc(yanklines, sizeof(char *));</a>
<a name="ln2636">  reg-&gt;additional_data = NULL;</a>
<a name="ln2637">  reg-&gt;timestamp = os_time();</a>
<a name="ln2638"> </a>
<a name="ln2639">  size_t y_idx = 0;  // index in y_array[]</a>
<a name="ln2640">  lnum = oap-&gt;start.lnum;</a>
<a name="ln2641"> </a>
<a name="ln2642">  if (yank_type == kMTBlockWise) {</a>
<a name="ln2643">    // Visual block mode</a>
<a name="ln2644">    reg-&gt;y_width = oap-&gt;end_vcol - oap-&gt;start_vcol;</a>
<a name="ln2645"> </a>
<a name="ln2646">    if (curwin-&gt;w_curswant == MAXCOL &amp;&amp; reg-&gt;y_width &gt; 0) {</a>
<a name="ln2647">      reg-&gt;y_width--;</a>
<a name="ln2648">    }</a>
<a name="ln2649">  }</a>
<a name="ln2650"> </a>
<a name="ln2651">  for (; lnum &lt;= yankendlnum; lnum++, y_idx++) {</a>
<a name="ln2652">    switch (reg-&gt;y_type) {</a>
<a name="ln2653">    case kMTBlockWise:</a>
<a name="ln2654">      block_prep(oap, &amp;bd, lnum, false);</a>
<a name="ln2655">      yank_copy_line(reg, &amp;bd, y_idx, oap-&gt;excl_tr_ws);</a>
<a name="ln2656">      break;</a>
<a name="ln2657"> </a>
<a name="ln2658">    case kMTLineWise:</a>
<a name="ln2659">      reg-&gt;y_array[y_idx] = xstrdup(ml_get(lnum));</a>
<a name="ln2660">      break;</a>
<a name="ln2661"> </a>
<a name="ln2662">    case kMTCharWise: {</a>
<a name="ln2663">      colnr_T startcol = 0, endcol = MAXCOL;</a>
<a name="ln2664">      int is_oneChar = false;</a>
<a name="ln2665">      colnr_T cs, ce;</a>
<a name="ln2666">      p = (char_u *)ml_get(lnum);</a>
<a name="ln2667">      bd.startspaces = 0;</a>
<a name="ln2668">      bd.endspaces = 0;</a>
<a name="ln2669"> </a>
<a name="ln2670">      if (lnum == oap-&gt;start.lnum) {</a>
<a name="ln2671">        startcol = oap-&gt;start.col;</a>
<a name="ln2672">        if (virtual_op) {</a>
<a name="ln2673">          getvcol(curwin, &amp;oap-&gt;start, &amp;cs, NULL, &amp;ce);</a>
<a name="ln2674">          if (ce != cs &amp;&amp; oap-&gt;start.coladd &gt; 0) {</a>
<a name="ln2675">            // Part of a tab selected -- but don't double-count it.</a>
<a name="ln2676">            bd.startspaces = (ce - cs + 1)</a>
<a name="ln2677">                             - oap-&gt;start.coladd;</a>
<a name="ln2678">            startcol++;</a>
<a name="ln2679">          }</a>
<a name="ln2680">        }</a>
<a name="ln2681">      }</a>
<a name="ln2682"> </a>
<a name="ln2683">      if (lnum == oap-&gt;end.lnum) {</a>
<a name="ln2684">        endcol = oap-&gt;end.col;</a>
<a name="ln2685">        if (virtual_op) {</a>
<a name="ln2686">          getvcol(curwin, &amp;oap-&gt;end, &amp;cs, NULL, &amp;ce);</a>
<a name="ln2687">          if (p[endcol] == NUL || (cs + oap-&gt;end.coladd &lt; ce</a>
<a name="ln2688">                                   // Don't add space for double-wide</a>
<a name="ln2689">                                   // char; endcol will be on last byte</a>
<a name="ln2690">                                   // of multi-byte char.</a>
<a name="ln2691">                                   &amp;&amp; utf_head_off((char *)p, (char *)p + endcol) == 0)) {</a>
<a name="ln2692">            if (oap-&gt;start.lnum == oap-&gt;end.lnum</a>
<a name="ln2693">                &amp;&amp; oap-&gt;start.col == oap-&gt;end.col) {</a>
<a name="ln2694">              // Special case: inside a single char</a>
<a name="ln2695">              is_oneChar = true;</a>
<a name="ln2696">              bd.startspaces = oap-&gt;end.coladd</a>
<a name="ln2697">                               - oap-&gt;start.coladd + oap-&gt;inclusive;</a>
<a name="ln2698">              endcol = startcol;</a>
<a name="ln2699">            } else {</a>
<a name="ln2700">              bd.endspaces = oap-&gt;end.coladd</a>
<a name="ln2701">                             + oap-&gt;inclusive;</a>
<a name="ln2702">              endcol -= oap-&gt;inclusive;</a>
<a name="ln2703">            }</a>
<a name="ln2704">          }</a>
<a name="ln2705">        }</a>
<a name="ln2706">      }</a>
<a name="ln2707">      if (endcol == MAXCOL) {</a>
<a name="ln2708">        endcol = (colnr_T)STRLEN(p);</a>
<a name="ln2709">      }</a>
<a name="ln2710">      if (startcol &gt; endcol</a>
<a name="ln2711">          || is_oneChar) {</a>
<a name="ln2712">        bd.textlen = 0;</a>
<a name="ln2713">      } else {</a>
<a name="ln2714">        bd.textlen = endcol - startcol + oap-&gt;inclusive;</a>
<a name="ln2715">      }</a>
<a name="ln2716">      bd.textstart = p + startcol;</a>
<a name="ln2717">      yank_copy_line(reg, &amp;bd, y_idx, false);</a>
<a name="ln2718">      break;</a>
<a name="ln2719">    }</a>
<a name="ln2720">    // NOTREACHED</a>
<a name="ln2721">    case kMTUnknown:</a>
<a name="ln2722">      abort();</a>
<a name="ln2723">    }</a>
<a name="ln2724">  }</a>
<a name="ln2725"> </a>
<a name="ln2726">  if (curr != reg) {      // append the new block to the old block</a>
<a name="ln2727">    new_ptr = xmalloc(sizeof(char_u *) * (curr-&gt;y_size + reg-&gt;y_size));</a>
<a name="ln2728">    for (j = 0; j &lt; curr-&gt;y_size; j++) {</a>
<a name="ln2729">      new_ptr[j] = curr-&gt;y_array[j];</a>
<a name="ln2730">    }</a>
<a name="ln2731">    xfree(curr-&gt;y_array);</a>
<a name="ln2732">    curr-&gt;y_array = new_ptr;</a>
<a name="ln2733"> </a>
<a name="ln2734">    if (yank_type == kMTLineWise) {</a>
<a name="ln2735">      // kMTLineWise overrides kMTCharWise and kMTBlockWise</a>
<a name="ln2736">      curr-&gt;y_type = kMTLineWise;</a>
<a name="ln2737">    }</a>
<a name="ln2738"> </a>
<a name="ln2739">    // Concatenate the last line of the old block with the first line of</a>
<a name="ln2740">    // the new block, unless being Vi compatible.</a>
<a name="ln2741">    if (curr-&gt;y_type == kMTCharWise</a>
<a name="ln2742">        &amp;&amp; vim_strchr(p_cpo, CPO_REGAPPEND) == NULL) {</a>
<a name="ln2743">      pnew = xmalloc(strlen(curr-&gt;y_array[curr-&gt;y_size - 1])</a>
<a name="ln2744">                     + strlen(reg-&gt;y_array[0]) + 1);</a>
<a name="ln2745">      STRCPY(pnew, curr-&gt;y_array[--j]);</a>
<a name="ln2746">      STRCAT(pnew, reg-&gt;y_array[0]);</a>
<a name="ln2747">      xfree(curr-&gt;y_array[j]);</a>
<a name="ln2748">      xfree(reg-&gt;y_array[0]);</a>
<a name="ln2749">      curr-&gt;y_array[j++] = (char *)pnew;</a>
<a name="ln2750">      y_idx = 1;</a>
<a name="ln2751">    } else {</a>
<a name="ln2752">      y_idx = 0;</a>
<a name="ln2753">    }</a>
<a name="ln2754">    while (y_idx &lt; reg-&gt;y_size) {</a>
<a name="ln2755">      curr-&gt;y_array[j++] = reg-&gt;y_array[y_idx++];</a>
<a name="ln2756">    }</a>
<a name="ln2757">    curr-&gt;y_size = j;</a>
<a name="ln2758">    xfree(reg-&gt;y_array);</a>
<a name="ln2759">  }</a>
<a name="ln2760"> </a>
<a name="ln2761">  if (message) {  // Display message about yank?</a>
<a name="ln2762">    if (yank_type == kMTCharWise &amp;&amp; yanklines == 1) {</a>
<a name="ln2763">      yanklines = 0;</a>
<a name="ln2764">    }</a>
<a name="ln2765">    // Some versions of Vi use &quot;&gt;=&quot; here, some don't...</a>
<a name="ln2766">    if (yanklines &gt; (size_t)p_report) {</a>
<a name="ln2767">      char namebuf[100];</a>
<a name="ln2768"> </a>
<a name="ln2769">      if (oap-&gt;regname == NUL) {</a>
<a name="ln2770">        *namebuf = NUL;</a>
<a name="ln2771">      } else {</a>
<a name="ln2772">        vim_snprintf(namebuf, sizeof(namebuf), _(&quot; into \&quot;%c&quot;), oap-&gt;regname);</a>
<a name="ln2773">      }</a>
<a name="ln2774"> </a>
<a name="ln2775">      // redisplay now, so message is not deleted</a>
<a name="ln2776">      update_topline(curwin);</a>
<a name="ln2777">      if (must_redraw) {</a>
<a name="ln2778">        update_screen();</a>
<a name="ln2779">      }</a>
<a name="ln2780">      if (yank_type == kMTBlockWise) {</a>
<a name="ln2781">        smsg(NGETTEXT(&quot;block of %&quot; PRId64 &quot; line yanked%s&quot;,</a>
<a name="ln2782">                      &quot;block of %&quot; PRId64 &quot; lines yanked%s&quot;, yanklines),</a>
<a name="ln2783">             (int64_t)yanklines, namebuf);</a>
<a name="ln2784">      } else {</a>
<a name="ln2785">        smsg(NGETTEXT(&quot;%&quot; PRId64 &quot; line yanked%s&quot;,</a>
<a name="ln2786">                      &quot;%&quot; PRId64 &quot; lines yanked%s&quot;, yanklines),</a>
<a name="ln2787">             (int64_t)yanklines, namebuf);</a>
<a name="ln2788">      }</a>
<a name="ln2789">    }</a>
<a name="ln2790">  }</a>
<a name="ln2791"> </a>
<a name="ln2792">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln2793">    // Set &quot;'[&quot; and &quot;']&quot; marks.</a>
<a name="ln2794">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln2795">    curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln2796">    if (yank_type == kMTLineWise) {</a>
<a name="ln2797">      curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln2798">      curbuf-&gt;b_op_end.col = MAXCOL;</a>
<a name="ln2799">    }</a>
<a name="ln2800">  }</a>
<a name="ln2801">}</a>
<a name="ln2802"> </a>
<a name="ln2803">/// Copy a block range into a register.</a>
<a name="ln2804">///</a>
<a name="ln2805">/// @param exclude_trailing_space  if true, do not copy trailing whitespaces.</a>
<a name="ln2806">static void yank_copy_line(yankreg_T *reg, struct block_def *bd, size_t y_idx,</a>
<a name="ln2807">                           bool exclude_trailing_space)</a>
<a name="ln2808">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2809">{</a>
<a name="ln2810">  if (exclude_trailing_space) {</a>
<a name="ln2811">    bd-&gt;endspaces = 0;</a>
<a name="ln2812">  }</a>
<a name="ln2813">  int size = bd-&gt;startspaces + bd-&gt;endspaces + bd-&gt;textlen;</a>
<a name="ln2814">  assert(size &gt;= 0);</a>
<a name="ln2815">  char_u *pnew = xmallocz((size_t)size);</a>
<a name="ln2816">  reg-&gt;y_array[y_idx] = (char *)pnew;</a>
<a name="ln2817">  memset(pnew, ' ', (size_t)bd-&gt;startspaces);</a>
<a name="ln2818">  pnew += bd-&gt;startspaces;</a>
<a name="ln2819">  memmove(pnew, bd-&gt;textstart, (size_t)bd-&gt;textlen);</a>
<a name="ln2820">  pnew += bd-&gt;textlen;</a>
<a name="ln2821">  memset(pnew, ' ', (size_t)bd-&gt;endspaces);</a>
<a name="ln2822">  pnew += bd-&gt;endspaces;</a>
<a name="ln2823">  if (exclude_trailing_space) {</a>
<a name="ln2824">    int s = bd-&gt;textlen + bd-&gt;endspaces;</a>
<a name="ln2825"> </a>
<a name="ln2826">    while (s &gt; 0 &amp;&amp; ascii_iswhite(*(bd-&gt;textstart + s - 1))) {</a>
<a name="ln2827">      s = s - utf_head_off((char *)bd-&gt;textstart, (char *)bd-&gt;textstart + s - 1) - 1;</a>
<a name="ln2828">      pnew--;</a>
<a name="ln2829">    }</a>
<a name="ln2830">  }</a>
<a name="ln2831">  *pnew = NUL;</a>
<a name="ln2832">}</a>
<a name="ln2833"> </a>
<a name="ln2834">/// Execute autocommands for TextYankPost.</a>
<a name="ln2835">///</a>
<a name="ln2836">/// @param oap Operator arguments.</a>
<a name="ln2837">/// @param reg The yank register used.</a>
<a name="ln2838">static void do_autocmd_textyankpost(oparg_T *oap, yankreg_T *reg)</a>
<a name="ln2839">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2840">{</a>
<a name="ln2841">  static bool recursive = false;</a>
<a name="ln2842"> </a>
<a name="ln2843">  if (recursive || !has_event(EVENT_TEXTYANKPOST)) {</a>
<a name="ln2844">    // No autocommand was defined, or we yanked from this autocommand.</a>
<a name="ln2845">    return;</a>
<a name="ln2846">  }</a>
<a name="ln2847"> </a>
<a name="ln2848">  recursive = true;</a>
<a name="ln2849"> </a>
<a name="ln2850">  save_v_event_T save_v_event;</a>
<a name="ln2851">  // Set the v:event dictionary with information about the yank.</a>
<a name="ln2852">  dict_T *dict = get_v_event(&amp;save_v_event);</a>
<a name="ln2853"> </a>
<a name="ln2854">  // The yanked text contents.</a>
<a name="ln2855">  list_T *const list = tv_list_alloc((ptrdiff_t)reg-&gt;y_size);</a>
<a name="ln2856">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln2857">    tv_list_append_string(list, (const char *)reg-&gt;y_array[i], -1);</a>
<a name="ln2858">  }</a>
<a name="ln2859">  tv_list_set_lock(list, VAR_FIXED);</a>
<a name="ln2860">  (void)tv_dict_add_list(dict, S_LEN(&quot;regcontents&quot;), list);</a>
<a name="ln2861"> </a>
<a name="ln2862">  // Register type.</a>
<a name="ln2863">  char buf[NUMBUFLEN + 2];</a>
<a name="ln2864">  format_reg_type(reg-&gt;y_type, reg-&gt;y_width, buf, ARRAY_SIZE(buf));</a>
<a name="ln2865">  (void)tv_dict_add_str(dict, S_LEN(&quot;regtype&quot;), buf);</a>
<a name="ln2866"> </a>
<a name="ln2867">  // Name of requested register, or empty string for unnamed operation.</a>
<a name="ln2868">  buf[0] = (char)oap-&gt;regname;</a>
<a name="ln2869">  buf[1] = NUL;</a>
<a name="ln2870">  (void)tv_dict_add_str(dict, S_LEN(&quot;regname&quot;), buf);</a>
<a name="ln2871"> </a>
<a name="ln2872">  // Motion type: inclusive or exclusive.</a>
<a name="ln2873">  tv_dict_add_bool(dict, S_LEN(&quot;inclusive&quot;),</a>
<a name="ln2874">                   oap-&gt;inclusive ? kBoolVarTrue : kBoolVarFalse);</a>
<a name="ln2875"> </a>
<a name="ln2876">  // Kind of operation: yank, delete, change).</a>
<a name="ln2877">  buf[0] = (char)get_op_char(oap-&gt;op_type);</a>
<a name="ln2878">  buf[1] = NUL;</a>
<a name="ln2879">  (void)tv_dict_add_str(dict, S_LEN(&quot;operator&quot;), buf);</a>
<a name="ln2880"> </a>
<a name="ln2881">  // Selection type: visual or not.</a>
<a name="ln2882">  (void)tv_dict_add_bool(dict, S_LEN(&quot;visual&quot;),</a>
<a name="ln2883">                         oap-&gt;is_VIsual ? kBoolVarTrue : kBoolVarFalse);</a>
<a name="ln2884"> </a>
<a name="ln2885">  tv_dict_set_keys_readonly(dict);</a>
<a name="ln2886">  textlock++;</a>
<a name="ln2887">  apply_autocmds(EVENT_TEXTYANKPOST, NULL, NULL, false, curbuf);</a>
<a name="ln2888">  textlock--;</a>
<a name="ln2889">  restore_v_event(dict, &amp;save_v_event);</a>
<a name="ln2890"> </a>
<a name="ln2891">  recursive = false;</a>
<a name="ln2892">}</a>
<a name="ln2893"> </a>
<a name="ln2894">/// Put contents of register &quot;regname&quot; into the text.</a>
<a name="ln2895">/// Caller must check &quot;regname&quot; to be valid!</a>
<a name="ln2896">///</a>
<a name="ln2897">/// @param flags  PUT_FIXINDENT     make indent look nice</a>
<a name="ln2898">///               PUT_CURSEND       leave cursor after end of new text</a>
<a name="ln2899">///               PUT_LINE          force linewise put (&quot;:put&quot;)</a>
<a name="ln2900">///               PUT_BLOCK_INNER   in block mode, do not add trailing spaces</a>
<a name="ln2901">/// @param dir    BACKWARD for 'P', FORWARD for 'p'</a>
<a name="ln2902">void do_put(int regname, yankreg_T *reg, int dir, long count, int flags)</a>
<a name="ln2903">{</a>
<a name="ln2904">  char *ptr;</a>
<a name="ln2905">  char *newp;</a>
<a name="ln2906">  char *oldp;</a>
<a name="ln2907">  int yanklen;</a>
<a name="ln2908">  size_t totlen = 0;  // init for gcc</a>
<a name="ln2909">  linenr_T lnum = 0;</a>
<a name="ln2910">  colnr_T col = 0;</a>
<a name="ln2911">  size_t i;  // index in y_array[]</a>
<a name="ln2912">  MotionType y_type;</a>
<a name="ln2913">  size_t y_size;</a>
<a name="ln2914">  size_t oldlen;</a>
<a name="ln2915">  int y_width = 0;</a>
<a name="ln2916">  colnr_T vcol = 0;</a>
<a name="ln2917">  int delcount;</a>
<a name="ln2918">  int incr = 0;</a>
<a name="ln2919">  struct block_def bd;</a>
<a name="ln2920">  char **y_array = NULL;</a>
<a name="ln2921">  linenr_T nr_lines = 0;</a>
<a name="ln2922">  pos_T new_cursor;</a>
<a name="ln2923">  int indent;</a>
<a name="ln2924">  int orig_indent = 0;                  // init for gcc</a>
<a name="ln2925">  int indent_diff = 0;                  // init for gcc</a>
<a name="ln2926">  bool first_indent = true;</a>
<a name="ln2927">  int lendiff = 0;</a>
<a name="ln2928">  pos_T old_pos;</a>
<a name="ln2929">  char *insert_string = NULL;</a>
<a name="ln2930">  bool allocated = false;</a>
<a name="ln2931">  long cnt;</a>
<a name="ln2932">  const pos_T orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln2933">  const pos_T orig_end = curbuf-&gt;b_op_end;</a>
<a name="ln2934">  unsigned int cur_ve_flags = get_ve_flags();</a>
<a name="ln2935"> </a>
<a name="ln2936">  if (flags &amp; PUT_FIXINDENT) {</a>
<a name="ln2937">    orig_indent = get_indent();</a>
<a name="ln2938">  }</a>
<a name="ln2939"> </a>
<a name="ln2940">  curbuf-&gt;b_op_start = curwin-&gt;w_cursor;        // default for '[ mark</a>
<a name="ln2941">  curbuf-&gt;b_op_end = curwin-&gt;w_cursor;          // default for '] mark</a>
<a name="ln2942"> </a>
<a name="ln2943">  // Using inserted text works differently, because the register includes</a>
<a name="ln2944">  // special characters (newlines, etc.).</a>
<a name="ln2945">  if (regname == '.' &amp;&amp; !reg) {</a>
<a name="ln2946">    bool non_linewise_vis = (VIsual_active &amp;&amp; VIsual_mode != 'V');</a>
<a name="ln2947"> </a>
<a name="ln2948">    // PUT_LINE has special handling below which means we use 'i' to start.</a>
<a name="ln2949">    char command_start_char = non_linewise_vis ? 'c' :</a>
<a name="ln2950">                              (flags &amp; PUT_LINE ? 'i' : (dir == FORWARD ? 'a' : 'i'));</a>
<a name="ln2951"> </a>
<a name="ln2952">    // To avoid 'autoindent' on linewise puts, create a new line with `:put _`.</a>
<a name="ln2953">    if (flags &amp; PUT_LINE) {</a>
<a name="ln2954">      do_put('_', NULL, dir, 1, PUT_LINE);</a>
<a name="ln2955">    }</a>
<a name="ln2956"> </a>
<a name="ln2957">    // If given a count when putting linewise, we stuff the readbuf with the</a>
<a name="ln2958">    // dot register 'count' times split by newlines.</a>
<a name="ln2959">    if (flags &amp; PUT_LINE) {</a>
<a name="ln2960">      stuffcharReadbuff(command_start_char);</a>
<a name="ln2961">      for (; count &gt; 0; count--) {</a>
<a name="ln2962">        (void)stuff_inserted(NUL, 1, count != 1);</a>
<a name="ln2963">        if (count != 1) {</a>
<a name="ln2964">          // To avoid 'autoindent' affecting the text, use Ctrl_U to remove any</a>
<a name="ln2965">          // whitespace. Can't just insert Ctrl_U into readbuf1, this would go</a>
<a name="ln2966">          // back to the previous line in the case of 'noautoindent' and</a>
<a name="ln2967">          // 'backspace' includes &quot;eol&quot;. So we insert a dummy space for Ctrl_U</a>
<a name="ln2968">          // to consume.</a>
<a name="ln2969">          stuffReadbuff(&quot;\n &quot;);</a>
<a name="ln2970">          stuffcharReadbuff(Ctrl_U);</a>
<a name="ln2971">        }</a>
<a name="ln2972">      }</a>
<a name="ln2973">    } else {</a>
<a name="ln2974">      (void)stuff_inserted(command_start_char, count, false);</a>
<a name="ln2975">    }</a>
<a name="ln2976"> </a>
<a name="ln2977">    // Putting the text is done later, so can't move the cursor to the next</a>
<a name="ln2978">    // character.  Simulate it with motion commands after the insert.</a>
<a name="ln2979">    if (flags &amp; PUT_CURSEND) {</a>
<a name="ln2980">      if (flags &amp; PUT_LINE) {</a>
<a name="ln2981">        stuffReadbuff(&quot;j0&quot;);</a>
<a name="ln2982">      } else {</a>
<a name="ln2983">        // Avoid ringing the bell from attempting to move into the space after</a>
<a name="ln2984">        // the current line. We can stuff the readbuffer with &quot;l&quot; if:</a>
<a name="ln2985">        // 1) 'virtualedit' is &quot;all&quot; or &quot;onemore&quot;</a>
<a name="ln2986">        // 2) We are not at the end of the line</a>
<a name="ln2987">        // 3) We are not  (one past the end of the line &amp;&amp; on the last line)</a>
<a name="ln2988">        //    This allows a visual put over a selection one past the end of the</a>
<a name="ln2989">        //    line joining the current line with the one below.</a>
<a name="ln2990"> </a>
<a name="ln2991">        // curwin-&gt;w_cursor.col marks the byte position of the cursor in the</a>
<a name="ln2992">        // currunt line. It increases up to a max of</a>
<a name="ln2993">        // strlen(ml_get(curwin-&gt;w_cursor.lnum)). With 'virtualedit' and the</a>
<a name="ln2994">        // cursor past the end of the line, curwin-&gt;w_cursor.coladd is</a>
<a name="ln2995">        // incremented instead of curwin-&gt;w_cursor.col.</a>
<a name="ln2996">        char_u *cursor_pos = (char_u *)get_cursor_pos_ptr();</a>
<a name="ln2997">        bool one_past_line = (*cursor_pos == NUL);</a>
<a name="ln2998">        bool eol = false;</a>
<a name="ln2999">        if (!one_past_line) {</a>
<a name="ln3000">          eol = (*(cursor_pos + utfc_ptr2len((char *)cursor_pos)) == NUL);</a>
<a name="ln3001">        }</a>
<a name="ln3002"> </a>
<a name="ln3003">        bool ve_allows = (cur_ve_flags == VE_ALL || cur_ve_flags == VE_ONEMORE);</a>
<a name="ln3004">        bool eof = curbuf-&gt;b_ml.ml_line_count == curwin-&gt;w_cursor.lnum</a>
<a name="ln3005">                   &amp;&amp; one_past_line;</a>
<a name="ln3006">        if (ve_allows || !(eol || eof)) {</a>
<a name="ln3007">          stuffcharReadbuff('l');</a>
<a name="ln3008">        }</a>
<a name="ln3009">      }</a>
<a name="ln3010">    } else if (flags &amp; PUT_LINE) {</a>
<a name="ln3011">      stuffReadbuff(&quot;g'[&quot;);</a>
<a name="ln3012">    }</a>
<a name="ln3013"> </a>
<a name="ln3014">    // So the 'u' command restores cursor position after &quot;.p, save the cursor</a>
<a name="ln3015">    // position now (though not saving any text).</a>
<a name="ln3016">    if (command_start_char == 'a') {</a>
<a name="ln3017">      if (u_save(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum + 1) == FAIL) {</a>
<a name="ln3018">        return;</a>
<a name="ln3019">      }</a>
<a name="ln3020">    }</a>
<a name="ln3021">    return;</a>
<a name="ln3022">  }</a>
<a name="ln3023"> </a>
<a name="ln3024">  // For special registers '%' (file name), '#' (alternate file name) and</a>
<a name="ln3025">  // ':' (last command line), etc. we have to create a fake yank register.</a>
<a name="ln3026">  if (!reg &amp;&amp; get_spec_reg(regname, &amp;insert_string, &amp;allocated, true)) {</a>
<a name="ln3027">    if (insert_string == NULL) {</a>
<a name="ln3028">      return;</a>
<a name="ln3029">    }</a>
<a name="ln3030">  }</a>
<a name="ln3031"> </a>
<a name="ln3032">  if (!curbuf-&gt;terminal) {</a>
<a name="ln3033">    // Autocommands may be executed when saving lines for undo.  This might</a>
<a name="ln3034">    // make y_array invalid, so we start undo now to avoid that.</a>
<a name="ln3035">    if (u_save(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum + 1) == FAIL) {</a>
<a name="ln3036">      return;</a>
<a name="ln3037">    }</a>
<a name="ln3038">  }</a>
<a name="ln3039"> </a>
<a name="ln3040">  if (insert_string != NULL) {</a>
<a name="ln3041">    y_type = kMTCharWise;</a>
<a name="ln3042">    if (regname == '=') {</a>
<a name="ln3043">      // For the = register we need to split the string at NL</a>
<a name="ln3044">      // characters.</a>
<a name="ln3045">      // Loop twice: count the number of lines and save them.</a>
<a name="ln3046">      for (;;) {</a>
<a name="ln3047">        y_size = 0;</a>
<a name="ln3048">        ptr = insert_string;</a>
<a name="ln3049">        while (ptr != NULL) {</a>
<a name="ln3050">          if (y_array != NULL) {</a>
<a name="ln3051">            y_array[y_size] = ptr;</a>
<a name="ln3052">          }</a>
<a name="ln3053">          y_size++;</a>
<a name="ln3054">          ptr = vim_strchr(ptr, '\n');</a>
<a name="ln3055">          if (ptr != NULL) {</a>
<a name="ln3056">            if (y_array != NULL) {</a>
<a name="ln3057">              *ptr = NUL;</a>
<a name="ln3058">            }</a>
<a name="ln3059">            ptr++;</a>
<a name="ln3060">            // A trailing '\n' makes the register linewise.</a>
<a name="ln3061">            if (*ptr == NUL) {</a>
<a name="ln3062">              y_type = kMTLineWise;</a>
<a name="ln3063">              break;</a>
<a name="ln3064">            }</a>
<a name="ln3065">          }</a>
<a name="ln3066">        }</a>
<a name="ln3067">        if (y_array != NULL) {</a>
<a name="ln3068">          break;</a>
<a name="ln3069">        }</a>
<a name="ln3070">        y_array = xmalloc(y_size * sizeof(char_u *));</a>
<a name="ln3071">      }</a>
<a name="ln3072">    } else {</a>
<a name="ln3073">      y_size = 1;               // use fake one-line yank register</a>
<a name="ln3074">      y_array = &amp;insert_string;</a>
<a name="ln3075">    }</a>
<a name="ln3076">  } else {</a>
<a name="ln3077">    // in case of replacing visually selected text</a>
<a name="ln3078">    // the yankreg might already have been saved to avoid</a>
<a name="ln3079">    // just restoring the deleted text.</a>
<a name="ln3080">    if (reg == NULL) {</a>
<a name="ln3081">      reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln3082">    }</a>
<a name="ln3083"> </a>
<a name="ln3084">    y_type = reg-&gt;y_type;</a>
<a name="ln3085">    y_width = reg-&gt;y_width;</a>
<a name="ln3086">    y_size = reg-&gt;y_size;</a>
<a name="ln3087">    y_array = reg-&gt;y_array;</a>
<a name="ln3088">  }</a>
<a name="ln3089"> </a>
<a name="ln3090">  if (curbuf-&gt;terminal) {</a>
<a name="ln3091">    terminal_paste(count, y_array, y_size);</a>
<a name="ln3092">    return;</a>
<a name="ln3093">  }</a>
<a name="ln3094"> </a>
<a name="ln3095">  if (y_type == kMTLineWise) {</a>
<a name="ln3096">    if (flags &amp; PUT_LINE_SPLIT) {</a>
<a name="ln3097">      // &quot;p&quot; or &quot;P&quot; in Visual mode: split the lines to put the text in</a>
<a name="ln3098">      // between.</a>
<a name="ln3099">      if (u_save_cursor() == FAIL) {</a>
<a name="ln3100">        goto end;</a>
<a name="ln3101">      }</a>
<a name="ln3102">      char *p = get_cursor_pos_ptr();</a>
<a name="ln3103">      if (dir == FORWARD &amp;&amp; *p != NUL) {</a>
<a name="ln3104">        MB_PTR_ADV(p);</a>
<a name="ln3105">      }</a>
<a name="ln3106">      ptr = xstrdup(p);</a>
<a name="ln3107">      ml_append(curwin-&gt;w_cursor.lnum, ptr, (colnr_T)0, false);</a>
<a name="ln3108">      xfree(ptr);</a>
<a name="ln3109"> </a>
<a name="ln3110">      oldp = get_cursor_line_ptr();</a>
<a name="ln3111">      p = oldp + curwin-&gt;w_cursor.col;</a>
<a name="ln3112">      if (dir == FORWARD &amp;&amp; *p != NUL) {</a>
<a name="ln3113">        MB_PTR_ADV(p);</a>
<a name="ln3114">      }</a>
<a name="ln3115">      ptr = xstrnsave(oldp, (size_t)(p - oldp));</a>
<a name="ln3116">      ml_replace(curwin-&gt;w_cursor.lnum, ptr, false);</a>
<a name="ln3117">      nr_lines++;</a>
<a name="ln3118">      dir = FORWARD;</a>
<a name="ln3119">    }</a>
<a name="ln3120">    if (flags &amp; PUT_LINE_FORWARD) {</a>
<a name="ln3121">      // Must be &quot;p&quot; for a Visual block, put lines below the block.</a>
<a name="ln3122">      curwin-&gt;w_cursor = curbuf-&gt;b_visual.vi_end;</a>
<a name="ln3123">      dir = FORWARD;</a>
<a name="ln3124">    }</a>
<a name="ln3125">    curbuf-&gt;b_op_start = curwin-&gt;w_cursor;      // default for '[ mark</a>
<a name="ln3126">    curbuf-&gt;b_op_end = curwin-&gt;w_cursor;        // default for '] mark</a>
<a name="ln3127">  }</a>
<a name="ln3128"> </a>
<a name="ln3129">  if (flags &amp; PUT_LINE) {  // :put command or &quot;p&quot; in Visual line mode.</a>
<a name="ln3130">    y_type = kMTLineWise;</a>
<a name="ln3131">  }</a>
<a name="ln3132"> </a>
<a name="ln3133">  if (y_size == 0 || y_array == NULL) {</a>
<a name="ln3134">    semsg(_(&quot;E353: Nothing in register %s&quot;),</a>
<a name="ln3135">          regname == 0 ? (char_u *)&quot;\&quot;&quot; : transchar(regname));</a>
<a name="ln3136">    goto end;</a>
<a name="ln3137">  }</a>
<a name="ln3138"> </a>
<a name="ln3139">  if (y_type == kMTBlockWise) {</a>
<a name="ln3140">    lnum = curwin-&gt;w_cursor.lnum + (linenr_T)y_size + 1;</a>
<a name="ln3141">    if (lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3142">      lnum = curbuf-&gt;b_ml.ml_line_count + 1;</a>
<a name="ln3143">    }</a>
<a name="ln3144">    if (u_save(curwin-&gt;w_cursor.lnum - 1, lnum) == FAIL) {</a>
<a name="ln3145">      goto end;</a>
<a name="ln3146">    }</a>
<a name="ln3147">  } else if (y_type == kMTLineWise) {</a>
<a name="ln3148">    lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3149">    // Correct line number for closed fold.  Don't move the cursor yet,</a>
<a name="ln3150">    // u_save() uses it.</a>
<a name="ln3151">    if (dir == BACKWARD) {</a>
<a name="ln3152">      (void)hasFolding(lnum, &amp;lnum, NULL);</a>
<a name="ln3153">    } else {</a>
<a name="ln3154">      (void)hasFolding(lnum, NULL, &amp;lnum);</a>
<a name="ln3155">    }</a>
<a name="ln3156">    if (dir == FORWARD) {</a>
<a name="ln3157">      lnum++;</a>
<a name="ln3158">    }</a>
<a name="ln3159">    // In an empty buffer the empty line is going to be replaced, include</a>
<a name="ln3160">    // it in the saved lines.</a>
<a name="ln3161">    if ((buf_is_empty(curbuf) ?</a>
<a name="ln3162">         u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL) {</a>
<a name="ln3163">      goto end;</a>
<a name="ln3164">    }</a>
<a name="ln3165">    if (dir == FORWARD) {</a>
<a name="ln3166">      curwin-&gt;w_cursor.lnum = lnum - 1;</a>
<a name="ln3167">    } else {</a>
<a name="ln3168">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3169">    }</a>
<a name="ln3170">    curbuf-&gt;b_op_start = curwin-&gt;w_cursor;      // for mark_adjust()</a>
<a name="ln3171">  } else if (u_save_cursor() == FAIL) {</a>
<a name="ln3172">    goto end;</a>
<a name="ln3173">  }</a>
<a name="ln3174"> </a>
<a name="ln3175">  yanklen = (int)strlen(y_array[0]);</a>
<a name="ln3176"> </a>
<a name="ln3177">  if (cur_ve_flags == VE_ALL &amp;&amp; y_type == kMTCharWise) {</a>
<a name="ln3178">    if (gchar_cursor() == TAB) {</a>
<a name="ln3179">      int viscol = getviscol();</a>
<a name="ln3180">      long ts = curbuf-&gt;b_p_ts;</a>
<a name="ln3181">      // Don't need to insert spaces when &quot;p&quot; on the last position of a</a>
<a name="ln3182">      // tab or &quot;P&quot; on the first position.</a>
<a name="ln3183">      if (dir == FORWARD</a>
<a name="ln3184">          ? tabstop_padding(viscol, ts, curbuf-&gt;b_p_vts_array) != 1</a>
<a name="ln3185">          : curwin-&gt;w_cursor.coladd &gt; 0) {</a>
<a name="ln3186">        coladvance_force(viscol);</a>
<a name="ln3187">      } else {</a>
<a name="ln3188">        curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln3189">      }</a>
<a name="ln3190">    } else if (curwin-&gt;w_cursor.coladd &gt; 0 || gchar_cursor() == NUL) {</a>
<a name="ln3191">      coladvance_force(getviscol() + (dir == FORWARD));</a>
<a name="ln3192">    }</a>
<a name="ln3193">  }</a>
<a name="ln3194"> </a>
<a name="ln3195">  lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3196">  col = curwin-&gt;w_cursor.col;</a>
<a name="ln3197"> </a>
<a name="ln3198">  // Block mode</a>
<a name="ln3199">  if (y_type == kMTBlockWise) {</a>
<a name="ln3200">    int c = gchar_cursor();</a>
<a name="ln3201">    colnr_T endcol2 = 0;</a>
<a name="ln3202"> </a>
<a name="ln3203">    if (dir == FORWARD &amp;&amp; c != NUL) {</a>
<a name="ln3204">      if (cur_ve_flags == VE_ALL) {</a>
<a name="ln3205">        getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;col, NULL, &amp;endcol2);</a>
<a name="ln3206">      } else {</a>
<a name="ln3207">        getvcol(curwin, &amp;curwin-&gt;w_cursor, NULL, NULL, &amp;col);</a>
<a name="ln3208">      }</a>
<a name="ln3209"> </a>
<a name="ln3210">      // move to start of next multi-byte character</a>
<a name="ln3211">      curwin-&gt;w_cursor.col += utfc_ptr2len(get_cursor_pos_ptr());</a>
<a name="ln3212">      col++;</a>
<a name="ln3213">    } else {</a>
<a name="ln3214">      getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;col, NULL, &amp;endcol2);</a>
<a name="ln3215">    }</a>
<a name="ln3216"> </a>
<a name="ln3217">    col += curwin-&gt;w_cursor.coladd;</a>
<a name="ln3218">    if (cur_ve_flags == VE_ALL</a>
<a name="ln3219">        &amp;&amp; (curwin-&gt;w_cursor.coladd &gt; 0 || endcol2 == curwin-&gt;w_cursor.col)) {</a>
<a name="ln3220">      if (dir == FORWARD &amp;&amp; c == NUL) {</a>
<a name="ln3221">        col++;</a>
<a name="ln3222">      }</a>
<a name="ln3223">      if (dir != FORWARD &amp;&amp; c != NUL &amp;&amp; curwin-&gt;w_cursor.coladd &gt; 0) {</a>
<a name="ln3224">        curwin-&gt;w_cursor.col++;</a>
<a name="ln3225">      }</a>
<a name="ln3226">      if (c == TAB) {</a>
<a name="ln3227">        if (dir == BACKWARD &amp;&amp; curwin-&gt;w_cursor.col) {</a>
<a name="ln3228">          curwin-&gt;w_cursor.col--;</a>
<a name="ln3229">        }</a>
<a name="ln3230">        if (dir == FORWARD &amp;&amp; col - 1 == endcol2) {</a>
<a name="ln3231">          curwin-&gt;w_cursor.col++;</a>
<a name="ln3232">        }</a>
<a name="ln3233">      }</a>
<a name="ln3234">    }</a>
<a name="ln3235">    curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln3236">    bd.textcol = 0;</a>
<a name="ln3237">    for (i = 0; i &lt; y_size; i++) {</a>
<a name="ln3238">      int spaces = 0;</a>
<a name="ln3239">      char shortline;</a>
<a name="ln3240">      // can just be 0 or 1, needed for blockwise paste beyond the current</a>
<a name="ln3241">      // buffer end</a>
<a name="ln3242">      int lines_appended = 0;</a>
<a name="ln3243"> </a>
<a name="ln3244">      bd.startspaces = 0;</a>
<a name="ln3245">      bd.endspaces = 0;</a>
<a name="ln3246">      vcol = 0;</a>
<a name="ln3247">      delcount = 0;</a>
<a name="ln3248"> </a>
<a name="ln3249">      // add a new line</a>
<a name="ln3250">      if (curwin-&gt;w_cursor.lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3251">        if (ml_append(curbuf-&gt;b_ml.ml_line_count, &quot;&quot;,</a>
<a name="ln3252">                      (colnr_T)1, false) == FAIL) {</a>
<a name="ln3253">          break;</a>
<a name="ln3254">        }</a>
<a name="ln3255">        nr_lines++;</a>
<a name="ln3256">        lines_appended = 1;</a>
<a name="ln3257">      }</a>
<a name="ln3258">      // get the old line and advance to the position to insert at</a>
<a name="ln3259">      oldp = get_cursor_line_ptr();</a>
<a name="ln3260">      oldlen = strlen(oldp);</a>
<a name="ln3261">      chartabsize_T cts;</a>
<a name="ln3262">      init_chartabsize_arg(&amp;cts, curwin, curwin-&gt;w_cursor.lnum, 0, oldp, oldp);</a>
<a name="ln3263"> </a>
<a name="ln3264">      while (cts.cts_vcol &lt; col &amp;&amp; *cts.cts_ptr != NUL) {</a>
<a name="ln3265">        // Count a tab for what it's worth (if list mode not on)</a>
<a name="ln3266">        incr = lbr_chartabsize_adv(&amp;cts);</a>
<a name="ln3267">        cts.cts_vcol += incr;</a>
<a name="ln3268">      }</a>
<a name="ln3269">      vcol = cts.cts_vcol;</a>
<a name="ln3270">      ptr = cts.cts_ptr;</a>
<a name="ln3271">      bd.textcol = (colnr_T)(ptr - oldp);</a>
<a name="ln3272">      clear_chartabsize_arg(&amp;cts);</a>
<a name="ln3273"> </a>
<a name="ln3274">      shortline = (vcol &lt; col) || (vcol == col &amp;&amp; !*ptr);</a>
<a name="ln3275"> </a>
<a name="ln3276">      if (vcol &lt; col) {     // line too short, padd with spaces</a>
<a name="ln3277">        bd.startspaces = col - vcol;</a>
<a name="ln3278">      } else if (vcol &gt; col) {</a>
<a name="ln3279">        bd.endspaces = vcol - col;</a>
<a name="ln3280">        bd.startspaces = incr - bd.endspaces;</a>
<a name="ln3281">        bd.textcol--;</a>
<a name="ln3282">        delcount = 1;</a>
<a name="ln3283">        bd.textcol -= utf_head_off(oldp, oldp + bd.textcol);</a>
<a name="ln3284">        if (oldp[bd.textcol] != TAB) {</a>
<a name="ln3285">          // Only a Tab can be split into spaces.  Other</a>
<a name="ln3286">          // characters will have to be moved to after the</a>
<a name="ln3287">          // block, causing misalignment.</a>
<a name="ln3288">          delcount = 0;</a>
<a name="ln3289">          bd.endspaces = 0;</a>
<a name="ln3290">        }</a>
<a name="ln3291">      }</a>
<a name="ln3292"> </a>
<a name="ln3293">      yanklen = (int)strlen(y_array[i]);</a>
<a name="ln3294"> </a>
<a name="ln3295">      if ((flags &amp; PUT_BLOCK_INNER) == 0) {</a>
<a name="ln3296">        // calculate number of spaces required to fill right side of</a>
<a name="ln3297">        // block</a>
<a name="ln3298">        spaces = y_width + 1;</a>
<a name="ln3299">        init_chartabsize_arg(&amp;cts, curwin, 0, 0, y_array[i], y_array[i]);</a>
<a name="ln3300">        for (int j = 0; j &lt; yanklen; j++) {</a>
<a name="ln3301">          spaces -= lbr_chartabsize(&amp;cts);</a>
<a name="ln3302">          cts.cts_ptr++;</a>
<a name="ln3303">          cts.cts_vcol = 0;</a>
<a name="ln3304">        }</a>
<a name="ln3305">        clear_chartabsize_arg(&amp;cts);</a>
<a name="ln3306">        if (spaces &lt; 0) {</a>
<a name="ln3307">          spaces = 0;</a>
<a name="ln3308">        }</a>
<a name="ln3309">      }</a>
<a name="ln3310"> </a>
<a name="ln3311">      // Insert the new text.</a>
<a name="ln3312">      // First check for multiplication overflow.</a>
<a name="ln3313">      if (yanklen + spaces != 0</a>
<a name="ln3314">          &amp;&amp; count &gt; ((INT_MAX - (bd.startspaces + bd.endspaces)) / (yanklen + spaces))) {</a>
<a name="ln3315">        emsg(_(e_resulting_text_too_long));</a>
<a name="ln3316">        break;</a>
<a name="ln3317">      }</a>
<a name="ln3318"> </a>
<a name="ln3319">      totlen = (size_t)(count * (yanklen + spaces) + bd.startspaces + bd.endspaces);</a>
<a name="ln3320">      newp = xmalloc(totlen + oldlen + 1);</a>
<a name="ln3321"> </a>
<a name="ln3322">      // copy part up to cursor to new line</a>
<a name="ln3323">      ptr = newp;</a>
<a name="ln3324">      memmove(ptr, oldp, (size_t)bd.textcol);</a>
<a name="ln3325">      ptr += bd.textcol;</a>
<a name="ln3326"> </a>
<a name="ln3327">      // may insert some spaces before the new text</a>
<a name="ln3328">      memset(ptr, ' ', (size_t)bd.startspaces);</a>
<a name="ln3329">      ptr += bd.startspaces;</a>
<a name="ln3330"> </a>
<a name="ln3331">      // insert the new text</a>
<a name="ln3332">      for (long j = 0; j &lt; count; j++) {</a>
<a name="ln3333">        memmove(ptr, y_array[i], (size_t)yanklen);</a>
<a name="ln3334">        ptr += yanklen;</a>
<a name="ln3335"> </a>
<a name="ln3336">        // insert block's trailing spaces only if there's text behind</a>
<a name="ln3337">        if ((j &lt; count - 1 || !shortline) &amp;&amp; spaces) {</a>
<a name="ln3338">          memset(ptr, ' ', (size_t)spaces);</a>
<a name="ln3339">          ptr += spaces;</a>
<a name="ln3340">        } else {</a>
<a name="ln3341">          totlen -= (size_t)spaces;  // didn't use these spaces</a>
<a name="ln3342">        }</a>
<a name="ln3343">      }</a>
<a name="ln3344"> </a>
<a name="ln3345">      // may insert some spaces after the new text</a>
<a name="ln3346">      memset(ptr, ' ', (size_t)bd.endspaces);</a>
<a name="ln3347">      ptr += bd.endspaces;</a>
<a name="ln3348"> </a>
<a name="ln3349">      // move the text after the cursor to the end of the line.</a>
<a name="ln3350">      int columns = (int)oldlen - bd.textcol - delcount + 1;</a>
<a name="ln3351">      assert(columns &gt;= 0);</a>
<a name="ln3352">      memmove(ptr, oldp + bd.textcol + delcount, (size_t)columns);</a>
<a name="ln3353">      ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln3354">      extmark_splice_cols(curbuf, (int)curwin-&gt;w_cursor.lnum - 1, bd.textcol,</a>
<a name="ln3355">                          delcount, (int)totlen + lines_appended, kExtmarkUndo);</a>
<a name="ln3356"> </a>
<a name="ln3357">      curwin-&gt;w_cursor.lnum++;</a>
<a name="ln3358">      if (i == 0) {</a>
<a name="ln3359">        curwin-&gt;w_cursor.col += bd.startspaces;</a>
<a name="ln3360">      }</a>
<a name="ln3361">    }</a>
<a name="ln3362"> </a>
<a name="ln3363">    changed_lines(lnum, 0, curbuf-&gt;b_op_start.lnum + (linenr_T)y_size</a>
<a name="ln3364">                  - nr_lines, nr_lines, true);</a>
<a name="ln3365"> </a>
<a name="ln3366">    // Set '[ mark.</a>
<a name="ln3367">    curbuf-&gt;b_op_start = curwin-&gt;w_cursor;</a>
<a name="ln3368">    curbuf-&gt;b_op_start.lnum = lnum;</a>
<a name="ln3369"> </a>
<a name="ln3370">    // adjust '] mark</a>
<a name="ln3371">    curbuf-&gt;b_op_end.lnum = curwin-&gt;w_cursor.lnum - 1;</a>
<a name="ln3372">    curbuf-&gt;b_op_end.col = bd.textcol + (colnr_T)totlen - 1;</a>
<a name="ln3373">    curbuf-&gt;b_op_end.coladd = 0;</a>
<a name="ln3374">    if (flags &amp; PUT_CURSEND) {</a>
<a name="ln3375">      colnr_T len;</a>
<a name="ln3376"> </a>
<a name="ln3377">      curwin-&gt;w_cursor = curbuf-&gt;b_op_end;</a>
<a name="ln3378">      curwin-&gt;w_cursor.col++;</a>
<a name="ln3379"> </a>
<a name="ln3380">      // in Insert mode we might be after the NUL, correct for that</a>
<a name="ln3381">      len = (colnr_T)strlen(get_cursor_line_ptr());</a>
<a name="ln3382">      if (curwin-&gt;w_cursor.col &gt; len) {</a>
<a name="ln3383">        curwin-&gt;w_cursor.col = len;</a>
<a name="ln3384">      }</a>
<a name="ln3385">    } else {</a>
<a name="ln3386">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3387">    }</a>
<a name="ln3388">  } else {</a>
<a name="ln3389">    // Character or Line mode</a>
<a name="ln3390">    if (y_type == kMTCharWise) {</a>
<a name="ln3391">      // if type is kMTCharWise, FORWARD is the same as BACKWARD on the next</a>
<a name="ln3392">      // char</a>
<a name="ln3393">      if (dir == FORWARD &amp;&amp; gchar_cursor() != NUL) {</a>
<a name="ln3394">        int bytelen = utfc_ptr2len(get_cursor_pos_ptr());</a>
<a name="ln3395"> </a>
<a name="ln3396">        // put it on the next of the multi-byte character.</a>
<a name="ln3397">        col += bytelen;</a>
<a name="ln3398">        if (yanklen) {</a>
<a name="ln3399">          curwin-&gt;w_cursor.col += bytelen;</a>
<a name="ln3400">          curbuf-&gt;b_op_end.col += bytelen;</a>
<a name="ln3401">        }</a>
<a name="ln3402">      }</a>
<a name="ln3403">      curbuf-&gt;b_op_start = curwin-&gt;w_cursor;</a>
<a name="ln3404">    } else if (dir == BACKWARD) {</a>
<a name="ln3405">      // Line mode: BACKWARD is the same as FORWARD on the previous line</a>
<a name="ln3406">      lnum--;</a>
<a name="ln3407">    }</a>
<a name="ln3408">    new_cursor = curwin-&gt;w_cursor;</a>
<a name="ln3409"> </a>
<a name="ln3410">    // simple case: insert into one line at a time</a>
<a name="ln3411">    if (y_type == kMTCharWise &amp;&amp; y_size == 1) {</a>
<a name="ln3412">      linenr_T end_lnum = 0;  // init for gcc</a>
<a name="ln3413">      linenr_T start_lnum = lnum;</a>
<a name="ln3414">      int first_byte_off = 0;</a>
<a name="ln3415"> </a>
<a name="ln3416">      if (VIsual_active) {</a>
<a name="ln3417">        end_lnum = curbuf-&gt;b_visual.vi_end.lnum;</a>
<a name="ln3418">        if (end_lnum &lt; curbuf-&gt;b_visual.vi_start.lnum) {</a>
<a name="ln3419">          end_lnum = curbuf-&gt;b_visual.vi_start.lnum;</a>
<a name="ln3420">        }</a>
<a name="ln3421">        if (end_lnum &gt; start_lnum) {</a>
<a name="ln3422">          // &quot;col&quot; is valid for the first line, in following lines</a>
<a name="ln3423">          // the virtual column needs to be used.  Matters for</a>
<a name="ln3424">          // multi-byte characters.</a>
<a name="ln3425">          pos_T pos = {</a>
<a name="ln3426">            .lnum = lnum,</a>
<a name="ln3427">            .col = col,</a>
<a name="ln3428">            .coladd = 0,</a>
<a name="ln3429">          };</a>
<a name="ln3430">          getvcol(curwin, &amp;pos, NULL, &amp;vcol, NULL);</a>
<a name="ln3431">        }</a>
<a name="ln3432">      }</a>
<a name="ln3433"> </a>
<a name="ln3434">      if (count == 0 || yanklen == 0) {</a>
<a name="ln3435">        if (VIsual_active) {</a>
<a name="ln3436">          lnum = end_lnum;</a>
<a name="ln3437">        }</a>
<a name="ln3438">      } else if (count &gt; INT_MAX / yanklen) {</a>
<a name="ln3439">        // multiplication overflow</a>
<a name="ln3440">        emsg(_(e_resulting_text_too_long));</a>
<a name="ln3441">      } else {</a>
<a name="ln3442">        totlen = (size_t)(count * yanklen);</a>
<a name="ln3443">        do {</a>
<a name="ln3444">          oldp = ml_get(lnum);</a>
<a name="ln3445">          oldlen = strlen(oldp);</a>
<a name="ln3446">          if (lnum &gt; start_lnum) {</a>
<a name="ln3447">            pos_T pos = {</a>
<a name="ln3448">              .lnum = lnum,</a>
<a name="ln3449">            };</a>
<a name="ln3450">            if (getvpos(&amp;pos, vcol) == OK) {</a>
<a name="ln3451">              col = pos.col;</a>
<a name="ln3452">            } else {</a>
<a name="ln3453">              col = MAXCOL;</a>
<a name="ln3454">            }</a>
<a name="ln3455">          }</a>
<a name="ln3456">          if (VIsual_active &amp;&amp; col &gt; (colnr_T)oldlen) {</a>
<a name="ln3457">            lnum++;</a>
<a name="ln3458">            continue;</a>
<a name="ln3459">          }</a>
<a name="ln3460">          newp = xmalloc(totlen + oldlen + 1);</a>
<a name="ln3461">          memmove(newp, oldp, (size_t)col);</a>
<a name="ln3462">          ptr = newp + col;</a>
<a name="ln3463">          for (i = 0; i &lt; (size_t)count; i++) {</a>
<a name="ln3464">            memmove(ptr, y_array[0], (size_t)yanklen);</a>
<a name="ln3465">            ptr += yanklen;</a>
<a name="ln3466">          }</a>
<a name="ln3467">          STRMOVE(ptr, oldp + col);</a>
<a name="ln3468">          ml_replace(lnum, newp, false);</a>
<a name="ln3469"> </a>
<a name="ln3470">          // compute the byte offset for the last character</a>
<a name="ln3471">          first_byte_off = utf_head_off(newp, ptr - 1);</a>
<a name="ln3472"> </a>
<a name="ln3473">          // Place cursor on last putted char.</a>
<a name="ln3474">          if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln3475">            // make sure curwin-&gt;w_virtcol is updated</a>
<a name="ln3476">            changed_cline_bef_curs();</a>
<a name="ln3477">            curwin-&gt;w_cursor.col += (colnr_T)(totlen - 1);</a>
<a name="ln3478">          }</a>
<a name="ln3479">          changed_bytes(lnum, col);</a>
<a name="ln3480">          extmark_splice_cols(curbuf, (int)lnum - 1, col,</a>
<a name="ln3481">                              0, (int)totlen, kExtmarkUndo);</a>
<a name="ln3482">          if (VIsual_active) {</a>
<a name="ln3483">            lnum++;</a>
<a name="ln3484">          }</a>
<a name="ln3485">        } while (VIsual_active &amp;&amp; lnum &lt;= end_lnum);</a>
<a name="ln3486"> </a>
<a name="ln3487">        if (VIsual_active) {  // reset lnum to the last visual line</a>
<a name="ln3488">          lnum--;</a>
<a name="ln3489">        }</a>
<a name="ln3490">      }</a>
<a name="ln3491"> </a>
<a name="ln3492">      // put '] at the first byte of the last character</a>
<a name="ln3493">      curbuf-&gt;b_op_end = curwin-&gt;w_cursor;</a>
<a name="ln3494">      curbuf-&gt;b_op_end.col -= first_byte_off;</a>
<a name="ln3495"> </a>
<a name="ln3496">      // For &quot;CTRL-O p&quot; in Insert mode, put cursor after last char</a>
<a name="ln3497">      if (totlen &amp;&amp; (restart_edit != 0 || (flags &amp; PUT_CURSEND))) {</a>
<a name="ln3498">        curwin-&gt;w_cursor.col++;</a>
<a name="ln3499">      } else {</a>
<a name="ln3500">        curwin-&gt;w_cursor.col -= first_byte_off;</a>
<a name="ln3501">      }</a>
<a name="ln3502">    } else {</a>
<a name="ln3503">      linenr_T new_lnum = new_cursor.lnum;</a>
<a name="ln3504">      size_t len;</a>
<a name="ln3505"> </a>
<a name="ln3506">      // Insert at least one line.  When y_type is kMTCharWise, break the first</a>
<a name="ln3507">      // line in two.</a>
<a name="ln3508">      for (cnt = 1; cnt &lt;= count; cnt++) {</a>
<a name="ln3509">        i = 0;</a>
<a name="ln3510">        if (y_type == kMTCharWise) {</a>
<a name="ln3511">          // Split the current line in two at the insert position.</a>
<a name="ln3512">          // First insert y_array[size - 1] in front of second line.</a>
<a name="ln3513">          // Then append y_array[0] to first line.</a>
<a name="ln3514">          lnum = new_cursor.lnum;</a>
<a name="ln3515">          ptr = ml_get(lnum) + col;</a>
<a name="ln3516">          totlen = strlen(y_array[y_size - 1]);</a>
<a name="ln3517">          newp = xmalloc((size_t)(strlen(ptr) + totlen + 1));</a>
<a name="ln3518">          STRCPY(newp, y_array[y_size - 1]);</a>
<a name="ln3519">          STRCAT(newp, ptr);</a>
<a name="ln3520">          // insert second line</a>
<a name="ln3521">          ml_append(lnum, newp, (colnr_T)0, false);</a>
<a name="ln3522">          new_lnum++;</a>
<a name="ln3523">          xfree(newp);</a>
<a name="ln3524"> </a>
<a name="ln3525">          oldp = ml_get(lnum);</a>
<a name="ln3526">          newp = xmalloc((size_t)col + (size_t)yanklen + 1);</a>
<a name="ln3527">          // copy first part of line</a>
<a name="ln3528">          memmove(newp, oldp, (size_t)col);</a>
<a name="ln3529">          // append to first line</a>
<a name="ln3530">          memmove(newp + col, y_array[0], (size_t)yanklen + 1);</a>
<a name="ln3531">          ml_replace(lnum, newp, false);</a>
<a name="ln3532"> </a>
<a name="ln3533">          curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3534">          i = 1;</a>
<a name="ln3535">        }</a>
<a name="ln3536"> </a>
<a name="ln3537">        for (; i &lt; y_size; i++) {</a>
<a name="ln3538">          if ((y_type != kMTCharWise || i &lt; y_size - 1)) {</a>
<a name="ln3539">            if (ml_append(lnum, y_array[i], (colnr_T)0, false) == FAIL) {</a>
<a name="ln3540">              goto error;</a>
<a name="ln3541">            }</a>
<a name="ln3542">            new_lnum++;</a>
<a name="ln3543">          }</a>
<a name="ln3544">          lnum++;</a>
<a name="ln3545">          nr_lines++;</a>
<a name="ln3546">          if (flags &amp; PUT_FIXINDENT) {</a>
<a name="ln3547">            old_pos = curwin-&gt;w_cursor;</a>
<a name="ln3548">            curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3549">            ptr = ml_get(lnum);</a>
<a name="ln3550">            if (cnt == count &amp;&amp; i == y_size - 1) {</a>
<a name="ln3551">              lendiff = (int)strlen(ptr);</a>
<a name="ln3552">            }</a>
<a name="ln3553">            if (*ptr == '#' &amp;&amp; preprocs_left()) {</a>
<a name="ln3554">              indent = 0;                   // Leave # lines at start</a>
<a name="ln3555">            } else if (*ptr == NUL) {</a>
<a name="ln3556">              indent = 0;                   // Ignore empty lines</a>
<a name="ln3557">            } else if (first_indent) {</a>
<a name="ln3558">              indent_diff = orig_indent - get_indent();</a>
<a name="ln3559">              indent = orig_indent;</a>
<a name="ln3560">              first_indent = false;</a>
<a name="ln3561">            } else if ((indent = get_indent() + indent_diff) &lt; 0) {</a>
<a name="ln3562">              indent = 0;</a>
<a name="ln3563">            }</a>
<a name="ln3564">            (void)set_indent(indent, SIN_NOMARK);</a>
<a name="ln3565">            curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3566">            // remember how many chars were removed</a>
<a name="ln3567">            if (cnt == count &amp;&amp; i == y_size - 1) {</a>
<a name="ln3568">              lendiff -= (int)strlen(ml_get(lnum));</a>
<a name="ln3569">            }</a>
<a name="ln3570">          }</a>
<a name="ln3571">        }</a>
<a name="ln3572"> </a>
<a name="ln3573">        bcount_t totsize = 0;</a>
<a name="ln3574">        int lastsize = 0;</a>
<a name="ln3575">        if (y_type == kMTCharWise</a>
<a name="ln3576">            || (y_type == kMTLineWise &amp;&amp; flags &amp; PUT_LINE_SPLIT)) {</a>
<a name="ln3577">          for (i = 0; i &lt; y_size - 1; i++) {</a>
<a name="ln3578">            totsize += (bcount_t)strlen(y_array[i]) + 1;</a>
<a name="ln3579">          }</a>
<a name="ln3580">          lastsize = (int)strlen(y_array[y_size - 1]);</a>
<a name="ln3581">          totsize += lastsize;</a>
<a name="ln3582">        }</a>
<a name="ln3583">        if (y_type == kMTCharWise) {</a>
<a name="ln3584">          extmark_splice(curbuf, (int)new_cursor.lnum - 1, col, 0, 0, 0,</a>
<a name="ln3585">                         (int)y_size - 1, lastsize, totsize,</a>
<a name="ln3586">                         kExtmarkUndo);</a>
<a name="ln3587">        } else if (y_type == kMTLineWise &amp;&amp; flags &amp; PUT_LINE_SPLIT) {</a>
<a name="ln3588">          // Account for last pasted NL + last NL</a>
<a name="ln3589">          extmark_splice(curbuf, (int)new_cursor.lnum - 1, col + 1, 0, 0, 0,</a>
<a name="ln3590">                         (int)y_size + 1, 0, totsize + 2, kExtmarkUndo);</a>
<a name="ln3591">        }</a>
<a name="ln3592"> </a>
<a name="ln3593">        if (cnt == 1) {</a>
<a name="ln3594">          new_lnum = lnum;</a>
<a name="ln3595">        }</a>
<a name="ln3596">      }</a>
<a name="ln3597"> </a>
<a name="ln3598">error:</a>
<a name="ln3599">      // Adjust marks.</a>
<a name="ln3600">      if (y_type == kMTLineWise) {</a>
<a name="ln3601">        curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln3602">        if (dir == FORWARD) {</a>
<a name="ln3603">          curbuf-&gt;b_op_start.lnum++;</a>
<a name="ln3604">        }</a>
<a name="ln3605">      }</a>
<a name="ln3606"> </a>
<a name="ln3607">      ExtmarkOp kind = (y_type == kMTLineWise &amp;&amp; !(flags &amp; PUT_LINE_SPLIT))</a>
<a name="ln3608">                       ? kExtmarkUndo : kExtmarkNOOP;</a>
<a name="ln3609">      mark_adjust(curbuf-&gt;b_op_start.lnum + (y_type == kMTCharWise),</a>
<a name="ln3610">                  (linenr_T)MAXLNUM, nr_lines, 0L, kind);</a>
<a name="ln3611"> </a>
<a name="ln3612">      // note changed text for displaying and folding</a>
<a name="ln3613">      if (y_type == kMTCharWise) {</a>
<a name="ln3614">        changed_lines(curwin-&gt;w_cursor.lnum, col,</a>
<a name="ln3615">                      curwin-&gt;w_cursor.lnum + 1, nr_lines, true);</a>
<a name="ln3616">      } else {</a>
<a name="ln3617">        changed_lines(curbuf-&gt;b_op_start.lnum, 0,</a>
<a name="ln3618">                      curbuf-&gt;b_op_start.lnum, nr_lines, true);</a>
<a name="ln3619">      }</a>
<a name="ln3620"> </a>
<a name="ln3621">      // Put the '] mark on the first byte of the last inserted character.</a>
<a name="ln3622">      // Correct the length for change in indent.</a>
<a name="ln3623">      curbuf-&gt;b_op_end.lnum = new_lnum;</a>
<a name="ln3624">      len = strlen(y_array[y_size - 1]);</a>
<a name="ln3625">      col = (colnr_T)len - lendiff;</a>
<a name="ln3626">      if (col &gt; 1) {</a>
<a name="ln3627">        curbuf-&gt;b_op_end.col = col - 1;</a>
<a name="ln3628">        if (len &gt; 0) {</a>
<a name="ln3629">          curbuf-&gt;b_op_end.col -= utf_head_off(y_array[y_size - 1],</a>
<a name="ln3630">                                               y_array[y_size - 1] + len - 1);</a>
<a name="ln3631">        }</a>
<a name="ln3632">      } else {</a>
<a name="ln3633">        curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln3634">      }</a>
<a name="ln3635"> </a>
<a name="ln3636">      if (flags &amp; PUT_CURSLINE) {</a>
<a name="ln3637">        // &quot;:put&quot;: put cursor on last inserted line</a>
<a name="ln3638">        curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3639">        beginline(BL_WHITE | BL_FIX);</a>
<a name="ln3640">      } else if (flags &amp; PUT_CURSEND) {</a>
<a name="ln3641">        // put cursor after inserted text</a>
<a name="ln3642">        if (y_type == kMTLineWise) {</a>
<a name="ln3643">          if (lnum &gt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3644">            curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3645">          } else {</a>
<a name="ln3646">            curwin-&gt;w_cursor.lnum = lnum + 1;</a>
<a name="ln3647">          }</a>
<a name="ln3648">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3649">        } else {</a>
<a name="ln3650">          curwin-&gt;w_cursor.lnum = new_lnum;</a>
<a name="ln3651">          curwin-&gt;w_cursor.col = col;</a>
<a name="ln3652">          curbuf-&gt;b_op_end = curwin-&gt;w_cursor;</a>
<a name="ln3653">          if (col &gt; 1) {</a>
<a name="ln3654">            curbuf-&gt;b_op_end.col = col - 1;</a>
<a name="ln3655">          }</a>
<a name="ln3656">        }</a>
<a name="ln3657">      } else if (y_type == kMTLineWise) {</a>
<a name="ln3658">        // put cursor on first non-blank in first inserted line</a>
<a name="ln3659">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3660">        if (dir == FORWARD) {</a>
<a name="ln3661">          curwin-&gt;w_cursor.lnum++;</a>
<a name="ln3662">        }</a>
<a name="ln3663">        beginline(BL_WHITE | BL_FIX);</a>
<a name="ln3664">      } else {  // put cursor on first inserted character</a>
<a name="ln3665">        curwin-&gt;w_cursor = new_cursor;</a>
<a name="ln3666">      }</a>
<a name="ln3667">    }</a>
<a name="ln3668">  }</a>
<a name="ln3669"> </a>
<a name="ln3670">  msgmore(nr_lines);</a>
<a name="ln3671">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln3672"> </a>
<a name="ln3673">end:</a>
<a name="ln3674">  if (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) {</a>
<a name="ln3675">    curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln3676">    curbuf-&gt;b_op_end = orig_end;</a>
<a name="ln3677">  }</a>
<a name="ln3678">  if (allocated) {</a>
<a name="ln3679">    xfree(insert_string);</a>
<a name="ln3680">  }</a>
<a name="ln3681">  if (regname == '=') {</a>
<a name="ln3682">    xfree(y_array);</a>
<a name="ln3683">  }</a>
<a name="ln3684"> </a>
<a name="ln3685">  VIsual_active = false;</a>
<a name="ln3686"> </a>
<a name="ln3687">  // If the cursor is past the end of the line put it at the end.</a>
<a name="ln3688">  adjust_cursor_eol();</a>
<a name="ln3689">}</a>
<a name="ln3690"> </a>
<a name="ln3691">/// When the cursor is on the NUL past the end of the line and it should not be</a>
<a name="ln3692">/// there move it left.</a>
<a name="ln3693">void adjust_cursor_eol(void)</a>
<a name="ln3694">{</a>
<a name="ln3695">  unsigned int cur_ve_flags = get_ve_flags();</a>
<a name="ln3696"> </a>
<a name="ln3697">  if (curwin-&gt;w_cursor.col &gt; 0</a>
<a name="ln3698">      &amp;&amp; gchar_cursor() == NUL</a>
<a name="ln3699">      &amp;&amp; (cur_ve_flags &amp; VE_ONEMORE) == 0</a>
<a name="ln3700">      &amp;&amp; !(restart_edit || (State &amp; MODE_INSERT))) {</a>
<a name="ln3701">    // Put the cursor on the last character in the line.</a>
<a name="ln3702">    dec_cursor();</a>
<a name="ln3703"> </a>
<a name="ln3704">    if (cur_ve_flags == VE_ALL) {</a>
<a name="ln3705">      colnr_T scol, ecol;</a>
<a name="ln3706"> </a>
<a name="ln3707">      // Coladd is set to the width of the last character.</a>
<a name="ln3708">      getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;scol, NULL, &amp;ecol);</a>
<a name="ln3709">      curwin-&gt;w_cursor.coladd = ecol - scol + 1;</a>
<a name="ln3710">    }</a>
<a name="ln3711">  }</a>
<a name="ln3712">}</a>
<a name="ln3713"> </a>
<a name="ln3714">/// @return  true if lines starting with '#' should be left aligned.</a>
<a name="ln3715">int preprocs_left(void)</a>
<a name="ln3716">{</a>
<a name="ln3717">  return ((curbuf-&gt;b_p_si &amp;&amp; !curbuf-&gt;b_p_cin)</a>
<a name="ln3718">          || (curbuf-&gt;b_p_cin &amp;&amp; in_cinkeys('#', ' ', true)</a>
<a name="ln3719">              &amp;&amp; curbuf-&gt;b_ind_hash_comment == 0));</a>
<a name="ln3720">}</a>
<a name="ln3721"> </a>
<a name="ln3722">/// @return  the character name of the register with the given number</a>
<a name="ln3723">int get_register_name(int num)</a>
<a name="ln3724">{</a>
<a name="ln3725">  if (num == -1) {</a>
<a name="ln3726">    return '&quot;';</a>
<a name="ln3727">  } else if (num &lt; 10) {</a>
<a name="ln3728">    return num + '0';</a>
<a name="ln3729">  } else if (num == DELETION_REGISTER) {</a>
<a name="ln3730">    return '-';</a>
<a name="ln3731">  } else if (num == STAR_REGISTER) {</a>
<a name="ln3732">    return '*';</a>
<a name="ln3733">  } else if (num == PLUS_REGISTER) {</a>
<a name="ln3734">    return '+';</a>
<a name="ln3735">  } else {</a>
<a name="ln3736">    return num + 'a' - 10;</a>
<a name="ln3737">  }</a>
<a name="ln3738">}</a>
<a name="ln3739"> </a>
<a name="ln3740">/// @return the index of the register &quot;&quot; points to.</a>
<a name="ln3741">int get_unname_register(void)</a>
<a name="ln3742">{</a>
<a name="ln3743">  return y_previous == NULL ? -1 : (int)(y_previous - &amp;y_regs[0]);</a>
<a name="ln3744">}</a>
<a name="ln3745"> </a>
<a name="ln3746">/// &quot;:dis&quot; and &quot;:registers&quot;: Display the contents of the yank registers.</a>
<a name="ln3747">void ex_display(exarg_T *eap)</a>
<a name="ln3748">{</a>
<a name="ln3749">  char_u *p;</a>
<a name="ln3750">  yankreg_T *yb;</a>
<a name="ln3751">  int name;</a>
<a name="ln3752">  char_u *arg = (char_u *)eap-&gt;arg;</a>
<a name="ln3753">  int clen;</a>
<a name="ln3754">  int type;</a>
<a name="ln3755"> </a>
<a name="ln3756">  if (arg != NULL &amp;&amp; *arg == NUL) {</a>
<a name="ln3757">    arg = NULL;</a>
<a name="ln3758">  }</a>
<a name="ln3759">  int attr = HL_ATTR(HLF_8);</a>
<a name="ln3760"> </a>
<a name="ln3761">  // Highlight title</a>
<a name="ln3762">  msg_puts_title(_(&quot;\nType Name Content&quot;));</a>
<a name="ln3763">  for (int i = -1; i &lt; NUM_REGISTERS &amp;&amp; !got_int; i++) {</a>
<a name="ln3764">    name = get_register_name(i);</a>
<a name="ln3765">    switch (get_reg_type(name, NULL)) {</a>
<a name="ln3766">    case kMTLineWise:</a>
<a name="ln3767">      type = 'l'; break;</a>
<a name="ln3768">    case kMTCharWise:</a>
<a name="ln3769">      type = 'c'; break;</a>
<a name="ln3770">    default:</a>
<a name="ln3771">      type = 'b'; break;</a>
<a name="ln3772">    }</a>
<a name="ln3773"> </a>
<a name="ln3774">    if (arg != NULL &amp;&amp; vim_strchr((char *)arg, name) == NULL) {</a>
<a name="ln3775">      continue;             // did not ask for this register</a>
<a name="ln3776">    }</a>
<a name="ln3777"> </a>
<a name="ln3778">    if (i == -1) {</a>
<a name="ln3779">      if (y_previous != NULL) {</a>
<a name="ln3780">        yb = y_previous;</a>
<a name="ln3781">      } else {</a>
<a name="ln3782">        yb = &amp;(y_regs[0]);</a>
<a name="ln3783">      }</a>
<a name="ln3784">    } else {</a>
<a name="ln3785">      yb = &amp;(y_regs[i]);</a>
<a name="ln3786">    }</a>
<a name="ln3787"> </a>
<a name="ln3788">    get_clipboard(name, &amp;yb, true);</a>
<a name="ln3789"> </a>
<a name="ln3790">    if (name == mb_tolower(redir_reg)</a>
<a name="ln3791">        || (redir_reg == '&quot;' &amp;&amp; yb == y_previous)) {</a>
<a name="ln3792">      continue;  // do not list register being written to, the</a>
<a name="ln3793">                 // pointer can be freed</a>
<a name="ln3794">    }</a>
<a name="ln3795"> </a>
<a name="ln3796">    if (yb-&gt;y_array != NULL) {</a>
<a name="ln3797">      bool do_show = false;</a>
<a name="ln3798"> </a>
<a name="ln3799">      for (size_t j = 0; !do_show &amp;&amp; j &lt; yb-&gt;y_size; j++) {</a>
<a name="ln3800">        do_show = !message_filtered(yb-&gt;y_array[j]);</a>
<a name="ln3801">      }</a>
<a name="ln3802"> </a>
<a name="ln3803">      if (do_show || yb-&gt;y_size == 0) {</a>
<a name="ln3804">        msg_putchar('\n');</a>
<a name="ln3805">        msg_puts(&quot;  &quot;);</a>
<a name="ln3806">        msg_putchar(type);</a>
<a name="ln3807">        msg_puts(&quot;  &quot;);</a>
<a name="ln3808">        msg_putchar('&quot;');</a>
<a name="ln3809">        msg_putchar(name);</a>
<a name="ln3810">        msg_puts(&quot;   &quot;);</a>
<a name="ln3811"> </a>
<a name="ln3812">        int n = Columns - 11;</a>
<a name="ln3813">        for (size_t j = 0; j &lt; yb-&gt;y_size &amp;&amp; n &gt; 1; j++) {</a>
<a name="ln3814">          if (j) {</a>
<a name="ln3815">            msg_puts_attr(&quot;^J&quot;, attr);</a>
<a name="ln3816">            n -= 2;</a>
<a name="ln3817">          }</a>
<a name="ln3818">          for (p = (char_u *)yb-&gt;y_array[j];</a>
<a name="ln3819">               *p != NUL &amp;&amp; (n -= ptr2cells((char *)p)) &gt;= 0; p++) {  // -V1019</a>
<a name="ln3820">            clen = utfc_ptr2len((char *)p);</a>
<a name="ln3821">            msg_outtrans_len((char *)p, clen);</a>
<a name="ln3822">            p += clen - 1;</a>
<a name="ln3823">          }</a>
<a name="ln3824">        }</a>
<a name="ln3825">        if (n &gt; 1 &amp;&amp; yb-&gt;y_type == kMTLineWise) {</a>
<a name="ln3826">          msg_puts_attr(&quot;^J&quot;, attr);</a>
<a name="ln3827">        }</a>
<a name="ln3828">      }</a>
<a name="ln3829">      os_breakcheck();</a>
<a name="ln3830">    }</a>
<a name="ln3831">  }</a>
<a name="ln3832"> </a>
<a name="ln3833">  // display last inserted text</a>
<a name="ln3834">  if ((p = get_last_insert()) != NULL</a>
<a name="ln3835">      &amp;&amp; (arg == NULL || vim_strchr((char *)arg, '.') != NULL) &amp;&amp; !got_int</a>
<a name="ln3836">      &amp;&amp; !message_filtered((char *)p)) {</a>
<a name="ln3837">    msg_puts(&quot;\n  c  \&quot;.   &quot;);</a>
<a name="ln3838">    dis_msg((char *)p, true);</a>
<a name="ln3839">  }</a>
<a name="ln3840"> </a>
<a name="ln3841">  // display last command line</a>
<a name="ln3842">  if (last_cmdline != NULL &amp;&amp; (arg == NULL || vim_strchr((char *)arg, ':') != NULL)</a>
<a name="ln3843">      &amp;&amp; !got_int &amp;&amp; !message_filtered(last_cmdline)) {</a>
<a name="ln3844">    msg_puts(&quot;\n  c  \&quot;:   &quot;);</a>
<a name="ln3845">    dis_msg(last_cmdline, false);</a>
<a name="ln3846">  }</a>
<a name="ln3847"> </a>
<a name="ln3848">  // display current file name</a>
<a name="ln3849">  if (curbuf-&gt;b_fname != NULL</a>
<a name="ln3850">      &amp;&amp; (arg == NULL || vim_strchr((char *)arg, '%') != NULL) &amp;&amp; !got_int</a>
<a name="ln3851">      &amp;&amp; !message_filtered(curbuf-&gt;b_fname)) {</a>
<a name="ln3852">    msg_puts(&quot;\n  c  \&quot;%   &quot;);</a>
<a name="ln3853">    dis_msg(curbuf-&gt;b_fname, false);</a>
<a name="ln3854">  }</a>
<a name="ln3855"> </a>
<a name="ln3856">  // display alternate file name</a>
<a name="ln3857">  if ((arg == NULL || vim_strchr((char *)arg, '%') != NULL) &amp;&amp; !got_int) {</a>
<a name="ln3858">    char *fname;</a>
<a name="ln3859">    linenr_T dummy;</a>
<a name="ln3860"> </a>
<a name="ln3861">    if (buflist_name_nr(0, &amp;fname, &amp;dummy) != FAIL &amp;&amp; !message_filtered(fname)) {</a>
<a name="ln3862">      msg_puts(&quot;\n  c  \&quot;#   &quot;);</a>
<a name="ln3863">      dis_msg(fname, false);</a>
<a name="ln3864">    }</a>
<a name="ln3865">  }</a>
<a name="ln3866"> </a>
<a name="ln3867">  // display last search pattern</a>
<a name="ln3868">  if (last_search_pat() != NULL</a>
<a name="ln3869">      &amp;&amp; (arg == NULL || vim_strchr((char *)arg, '/') != NULL) &amp;&amp; !got_int</a>
<a name="ln3870">      &amp;&amp; !message_filtered((char *)last_search_pat())) {</a>
<a name="ln3871">    msg_puts(&quot;\n  c  \&quot;/   &quot;);</a>
<a name="ln3872">    dis_msg((char *)last_search_pat(), false);</a>
<a name="ln3873">  }</a>
<a name="ln3874"> </a>
<a name="ln3875">  // display last used expression</a>
<a name="ln3876">  if (expr_line != NULL &amp;&amp; (arg == NULL || vim_strchr((char *)arg, '=') != NULL)</a>
<a name="ln3877">      &amp;&amp; !got_int &amp;&amp; !message_filtered((char *)expr_line)) {</a>
<a name="ln3878">    msg_puts(&quot;\n  c  \&quot;=   &quot;);</a>
<a name="ln3879">    dis_msg((char *)expr_line, false);</a>
<a name="ln3880">  }</a>
<a name="ln3881">}</a>
<a name="ln3882"> </a>
<a name="ln3883">/// display a string for do_dis()</a>
<a name="ln3884">/// truncate at end of screen line</a>
<a name="ln3885">///</a>
<a name="ln3886">/// @param skip_esc  if true, ignore trailing ESC</a>
<a name="ln3887">static void dis_msg(const char *p, bool skip_esc)</a>
<a name="ln3888">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3889">{</a>
<a name="ln3890">  int n;</a>
<a name="ln3891">  int l;</a>
<a name="ln3892"> </a>
<a name="ln3893">  n = Columns - 6;</a>
<a name="ln3894">  while (*p != NUL</a>
<a name="ln3895">         &amp;&amp; !(*p == ESC &amp;&amp; skip_esc &amp;&amp; *(p + 1) == NUL)</a>
<a name="ln3896">         &amp;&amp; (n -= ptr2cells(p)) &gt;= 0) {</a>
<a name="ln3897">    if ((l = utfc_ptr2len(p)) &gt; 1) {</a>
<a name="ln3898">      msg_outtrans_len(p, l);</a>
<a name="ln3899">      p += l;</a>
<a name="ln3900">    } else {</a>
<a name="ln3901">      msg_outtrans_len(p++, 1);</a>
<a name="ln3902">    }</a>
<a name="ln3903">  }</a>
<a name="ln3904">  os_breakcheck();</a>
<a name="ln3905">}</a>
<a name="ln3906"> </a>
<a name="ln3907">/// If \p &quot;process&quot; is true and the line begins with a comment leader (possibly</a>
<a name="ln3908">/// after some white space), return a pointer to the text after it.</a>
<a name="ln3909">/// Put a boolean value indicating whether the line ends with an unclosed</a>
<a name="ln3910">/// comment in &quot;is_comment&quot;.</a>
<a name="ln3911">///</a>
<a name="ln3912">/// @param line - line to be processed</a>
<a name="ln3913">/// @param process - if false, will only check whether the line ends</a>
<a name="ln3914">///         with an unclosed comment,</a>
<a name="ln3915">/// @param include_space - whether to skip space following the comment leader</a>
<a name="ln3916">/// @param[out] is_comment - whether the current line ends with an unclosed</a>
<a name="ln3917">///  comment.</a>
<a name="ln3918">char *skip_comment(char *line, bool process, bool include_space, bool *is_comment)</a>
<a name="ln3919">{</a>
<a name="ln3920">  char *comment_flags = NULL;</a>
<a name="ln3921">  int lead_len;</a>
<a name="ln3922">  int leader_offset = get_last_leader_offset(line, &amp;comment_flags);</a>
<a name="ln3923"> </a>
<a name="ln3924">  *is_comment = false;</a>
<a name="ln3925">  if (leader_offset != -1) {</a>
<a name="ln3926">    // Let's check whether the line ends with an unclosed comment.</a>
<a name="ln3927">    // If the last comment leader has COM_END in flags, there's no comment.</a>
<a name="ln3928">    while (*comment_flags) {</a>
<a name="ln3929">      if (*comment_flags == COM_END</a>
<a name="ln3930">          || *comment_flags == ':') {</a>
<a name="ln3931">        break;</a>
<a name="ln3932">      }</a>
<a name="ln3933">      comment_flags++;</a>
<a name="ln3934">    }</a>
<a name="ln3935">    if (*comment_flags != COM_END) {</a>
<a name="ln3936">      *is_comment = true;</a>
<a name="ln3937">    }</a>
<a name="ln3938">  }</a>
<a name="ln3939"> </a>
<a name="ln3940">  if (process == false) {</a>
<a name="ln3941">    return line;</a>
<a name="ln3942">  }</a>
<a name="ln3943"> </a>
<a name="ln3944">  lead_len = get_leader_len(line, &amp;comment_flags, false, include_space);</a>
<a name="ln3945"> </a>
<a name="ln3946">  if (lead_len == 0) {</a>
<a name="ln3947">    return line;</a>
<a name="ln3948">  }</a>
<a name="ln3949"> </a>
<a name="ln3950">  // Find:</a>
<a name="ln3951">  // - COM_END,</a>
<a name="ln3952">  // - colon,</a>
<a name="ln3953">  // whichever comes first.</a>
<a name="ln3954">  while (*comment_flags) {</a>
<a name="ln3955">    if (*comment_flags == COM_END</a>
<a name="ln3956">        || *comment_flags == ':') {</a>
<a name="ln3957">      break;</a>
<a name="ln3958">    }</a>
<a name="ln3959">    comment_flags++;</a>
<a name="ln3960">  }</a>
<a name="ln3961"> </a>
<a name="ln3962">  // If we found a colon, it means that we are not processing a line</a>
<a name="ln3963">  // starting with a closing part of a three-part comment. That's good,</a>
<a name="ln3964">  // because we don't want to remove those as this would be annoying.</a>
<a name="ln3965">  if (*comment_flags == ':' || *comment_flags == NUL) {</a>
<a name="ln3966">    line += lead_len;</a>
<a name="ln3967">  }</a>
<a name="ln3968"> </a>
<a name="ln3969">  return line;</a>
<a name="ln3970">}</a>
<a name="ln3971"> </a>
<a name="ln3972">/// @param count              number of lines (minimal 2) to join at cursor position.</a>
<a name="ln3973">/// @param save_undo          when true, save lines for undo first.</a>
<a name="ln3974">/// @param use_formatoptions  set to false when e.g. processing backspace and comment</a>
<a name="ln3975">///                           leaders should not be removed.</a>
<a name="ln3976">/// @param setmark            when true, sets the '[ and '] mark, else, the caller is expected</a>
<a name="ln3977">///                           to set those marks.</a>
<a name="ln3978">///</a>
<a name="ln3979">/// @return  FAIL for failure, OK otherwise</a>
<a name="ln3980">int do_join(size_t count, int insert_space, int save_undo, int use_formatoptions, bool setmark)</a>
<a name="ln3981">{</a>
<a name="ln3982">  char *curr = NULL;</a>
<a name="ln3983">  char *curr_start = NULL;</a>
<a name="ln3984">  char *cend;</a>
<a name="ln3985">  char *newp;</a>
<a name="ln3986">  char *spaces;          // number of spaces inserted before a line</a>
<a name="ln3987">  int endcurr1 = NUL;</a>
<a name="ln3988">  int endcurr2 = NUL;</a>
<a name="ln3989">  int currsize = 0;             // size of the current line</a>
<a name="ln3990">  int sumsize = 0;              // size of the long new line</a>
<a name="ln3991">  linenr_T t;</a>
<a name="ln3992">  colnr_T col = 0;</a>
<a name="ln3993">  int ret = OK;</a>
<a name="ln3994">  int *comments = NULL;</a>
<a name="ln3995">  int remove_comments = (use_formatoptions == true)</a>
<a name="ln3996">                        &amp;&amp; has_format_option(FO_REMOVE_COMS);</a>
<a name="ln3997">  bool prev_was_comment = false;</a>
<a name="ln3998">  assert(count &gt;= 1);</a>
<a name="ln3999"> </a>
<a name="ln4000">  if (save_undo &amp;&amp; u_save(curwin-&gt;w_cursor.lnum - 1,</a>
<a name="ln4001">                          curwin-&gt;w_cursor.lnum + (linenr_T)count) == FAIL) {</a>
<a name="ln4002">    return FAIL;</a>
<a name="ln4003">  }</a>
<a name="ln4004">  // Allocate an array to store the number of spaces inserted before each</a>
<a name="ln4005">  // line.  We will use it to pre-compute the length of the new line and the</a>
<a name="ln4006">  // proper placement of each original line in the new one.</a>
<a name="ln4007">  spaces = xcalloc(count, 1);</a>
<a name="ln4008">  if (remove_comments) {</a>
<a name="ln4009">    comments = xcalloc(count, sizeof(*comments));</a>
<a name="ln4010">  }</a>
<a name="ln4011"> </a>
<a name="ln4012">  // Don't move anything, just compute the final line length</a>
<a name="ln4013">  // and setup the array of space strings lengths</a>
<a name="ln4014">  for (t = 0; t &lt; (linenr_T)count; t++) {</a>
<a name="ln4015">    curr_start = ml_get((linenr_T)(curwin-&gt;w_cursor.lnum + t));</a>
<a name="ln4016">    curr = curr_start;</a>
<a name="ln4017">    if (t == 0 &amp;&amp; setmark &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln4018">      // Set the '[ mark.</a>
<a name="ln4019">      curwin-&gt;w_buffer-&gt;b_op_start.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4020">      curwin-&gt;w_buffer-&gt;b_op_start.col = (colnr_T)strlen(curr);</a>
<a name="ln4021">    }</a>
<a name="ln4022">    if (remove_comments) {</a>
<a name="ln4023">      // We don't want to remove the comment leader if the</a>
<a name="ln4024">      // previous line is not a comment.</a>
<a name="ln4025">      if (t &gt; 0 &amp;&amp; prev_was_comment) {</a>
<a name="ln4026">        char *new_curr = skip_comment(curr, true, insert_space, &amp;prev_was_comment);</a>
<a name="ln4027">        comments[t] = (int)(new_curr - curr);</a>
<a name="ln4028">        curr = new_curr;</a>
<a name="ln4029">      } else {</a>
<a name="ln4030">        curr = skip_comment(curr, false, insert_space, &amp;prev_was_comment);</a>
<a name="ln4031">      }</a>
<a name="ln4032">    }</a>
<a name="ln4033"> </a>
<a name="ln4034">    if (insert_space &amp;&amp; t &gt; 0) {</a>
<a name="ln4035">      curr = skipwhite(curr);</a>
<a name="ln4036">      if (*curr != NUL</a>
<a name="ln4037">          &amp;&amp; *curr != ')'</a>
<a name="ln4038">          &amp;&amp; sumsize != 0</a>
<a name="ln4039">          &amp;&amp; endcurr1 != TAB</a>
<a name="ln4040">          &amp;&amp; (!has_format_option(FO_MBYTE_JOIN)</a>
<a name="ln4041">              || (utf_ptr2char(curr) &lt; 0x100 &amp;&amp; endcurr1 &lt; 0x100))</a>
<a name="ln4042">          &amp;&amp; (!has_format_option(FO_MBYTE_JOIN2)</a>
<a name="ln4043">              || (utf_ptr2char(curr) &lt; 0x100 &amp;&amp; !utf_eat_space(endcurr1))</a>
<a name="ln4044">              || (endcurr1 &lt; 0x100</a>
<a name="ln4045">                  &amp;&amp; !utf_eat_space(utf_ptr2char(curr))))) {</a>
<a name="ln4046">        // don't add a space if the line is ending in a space</a>
<a name="ln4047">        if (endcurr1 == ' ') {</a>
<a name="ln4048">          endcurr1 = endcurr2;</a>
<a name="ln4049">        } else {</a>
<a name="ln4050">          spaces[t]++;</a>
<a name="ln4051">        }</a>
<a name="ln4052">        // Extra space when 'joinspaces' set and line ends in '.', '?', or '!'.</a>
<a name="ln4053">        if (p_js &amp;&amp; (endcurr1 == '.' || endcurr1 == '?' || endcurr1 == '!')) {</a>
<a name="ln4054">          spaces[t]++;</a>
<a name="ln4055">        }</a>
<a name="ln4056">      }</a>
<a name="ln4057">    }</a>
<a name="ln4058"> </a>
<a name="ln4059">    if (t &gt; 0 &amp;&amp; curbuf_splice_pending == 0) {</a>
<a name="ln4060">      colnr_T removed = (int)(curr - curr_start);</a>
<a name="ln4061">      extmark_splice(curbuf, (int)curwin-&gt;w_cursor.lnum - 1, sumsize,</a>
<a name="ln4062">                     1, removed, removed + 1,</a>
<a name="ln4063">                     0, spaces[t], spaces[t],</a>
<a name="ln4064">                     kExtmarkUndo);</a>
<a name="ln4065">    }</a>
<a name="ln4066">    currsize = (int)strlen(curr);</a>
<a name="ln4067">    sumsize += currsize + spaces[t];</a>
<a name="ln4068">    endcurr1 = endcurr2 = NUL;</a>
<a name="ln4069">    if (insert_space &amp;&amp; currsize &gt; 0) {</a>
<a name="ln4070">      cend = curr + currsize;</a>
<a name="ln4071">      MB_PTR_BACK(curr, cend);</a>
<a name="ln4072">      endcurr1 = utf_ptr2char(cend);</a>
<a name="ln4073">      if (cend &gt; curr) {</a>
<a name="ln4074">        MB_PTR_BACK(curr, cend);</a>
<a name="ln4075">        endcurr2 = utf_ptr2char(cend);</a>
<a name="ln4076">      }</a>
<a name="ln4077">    }</a>
<a name="ln4078">    line_breakcheck();</a>
<a name="ln4079">    if (got_int) {</a>
<a name="ln4080">      ret = FAIL;</a>
<a name="ln4081">      goto theend;</a>
<a name="ln4082">    }</a>
<a name="ln4083">  }</a>
<a name="ln4084"> </a>
<a name="ln4085">  // store the column position before last line</a>
<a name="ln4086">  col = sumsize - currsize - spaces[count - 1];</a>
<a name="ln4087"> </a>
<a name="ln4088">  // allocate the space for the new line</a>
<a name="ln4089">  newp = xmalloc((size_t)sumsize + 1);</a>
<a name="ln4090">  cend = newp + sumsize;</a>
<a name="ln4091">  *cend = 0;</a>
<a name="ln4092"> </a>
<a name="ln4093">  // Move affected lines to the new long one.</a>
<a name="ln4094">  //</a>
<a name="ln4095">  // Move marks from each deleted line to the joined line, adjusting the</a>
<a name="ln4096">  // column.  This is not Vi compatible, but Vi deletes the marks, thus that</a>
<a name="ln4097">  // should not really be a problem.</a>
<a name="ln4098"> </a>
<a name="ln4099">  curbuf_splice_pending++;</a>
<a name="ln4100"> </a>
<a name="ln4101">  for (t = (linenr_T)count - 1;; t--) {</a>
<a name="ln4102">    cend -= currsize;</a>
<a name="ln4103">    memmove(cend, curr, (size_t)currsize);</a>
<a name="ln4104">    if (spaces[t] &gt; 0) {</a>
<a name="ln4105">      cend -= spaces[t];</a>
<a name="ln4106">      memset(cend, ' ', (size_t)(spaces[t]));</a>
<a name="ln4107">    }</a>
<a name="ln4108"> </a>
<a name="ln4109">    // If deleting more spaces than adding, the cursor moves no more than</a>
<a name="ln4110">    // what is added if it is inside these spaces.</a>
<a name="ln4111">    const int spaces_removed = (int)((curr - curr_start) - spaces[t]);</a>
<a name="ln4112">    linenr_T lnum = curwin-&gt;w_cursor.lnum + t;</a>
<a name="ln4113">    colnr_T mincol = (colnr_T)0;</a>
<a name="ln4114">    linenr_T lnum_amount = -t;</a>
<a name="ln4115">    long col_amount = (cend - newp - spaces_removed);</a>
<a name="ln4116"> </a>
<a name="ln4117">    mark_col_adjust(lnum, mincol, lnum_amount, col_amount, spaces_removed);</a>
<a name="ln4118"> </a>
<a name="ln4119">    if (t == 0) {</a>
<a name="ln4120">      break;</a>
<a name="ln4121">    }</a>
<a name="ln4122"> </a>
<a name="ln4123">    curr_start = ml_get((linenr_T)(curwin-&gt;w_cursor.lnum + t - 1));</a>
<a name="ln4124">    curr = curr_start;</a>
<a name="ln4125">    if (remove_comments) {</a>
<a name="ln4126">      curr += comments[t - 1];</a>
<a name="ln4127">    }</a>
<a name="ln4128">    if (insert_space &amp;&amp; t &gt; 1) {</a>
<a name="ln4129">      curr = skipwhite(curr);</a>
<a name="ln4130">    }</a>
<a name="ln4131">    currsize = (int)strlen(curr);</a>
<a name="ln4132">  }</a>
<a name="ln4133"> </a>
<a name="ln4134">  ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln4135"> </a>
<a name="ln4136">  if (setmark &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln4137">    // Set the '] mark.</a>
<a name="ln4138">    curwin-&gt;w_buffer-&gt;b_op_end.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4139">    curwin-&gt;w_buffer-&gt;b_op_end.col = sumsize;</a>
<a name="ln4140">  }</a>
<a name="ln4141"> </a>
<a name="ln4142">  // Only report the change in the first line here, del_lines() will report</a>
<a name="ln4143">  // the deleted line.</a>
<a name="ln4144">  changed_lines(curwin-&gt;w_cursor.lnum, currsize,</a>
<a name="ln4145">                curwin-&gt;w_cursor.lnum + 1, 0L, true);</a>
<a name="ln4146"> </a>
<a name="ln4147">  // Delete following lines. To do this we move the cursor there</a>
<a name="ln4148">  // briefly, and then move it back. After del_lines() the cursor may</a>
<a name="ln4149">  // have moved up (last line deleted), so the current lnum is kept in t.</a>
<a name="ln4150">  t = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4151">  curwin-&gt;w_cursor.lnum++;</a>
<a name="ln4152">  del_lines((long)count - 1, false);</a>
<a name="ln4153">  curwin-&gt;w_cursor.lnum = t;</a>
<a name="ln4154">  curbuf_splice_pending--;</a>
<a name="ln4155">  curbuf-&gt;deleted_bytes2 = 0;</a>
<a name="ln4156"> </a>
<a name="ln4157">  // Set the cursor column:</a>
<a name="ln4158">  // Vi compatible: use the column of the first join</a>
<a name="ln4159">  // vim:             use the column of the last join</a>
<a name="ln4160">  curwin-&gt;w_cursor.col =</a>
<a name="ln4161">    (vim_strchr(p_cpo, CPO_JOINCOL) != NULL ? currsize : col);</a>
<a name="ln4162">  check_cursor_col();</a>
<a name="ln4163"> </a>
<a name="ln4164">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln4165">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln4166"> </a>
<a name="ln4167">theend:</a>
<a name="ln4168">  xfree(spaces);</a>
<a name="ln4169">  if (remove_comments) {</a>
<a name="ln4170">    xfree(comments);</a>
<a name="ln4171">  }</a>
<a name="ln4172">  return ret;</a>
<a name="ln4173">}</a>
<a name="ln4174"> </a>
<a name="ln4175">/// Reset 'linebreak' and take care of side effects.</a>
<a name="ln4176">/// @return  the previous value, to be passed to restore_lbr().</a>
<a name="ln4177">static bool reset_lbr(void)</a>
<a name="ln4178">{</a>
<a name="ln4179">  if (!curwin-&gt;w_p_lbr) {</a>
<a name="ln4180">    return false;</a>
<a name="ln4181">  }</a>
<a name="ln4182">  // changing 'linebreak' may require w_virtcol to be updated</a>
<a name="ln4183">  curwin-&gt;w_p_lbr = false;</a>
<a name="ln4184">  curwin-&gt;w_valid &amp;= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);</a>
<a name="ln4185">  return true;</a>
<a name="ln4186">}</a>
<a name="ln4187"> </a>
<a name="ln4188">/// Restore 'linebreak' and take care of side effects.</a>
<a name="ln4189">static void restore_lbr(bool lbr_saved)</a>
<a name="ln4190">{</a>
<a name="ln4191">  if (!curwin-&gt;w_p_lbr &amp;&amp; lbr_saved) {</a>
<a name="ln4192">    // changing 'linebreak' may require w_virtcol to be updated</a>
<a name="ln4193">    curwin-&gt;w_p_lbr = true;</a>
<a name="ln4194">    curwin-&gt;w_valid &amp;= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);</a>
<a name="ln4195">  }</a>
<a name="ln4196">}</a>
<a name="ln4197"> </a>
<a name="ln4198">/// prepare a few things for block mode yank/delete/tilde</a>
<a name="ln4199">///</a>
<a name="ln4200">/// for delete:</a>
<a name="ln4201">/// - textlen includes the first/last char to be (partly) deleted</a>
<a name="ln4202">/// - start/endspaces is the number of columns that are taken by the</a>
<a name="ln4203">///   first/last deleted char minus the number of columns that have to be</a>
<a name="ln4204">///   deleted.</a>
<a name="ln4205">/// for yank and tilde:</a>
<a name="ln4206">/// - textlen includes the first/last char to be wholly yanked</a>
<a name="ln4207">/// - start/endspaces is the number of columns of the first/last yanked char</a>
<a name="ln4208">///   that are to be yanked.</a>
<a name="ln4209">static void block_prep(oparg_T *oap, struct block_def *bdp, linenr_T lnum, bool is_del)</a>
<a name="ln4210">{</a>
<a name="ln4211">  int incr = 0;</a>
<a name="ln4212">  char *pend;</a>
<a name="ln4213">  char *pstart;</a>
<a name="ln4214">  char *line;</a>
<a name="ln4215">  char *prev_pstart;</a>
<a name="ln4216">  char *prev_pend;</a>
<a name="ln4217">  // Avoid a problem with unwanted linebreaks in block mode.</a>
<a name="ln4218">  const bool lbr_saved = reset_lbr();</a>
<a name="ln4219"> </a>
<a name="ln4220">  bdp-&gt;startspaces = 0;</a>
<a name="ln4221">  bdp-&gt;endspaces = 0;</a>
<a name="ln4222">  bdp-&gt;textlen = 0;</a>
<a name="ln4223">  bdp-&gt;start_vcol = 0;</a>
<a name="ln4224">  bdp-&gt;end_vcol = 0;</a>
<a name="ln4225">  bdp-&gt;is_short = false;</a>
<a name="ln4226">  bdp-&gt;is_oneChar = false;</a>
<a name="ln4227">  bdp-&gt;pre_whitesp = 0;</a>
<a name="ln4228">  bdp-&gt;pre_whitesp_c = 0;</a>
<a name="ln4229">  bdp-&gt;end_char_vcols = 0;</a>
<a name="ln4230">  bdp-&gt;start_char_vcols = 0;</a>
<a name="ln4231"> </a>
<a name="ln4232">  line = ml_get(lnum);</a>
<a name="ln4233">  prev_pstart = line;</a>
<a name="ln4234"> </a>
<a name="ln4235">  chartabsize_T cts;</a>
<a name="ln4236">  init_chartabsize_arg(&amp;cts, curwin, lnum, bdp-&gt;start_vcol, line, line);</a>
<a name="ln4237">  while (cts.cts_vcol &lt; oap-&gt;start_vcol &amp;&amp; *cts.cts_ptr != NUL) {</a>
<a name="ln4238">    // Count a tab for what it's worth (if list mode not on)</a>
<a name="ln4239">    incr = lbr_chartabsize(&amp;cts);</a>
<a name="ln4240">    cts.cts_vcol += incr;</a>
<a name="ln4241">    if (ascii_iswhite(*cts.cts_ptr)) {</a>
<a name="ln4242">      bdp-&gt;pre_whitesp += incr;</a>
<a name="ln4243">      bdp-&gt;pre_whitesp_c++;</a>
<a name="ln4244">    } else {</a>
<a name="ln4245">      bdp-&gt;pre_whitesp = 0;</a>
<a name="ln4246">      bdp-&gt;pre_whitesp_c = 0;</a>
<a name="ln4247">    }</a>
<a name="ln4248">    prev_pstart = cts.cts_ptr;</a>
<a name="ln4249">    MB_PTR_ADV(cts.cts_ptr);</a>
<a name="ln4250">  }</a>
<a name="ln4251">  bdp-&gt;start_vcol = cts.cts_vcol;</a>
<a name="ln4252">  pstart = cts.cts_ptr;</a>
<a name="ln4253">  clear_chartabsize_arg(&amp;cts);</a>
<a name="ln4254"> </a>
<a name="ln4255">  bdp-&gt;start_char_vcols = incr;</a>
<a name="ln4256">  if (bdp-&gt;start_vcol &lt; oap-&gt;start_vcol) {      // line too short</a>
<a name="ln4257">    bdp-&gt;end_vcol = bdp-&gt;start_vcol;</a>
<a name="ln4258">    bdp-&gt;is_short = true;</a>
<a name="ln4259">    if (!is_del || oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln4260">      bdp-&gt;endspaces = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln4261">    }</a>
<a name="ln4262">  } else {</a>
<a name="ln4263">    // notice: this converts partly selected Multibyte characters to</a>
<a name="ln4264">    // spaces, too.</a>
<a name="ln4265">    bdp-&gt;startspaces = bdp-&gt;start_vcol - oap-&gt;start_vcol;</a>
<a name="ln4266">    if (is_del &amp;&amp; bdp-&gt;startspaces) {</a>
<a name="ln4267">      bdp-&gt;startspaces = bdp-&gt;start_char_vcols - bdp-&gt;startspaces;</a>
<a name="ln4268">    }</a>
<a name="ln4269">    pend = pstart;</a>
<a name="ln4270">    bdp-&gt;end_vcol = bdp-&gt;start_vcol;</a>
<a name="ln4271">    if (bdp-&gt;end_vcol &gt; oap-&gt;end_vcol) {  // it's all in one character</a>
<a name="ln4272">      bdp-&gt;is_oneChar = true;</a>
<a name="ln4273">      if (oap-&gt;op_type == OP_INSERT) {</a>
<a name="ln4274">        bdp-&gt;endspaces = bdp-&gt;start_char_vcols - bdp-&gt;startspaces;</a>
<a name="ln4275">      } else if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln4276">        bdp-&gt;startspaces += oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln4277">        bdp-&gt;endspaces = bdp-&gt;start_char_vcols - bdp-&gt;startspaces;</a>
<a name="ln4278">      } else {</a>
<a name="ln4279">        bdp-&gt;startspaces = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln4280">        if (is_del &amp;&amp; oap-&gt;op_type != OP_LSHIFT) {</a>
<a name="ln4281">          // just putting the sum of those two into</a>
<a name="ln4282">          // bdp-&gt;startspaces doesn't work for Visual replace,</a>
<a name="ln4283">          // so we have to split the tab in two</a>
<a name="ln4284">          bdp-&gt;startspaces = bdp-&gt;start_char_vcols</a>
<a name="ln4285">                             - (bdp-&gt;start_vcol - oap-&gt;start_vcol);</a>
<a name="ln4286">          bdp-&gt;endspaces = bdp-&gt;end_vcol - oap-&gt;end_vcol - 1;</a>
<a name="ln4287">        }</a>
<a name="ln4288">      }</a>
<a name="ln4289">    } else {</a>
<a name="ln4290">      init_chartabsize_arg(&amp;cts, curwin, lnum, bdp-&gt;end_vcol, line, pend);</a>
<a name="ln4291">      prev_pend = pend;</a>
<a name="ln4292">      while (cts.cts_vcol &lt;= oap-&gt;end_vcol &amp;&amp; *cts.cts_ptr != NUL) {</a>
<a name="ln4293">        // Count a tab for what it's worth (if list mode not on)</a>
<a name="ln4294">        prev_pend = cts.cts_ptr;</a>
<a name="ln4295">        incr = lbr_chartabsize_adv(&amp;cts);</a>
<a name="ln4296">        cts.cts_vcol += incr;</a>
<a name="ln4297">      }</a>
<a name="ln4298">      bdp-&gt;end_vcol = cts.cts_vcol;</a>
<a name="ln4299">      pend = cts.cts_ptr;</a>
<a name="ln4300">      clear_chartabsize_arg(&amp;cts);</a>
<a name="ln4301"> </a>
<a name="ln4302">      if (bdp-&gt;end_vcol &lt;= oap-&gt;end_vcol</a>
<a name="ln4303">          &amp;&amp; (!is_del</a>
<a name="ln4304">              || oap-&gt;op_type == OP_APPEND</a>
<a name="ln4305">              || oap-&gt;op_type == OP_REPLACE)) {  // line too short</a>
<a name="ln4306">        bdp-&gt;is_short = true;</a>
<a name="ln4307">        // Alternative: include spaces to fill up the block.</a>
<a name="ln4308">        // Disadvantage: can lead to trailing spaces when the line is</a>
<a name="ln4309">        // short where the text is put</a>
<a name="ln4310">        // if (!is_del || oap-&gt;op_type == OP_APPEND)</a>
<a name="ln4311">        if (oap-&gt;op_type == OP_APPEND || virtual_op) {</a>
<a name="ln4312">          bdp-&gt;endspaces = oap-&gt;end_vcol - bdp-&gt;end_vcol</a>
<a name="ln4313">                           + oap-&gt;inclusive;</a>
<a name="ln4314">        }</a>
<a name="ln4315">      } else if (bdp-&gt;end_vcol &gt; oap-&gt;end_vcol) {</a>
<a name="ln4316">        bdp-&gt;endspaces = bdp-&gt;end_vcol - oap-&gt;end_vcol - 1;</a>
<a name="ln4317">        if (!is_del &amp;&amp; bdp-&gt;endspaces) {</a>
<a name="ln4318">          bdp-&gt;endspaces = incr - bdp-&gt;endspaces;</a>
<a name="ln4319">          if (pend != pstart) {</a>
<a name="ln4320">            pend = prev_pend;</a>
<a name="ln4321">          }</a>
<a name="ln4322">        }</a>
<a name="ln4323">      }</a>
<a name="ln4324">    }</a>
<a name="ln4325">    bdp-&gt;end_char_vcols = incr;</a>
<a name="ln4326">    if (is_del &amp;&amp; bdp-&gt;startspaces) {</a>
<a name="ln4327">      pstart = prev_pstart;</a>
<a name="ln4328">    }</a>
<a name="ln4329">    bdp-&gt;textlen = (int)(pend - pstart);</a>
<a name="ln4330">  }</a>
<a name="ln4331">  bdp-&gt;textcol = (colnr_T)(pstart - line);</a>
<a name="ln4332">  bdp-&gt;textstart = (char_u *)pstart;</a>
<a name="ln4333">  restore_lbr(lbr_saved);</a>
<a name="ln4334">}</a>
<a name="ln4335"> </a>
<a name="ln4336">/// Handle the add/subtract operator.</a>
<a name="ln4337">///</a>
<a name="ln4338">/// @param[in]  oap      Arguments of operator.</a>
<a name="ln4339">/// @param[in]  Prenum1  Amount of addition or subtraction.</a>
<a name="ln4340">/// @param[in]  g_cmd    Prefixed with `g`.</a>
<a name="ln4341">void op_addsub(oparg_T *oap, linenr_T Prenum1, bool g_cmd)</a>
<a name="ln4342">{</a>
<a name="ln4343">  pos_T pos;</a>
<a name="ln4344">  struct block_def bd;</a>
<a name="ln4345">  ssize_t change_cnt = 0;</a>
<a name="ln4346">  linenr_T amount = Prenum1;</a>
<a name="ln4347"> </a>
<a name="ln4348">  // do_addsub() might trigger re-evaluation of 'foldexpr' halfway, when the</a>
<a name="ln4349">  // buffer is not completely updated yet. Postpone updating folds until before</a>
<a name="ln4350">  // the call to changed_lines().</a>
<a name="ln4351">  disable_fold_update++;</a>
<a name="ln4352"> </a>
<a name="ln4353">  if (!VIsual_active) {</a>
<a name="ln4354">    pos = curwin-&gt;w_cursor;</a>
<a name="ln4355">    if (u_save_cursor() == FAIL) {</a>
<a name="ln4356">      disable_fold_update--;</a>
<a name="ln4357">      return;</a>
<a name="ln4358">    }</a>
<a name="ln4359">    change_cnt = do_addsub(oap-&gt;op_type, &amp;pos, 0, amount);</a>
<a name="ln4360">    disable_fold_update--;</a>
<a name="ln4361">    if (change_cnt) {</a>
<a name="ln4362">      changed_lines(pos.lnum, 0, pos.lnum + 1, 0L, true);</a>
<a name="ln4363">    }</a>
<a name="ln4364">  } else {</a>
<a name="ln4365">    int one_change;</a>
<a name="ln4366">    int length;</a>
<a name="ln4367">    pos_T startpos;</a>
<a name="ln4368"> </a>
<a name="ln4369">    if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln4370">               (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln4371">      disable_fold_update--;</a>
<a name="ln4372">      return;</a>
<a name="ln4373">    }</a>
<a name="ln4374"> </a>
<a name="ln4375">    pos = oap-&gt;start;</a>
<a name="ln4376">    for (; pos.lnum &lt;= oap-&gt;end.lnum; pos.lnum++) {</a>
<a name="ln4377">      if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln4378">        // Visual block mode</a>
<a name="ln4379">        block_prep(oap, &amp;bd, pos.lnum, false);</a>
<a name="ln4380">        pos.col = bd.textcol;</a>
<a name="ln4381">        length = bd.textlen;</a>
<a name="ln4382">      } else if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln4383">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln4384">        pos.col = 0;</a>
<a name="ln4385">        length = (colnr_T)strlen(ml_get(pos.lnum));</a>
<a name="ln4386">      } else {</a>
<a name="ln4387">        // oap-&gt;motion_type == kMTCharWise</a>
<a name="ln4388">        if (pos.lnum == oap-&gt;start.lnum &amp;&amp; !oap-&gt;inclusive) {</a>
<a name="ln4389">          dec(&amp;(oap-&gt;end));</a>
<a name="ln4390">        }</a>
<a name="ln4391">        length = (colnr_T)strlen(ml_get(pos.lnum));</a>
<a name="ln4392">        pos.col = 0;</a>
<a name="ln4393">        if (pos.lnum == oap-&gt;start.lnum) {</a>
<a name="ln4394">          pos.col += oap-&gt;start.col;</a>
<a name="ln4395">          length -= oap-&gt;start.col;</a>
<a name="ln4396">        }</a>
<a name="ln4397">        if (pos.lnum == oap-&gt;end.lnum) {</a>
<a name="ln4398">          length = (int)strlen(ml_get(oap-&gt;end.lnum));</a>
<a name="ln4399">          if (oap-&gt;end.col &gt;= length) {</a>
<a name="ln4400">            oap-&gt;end.col = length - 1;</a>
<a name="ln4401">          }</a>
<a name="ln4402">          length = oap-&gt;end.col - pos.col + 1;</a>
<a name="ln4403">        }</a>
<a name="ln4404">      }</a>
<a name="ln4405">      one_change = do_addsub(oap-&gt;op_type, &amp;pos, length, amount);</a>
<a name="ln4406">      if (one_change) {</a>
<a name="ln4407">        // Remember the start position of the first change.</a>
<a name="ln4408">        if (change_cnt == 0) {</a>
<a name="ln4409">          startpos = curbuf-&gt;b_op_start;</a>
<a name="ln4410">        }</a>
<a name="ln4411">        change_cnt++;</a>
<a name="ln4412">      }</a>
<a name="ln4413"> </a>
<a name="ln4414">      if (g_cmd &amp;&amp; one_change) {</a>
<a name="ln4415">        amount += Prenum1;</a>
<a name="ln4416">      }</a>
<a name="ln4417">    }</a>
<a name="ln4418"> </a>
<a name="ln4419">    disable_fold_update--;</a>
<a name="ln4420">    if (change_cnt) {</a>
<a name="ln4421">      changed_lines(oap-&gt;start.lnum, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln4422">    }</a>
<a name="ln4423"> </a>
<a name="ln4424">    if (!change_cnt &amp;&amp; oap-&gt;is_VIsual) {</a>
<a name="ln4425">      // No change: need to remove the Visual selection</a>
<a name="ln4426">      redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln4427">    }</a>
<a name="ln4428"> </a>
<a name="ln4429">    // Set '[ mark if something changed. Keep the last end</a>
<a name="ln4430">    // position from do_addsub().</a>
<a name="ln4431">    if (change_cnt &gt; 0 &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln4432">      curbuf-&gt;b_op_start = startpos;</a>
<a name="ln4433">    }</a>
<a name="ln4434"> </a>
<a name="ln4435">    if (change_cnt &gt; p_report) {</a>
<a name="ln4436">      smsg(NGETTEXT(&quot;%&quot; PRId64 &quot; lines changed&quot;,</a>
<a name="ln4437">                    &quot;%&quot; PRId64 &quot; lines changed&quot;, change_cnt),</a>
<a name="ln4438">           (int64_t)change_cnt);</a>
<a name="ln4439">    }</a>
<a name="ln4440">  }</a>
<a name="ln4441">}</a>
<a name="ln4442"> </a>
<a name="ln4443">/// Add or subtract from a number in a line.</a>
<a name="ln4444">///</a>
<a name="ln4445">/// @param op_type OP_NR_ADD or OP_NR_SUB.</a>
<a name="ln4446">/// @param pos     Cursor position.</a>
<a name="ln4447">/// @param length  Target number length.</a>
<a name="ln4448">/// @param Prenum1 Amount of addition or subtraction.</a>
<a name="ln4449">///</a>
<a name="ln4450">/// @return true if some character was changed.</a>
<a name="ln4451">int do_addsub(int op_type, pos_T *pos, int length, linenr_T Prenum1)</a>
<a name="ln4452">{</a>
<a name="ln4453">  int col;</a>
<a name="ln4454">  char_u *buf1 = NULL;</a>
<a name="ln4455">  char_u buf2[NUMBUFLEN];</a>
<a name="ln4456">  int pre;  // 'X' or 'x': hex; '0': octal; 'B' or 'b': bin</a>
<a name="ln4457">  static bool hexupper = false;  // 0xABC</a>
<a name="ln4458">  uvarnumber_T n;</a>
<a name="ln4459">  uvarnumber_T oldn;</a>
<a name="ln4460">  char_u *ptr;</a>
<a name="ln4461">  int c;</a>
<a name="ln4462">  int todel;</a>
<a name="ln4463">  int firstdigit;</a>
<a name="ln4464">  bool negative = false;</a>
<a name="ln4465">  bool was_positive = true;</a>
<a name="ln4466">  bool visual = VIsual_active;</a>
<a name="ln4467">  bool did_change = false;</a>
<a name="ln4468">  pos_T save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln4469">  int maxlen = 0;</a>
<a name="ln4470">  pos_T startpos;</a>
<a name="ln4471">  pos_T endpos;</a>
<a name="ln4472">  colnr_T save_coladd = 0;</a>
<a name="ln4473"> </a>
<a name="ln4474">  const bool do_hex = vim_strchr(curbuf-&gt;b_p_nf, 'x') != NULL;    // &quot;heX&quot;</a>
<a name="ln4475">  const bool do_oct = vim_strchr(curbuf-&gt;b_p_nf, 'o') != NULL;    // &quot;Octal&quot;</a>
<a name="ln4476">  const bool do_bin = vim_strchr(curbuf-&gt;b_p_nf, 'b') != NULL;    // &quot;Bin&quot;</a>
<a name="ln4477">  const bool do_alpha = vim_strchr(curbuf-&gt;b_p_nf, 'p') != NULL;  // &quot;alPha&quot;</a>
<a name="ln4478">  // &quot;Unsigned&quot;</a>
<a name="ln4479">  const bool do_unsigned = vim_strchr(curbuf-&gt;b_p_nf, 'u') != NULL;</a>
<a name="ln4480"> </a>
<a name="ln4481">  if (virtual_active()) {</a>
<a name="ln4482">    save_coladd = pos-&gt;coladd;</a>
<a name="ln4483">    pos-&gt;coladd = 0;</a>
<a name="ln4484">  }</a>
<a name="ln4485"> </a>
<a name="ln4486">  curwin-&gt;w_cursor = *pos;</a>
<a name="ln4487">  ptr = (char_u *)ml_get(pos-&gt;lnum);</a>
<a name="ln4488">  col = pos-&gt;col;</a>
<a name="ln4489"> </a>
<a name="ln4490">  if (*ptr == NUL || col + !!save_coladd &gt;= (int)STRLEN(ptr)) {</a>
<a name="ln4491">    goto theend;</a>
<a name="ln4492">  }</a>
<a name="ln4493"> </a>
<a name="ln4494">  // First check if we are on a hexadecimal number, after the &quot;0x&quot;.</a>
<a name="ln4495">  if (!VIsual_active) {</a>
<a name="ln4496">    if (do_bin) {</a>
<a name="ln4497">      while (col &gt; 0 &amp;&amp; ascii_isbdigit(ptr[col])) {</a>
<a name="ln4498">        col--;</a>
<a name="ln4499">        col -= utf_head_off((char *)ptr, (char *)ptr + col);</a>
<a name="ln4500">      }</a>
<a name="ln4501">    }</a>
<a name="ln4502"> </a>
<a name="ln4503">    if (do_hex) {</a>
<a name="ln4504">      while (col &gt; 0 &amp;&amp; ascii_isxdigit(ptr[col])) {</a>
<a name="ln4505">        col--;</a>
<a name="ln4506">        col -= utf_head_off((char *)ptr, (char *)ptr + col);</a>
<a name="ln4507">      }</a>
<a name="ln4508">    }</a>
<a name="ln4509">    if (do_bin</a>
<a name="ln4510">        &amp;&amp; do_hex</a>
<a name="ln4511">        &amp;&amp; !((col &gt; 0</a>
<a name="ln4512">              &amp;&amp; (ptr[col] == 'X' || ptr[col] == 'x')</a>
<a name="ln4513">              &amp;&amp; ptr[col - 1] == '0'</a>
<a name="ln4514">              &amp;&amp; !utf_head_off((char *)ptr, (char *)ptr + col - 1)</a>
<a name="ln4515">              &amp;&amp; ascii_isxdigit(ptr[col + 1])))) {</a>
<a name="ln4516">      // In case of binary/hexadecimal pattern overlap match, rescan</a>
<a name="ln4517"> </a>
<a name="ln4518">      col = curwin-&gt;w_cursor.col;</a>
<a name="ln4519"> </a>
<a name="ln4520">      while (col &gt; 0 &amp;&amp; ascii_isdigit(ptr[col])) {</a>
<a name="ln4521">        col--;</a>
<a name="ln4522">        col -= utf_head_off((char *)ptr, (char *)ptr + col);</a>
<a name="ln4523">      }</a>
<a name="ln4524">    }</a>
<a name="ln4525"> </a>
<a name="ln4526">    if ((do_hex</a>
<a name="ln4527">         &amp;&amp; col &gt; 0</a>
<a name="ln4528">         &amp;&amp; (ptr[col] == 'X' || ptr[col] == 'x')</a>
<a name="ln4529">         &amp;&amp; ptr[col - 1] == '0'</a>
<a name="ln4530">         &amp;&amp; !utf_head_off((char *)ptr, (char *)ptr + col - 1)</a>
<a name="ln4531">         &amp;&amp; ascii_isxdigit(ptr[col + 1]))</a>
<a name="ln4532">        || (do_bin</a>
<a name="ln4533">            &amp;&amp; col &gt; 0</a>
<a name="ln4534">            &amp;&amp; (ptr[col] == 'B' || ptr[col] == 'b')</a>
<a name="ln4535">            &amp;&amp; ptr[col - 1] == '0'</a>
<a name="ln4536">            &amp;&amp; !utf_head_off((char *)ptr, (char *)ptr + col - 1)</a>
<a name="ln4537">            &amp;&amp; ascii_isbdigit(ptr[col + 1]))) {</a>
<a name="ln4538">      // Found hexadecimal or binary number, move to its start.</a>
<a name="ln4539">      col--;</a>
<a name="ln4540">      col -= utf_head_off((char *)ptr, (char *)ptr + col);</a>
<a name="ln4541">    } else {</a>
<a name="ln4542">      // Search forward and then backward to find the start of number.</a>
<a name="ln4543">      col = pos-&gt;col;</a>
<a name="ln4544"> </a>
<a name="ln4545">      while (ptr[col] != NUL</a>
<a name="ln4546">             &amp;&amp; !ascii_isdigit(ptr[col])</a>
<a name="ln4547">             &amp;&amp; !(do_alpha &amp;&amp; ASCII_ISALPHA(ptr[col]))) {</a>
<a name="ln4548">        col++;</a>
<a name="ln4549">      }</a>
<a name="ln4550"> </a>
<a name="ln4551">      while (col &gt; 0</a>
<a name="ln4552">             &amp;&amp; ascii_isdigit(ptr[col - 1])</a>
<a name="ln4553">             &amp;&amp; !(do_alpha &amp;&amp; ASCII_ISALPHA(ptr[col]))) {</a>
<a name="ln4554">        col--;</a>
<a name="ln4555">      }</a>
<a name="ln4556">    }</a>
<a name="ln4557">  }</a>
<a name="ln4558"> </a>
<a name="ln4559">  if (visual) {</a>
<a name="ln4560">    while (ptr[col] != NUL &amp;&amp; length &gt; 0 &amp;&amp; !ascii_isdigit(ptr[col])</a>
<a name="ln4561">           &amp;&amp; !(do_alpha &amp;&amp; ASCII_ISALPHA(ptr[col]))) {</a>
<a name="ln4562">      int mb_len = utfc_ptr2len((char *)ptr + col);</a>
<a name="ln4563"> </a>
<a name="ln4564">      col += mb_len;</a>
<a name="ln4565">      length -= mb_len;</a>
<a name="ln4566">    }</a>
<a name="ln4567"> </a>
<a name="ln4568">    if (length == 0) {</a>
<a name="ln4569">      goto theend;</a>
<a name="ln4570">    }</a>
<a name="ln4571"> </a>
<a name="ln4572">    if (col &gt; pos-&gt;col &amp;&amp; ptr[col - 1] == '-'</a>
<a name="ln4573">        &amp;&amp; !utf_head_off((char *)ptr, (char *)ptr + col - 1)</a>
<a name="ln4574">        &amp;&amp; !do_unsigned) {</a>
<a name="ln4575">      negative = true;</a>
<a name="ln4576">      was_positive = false;</a>
<a name="ln4577">    }</a>
<a name="ln4578">  }</a>
<a name="ln4579"> </a>
<a name="ln4580">  // If a number was found, and saving for undo works, replace the number.</a>
<a name="ln4581">  firstdigit = ptr[col];</a>
<a name="ln4582">  if (!ascii_isdigit(firstdigit) &amp;&amp; !(do_alpha &amp;&amp; ASCII_ISALPHA(firstdigit))) {</a>
<a name="ln4583">    beep_flush();</a>
<a name="ln4584">    goto theend;</a>
<a name="ln4585">  }</a>
<a name="ln4586"> </a>
<a name="ln4587">  if (do_alpha &amp;&amp; ASCII_ISALPHA(firstdigit)) {</a>
<a name="ln4588">    // decrement or increment alphabetic character</a>
<a name="ln4589">    if (op_type == OP_NR_SUB) {</a>
<a name="ln4590">      if (CHAR_ORD(firstdigit) &lt; Prenum1) {</a>
<a name="ln4591">        if (isupper(firstdigit)) {</a>
<a name="ln4592">          firstdigit = 'A';</a>
<a name="ln4593">        } else {</a>
<a name="ln4594">          firstdigit = 'a';</a>
<a name="ln4595">        }</a>
<a name="ln4596">      } else {</a>
<a name="ln4597">        firstdigit -= (int)Prenum1;</a>
<a name="ln4598">      }</a>
<a name="ln4599">    } else {</a>
<a name="ln4600">      if (26 - CHAR_ORD(firstdigit) - 1 &lt; Prenum1) {</a>
<a name="ln4601">        if (isupper(firstdigit)) {</a>
<a name="ln4602">          firstdigit = 'Z';</a>
<a name="ln4603">        } else {</a>
<a name="ln4604">          firstdigit = 'z';</a>
<a name="ln4605">        }</a>
<a name="ln4606">      } else {</a>
<a name="ln4607">        firstdigit += (int)Prenum1;</a>
<a name="ln4608">      }</a>
<a name="ln4609">    }</a>
<a name="ln4610">    curwin-&gt;w_cursor.col = col;</a>
<a name="ln4611">    startpos = curwin-&gt;w_cursor;</a>
<a name="ln4612">    did_change = true;</a>
<a name="ln4613">    (void)del_char(false);</a>
<a name="ln4614">    ins_char(firstdigit);</a>
<a name="ln4615">    endpos = curwin-&gt;w_cursor;</a>
<a name="ln4616">    curwin-&gt;w_cursor.col = col;</a>
<a name="ln4617">  } else {</a>
<a name="ln4618">    if (col &gt; 0 &amp;&amp; ptr[col - 1] == '-'</a>
<a name="ln4619">        &amp;&amp; !utf_head_off((char *)ptr, (char *)ptr + col - 1)</a>
<a name="ln4620">        &amp;&amp; !visual</a>
<a name="ln4621">        &amp;&amp; !do_unsigned) {</a>
<a name="ln4622">      // negative number</a>
<a name="ln4623">      col--;</a>
<a name="ln4624">      negative = true;</a>
<a name="ln4625">    }</a>
<a name="ln4626"> </a>
<a name="ln4627">    // get the number value (unsigned)</a>
<a name="ln4628">    if (visual &amp;&amp; VIsual_mode != 'V') {</a>
<a name="ln4629">      maxlen = (curbuf-&gt;b_visual.vi_curswant == MAXCOL</a>
<a name="ln4630">                ? (int)STRLEN(ptr) - col</a>
<a name="ln4631">                : length);</a>
<a name="ln4632">    }</a>
<a name="ln4633"> </a>
<a name="ln4634">    vim_str2nr((char *)ptr + col, &amp;pre, &amp;length,</a>
<a name="ln4635">               0 + (do_bin ? STR2NR_BIN : 0)</a>
<a name="ln4636">               + (do_oct ? STR2NR_OCT : 0)</a>
<a name="ln4637">               + (do_hex ? STR2NR_HEX : 0),</a>
<a name="ln4638">               NULL, &amp;n, maxlen, false);</a>
<a name="ln4639"> </a>
<a name="ln4640">    // ignore leading '-' for hex, octal and bin numbers</a>
<a name="ln4641">    if (pre &amp;&amp; negative) {</a>
<a name="ln4642">      col++;</a>
<a name="ln4643">      length--;</a>
<a name="ln4644">      negative = false;</a>
<a name="ln4645">    }</a>
<a name="ln4646"> </a>
<a name="ln4647">    // add or subtract</a>
<a name="ln4648">    bool subtract = false;</a>
<a name="ln4649">    if (op_type == OP_NR_SUB) {</a>
<a name="ln4650">      subtract ^= true;</a>
<a name="ln4651">    }</a>
<a name="ln4652">    if (negative) {</a>
<a name="ln4653">      subtract ^= true;</a>
<a name="ln4654">    }</a>
<a name="ln4655"> </a>
<a name="ln4656">    oldn = n;</a>
<a name="ln4657"> </a>
<a name="ln4658">    n = subtract ? n - (uvarnumber_T)Prenum1</a>
<a name="ln4659">                 : n + (uvarnumber_T)Prenum1;</a>
<a name="ln4660"> </a>
<a name="ln4661">    // handle wraparound for decimal numbers</a>
<a name="ln4662">    if (!pre) {</a>
<a name="ln4663">      if (subtract) {</a>
<a name="ln4664">        if (n &gt; oldn) {</a>
<a name="ln4665">          n = 1 + (n ^ (uvarnumber_T) - 1);</a>
<a name="ln4666">          negative ^= true;</a>
<a name="ln4667">        }</a>
<a name="ln4668">      } else {</a>
<a name="ln4669">        // add</a>
<a name="ln4670">        if (n &lt; oldn) {</a>
<a name="ln4671">          n = (n ^ (uvarnumber_T) - 1);</a>
<a name="ln4672">          negative ^= true;</a>
<a name="ln4673">        }</a>
<a name="ln4674">      }</a>
<a name="ln4675">      if (n == 0) {</a>
<a name="ln4676">        negative = false;</a>
<a name="ln4677">      }</a>
<a name="ln4678">    }</a>
<a name="ln4679"> </a>
<a name="ln4680">    if (do_unsigned &amp;&amp; negative) {</a>
<a name="ln4681">      if (subtract) {</a>
<a name="ln4682">        // sticking at zero.</a>
<a name="ln4683">        n = (uvarnumber_T)0;</a>
<a name="ln4684">      } else {</a>
<a name="ln4685">        // sticking at 2^64 - 1.</a>
<a name="ln4686">        n = (uvarnumber_T)(-1);</a>
<a name="ln4687">      }</a>
<a name="ln4688">      negative = false;</a>
<a name="ln4689">    }</a>
<a name="ln4690"> </a>
<a name="ln4691">    if (visual &amp;&amp; !was_positive &amp;&amp; !negative &amp;&amp; col &gt; 0) {</a>
<a name="ln4692">      // need to remove the '-'</a>
<a name="ln4693">      col--;</a>
<a name="ln4694">      length++;</a>
<a name="ln4695">    }</a>
<a name="ln4696"> </a>
<a name="ln4697">    // Delete the old number.</a>
<a name="ln4698">    curwin-&gt;w_cursor.col = col;</a>
<a name="ln4699">    startpos = curwin-&gt;w_cursor;</a>
<a name="ln4700">    did_change = true;</a>
<a name="ln4701">    todel = length;</a>
<a name="ln4702">    c = gchar_cursor();</a>
<a name="ln4703"> </a>
<a name="ln4704">    // Don't include the '-' in the length, only the length of the part</a>
<a name="ln4705">    // after it is kept the same.</a>
<a name="ln4706">    if (c == '-') {</a>
<a name="ln4707">      length--;</a>
<a name="ln4708">    }</a>
<a name="ln4709">    while (todel-- &gt; 0) {</a>
<a name="ln4710">      if (c &lt; 0x100 &amp;&amp; isalpha(c)) {</a>
<a name="ln4711">        if (isupper(c)) {</a>
<a name="ln4712">          hexupper = true;</a>
<a name="ln4713">        } else {</a>
<a name="ln4714">          hexupper = false;</a>
<a name="ln4715">        }</a>
<a name="ln4716">      }</a>
<a name="ln4717">      // del_char() will mark line needing displaying</a>
<a name="ln4718">      (void)del_char(false);</a>
<a name="ln4719">      c = gchar_cursor();</a>
<a name="ln4720">    }</a>
<a name="ln4721"> </a>
<a name="ln4722">    // Prepare the leading characters in buf1[].</a>
<a name="ln4723">    // When there are many leading zeros it could be very long.</a>
<a name="ln4724">    // Allocate a bit too much.</a>
<a name="ln4725">    buf1 = xmalloc((size_t)length + NUMBUFLEN);</a>
<a name="ln4726">    ptr = buf1;</a>
<a name="ln4727">    if (negative &amp;&amp; (!visual || was_positive)) {</a>
<a name="ln4728">      *ptr++ = '-';</a>
<a name="ln4729">    }</a>
<a name="ln4730">    if (pre) {</a>
<a name="ln4731">      *ptr++ = '0';</a>
<a name="ln4732">      length--;</a>
<a name="ln4733">    }</a>
<a name="ln4734">    if (pre == 'b' || pre == 'B' || pre == 'x' || pre == 'X') {</a>
<a name="ln4735">      *ptr++ = (char_u)pre;</a>
<a name="ln4736">      length--;</a>
<a name="ln4737">    }</a>
<a name="ln4738"> </a>
<a name="ln4739">    // Put the number characters in buf2[].</a>
<a name="ln4740">    if (pre == 'b' || pre == 'B') {</a>
<a name="ln4741">      size_t bits = 0;</a>
<a name="ln4742">      size_t i = 0;</a>
<a name="ln4743"> </a>
<a name="ln4744">      // leading zeros</a>
<a name="ln4745">      for (bits = 8 * sizeof(n); bits &gt; 0; bits--) {</a>
<a name="ln4746">        if ((n &gt;&gt; (bits - 1)) &amp; 0x1) {</a>
<a name="ln4747">          break;</a>
<a name="ln4748">        }</a>
<a name="ln4749">      }</a>
<a name="ln4750"> </a>
<a name="ln4751">      while (bits &gt; 0) {</a>
<a name="ln4752">        buf2[i++] = ((n &gt;&gt; --bits) &amp; 0x1) ? '1' : '0';</a>
<a name="ln4753">      }</a>
<a name="ln4754"> </a>
<a name="ln4755">      buf2[i] = '\0';</a>
<a name="ln4756">    } else if (pre == 0) {</a>
<a name="ln4757">      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIu64, (uint64_t)n);</a>
<a name="ln4758">    } else if (pre == '0') {</a>
<a name="ln4759">      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIo64, (uint64_t)n);</a>
<a name="ln4760">    } else if (hexupper) {</a>
<a name="ln4761">      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIX64, (uint64_t)n);</a>
<a name="ln4762">    } else {</a>
<a name="ln4763">      vim_snprintf((char *)buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIx64, (uint64_t)n);</a>
<a name="ln4764">    }</a>
<a name="ln4765">    length -= (int)STRLEN(buf2);</a>
<a name="ln4766"> </a>
<a name="ln4767">    // Adjust number of zeros to the new number of digits, so the</a>
<a name="ln4768">    // total length of the number remains the same.</a>
<a name="ln4769">    // Don't do this when</a>
<a name="ln4770">    // the result may look like an octal number.</a>
<a name="ln4771">    if (firstdigit == '0' &amp;&amp; !(do_oct &amp;&amp; pre == 0)) {</a>
<a name="ln4772">      while (length-- &gt; 0) {</a>
<a name="ln4773">        *ptr++ = '0';</a>
<a name="ln4774">      }</a>
<a name="ln4775">    }</a>
<a name="ln4776">    *ptr = NUL;</a>
<a name="ln4777">    STRCAT(buf1, buf2);</a>
<a name="ln4778">    ins_str((char *)buf1);              // insert the new number</a>
<a name="ln4779">    endpos = curwin-&gt;w_cursor;</a>
<a name="ln4780">    if (curwin-&gt;w_cursor.col) {</a>
<a name="ln4781">      curwin-&gt;w_cursor.col--;</a>
<a name="ln4782">    }</a>
<a name="ln4783">  }</a>
<a name="ln4784"> </a>
<a name="ln4785">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln4786">    // set the '[ and '] marks</a>
<a name="ln4787">    curbuf-&gt;b_op_start = startpos;</a>
<a name="ln4788">    curbuf-&gt;b_op_end = endpos;</a>
<a name="ln4789">    if (curbuf-&gt;b_op_end.col &gt; 0) {</a>
<a name="ln4790">      curbuf-&gt;b_op_end.col--;</a>
<a name="ln4791">    }</a>
<a name="ln4792">  }</a>
<a name="ln4793"> </a>
<a name="ln4794">theend:</a>
<a name="ln4795">  xfree(buf1);</a>
<a name="ln4796">  if (visual) {</a>
<a name="ln4797">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln4798">  } else if (did_change) {</a>
<a name="ln4799">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln4800">  } else if (virtual_active()) {</a>
<a name="ln4801">    curwin-&gt;w_cursor.coladd = save_coladd;</a>
<a name="ln4802">  }</a>
<a name="ln4803"> </a>
<a name="ln4804">  return did_change;</a>
<a name="ln4805">}</a>
<a name="ln4806"> </a>
<a name="ln4807">/// Used for getregtype()</a>
<a name="ln4808">///</a>
<a name="ln4809">/// @return  the type of a register or</a>
<a name="ln4810">///          kMTUnknown for error.</a>
<a name="ln4811">MotionType get_reg_type(int regname, colnr_T *reg_width)</a>
<a name="ln4812">{</a>
<a name="ln4813">  switch (regname) {</a>
<a name="ln4814">  case '%':     // file name</a>
<a name="ln4815">  case '#':     // alternate file name</a>
<a name="ln4816">  case '=':     // expression</a>
<a name="ln4817">  case ':':     // last command line</a>
<a name="ln4818">  case '/':     // last search-pattern</a>
<a name="ln4819">  case '.':     // last inserted text</a>
<a name="ln4820">  case Ctrl_F:  // Filename under cursor</a>
<a name="ln4821">  case Ctrl_P:  // Path under cursor, expand via &quot;path&quot;</a>
<a name="ln4822">  case Ctrl_W:  // word under cursor</a>
<a name="ln4823">  case Ctrl_A:  // WORD (mnemonic All) under cursor</a>
<a name="ln4824">  case '_':     // black hole: always empty</a>
<a name="ln4825">    return kMTCharWise;</a>
<a name="ln4826">  }</a>
<a name="ln4827"> </a>
<a name="ln4828">  if (regname != NUL &amp;&amp; !valid_yank_reg(regname, false)) {</a>
<a name="ln4829">    return kMTUnknown;</a>
<a name="ln4830">  }</a>
<a name="ln4831"> </a>
<a name="ln4832">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln4833"> </a>
<a name="ln4834">  if (reg-&gt;y_array != NULL) {</a>
<a name="ln4835">    if (reg_width != NULL &amp;&amp; reg-&gt;y_type == kMTBlockWise) {</a>
<a name="ln4836">      *reg_width = reg-&gt;y_width;</a>
<a name="ln4837">    }</a>
<a name="ln4838">    return reg-&gt;y_type;</a>
<a name="ln4839">  }</a>
<a name="ln4840">  return kMTUnknown;</a>
<a name="ln4841">}</a>
<a name="ln4842"> </a>
<a name="ln4843">/// Format the register type as a string.</a>
<a name="ln4844">///</a>
<a name="ln4845">/// @param reg_type The register type.</a>
<a name="ln4846">/// @param reg_width The width, only used if &quot;reg_type&quot; is kMTBlockWise.</a>
<a name="ln4847">/// @param[out] buf Buffer to store formatted string. The allocated size should</a>
<a name="ln4848">///                 be at least NUMBUFLEN+2 to always fit the value.</a>
<a name="ln4849">/// @param buf_len The allocated size of the buffer.</a>
<a name="ln4850">void format_reg_type(MotionType reg_type, colnr_T reg_width, char *buf, size_t buf_len)</a>
<a name="ln4851">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4852">{</a>
<a name="ln4853">  assert(buf_len &gt; 1);</a>
<a name="ln4854">  switch (reg_type) {</a>
<a name="ln4855">  case kMTLineWise:</a>
<a name="ln4856">    buf[0] = 'V';</a>
<a name="ln4857">    buf[1] = NUL;</a>
<a name="ln4858">    break;</a>
<a name="ln4859">  case kMTCharWise:</a>
<a name="ln4860">    buf[0] = 'v';</a>
<a name="ln4861">    buf[1] = NUL;</a>
<a name="ln4862">    break;</a>
<a name="ln4863">  case kMTBlockWise:</a>
<a name="ln4864">    snprintf(buf, buf_len, CTRL_V_STR &quot;%&quot; PRIdCOLNR, reg_width + 1);</a>
<a name="ln4865">    break;</a>
<a name="ln4866">  case kMTUnknown:</a>
<a name="ln4867">    buf[0] = NUL;</a>
<a name="ln4868">    break;</a>
<a name="ln4869">  }</a>
<a name="ln4870">}</a>
<a name="ln4871"> </a>
<a name="ln4872">/// When `flags` has `kGRegList` return a list with text `s`.</a>
<a name="ln4873">/// Otherwise just return `s`.</a>
<a name="ln4874">///</a>
<a name="ln4875">/// @return  a void * for use in get_reg_contents().</a>
<a name="ln4876">static void *get_reg_wrap_one_line(char *s, int flags)</a>
<a name="ln4877">{</a>
<a name="ln4878">  if (!(flags &amp; kGRegList)) {</a>
<a name="ln4879">    return s;</a>
<a name="ln4880">  }</a>
<a name="ln4881">  list_T *const list = tv_list_alloc(1);</a>
<a name="ln4882">  tv_list_append_allocated_string(list, s);</a>
<a name="ln4883">  return list;</a>
<a name="ln4884">}</a>
<a name="ln4885"> </a>
<a name="ln4886">/// Gets the contents of a register.</a>
<a name="ln4887">/// @remark Used for `@r` in expressions and for `getreg()`.</a>
<a name="ln4888">///</a>
<a name="ln4889">/// @param regname  The register.</a>
<a name="ln4890">/// @param flags    see @ref GRegFlags</a>
<a name="ln4891">///</a>
<a name="ln4892">/// @returns The contents of the register as an allocated string.</a>
<a name="ln4893">/// @returns A linked list when `flags` contains @ref kGRegList.</a>
<a name="ln4894">/// @returns NULL for error.</a>
<a name="ln4895">void *get_reg_contents(int regname, int flags)</a>
<a name="ln4896">{</a>
<a name="ln4897">  // Don't allow using an expression register inside an expression.</a>
<a name="ln4898">  if (regname == '=') {</a>
<a name="ln4899">    if (flags &amp; kGRegNoExpr) {</a>
<a name="ln4900">      return NULL;</a>
<a name="ln4901">    }</a>
<a name="ln4902">    if (flags &amp; kGRegExprSrc) {</a>
<a name="ln4903">      return get_reg_wrap_one_line(get_expr_line_src(), flags);</a>
<a name="ln4904">    }</a>
<a name="ln4905">    return get_reg_wrap_one_line(get_expr_line(), flags);</a>
<a name="ln4906">  }</a>
<a name="ln4907"> </a>
<a name="ln4908">  if (regname == '@') {     // &quot;@@&quot; is used for unnamed register</a>
<a name="ln4909">    regname = '&quot;';</a>
<a name="ln4910">  }</a>
<a name="ln4911"> </a>
<a name="ln4912">  // check for valid regname</a>
<a name="ln4913">  if (regname != NUL &amp;&amp; !valid_yank_reg(regname, false)) {</a>
<a name="ln4914">    return NULL;</a>
<a name="ln4915">  }</a>
<a name="ln4916"> </a>
<a name="ln4917">  char *retval;</a>
<a name="ln4918">  bool allocated;</a>
<a name="ln4919">  if (get_spec_reg(regname, &amp;retval, &amp;allocated, false)) {</a>
<a name="ln4920">    if (retval == NULL) {</a>
<a name="ln4921">      return NULL;</a>
<a name="ln4922">    }</a>
<a name="ln4923">    if (allocated) {</a>
<a name="ln4924">      return get_reg_wrap_one_line(retval, flags);</a>
<a name="ln4925">    }</a>
<a name="ln4926">    return get_reg_wrap_one_line(xstrdup(retval), flags);</a>
<a name="ln4927">  }</a>
<a name="ln4928"> </a>
<a name="ln4929">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln4930">  if (reg-&gt;y_array == NULL) {</a>
<a name="ln4931">    return NULL;</a>
<a name="ln4932">  }</a>
<a name="ln4933"> </a>
<a name="ln4934">  if (flags &amp; kGRegList) {</a>
<a name="ln4935">    list_T *const list = tv_list_alloc((ptrdiff_t)reg-&gt;y_size);</a>
<a name="ln4936">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln4937">      tv_list_append_string(list, (const char *)reg-&gt;y_array[i], -1);</a>
<a name="ln4938">    }</a>
<a name="ln4939"> </a>
<a name="ln4940">    return list;</a>
<a name="ln4941">  }</a>
<a name="ln4942"> </a>
<a name="ln4943">  // Compute length of resulting string.</a>
<a name="ln4944">  size_t len = 0;</a>
<a name="ln4945">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln4946">    len += strlen(reg-&gt;y_array[i]);</a>
<a name="ln4947">    // Insert a newline between lines and after last line if</a>
<a name="ln4948">    // y_type is kMTLineWise.</a>
<a name="ln4949">    if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1) {</a>
<a name="ln4950">      len++;</a>
<a name="ln4951">    }</a>
<a name="ln4952">  }</a>
<a name="ln4953"> </a>
<a name="ln4954">  retval = xmalloc(len + 1);</a>
<a name="ln4955"> </a>
<a name="ln4956">  // Copy the lines of the yank register into the string.</a>
<a name="ln4957">  len = 0;</a>
<a name="ln4958">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln4959">    STRCPY(retval + len, reg-&gt;y_array[i]);</a>
<a name="ln4960">    len += strlen(retval + len);</a>
<a name="ln4961"> </a>
<a name="ln4962">    // Insert a NL between lines and after the last line if y_type is</a>
<a name="ln4963">    // kMTLineWise.</a>
<a name="ln4964">    if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1) {</a>
<a name="ln4965">      retval[len++] = '\n';</a>
<a name="ln4966">    }</a>
<a name="ln4967">  }</a>
<a name="ln4968">  retval[len] = NUL;</a>
<a name="ln4969"> </a>
<a name="ln4970">  return retval;</a>
<a name="ln4971">}</a>
<a name="ln4972"> </a>
<a name="ln4973">static yankreg_T *init_write_reg(int name, yankreg_T **old_y_previous, bool must_append)</a>
<a name="ln4974">{</a>
<a name="ln4975">  if (!valid_yank_reg(name, true)) {  // check for valid reg name</a>
<a name="ln4976">    emsg_invreg(name);</a>
<a name="ln4977">    return NULL;</a>
<a name="ln4978">  }</a>
<a name="ln4979"> </a>
<a name="ln4980">  // Don't want to change the current (unnamed) register.</a>
<a name="ln4981">  *old_y_previous = y_previous;</a>
<a name="ln4982"> </a>
<a name="ln4983">  yankreg_T *reg = get_yank_register(name, YREG_YANK);</a>
<a name="ln4984">  if (!is_append_register(name) &amp;&amp; !must_append) {</a>
<a name="ln4985">    free_register(reg);</a>
<a name="ln4986">  }</a>
<a name="ln4987">  return reg;</a>
<a name="ln4988">}</a>
<a name="ln4989"> </a>
<a name="ln4990">static void finish_write_reg(int name, yankreg_T *reg, yankreg_T *old_y_previous)</a>
<a name="ln4991">{</a>
<a name="ln4992">  // Send text of clipboard register to the clipboard.</a>
<a name="ln4993">  set_clipboard(name, reg);</a>
<a name="ln4994"> </a>
<a name="ln4995">  // ':let @&quot; = &quot;val&quot;' should change the meaning of the &quot;&quot; register</a>
<a name="ln4996">  if (name != '&quot;') {</a>
<a name="ln4997">    y_previous = old_y_previous;</a>
<a name="ln4998">  }</a>
<a name="ln4999">}</a>
<a name="ln5000"> </a>
<a name="ln5001">/// store `str` in register `name`</a>
<a name="ln5002">///</a>
<a name="ln5003">/// @see write_reg_contents_ex</a>
<a name="ln5004">void write_reg_contents(int name, const char *str, ssize_t len, int must_append)</a>
<a name="ln5005">{</a>
<a name="ln5006">  write_reg_contents_ex(name, str, len, must_append, kMTUnknown, 0L);</a>
<a name="ln5007">}</a>
<a name="ln5008"> </a>
<a name="ln5009">void write_reg_contents_lst(int name, char **strings, bool must_append, MotionType yank_type,</a>
<a name="ln5010">                            colnr_T block_len)</a>
<a name="ln5011">{</a>
<a name="ln5012">  if (name == '/' || name == '=') {</a>
<a name="ln5013">    char *s = strings[0];</a>
<a name="ln5014">    if (strings[0] == NULL) {</a>
<a name="ln5015">      s = &quot;&quot;;</a>
<a name="ln5016">    } else if (strings[1] != NULL) {</a>
<a name="ln5017">      emsg(_(&quot;E883: search pattern and expression register may not &quot;</a>
<a name="ln5018">             &quot;contain two or more lines&quot;));</a>
<a name="ln5019">      return;</a>
<a name="ln5020">    }</a>
<a name="ln5021">    write_reg_contents_ex(name, s, -1, must_append, yank_type, block_len);</a>
<a name="ln5022">    return;</a>
<a name="ln5023">  }</a>
<a name="ln5024"> </a>
<a name="ln5025">  // black hole: nothing to do</a>
<a name="ln5026">  if (name == '_') {</a>
<a name="ln5027">    return;</a>
<a name="ln5028">  }</a>
<a name="ln5029"> </a>
<a name="ln5030">  yankreg_T *old_y_previous, *reg;</a>
<a name="ln5031">  if (!(reg = init_write_reg(name, &amp;old_y_previous, must_append))) {</a>
<a name="ln5032">    return;</a>
<a name="ln5033">  }</a>
<a name="ln5034"> </a>
<a name="ln5035">  str_to_reg(reg, yank_type, (char *)strings, STRLEN(strings),</a>
<a name="ln5036">             block_len, true);</a>
<a name="ln5037">  finish_write_reg(name, reg, old_y_previous);</a>
<a name="ln5038">}</a>
<a name="ln5039"> </a>
<a name="ln5040">/// write_reg_contents_ex - store `str` in register `name`</a>
<a name="ln5041">///</a>
<a name="ln5042">/// If `str` ends in '\n' or '\r', use linewise, otherwise use charwise.</a>
<a name="ln5043">///</a>
<a name="ln5044">/// @warning when `name` is '/', `len` and `must_append` are ignored. This</a>
<a name="ln5045">///          means that `str` MUST be NUL-terminated.</a>
<a name="ln5046">///</a>
<a name="ln5047">/// @param name The name of the register</a>
<a name="ln5048">/// @param str The contents to write</a>
<a name="ln5049">/// @param len If &gt;= 0, write `len` bytes of `str`. Otherwise, write</a>
<a name="ln5050">///               `strlen(str)` bytes. If `len` is larger than the</a>
<a name="ln5051">///               allocated size of `src`, the behaviour is undefined.</a>
<a name="ln5052">/// @param must_append If true, append the contents of `str` to the current</a>
<a name="ln5053">///                    contents of the register. Note that regardless of</a>
<a name="ln5054">///                    `must_append`, this function will append when `name`</a>
<a name="ln5055">///                    is an uppercase letter.</a>
<a name="ln5056">/// @param yank_type The motion type (kMTUnknown to auto detect)</a>
<a name="ln5057">/// @param block_len width of visual block</a>
<a name="ln5058">void write_reg_contents_ex(int name, const char *str, ssize_t len, bool must_append,</a>
<a name="ln5059">                           MotionType yank_type, colnr_T block_len)</a>
<a name="ln5060">{</a>
<a name="ln5061">  if (len &lt; 0) {</a>
<a name="ln5062">    len = (ssize_t)strlen(str);</a>
<a name="ln5063">  }</a>
<a name="ln5064"> </a>
<a name="ln5065">  // Special case: '/' search pattern</a>
<a name="ln5066">  if (name == '/') {</a>
<a name="ln5067">    set_last_search_pat((char_u *)str, RE_SEARCH, true, true);</a>
<a name="ln5068">    return;</a>
<a name="ln5069">  }</a>
<a name="ln5070"> </a>
<a name="ln5071">  if (name == '#') {</a>
<a name="ln5072">    buf_T *buf;</a>
<a name="ln5073"> </a>
<a name="ln5074">    if (ascii_isdigit(*str)) {</a>
<a name="ln5075">      int num = atoi(str);</a>
<a name="ln5076"> </a>
<a name="ln5077">      buf = buflist_findnr(num);</a>
<a name="ln5078">      if (buf == NULL) {</a>
<a name="ln5079">        semsg(_(e_nobufnr), (int64_t)num);</a>
<a name="ln5080">      }</a>
<a name="ln5081">    } else {</a>
<a name="ln5082">      buf = buflist_findnr(buflist_findpat(str, str + strlen(str),</a>
<a name="ln5083">                                           true, false, false));</a>
<a name="ln5084">    }</a>
<a name="ln5085">    if (buf == NULL) {</a>
<a name="ln5086">      return;</a>
<a name="ln5087">    }</a>
<a name="ln5088">    curwin-&gt;w_alt_fnum = buf-&gt;b_fnum;</a>
<a name="ln5089">    return;</a>
<a name="ln5090">  }</a>
<a name="ln5091"> </a>
<a name="ln5092">  if (name == '=') {</a>
<a name="ln5093">    size_t offset = 0;</a>
<a name="ln5094">    size_t totlen = (size_t)len;</a>
<a name="ln5095"> </a>
<a name="ln5096">    if (must_append &amp;&amp; expr_line) {</a>
<a name="ln5097">      // append has been specified and expr_line already exists, so we'll</a>
<a name="ln5098">      // append the new string to expr_line.</a>
<a name="ln5099">      size_t exprlen = STRLEN(expr_line);</a>
<a name="ln5100"> </a>
<a name="ln5101">      totlen += exprlen;</a>
<a name="ln5102">      offset = exprlen;</a>
<a name="ln5103">    }</a>
<a name="ln5104"> </a>
<a name="ln5105">    // modify the global expr_line, extend/shrink it if necessary (realloc).</a>
<a name="ln5106">    // Copy the input string into the adjusted memory at the specified</a>
<a name="ln5107">    // offset.</a>
<a name="ln5108">    expr_line = xrealloc(expr_line, totlen + 1);</a>
<a name="ln5109">    memcpy(expr_line + offset, str, (size_t)len);</a>
<a name="ln5110">    expr_line[totlen] = NUL;</a>
<a name="ln5111"> </a>
<a name="ln5112">    return;</a>
<a name="ln5113">  }</a>
<a name="ln5114"> </a>
<a name="ln5115">  if (name == '_') {        // black hole: nothing to do</a>
<a name="ln5116">    return;</a>
<a name="ln5117">  }</a>
<a name="ln5118"> </a>
<a name="ln5119">  yankreg_T *old_y_previous, *reg;</a>
<a name="ln5120">  if (!(reg = init_write_reg(name, &amp;old_y_previous, must_append))) {</a>
<a name="ln5121">    return;</a>
<a name="ln5122">  }</a>
<a name="ln5123">  str_to_reg(reg, yank_type, str, (size_t)len, block_len, false);</a>
<a name="ln5124">  finish_write_reg(name, reg, old_y_previous);</a>
<a name="ln5125">}</a>
<a name="ln5126"> </a>
<a name="ln5127">/// str_to_reg - Put a string into a register.</a>
<a name="ln5128">///</a>
<a name="ln5129">/// When the register is not empty, the string is appended.</a>
<a name="ln5130">///</a>
<a name="ln5131">/// @param y_ptr pointer to yank register</a>
<a name="ln5132">/// @param yank_type The motion type (kMTUnknown to auto detect)</a>
<a name="ln5133">/// @param str string or list of strings to put in register</a>
<a name="ln5134">/// @param len length of the string (Ignored when str_list=true.)</a>
<a name="ln5135">/// @param blocklen width of visual block, or -1 for &quot;I don't know.&quot;</a>
<a name="ln5136">/// @param str_list True if str is `char_u **`.</a>
<a name="ln5137">static void str_to_reg(yankreg_T *y_ptr, MotionType yank_type, const char *str, size_t len,</a>
<a name="ln5138">                       colnr_T blocklen, bool str_list)</a>
<a name="ln5139">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5140">{</a>
<a name="ln5141">  if (y_ptr-&gt;y_array == NULL) {  // NULL means empty register</a>
<a name="ln5142">    y_ptr-&gt;y_size = 0;</a>
<a name="ln5143">  }</a>
<a name="ln5144"> </a>
<a name="ln5145">  if (yank_type == kMTUnknown) {</a>
<a name="ln5146">    yank_type = ((str_list</a>
<a name="ln5147">                  || (len &gt; 0 &amp;&amp; (str[len - 1] == NL || str[len - 1] == CAR)))</a>
<a name="ln5148">                 ? kMTLineWise : kMTCharWise);</a>
<a name="ln5149">  }</a>
<a name="ln5150"> </a>
<a name="ln5151">  size_t newlines = 0;</a>
<a name="ln5152">  bool extraline = false;  // extra line at the end</a>
<a name="ln5153">  bool append = false;     // append to last line in register</a>
<a name="ln5154"> </a>
<a name="ln5155">  // Count the number of lines within the string</a>
<a name="ln5156">  if (str_list) {</a>
<a name="ln5157">    for (char_u **ss = (char_u **)str; *ss != NULL; ss++) {</a>
<a name="ln5158">      newlines++;</a>
<a name="ln5159">    }</a>
<a name="ln5160">  } else {</a>
<a name="ln5161">    newlines = memcnt(str, '\n', len);</a>
<a name="ln5162">    if (yank_type == kMTCharWise || len == 0 || str[len - 1] != '\n') {</a>
<a name="ln5163">      extraline = 1;</a>
<a name="ln5164">      newlines++;         // count extra newline at the end</a>
<a name="ln5165">    }</a>
<a name="ln5166">    if (y_ptr-&gt;y_size &gt; 0 &amp;&amp; y_ptr-&gt;y_type == kMTCharWise) {</a>
<a name="ln5167">      append = true;</a>
<a name="ln5168">      newlines--;         // uncount newline when appending first line</a>
<a name="ln5169">    }</a>
<a name="ln5170">  }</a>
<a name="ln5171"> </a>
<a name="ln5172">  // Without any lines make the register empty.</a>
<a name="ln5173">  if (y_ptr-&gt;y_size + newlines == 0) {</a>
<a name="ln5174">    XFREE_CLEAR(y_ptr-&gt;y_array);</a>
<a name="ln5175">    return;</a>
<a name="ln5176">  }</a>
<a name="ln5177"> </a>
<a name="ln5178">  // Grow the register array to hold the pointers to the new lines.</a>
<a name="ln5179">  char **pp = xrealloc(y_ptr-&gt;y_array, (y_ptr-&gt;y_size + newlines) * sizeof(char_u *));</a>
<a name="ln5180">  y_ptr-&gt;y_array = pp;</a>
<a name="ln5181"> </a>
<a name="ln5182">  size_t lnum = y_ptr-&gt;y_size;  // The current line number.</a>
<a name="ln5183"> </a>
<a name="ln5184">  // If called with `blocklen &lt; 0`, we have to update the yank reg's width.</a>
<a name="ln5185">  size_t maxlen = 0;</a>
<a name="ln5186"> </a>
<a name="ln5187">  // Find the end of each line and save it into the array.</a>
<a name="ln5188">  if (str_list) {</a>
<a name="ln5189">    for (char_u **ss = (char_u **)str; *ss != NULL; ss++, lnum++) {</a>
<a name="ln5190">      size_t ss_len = STRLEN(*ss);</a>
<a name="ln5191">      pp[lnum] = xmemdupz(*ss, ss_len);</a>
<a name="ln5192">      if (ss_len &gt; maxlen) {</a>
<a name="ln5193">        maxlen = ss_len;</a>
<a name="ln5194">      }</a>
<a name="ln5195">    }</a>
<a name="ln5196">  } else {</a>
<a name="ln5197">    size_t line_len;</a>
<a name="ln5198">    for (const char_u *start = (char_u *)str, *end = (char_u *)str + len;</a>
<a name="ln5199">         start &lt; end + extraline;</a>
<a name="ln5200">         start += line_len + 1, lnum++) {</a>
<a name="ln5201">      assert(end - start &gt;= 0);</a>
<a name="ln5202">      line_len = (size_t)((char_u *)xmemscan(start, '\n',</a>
<a name="ln5203">                                             (size_t)(end - start)) - start);</a>
<a name="ln5204">      if (line_len &gt; maxlen) {</a>
<a name="ln5205">        maxlen = line_len;</a>
<a name="ln5206">      }</a>
<a name="ln5207"> </a>
<a name="ln5208">      // When appending, copy the previous line and free it after.</a>
<a name="ln5209">      size_t extra = append ? strlen(pp[--lnum]) : 0;</a>
<a name="ln5210">      char *s = xmallocz(line_len + extra);</a>
<a name="ln5211">      if (extra &gt; 0) {</a>
<a name="ln5212">        memcpy(s, pp[lnum], extra);</a>
<a name="ln5213">      }</a>
<a name="ln5214">      memcpy(s + extra, start, line_len);</a>
<a name="ln5215">      size_t s_len = extra + line_len;</a>
<a name="ln5216"> </a>
<a name="ln5217">      if (append) {</a>
<a name="ln5218">        xfree(pp[lnum]);</a>
<a name="ln5219">        append = false;  // only first line is appended</a>
<a name="ln5220">      }</a>
<a name="ln5221">      pp[lnum] = s;</a>
<a name="ln5222"> </a>
<a name="ln5223">      // Convert NULs to '\n' to prevent truncation.</a>
<a name="ln5224">      memchrsub(pp[lnum], NUL, '\n', s_len);</a>
<a name="ln5225">    }</a>
<a name="ln5226">  }</a>
<a name="ln5227">  y_ptr-&gt;y_type = yank_type;</a>
<a name="ln5228">  y_ptr-&gt;y_size = lnum;</a>
<a name="ln5229">  set_yreg_additional_data(y_ptr, NULL);</a>
<a name="ln5230">  y_ptr-&gt;timestamp = os_time();</a>
<a name="ln5231">  if (yank_type == kMTBlockWise) {</a>
<a name="ln5232">    y_ptr-&gt;y_width = (blocklen == -1 ? (colnr_T)maxlen - 1 : blocklen);</a>
<a name="ln5233">  } else {</a>
<a name="ln5234">    y_ptr-&gt;y_width = 0;</a>
<a name="ln5235">  }</a>
<a name="ln5236">}</a>
<a name="ln5237"> </a>
<a name="ln5238">void clear_oparg(oparg_T *oap)</a>
<a name="ln5239">{</a>
<a name="ln5240">  CLEAR_POINTER(oap);</a>
<a name="ln5241">}</a>
<a name="ln5242"> </a>
<a name="ln5243">///  Count the number of bytes, characters and &quot;words&quot; in a line.</a>
<a name="ln5244">///</a>
<a name="ln5245">///  &quot;Words&quot; are counted by looking for boundaries between non-space and</a>
<a name="ln5246">///  space characters.  (it seems to produce results that match 'wc'.)</a>
<a name="ln5247">///</a>
<a name="ln5248">///  Return value is byte count; word count for the line is added to &quot;*wc&quot;.</a>
<a name="ln5249">///  Char count is added to &quot;*cc&quot;.</a>
<a name="ln5250">///</a>
<a name="ln5251">///  The function will only examine the first &quot;limit&quot; characters in the</a>
<a name="ln5252">///  line, stopping if it encounters an end-of-line (NUL byte).  In that</a>
<a name="ln5253">///  case, eol_size will be added to the character count to account for</a>
<a name="ln5254">///  the size of the EOL character.</a>
<a name="ln5255">static varnumber_T line_count_info(char_u *line, varnumber_T *wc, varnumber_T *cc,</a>
<a name="ln5256">                                   varnumber_T limit, int eol_size)</a>
<a name="ln5257">{</a>
<a name="ln5258">  varnumber_T i;</a>
<a name="ln5259">  varnumber_T words = 0;</a>
<a name="ln5260">  varnumber_T chars = 0;</a>
<a name="ln5261">  int is_word = 0;</a>
<a name="ln5262"> </a>
<a name="ln5263">  for (i = 0; i &lt; limit &amp;&amp; line[i] != NUL;) {</a>
<a name="ln5264">    if (is_word) {</a>
<a name="ln5265">      if (ascii_isspace(line[i])) {</a>
<a name="ln5266">        words++;</a>
<a name="ln5267">        is_word = 0;</a>
<a name="ln5268">      }</a>
<a name="ln5269">    } else if (!ascii_isspace(line[i])) {</a>
<a name="ln5270">      is_word = 1;</a>
<a name="ln5271">    }</a>
<a name="ln5272">    chars++;</a>
<a name="ln5273">    i += utfc_ptr2len((char *)line + i);</a>
<a name="ln5274">  }</a>
<a name="ln5275"> </a>
<a name="ln5276">  if (is_word) {</a>
<a name="ln5277">    words++;</a>
<a name="ln5278">  }</a>
<a name="ln5279">  *wc += words;</a>
<a name="ln5280"> </a>
<a name="ln5281">  // Add eol_size if the end of line was reached before hitting limit.</a>
<a name="ln5282">  if (i &lt; limit &amp;&amp; line[i] == NUL) {</a>
<a name="ln5283">    i += eol_size;</a>
<a name="ln5284">    chars += eol_size;</a>
<a name="ln5285">  }</a>
<a name="ln5286">  *cc += chars;</a>
<a name="ln5287">  return i;</a>
<a name="ln5288">}</a>
<a name="ln5289"> </a>
<a name="ln5290">/// Give some info about the position of the cursor (for &quot;g CTRL-G&quot;).</a>
<a name="ln5291">/// In Visual mode, give some info about the selected region.  (In this case,</a>
<a name="ln5292">/// the *_count_cursor variables store running totals for the selection.)</a>
<a name="ln5293">///</a>
<a name="ln5294">/// @param dict  when not NULL, store the info there instead of showing it.</a>
<a name="ln5295">void cursor_pos_info(dict_T *dict)</a>
<a name="ln5296">{</a>
<a name="ln5297">  char_u *p;</a>
<a name="ln5298">  char_u buf1[50];</a>
<a name="ln5299">  char_u buf2[40];</a>
<a name="ln5300">  linenr_T lnum;</a>
<a name="ln5301">  varnumber_T byte_count = 0;</a>
<a name="ln5302">  varnumber_T bom_count = 0;</a>
<a name="ln5303">  varnumber_T byte_count_cursor = 0;</a>
<a name="ln5304">  varnumber_T char_count = 0;</a>
<a name="ln5305">  varnumber_T char_count_cursor = 0;</a>
<a name="ln5306">  varnumber_T word_count = 0;</a>
<a name="ln5307">  varnumber_T word_count_cursor = 0;</a>
<a name="ln5308">  int eol_size;</a>
<a name="ln5309">  varnumber_T last_check = 100000L;</a>
<a name="ln5310">  long line_count_selected = 0;</a>
<a name="ln5311">  pos_T min_pos, max_pos;</a>
<a name="ln5312">  oparg_T oparg;</a>
<a name="ln5313">  struct block_def bd;</a>
<a name="ln5314">  const int l_VIsual_active = VIsual_active;</a>
<a name="ln5315">  const int l_VIsual_mode = VIsual_mode;</a>
<a name="ln5316"> </a>
<a name="ln5317">  // Compute the length of the file in characters.</a>
<a name="ln5318">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln5319">    if (dict == NULL) {</a>
<a name="ln5320">      msg(_(no_lines_msg));</a>
<a name="ln5321">      return;</a>
<a name="ln5322">    }</a>
<a name="ln5323">  } else {</a>
<a name="ln5324">    if (get_fileformat(curbuf) == EOL_DOS) {</a>
<a name="ln5325">      eol_size = 2;</a>
<a name="ln5326">    } else {</a>
<a name="ln5327">      eol_size = 1;</a>
<a name="ln5328">    }</a>
<a name="ln5329"> </a>
<a name="ln5330">    if (l_VIsual_active) {</a>
<a name="ln5331">      if (lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln5332">        min_pos = VIsual;</a>
<a name="ln5333">        max_pos = curwin-&gt;w_cursor;</a>
<a name="ln5334">      } else {</a>
<a name="ln5335">        min_pos = curwin-&gt;w_cursor;</a>
<a name="ln5336">        max_pos = VIsual;</a>
<a name="ln5337">      }</a>
<a name="ln5338">      if (*p_sel == 'e' &amp;&amp; max_pos.col &gt; 0) {</a>
<a name="ln5339">        max_pos.col--;</a>
<a name="ln5340">      }</a>
<a name="ln5341"> </a>
<a name="ln5342">      if (l_VIsual_mode == Ctrl_V) {</a>
<a name="ln5343">        char *const saved_sbr = p_sbr;</a>
<a name="ln5344">        char *const saved_w_sbr = curwin-&gt;w_p_sbr;</a>
<a name="ln5345"> </a>
<a name="ln5346">        // Make 'sbr' empty for a moment to get the correct size.</a>
<a name="ln5347">        p_sbr = empty_option;</a>
<a name="ln5348">        curwin-&gt;w_p_sbr = empty_option;</a>
<a name="ln5349">        oparg.is_VIsual = true;</a>
<a name="ln5350">        oparg.motion_type = kMTBlockWise;</a>
<a name="ln5351">        oparg.op_type = OP_NOP;</a>
<a name="ln5352">        getvcols(curwin, &amp;min_pos, &amp;max_pos, &amp;oparg.start_vcol, &amp;oparg.end_vcol);</a>
<a name="ln5353">        p_sbr = saved_sbr;</a>
<a name="ln5354">        curwin-&gt;w_p_sbr = saved_w_sbr;</a>
<a name="ln5355">        if (curwin-&gt;w_curswant == MAXCOL) {</a>
<a name="ln5356">          oparg.end_vcol = MAXCOL;</a>
<a name="ln5357">        }</a>
<a name="ln5358">        // Swap the start, end vcol if needed</a>
<a name="ln5359">        if (oparg.end_vcol &lt; oparg.start_vcol) {</a>
<a name="ln5360">          oparg.end_vcol += oparg.start_vcol;</a>
<a name="ln5361">          oparg.start_vcol = oparg.end_vcol - oparg.start_vcol;</a>
<a name="ln5362">          oparg.end_vcol -= oparg.start_vcol;</a>
<a name="ln5363">        }</a>
<a name="ln5364">      }</a>
<a name="ln5365">      line_count_selected = max_pos.lnum - min_pos.lnum + 1;</a>
<a name="ln5366">    }</a>
<a name="ln5367"> </a>
<a name="ln5368">    for (lnum = 1; lnum &lt;= curbuf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln5369">      // Check for a CTRL-C every 100000 characters.</a>
<a name="ln5370">      if (byte_count &gt; last_check) {</a>
<a name="ln5371">        os_breakcheck();</a>
<a name="ln5372">        if (got_int) {</a>
<a name="ln5373">          return;</a>
<a name="ln5374">        }</a>
<a name="ln5375">        last_check = byte_count + 100000L;</a>
<a name="ln5376">      }</a>
<a name="ln5377"> </a>
<a name="ln5378">      // Do extra processing for VIsual mode.</a>
<a name="ln5379">      if (l_VIsual_active</a>
<a name="ln5380">          &amp;&amp; lnum &gt;= min_pos.lnum &amp;&amp; lnum &lt;= max_pos.lnum) {</a>
<a name="ln5381">        char_u *s = NULL;</a>
<a name="ln5382">        long len = 0L;</a>
<a name="ln5383"> </a>
<a name="ln5384">        switch (l_VIsual_mode) {</a>
<a name="ln5385">        case Ctrl_V:</a>
<a name="ln5386">          virtual_op = virtual_active();</a>
<a name="ln5387">          block_prep(&amp;oparg, &amp;bd, lnum, false);</a>
<a name="ln5388">          virtual_op = kNone;</a>
<a name="ln5389">          s = bd.textstart;</a>
<a name="ln5390">          len = (long)bd.textlen;</a>
<a name="ln5391">          break;</a>
<a name="ln5392">        case 'V':</a>
<a name="ln5393">          s = (char_u *)ml_get(lnum);</a>
<a name="ln5394">          len = MAXCOL;</a>
<a name="ln5395">          break;</a>
<a name="ln5396">        case 'v': {</a>
<a name="ln5397">          colnr_T start_col = (lnum == min_pos.lnum)</a>
<a name="ln5398">                              ? min_pos.col : 0;</a>
<a name="ln5399">          colnr_T end_col = (lnum == max_pos.lnum)</a>
<a name="ln5400">                            ? max_pos.col - start_col + 1 : MAXCOL;</a>
<a name="ln5401"> </a>
<a name="ln5402">          s = (char_u *)ml_get(lnum) + start_col;</a>
<a name="ln5403">          len = end_col;</a>
<a name="ln5404">        }</a>
<a name="ln5405">        break;</a>
<a name="ln5406">        }</a>
<a name="ln5407">        if (s != NULL) {</a>
<a name="ln5408">          byte_count_cursor += line_count_info(s, &amp;word_count_cursor,</a>
<a name="ln5409">                                               &amp;char_count_cursor, len, eol_size);</a>
<a name="ln5410">          if (lnum == curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln5411">              &amp;&amp; !curbuf-&gt;b_p_eol</a>
<a name="ln5412">              &amp;&amp; (curbuf-&gt;b_p_bin || !curbuf-&gt;b_p_fixeol)</a>
<a name="ln5413">              &amp;&amp; (long)STRLEN(s) &lt; len) {</a>
<a name="ln5414">            byte_count_cursor -= eol_size;</a>
<a name="ln5415">          }</a>
<a name="ln5416">        }</a>
<a name="ln5417">      } else {</a>
<a name="ln5418">        // In non-visual mode, check for the line the cursor is on</a>
<a name="ln5419">        if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln5420">          word_count_cursor += word_count;</a>
<a name="ln5421">          char_count_cursor += char_count;</a>
<a name="ln5422">          byte_count_cursor = byte_count</a>
<a name="ln5423">                              + line_count_info((char_u *)ml_get(lnum), &amp;word_count_cursor,</a>
<a name="ln5424">                                                &amp;char_count_cursor,</a>
<a name="ln5425">                                                (varnumber_T)curwin-&gt;w_cursor.col + 1,</a>
<a name="ln5426">                                                eol_size);</a>
<a name="ln5427">        }</a>
<a name="ln5428">      }</a>
<a name="ln5429">      // Add to the running totals</a>
<a name="ln5430">      byte_count += line_count_info((char_u *)ml_get(lnum), &amp;word_count, &amp;char_count,</a>
<a name="ln5431">                                    (varnumber_T)MAXCOL, eol_size);</a>
<a name="ln5432">    }</a>
<a name="ln5433"> </a>
<a name="ln5434">    // Correction for when last line doesn't have an EOL.</a>
<a name="ln5435">    if (!curbuf-&gt;b_p_eol &amp;&amp; (curbuf-&gt;b_p_bin || !curbuf-&gt;b_p_fixeol)) {</a>
<a name="ln5436">      byte_count -= eol_size;</a>
<a name="ln5437">    }</a>
<a name="ln5438"> </a>
<a name="ln5439">    if (dict == NULL) {</a>
<a name="ln5440">      if (l_VIsual_active) {</a>
<a name="ln5441">        if (l_VIsual_mode == Ctrl_V &amp;&amp; curwin-&gt;w_curswant &lt; MAXCOL) {</a>
<a name="ln5442">          getvcols(curwin, &amp;min_pos, &amp;max_pos, &amp;min_pos.col, &amp;max_pos.col);</a>
<a name="ln5443">          int64_t cols;</a>
<a name="ln5444">          STRICT_SUB(oparg.end_vcol + 1, oparg.start_vcol, &amp;cols, int64_t);</a>
<a name="ln5445">          vim_snprintf((char *)buf1, sizeof(buf1), _(&quot;%&quot; PRId64 &quot; Cols; &quot;),</a>
<a name="ln5446">                       cols);</a>
<a name="ln5447">        } else {</a>
<a name="ln5448">          buf1[0] = NUL;</a>
<a name="ln5449">        }</a>
<a name="ln5450"> </a>
<a name="ln5451">        if (char_count_cursor == byte_count_cursor</a>
<a name="ln5452">            &amp;&amp; char_count == byte_count) {</a>
<a name="ln5453">          vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln5454">                       _(&quot;Selected %s%&quot; PRId64 &quot; of %&quot; PRId64 &quot; Lines;&quot;</a>
<a name="ln5455">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Words;&quot;</a>
<a name="ln5456">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Bytes&quot;),</a>
<a name="ln5457">                       buf1, (int64_t)line_count_selected,</a>
<a name="ln5458">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5459">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5460">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5461">        } else {</a>
<a name="ln5462">          vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln5463">                       _(&quot;Selected %s%&quot; PRId64 &quot; of %&quot; PRId64 &quot; Lines;&quot;</a>
<a name="ln5464">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Words;&quot;</a>
<a name="ln5465">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Chars;&quot;</a>
<a name="ln5466">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Bytes&quot;),</a>
<a name="ln5467">                       buf1, (int64_t)line_count_selected,</a>
<a name="ln5468">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5469">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5470">                       (int64_t)char_count_cursor, (int64_t)char_count,</a>
<a name="ln5471">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5472">        }</a>
<a name="ln5473">      } else {</a>
<a name="ln5474">        p = (char_u *)get_cursor_line_ptr();</a>
<a name="ln5475">        validate_virtcol();</a>
<a name="ln5476">        col_print((char *)buf1, sizeof(buf1), (int)curwin-&gt;w_cursor.col + 1,</a>
<a name="ln5477">                  (int)curwin-&gt;w_virtcol + 1);</a>
<a name="ln5478">        col_print((char *)buf2, sizeof(buf2), (int)STRLEN(p), linetabsize(p));</a>
<a name="ln5479"> </a>
<a name="ln5480">        if (char_count_cursor == byte_count_cursor</a>
<a name="ln5481">            &amp;&amp; char_count == byte_count) {</a>
<a name="ln5482">          vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln5483">                       _(&quot;Col %s of %s; Line %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5484">                         &quot; Word %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5485">                         &quot; Byte %&quot; PRId64 &quot; of %&quot; PRId64 &quot;&quot;),</a>
<a name="ln5486">                       (char *)buf1, (char *)buf2,</a>
<a name="ln5487">                       (int64_t)curwin-&gt;w_cursor.lnum,</a>
<a name="ln5488">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5489">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5490">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5491">        } else {</a>
<a name="ln5492">          vim_snprintf((char *)IObuff, IOSIZE,</a>
<a name="ln5493">                       _(&quot;Col %s of %s; Line %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5494">                         &quot; Word %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5495">                         &quot; Char %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5496">                         &quot; Byte %&quot; PRId64 &quot; of %&quot; PRId64 &quot;&quot;),</a>
<a name="ln5497">                       (char *)buf1, (char *)buf2,</a>
<a name="ln5498">                       (int64_t)curwin-&gt;w_cursor.lnum,</a>
<a name="ln5499">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5500">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5501">                       (int64_t)char_count_cursor, (int64_t)char_count,</a>
<a name="ln5502">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5503">        }</a>
<a name="ln5504">      }</a>
<a name="ln5505">    }</a>
<a name="ln5506"> </a>
<a name="ln5507">    bom_count = bomb_size();</a>
<a name="ln5508">    if (dict == NULL &amp;&amp; bom_count &gt; 0) {</a>
<a name="ln5509">      const size_t len = strlen(IObuff);</a>
<a name="ln5510">      vim_snprintf((char *)IObuff + len, IOSIZE - len,</a>
<a name="ln5511">                   _(&quot;(+%&quot; PRId64 &quot; for BOM)&quot;), (int64_t)bom_count);</a>
<a name="ln5512">    }</a>
<a name="ln5513">    if (dict == NULL) {</a>
<a name="ln5514">      // Don't shorten this message, the user asked for it.</a>
<a name="ln5515">      p = (char_u *)p_shm;</a>
<a name="ln5516">      p_shm = &quot;&quot;;</a>
<a name="ln5517">      if (p_ch &lt; 1) {</a>
<a name="ln5518">        msg_start();</a>
<a name="ln5519">        msg_scroll = true;</a>
<a name="ln5520">      }</a>
<a name="ln5521">      msg((char *)IObuff);</a>
<a name="ln5522">      p_shm = (char *)p;</a>
<a name="ln5523">    }</a>
<a name="ln5524">  }</a>
<a name="ln5525"> </a>
<a name="ln5526">  if (dict != NULL) {</a>
<a name="ln5527">    // Don't shorten this message, the user asked for it.</a>
<a name="ln5528">    tv_dict_add_nr(dict, S_LEN(&quot;words&quot;), word_count);</a>
<a name="ln5529">    tv_dict_add_nr(dict, S_LEN(&quot;chars&quot;), char_count);</a>
<a name="ln5530">    tv_dict_add_nr(dict, S_LEN(&quot;bytes&quot;), (varnumber_T)(byte_count + bom_count));</a>
<a name="ln5531"> </a>
<a name="ln5532">    STATIC_ASSERT(sizeof(&quot;visual&quot;) == sizeof(&quot;cursor&quot;),</a>
<a name="ln5533">                  &quot;key_len argument in tv_dict_add_nr is wrong&quot;);</a>
<a name="ln5534">    tv_dict_add_nr(dict, l_VIsual_active ? &quot;visual_bytes&quot; : &quot;cursor_bytes&quot;,</a>
<a name="ln5535">                   sizeof(&quot;visual_bytes&quot;) - 1, byte_count_cursor);</a>
<a name="ln5536">    tv_dict_add_nr(dict, l_VIsual_active ? &quot;visual_chars&quot; : &quot;cursor_chars&quot;,</a>
<a name="ln5537">                   sizeof(&quot;visual_chars&quot;) - 1, char_count_cursor);</a>
<a name="ln5538">    tv_dict_add_nr(dict, l_VIsual_active ? &quot;visual_words&quot; : &quot;cursor_words&quot;,</a>
<a name="ln5539">                   sizeof(&quot;visual_words&quot;) - 1, word_count_cursor);</a>
<a name="ln5540">  }</a>
<a name="ln5541">}</a>
<a name="ln5542"> </a>
<a name="ln5543">/// Handle indent and format operators and visual mode &quot;:&quot;.</a>
<a name="ln5544">static void op_colon(oparg_T *oap)</a>
<a name="ln5545">{</a>
<a name="ln5546">  stuffcharReadbuff(':');</a>
<a name="ln5547">  if (oap-&gt;is_VIsual) {</a>
<a name="ln5548">    stuffReadbuff(&quot;'&lt;,'&gt;&quot;);</a>
<a name="ln5549">  } else {</a>
<a name="ln5550">    // Make the range look nice, so it can be repeated.</a>
<a name="ln5551">    if (oap-&gt;start.lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln5552">      stuffcharReadbuff('.');</a>
<a name="ln5553">    } else {</a>
<a name="ln5554">      stuffnumReadbuff((long)oap-&gt;start.lnum);</a>
<a name="ln5555">    }</a>
<a name="ln5556">    if (oap-&gt;end.lnum != oap-&gt;start.lnum) {</a>
<a name="ln5557">      stuffcharReadbuff(',');</a>
<a name="ln5558">      if (oap-&gt;end.lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln5559">        stuffcharReadbuff('.');</a>
<a name="ln5560">      } else if (oap-&gt;end.lnum == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5561">        stuffcharReadbuff('$');</a>
<a name="ln5562">      } else if (oap-&gt;start.lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln5563">        stuffReadbuff(&quot;.+&quot;);</a>
<a name="ln5564">        stuffnumReadbuff(oap-&gt;line_count - 1);</a>
<a name="ln5565">      } else {</a>
<a name="ln5566">        stuffnumReadbuff((long)oap-&gt;end.lnum);</a>
<a name="ln5567">      }</a>
<a name="ln5568">    }</a>
<a name="ln5569">  }</a>
<a name="ln5570">  if (oap-&gt;op_type != OP_COLON) {</a>
<a name="ln5571">    stuffReadbuff(&quot;!&quot;);</a>
<a name="ln5572">  }</a>
<a name="ln5573">  if (oap-&gt;op_type == OP_INDENT) {</a>
<a name="ln5574">    stuffReadbuff((const char *)get_equalprg());</a>
<a name="ln5575">    stuffReadbuff(&quot;\n&quot;);</a>
<a name="ln5576">  } else if (oap-&gt;op_type == OP_FORMAT) {</a>
<a name="ln5577">    if (*curbuf-&gt;b_p_fp != NUL) {</a>
<a name="ln5578">      stuffReadbuff((const char *)curbuf-&gt;b_p_fp);</a>
<a name="ln5579">    } else if (*p_fp != NUL) {</a>
<a name="ln5580">      stuffReadbuff((const char *)p_fp);</a>
<a name="ln5581">    } else {</a>
<a name="ln5582">      stuffReadbuff(&quot;fmt&quot;);</a>
<a name="ln5583">    }</a>
<a name="ln5584">    stuffReadbuff(&quot;\n']&quot;);</a>
<a name="ln5585">  }</a>
<a name="ln5586"> </a>
<a name="ln5587">  // do_cmdline() does the rest</a>
<a name="ln5588">}</a>
<a name="ln5589"> </a>
<a name="ln5590">/// callback function for 'operatorfunc'</a>
<a name="ln5591">static Callback opfunc_cb;</a>
<a name="ln5592"> </a>
<a name="ln5593">/// Process the 'operatorfunc' option value.</a>
<a name="ln5594">/// @return  OK or FAIL</a>
<a name="ln5595">int set_operatorfunc_option(void)</a>
<a name="ln5596">{</a>
<a name="ln5597">  return option_set_callback_func(p_opfunc, &amp;opfunc_cb);</a>
<a name="ln5598">}</a>
<a name="ln5599"> </a>
<a name="ln5600">#if defined(EXITFREE)</a>
<a name="ln5601">void free_operatorfunc_option(void)</a>
<a name="ln5602">{</a>
<a name="ln5603">  callback_free(&amp;opfunc_cb);</a>
<a name="ln5604">}</a>
<a name="ln5605">#endif</a>
<a name="ln5606"> </a>
<a name="ln5607">/// Handle the &quot;g@&quot; operator: call 'operatorfunc'.</a>
<a name="ln5608">static void op_function(const oparg_T *oap)</a>
<a name="ln5609">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5610">{</a>
<a name="ln5611">  const TriState save_virtual_op = virtual_op;</a>
<a name="ln5612">  const bool save_finish_op = finish_op;</a>
<a name="ln5613">  const pos_T orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln5614">  const pos_T orig_end = curbuf-&gt;b_op_end;</a>
<a name="ln5615"> </a>
<a name="ln5616">  if (*p_opfunc == NUL) {</a>
<a name="ln5617">    emsg(_(&quot;E774: 'operatorfunc' is empty&quot;));</a>
<a name="ln5618">  } else {</a>
<a name="ln5619">    // Set '[ and '] marks to text to be operated on.</a>
<a name="ln5620">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln5621">    curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln5622">    if (oap-&gt;motion_type != kMTLineWise &amp;&amp; !oap-&gt;inclusive) {</a>
<a name="ln5623">      // Exclude the end position.</a>
<a name="ln5624">      decl(&amp;curbuf-&gt;b_op_end);</a>
<a name="ln5625">    }</a>
<a name="ln5626"> </a>
<a name="ln5627">    typval_T argv[2];</a>
<a name="ln5628">    argv[0].v_type = VAR_STRING;</a>
<a name="ln5629">    argv[1].v_type = VAR_UNKNOWN;</a>
<a name="ln5630">    argv[0].vval.v_string =</a>
<a name="ln5631">      (char *)(((const char *const[]) {</a>
<a name="ln5632">      [kMTBlockWise] = &quot;block&quot;,</a>
<a name="ln5633">      [kMTLineWise] = &quot;line&quot;,</a>
<a name="ln5634">      [kMTCharWise] = &quot;char&quot;,</a>
<a name="ln5635">    })[oap-&gt;motion_type]);</a>
<a name="ln5636"> </a>
<a name="ln5637">    // Reset virtual_op so that 'virtualedit' can be changed in the</a>
<a name="ln5638">    // function.</a>
<a name="ln5639">    virtual_op = kNone;</a>
<a name="ln5640"> </a>
<a name="ln5641">    // Reset finish_op so that mode() returns the right value.</a>
<a name="ln5642">    finish_op = false;</a>
<a name="ln5643"> </a>
<a name="ln5644">    typval_T rettv;</a>
<a name="ln5645">    if (callback_call(&amp;opfunc_cb, 1, argv, &amp;rettv)) {</a>
<a name="ln5646">      tv_clear(&amp;rettv);</a>
<a name="ln5647">    }</a>
<a name="ln5648"> </a>
<a name="ln5649">    virtual_op = save_virtual_op;</a>
<a name="ln5650">    finish_op = save_finish_op;</a>
<a name="ln5651">    if (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) {</a>
<a name="ln5652">      curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln5653">      curbuf-&gt;b_op_end = orig_end;</a>
<a name="ln5654">    }</a>
<a name="ln5655">  }</a>
<a name="ln5656">}</a>
<a name="ln5657"> </a>
<a name="ln5658">/// Calculate start/end virtual columns for operating in block mode.</a>
<a name="ln5659">///</a>
<a name="ln5660">/// @param initial  when true: adjust position for 'selectmode'</a>
<a name="ln5661">static void get_op_vcol(oparg_T *oap, colnr_T redo_VIsual_vcol, bool initial)</a>
<a name="ln5662">{</a>
<a name="ln5663">  colnr_T start;</a>
<a name="ln5664">  colnr_T end;</a>
<a name="ln5665"> </a>
<a name="ln5666">  if (VIsual_mode != Ctrl_V</a>
<a name="ln5667">      || (!initial &amp;&amp; oap-&gt;end.col &lt; curwin-&gt;w_width_inner)) {</a>
<a name="ln5668">    return;</a>
<a name="ln5669">  }</a>
<a name="ln5670"> </a>
<a name="ln5671">  oap-&gt;motion_type = kMTBlockWise;</a>
<a name="ln5672"> </a>
<a name="ln5673">  // prevent from moving onto a trail byte</a>
<a name="ln5674">  mark_mb_adjustpos(curwin-&gt;w_buffer, &amp;oap-&gt;end);</a>
<a name="ln5675"> </a>
<a name="ln5676">  getvvcol(curwin, &amp;(oap-&gt;start), &amp;oap-&gt;start_vcol, NULL, &amp;oap-&gt;end_vcol);</a>
<a name="ln5677">  if (!redo_VIsual_busy) {</a>
<a name="ln5678">    getvvcol(curwin, &amp;(oap-&gt;end), &amp;start, NULL, &amp;end);</a>
<a name="ln5679"> </a>
<a name="ln5680">    if (start &lt; oap-&gt;start_vcol) {</a>
<a name="ln5681">      oap-&gt;start_vcol = start;</a>
<a name="ln5682">    }</a>
<a name="ln5683">    if (end &gt; oap-&gt;end_vcol) {</a>
<a name="ln5684">      if (initial &amp;&amp; *p_sel == 'e'</a>
<a name="ln5685">          &amp;&amp; start &gt;= 1</a>
<a name="ln5686">          &amp;&amp; start - 1 &gt;= oap-&gt;end_vcol) {</a>
<a name="ln5687">        oap-&gt;end_vcol = start - 1;</a>
<a name="ln5688">      } else {</a>
<a name="ln5689">        oap-&gt;end_vcol = end;</a>
<a name="ln5690">      }</a>
<a name="ln5691">    }</a>
<a name="ln5692">  }</a>
<a name="ln5693"> </a>
<a name="ln5694">  // if '$' was used, get oap-&gt;end_vcol from longest line</a>
<a name="ln5695">  if (curwin-&gt;w_curswant == MAXCOL) {</a>
<a name="ln5696">    curwin-&gt;w_cursor.col = MAXCOL;</a>
<a name="ln5697">    oap-&gt;end_vcol = 0;</a>
<a name="ln5698">    for (curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln5699">         curwin-&gt;w_cursor.lnum &lt;= oap-&gt;end.lnum; curwin-&gt;w_cursor.lnum++) {</a>
<a name="ln5700">      getvvcol(curwin, &amp;curwin-&gt;w_cursor, NULL, NULL, &amp;end);</a>
<a name="ln5701">      if (end &gt; oap-&gt;end_vcol) {</a>
<a name="ln5702">        oap-&gt;end_vcol = end;</a>
<a name="ln5703">      }</a>
<a name="ln5704">    }</a>
<a name="ln5705">  } else if (redo_VIsual_busy) {</a>
<a name="ln5706">    oap-&gt;end_vcol = oap-&gt;start_vcol + redo_VIsual_vcol - 1;</a>
<a name="ln5707">  }</a>
<a name="ln5708"> </a>
<a name="ln5709">  // Correct oap-&gt;end.col and oap-&gt;start.col to be the</a>
<a name="ln5710">  // upper-left and lower-right corner of the block area.</a>
<a name="ln5711">  //</a>
<a name="ln5712">  // (Actually, this does convert column positions into character</a>
<a name="ln5713">  // positions)</a>
<a name="ln5714">  curwin-&gt;w_cursor.lnum = oap-&gt;end.lnum;</a>
<a name="ln5715">  coladvance(oap-&gt;end_vcol);</a>
<a name="ln5716">  oap-&gt;end = curwin-&gt;w_cursor;</a>
<a name="ln5717"> </a>
<a name="ln5718">  curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln5719">  coladvance(oap-&gt;start_vcol);</a>
<a name="ln5720">  oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln5721">}</a>
<a name="ln5722"> </a>
<a name="ln5723">/// Information for redoing the previous Visual selection.</a>
<a name="ln5724">typedef struct {</a>
<a name="ln5725">  int rv_mode;             ///&lt; 'v', 'V', or Ctrl-V</a>
<a name="ln5726">  linenr_T rv_line_count;  ///&lt; number of lines</a>
<a name="ln5727">  colnr_T rv_vcol;         ///&lt; number of cols or end column</a>
<a name="ln5728">  long rv_count;           ///&lt; count for Visual operator</a>
<a name="ln5729">  int rv_arg;              ///&lt; extra argument</a>
<a name="ln5730">} redo_VIsual_T;</a>
<a name="ln5731"> </a>
<a name="ln5732">/// Handle an operator after Visual mode or when the movement is finished.</a>
<a name="ln5733">/// &quot;gui_yank&quot; is true when yanking text for the clipboard.</a>
<a name="ln5734">void do_pending_operator(cmdarg_T *cap, int old_col, bool gui_yank)</a>
<a name="ln5735">{</a>
<a name="ln5736">  oparg_T *oap = cap-&gt;oap;</a>
<a name="ln5737">  pos_T old_cursor;</a>
<a name="ln5738">  bool empty_region_error;</a>
<a name="ln5739">  int restart_edit_save;</a>
<a name="ln5740">  int lbr_saved = curwin-&gt;w_p_lbr;</a>
<a name="ln5741"> </a>
<a name="ln5742">  // The visual area is remembered for redo</a>
<a name="ln5743">  static redo_VIsual_T redo_VIsual = { NUL, 0, 0, 0, 0 };</a>
<a name="ln5744"> </a>
<a name="ln5745">  bool include_line_break = false;</a>
<a name="ln5746"> </a>
<a name="ln5747">  old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln5748"> </a>
<a name="ln5749">  // If an operation is pending, handle it...</a>
<a name="ln5750">  if ((finish_op</a>
<a name="ln5751">       || VIsual_active)</a>
<a name="ln5752">      &amp;&amp; oap-&gt;op_type != OP_NOP) {</a>
<a name="ln5753">    // Yank can be redone when 'y' is in 'cpoptions', but not when yanking</a>
<a name="ln5754">    // for the clipboard.</a>
<a name="ln5755">    const bool redo_yank = vim_strchr(p_cpo, CPO_YANK) != NULL &amp;&amp; !gui_yank;</a>
<a name="ln5756"> </a>
<a name="ln5757">    // Avoid a problem with unwanted linebreaks in block mode</a>
<a name="ln5758">    (void)reset_lbr();</a>
<a name="ln5759">    oap-&gt;is_VIsual = VIsual_active;</a>
<a name="ln5760">    if (oap-&gt;motion_force == 'V') {</a>
<a name="ln5761">      oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln5762">    } else if (oap-&gt;motion_force == 'v') {</a>
<a name="ln5763">      // If the motion was linewise, &quot;inclusive&quot; will not have been set.</a>
<a name="ln5764">      // Use &quot;exclusive&quot; to be consistent.  Makes &quot;dvj&quot; work nice.</a>
<a name="ln5765">      if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln5766">        oap-&gt;inclusive = false;</a>
<a name="ln5767">      } else if (oap-&gt;motion_type == kMTCharWise) {</a>
<a name="ln5768">        // If the motion already was charwise, toggle &quot;inclusive&quot;</a>
<a name="ln5769">        oap-&gt;inclusive = !oap-&gt;inclusive;</a>
<a name="ln5770">      }</a>
<a name="ln5771">      oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln5772">    } else if (oap-&gt;motion_force == Ctrl_V) {</a>
<a name="ln5773">      // Change line- or charwise motion into Visual block mode.</a>
<a name="ln5774">      if (!VIsual_active) {</a>
<a name="ln5775">        VIsual_active = true;</a>
<a name="ln5776">        VIsual = oap-&gt;start;</a>
<a name="ln5777">      }</a>
<a name="ln5778">      VIsual_mode = Ctrl_V;</a>
<a name="ln5779">      VIsual_select = false;</a>
<a name="ln5780">      VIsual_reselect = false;</a>
<a name="ln5781">    }</a>
<a name="ln5782"> </a>
<a name="ln5783">    // Only redo yank when 'y' flag is in 'cpoptions'.</a>
<a name="ln5784">    // Never redo &quot;zf&quot; (define fold).</a>
<a name="ln5785">    if ((redo_yank || oap-&gt;op_type != OP_YANK)</a>
<a name="ln5786">        &amp;&amp; ((!VIsual_active || oap-&gt;motion_force)</a>
<a name="ln5787">            // Also redo Operator-pending Visual mode mappings.</a>
<a name="ln5788">            || ((cap-&gt;cmdchar == ':' || cap-&gt;cmdchar == K_COMMAND)</a>
<a name="ln5789">                &amp;&amp; oap-&gt;op_type != OP_COLON))</a>
<a name="ln5790">        &amp;&amp; cap-&gt;cmdchar != 'D'</a>
<a name="ln5791">        &amp;&amp; oap-&gt;op_type != OP_FOLD</a>
<a name="ln5792">        &amp;&amp; oap-&gt;op_type != OP_FOLDOPEN</a>
<a name="ln5793">        &amp;&amp; oap-&gt;op_type != OP_FOLDOPENREC</a>
<a name="ln5794">        &amp;&amp; oap-&gt;op_type != OP_FOLDCLOSE</a>
<a name="ln5795">        &amp;&amp; oap-&gt;op_type != OP_FOLDCLOSEREC</a>
<a name="ln5796">        &amp;&amp; oap-&gt;op_type != OP_FOLDDEL</a>
<a name="ln5797">        &amp;&amp; oap-&gt;op_type != OP_FOLDDELREC) {</a>
<a name="ln5798">      prep_redo(oap-&gt;regname, cap-&gt;count0,</a>
<a name="ln5799">                get_op_char(oap-&gt;op_type), get_extra_op_char(oap-&gt;op_type),</a>
<a name="ln5800">                oap-&gt;motion_force, cap-&gt;cmdchar, cap-&gt;nchar);</a>
<a name="ln5801">      if (cap-&gt;cmdchar == '/' || cap-&gt;cmdchar == '?') {     // was a search</a>
<a name="ln5802">        // If 'cpoptions' does not contain 'r', insert the search</a>
<a name="ln5803">        // pattern to really repeat the same command.</a>
<a name="ln5804">        if (vim_strchr(p_cpo, CPO_REDO) == NULL) {</a>
<a name="ln5805">          AppendToRedobuffLit(cap-&gt;searchbuf, -1);</a>
<a name="ln5806">        }</a>
<a name="ln5807">        AppendToRedobuff(NL_STR);</a>
<a name="ln5808">      } else if (cap-&gt;cmdchar == ':' || cap-&gt;cmdchar == K_COMMAND) {</a>
<a name="ln5809">        // do_cmdline() has stored the first typed line in</a>
<a name="ln5810">        // &quot;repeat_cmdline&quot;.  When several lines are typed repeating</a>
<a name="ln5811">        // won't be possible.</a>
<a name="ln5812">        if (repeat_cmdline == NULL) {</a>
<a name="ln5813">          ResetRedobuff();</a>
<a name="ln5814">        } else {</a>
<a name="ln5815">          AppendToRedobuffLit(repeat_cmdline, -1);</a>
<a name="ln5816">          AppendToRedobuff(NL_STR);</a>
<a name="ln5817">          XFREE_CLEAR(repeat_cmdline);</a>
<a name="ln5818">        }</a>
<a name="ln5819">      }</a>
<a name="ln5820">    }</a>
<a name="ln5821"> </a>
<a name="ln5822">    if (redo_VIsual_busy) {</a>
<a name="ln5823">      // Redo of an operation on a Visual area. Use the same size from</a>
<a name="ln5824">      // redo_VIsual.rv_line_count and redo_VIsual.rv_vcol.</a>
<a name="ln5825">      oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln5826">      curwin-&gt;w_cursor.lnum += redo_VIsual.rv_line_count - 1;</a>
<a name="ln5827">      if (curwin-&gt;w_cursor.lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5828">        curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln5829">      }</a>
<a name="ln5830">      VIsual_mode = redo_VIsual.rv_mode;</a>
<a name="ln5831">      if (redo_VIsual.rv_vcol == MAXCOL || VIsual_mode == 'v') {</a>
<a name="ln5832">        if (VIsual_mode == 'v') {</a>
<a name="ln5833">          if (redo_VIsual.rv_line_count &lt;= 1) {</a>
<a name="ln5834">            validate_virtcol();</a>
<a name="ln5835">            curwin-&gt;w_curswant = curwin-&gt;w_virtcol + redo_VIsual.rv_vcol - 1;</a>
<a name="ln5836">          } else {</a>
<a name="ln5837">            curwin-&gt;w_curswant = redo_VIsual.rv_vcol;</a>
<a name="ln5838">          }</a>
<a name="ln5839">        } else {</a>
<a name="ln5840">          curwin-&gt;w_curswant = MAXCOL;</a>
<a name="ln5841">        }</a>
<a name="ln5842">        coladvance(curwin-&gt;w_curswant);</a>
<a name="ln5843">      }</a>
<a name="ln5844">      cap-&gt;count0 = redo_VIsual.rv_count;</a>
<a name="ln5845">      cap-&gt;count1 = (cap-&gt;count0 == 0 ? 1 : cap-&gt;count0);</a>
<a name="ln5846">    } else if (VIsual_active) {</a>
<a name="ln5847">      if (!gui_yank) {</a>
<a name="ln5848">        // Save the current VIsual area for '&lt; and '&gt; marks, and &quot;gv&quot;</a>
<a name="ln5849">        curbuf-&gt;b_visual.vi_start = VIsual;</a>
<a name="ln5850">        curbuf-&gt;b_visual.vi_end = curwin-&gt;w_cursor;</a>
<a name="ln5851">        curbuf-&gt;b_visual.vi_mode = VIsual_mode;</a>
<a name="ln5852">        restore_visual_mode();</a>
<a name="ln5853">        curbuf-&gt;b_visual.vi_curswant = curwin-&gt;w_curswant;</a>
<a name="ln5854">        curbuf-&gt;b_visual_mode_eval = VIsual_mode;</a>
<a name="ln5855">      }</a>
<a name="ln5856"> </a>
<a name="ln5857">      // In Select mode, a linewise selection is operated upon like a</a>
<a name="ln5858">      // charwise selection.</a>
<a name="ln5859">      // Special case: gH&lt;Del&gt; deletes the last line.</a>
<a name="ln5860">      if (VIsual_select &amp;&amp; VIsual_mode == 'V'</a>
<a name="ln5861">          &amp;&amp; cap-&gt;oap-&gt;op_type != OP_DELETE) {</a>
<a name="ln5862">        if (lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln5863">          VIsual.col = 0;</a>
<a name="ln5864">          curwin-&gt;w_cursor.col =</a>
<a name="ln5865">            (colnr_T)strlen(ml_get(curwin-&gt;w_cursor.lnum));</a>
<a name="ln5866">        } else {</a>
<a name="ln5867">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln5868">          VIsual.col = (colnr_T)strlen(ml_get(VIsual.lnum));</a>
<a name="ln5869">        }</a>
<a name="ln5870">        VIsual_mode = 'v';</a>
<a name="ln5871">      } else if (VIsual_mode == 'v') {</a>
<a name="ln5872">        // If 'selection' is &quot;exclusive&quot;, backup one character for</a>
<a name="ln5873">        // charwise selections.</a>
<a name="ln5874">        include_line_break =</a>
<a name="ln5875">          unadjust_for_sel();</a>
<a name="ln5876">      }</a>
<a name="ln5877"> </a>
<a name="ln5878">      oap-&gt;start = VIsual;</a>
<a name="ln5879">      if (VIsual_mode == 'V') {</a>
<a name="ln5880">        oap-&gt;start.col = 0;</a>
<a name="ln5881">        oap-&gt;start.coladd = 0;</a>
<a name="ln5882">      }</a>
<a name="ln5883">    }</a>
<a name="ln5884"> </a>
<a name="ln5885">    // Set oap-&gt;start to the first position of the operated text, oap-&gt;end</a>
<a name="ln5886">    // to the end of the operated text.  w_cursor is equal to oap-&gt;start.</a>
<a name="ln5887">    if (lt(oap-&gt;start, curwin-&gt;w_cursor)) {</a>
<a name="ln5888">      // Include folded lines completely.</a>
<a name="ln5889">      if (!VIsual_active) {</a>
<a name="ln5890">        if (hasFolding(oap-&gt;start.lnum, &amp;oap-&gt;start.lnum, NULL)) {</a>
<a name="ln5891">          oap-&gt;start.col = 0;</a>
<a name="ln5892">        }</a>
<a name="ln5893">        if ((curwin-&gt;w_cursor.col &gt; 0</a>
<a name="ln5894">             || oap-&gt;inclusive</a>
<a name="ln5895">             || oap-&gt;motion_type == kMTLineWise)</a>
<a name="ln5896">            &amp;&amp; hasFolding(curwin-&gt;w_cursor.lnum, NULL,</a>
<a name="ln5897">                          &amp;curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln5898">          curwin-&gt;w_cursor.col = (colnr_T)strlen(get_cursor_line_ptr());</a>
<a name="ln5899">        }</a>
<a name="ln5900">      }</a>
<a name="ln5901">      oap-&gt;end = curwin-&gt;w_cursor;</a>
<a name="ln5902">      curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln5903"> </a>
<a name="ln5904">      // w_virtcol may have been updated; if the cursor goes back to its</a>
<a name="ln5905">      // previous position w_virtcol becomes invalid and isn't updated</a>
<a name="ln5906">      // automatically.</a>
<a name="ln5907">      curwin-&gt;w_valid &amp;= ~VALID_VIRTCOL;</a>
<a name="ln5908">    } else {</a>
<a name="ln5909">      // Include folded lines completely.</a>
<a name="ln5910">      if (!VIsual_active &amp;&amp; oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln5911">        if (hasFolding(curwin-&gt;w_cursor.lnum, &amp;curwin-&gt;w_cursor.lnum,</a>
<a name="ln5912">                       NULL)) {</a>
<a name="ln5913">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln5914">        }</a>
<a name="ln5915">        if (hasFolding(oap-&gt;start.lnum, NULL, &amp;oap-&gt;start.lnum)) {</a>
<a name="ln5916">          oap-&gt;start.col = (colnr_T)strlen(ml_get(oap-&gt;start.lnum));</a>
<a name="ln5917">        }</a>
<a name="ln5918">      }</a>
<a name="ln5919">      oap-&gt;end = oap-&gt;start;</a>
<a name="ln5920">      oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln5921">    }</a>
<a name="ln5922"> </a>
<a name="ln5923">    // Just in case lines were deleted that make the position invalid.</a>
<a name="ln5924">    check_pos(curwin-&gt;w_buffer, &amp;oap-&gt;end);</a>
<a name="ln5925">    oap-&gt;line_count = oap-&gt;end.lnum - oap-&gt;start.lnum + 1;</a>
<a name="ln5926"> </a>
<a name="ln5927">    // Set &quot;virtual_op&quot; before resetting VIsual_active.</a>
<a name="ln5928">    virtual_op = virtual_active();</a>
<a name="ln5929"> </a>
<a name="ln5930">    if (VIsual_active || redo_VIsual_busy) {</a>
<a name="ln5931">      get_op_vcol(oap, redo_VIsual.rv_vcol, true);</a>
<a name="ln5932"> </a>
<a name="ln5933">      if (!redo_VIsual_busy &amp;&amp; !gui_yank) {</a>
<a name="ln5934">        // Prepare to reselect and redo Visual: this is based on the</a>
<a name="ln5935">        // size of the Visual text</a>
<a name="ln5936">        resel_VIsual_mode = VIsual_mode;</a>
<a name="ln5937">        if (curwin-&gt;w_curswant == MAXCOL) {</a>
<a name="ln5938">          resel_VIsual_vcol = MAXCOL;</a>
<a name="ln5939">        } else {</a>
<a name="ln5940">          if (VIsual_mode != Ctrl_V) {</a>
<a name="ln5941">            getvvcol(curwin, &amp;(oap-&gt;end),</a>
<a name="ln5942">                     NULL, NULL, &amp;oap-&gt;end_vcol);</a>
<a name="ln5943">          }</a>
<a name="ln5944">          if (VIsual_mode == Ctrl_V || oap-&gt;line_count &lt;= 1) {</a>
<a name="ln5945">            if (VIsual_mode != Ctrl_V) {</a>
<a name="ln5946">              getvvcol(curwin, &amp;(oap-&gt;start),</a>
<a name="ln5947">                       &amp;oap-&gt;start_vcol, NULL, NULL);</a>
<a name="ln5948">            }</a>
<a name="ln5949">            resel_VIsual_vcol = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln5950">          } else {</a>
<a name="ln5951">            resel_VIsual_vcol = oap-&gt;end_vcol;</a>
<a name="ln5952">          }</a>
<a name="ln5953">        }</a>
<a name="ln5954">        resel_VIsual_line_count = (linenr_T)oap-&gt;line_count;</a>
<a name="ln5955">      }</a>
<a name="ln5956"> </a>
<a name="ln5957">      // can't redo yank (unless 'y' is in 'cpoptions') and &quot;:&quot;</a>
<a name="ln5958">      if ((redo_yank || oap-&gt;op_type != OP_YANK)</a>
<a name="ln5959">          &amp;&amp; oap-&gt;op_type != OP_COLON</a>
<a name="ln5960">          &amp;&amp; oap-&gt;op_type != OP_FOLD</a>
<a name="ln5961">          &amp;&amp; oap-&gt;op_type != OP_FOLDOPEN</a>
<a name="ln5962">          &amp;&amp; oap-&gt;op_type != OP_FOLDOPENREC</a>
<a name="ln5963">          &amp;&amp; oap-&gt;op_type != OP_FOLDCLOSE</a>
<a name="ln5964">          &amp;&amp; oap-&gt;op_type != OP_FOLDCLOSEREC</a>
<a name="ln5965">          &amp;&amp; oap-&gt;op_type != OP_FOLDDEL</a>
<a name="ln5966">          &amp;&amp; oap-&gt;op_type != OP_FOLDDELREC</a>
<a name="ln5967">          &amp;&amp; oap-&gt;motion_force == NUL) {</a>
<a name="ln5968">        // Prepare for redoing.  Only use the nchar field for &quot;r&quot;,</a>
<a name="ln5969">        // otherwise it might be the second char of the operator.</a>
<a name="ln5970">        if (cap-&gt;cmdchar == 'g' &amp;&amp; (cap-&gt;nchar == 'n'</a>
<a name="ln5971">                                    || cap-&gt;nchar == 'N')) {</a>
<a name="ln5972">          prep_redo(oap-&gt;regname, cap-&gt;count0,</a>
<a name="ln5973">                    get_op_char(oap-&gt;op_type), get_extra_op_char(oap-&gt;op_type),</a>
<a name="ln5974">                    oap-&gt;motion_force, cap-&gt;cmdchar, cap-&gt;nchar);</a>
<a name="ln5975">        } else if (cap-&gt;cmdchar != ':' &amp;&amp; cap-&gt;cmdchar != K_COMMAND) {</a>
<a name="ln5976">          int opchar = get_op_char(oap-&gt;op_type);</a>
<a name="ln5977">          int extra_opchar = get_extra_op_char(oap-&gt;op_type);</a>
<a name="ln5978">          int nchar = oap-&gt;op_type == OP_REPLACE ? cap-&gt;nchar : NUL;</a>
<a name="ln5979"> </a>
<a name="ln5980">          // reverse what nv_replace() did</a>
<a name="ln5981">          if (nchar == REPLACE_CR_NCHAR) {</a>
<a name="ln5982">            nchar = CAR;</a>
<a name="ln5983">          } else if (nchar == REPLACE_NL_NCHAR) {</a>
<a name="ln5984">            nchar = NL;</a>
<a name="ln5985">          }</a>
<a name="ln5986"> </a>
<a name="ln5987">          if (opchar == 'g' &amp;&amp; extra_opchar == '@') {</a>
<a name="ln5988">            // also repeat the count for 'operatorfunc'</a>
<a name="ln5989">            prep_redo_num2(oap-&gt;regname, 0L, NUL, 'v', cap-&gt;count0, opchar, extra_opchar, nchar);</a>
<a name="ln5990">          } else {</a>
<a name="ln5991">            prep_redo(oap-&gt;regname, 0L, NUL, 'v', opchar, extra_opchar, nchar);</a>
<a name="ln5992">          }</a>
<a name="ln5993">        }</a>
<a name="ln5994">        if (!redo_VIsual_busy) {</a>
<a name="ln5995">          redo_VIsual.rv_mode = resel_VIsual_mode;</a>
<a name="ln5996">          redo_VIsual.rv_vcol = resel_VIsual_vcol;</a>
<a name="ln5997">          redo_VIsual.rv_line_count = resel_VIsual_line_count;</a>
<a name="ln5998">          redo_VIsual.rv_count = cap-&gt;count0;</a>
<a name="ln5999">          redo_VIsual.rv_arg = cap-&gt;arg;</a>
<a name="ln6000">        }</a>
<a name="ln6001">      }</a>
<a name="ln6002"> </a>
<a name="ln6003">      // oap-&gt;inclusive defaults to true.</a>
<a name="ln6004">      // If oap-&gt;end is on a NUL (empty line) oap-&gt;inclusive becomes</a>
<a name="ln6005">      // false.  This makes &quot;d}P&quot; and &quot;v}dP&quot; work the same.</a>
<a name="ln6006">      if (oap-&gt;motion_force == NUL || oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln6007">        oap-&gt;inclusive = true;</a>
<a name="ln6008">      }</a>
<a name="ln6009">      if (VIsual_mode == 'V') {</a>
<a name="ln6010">        oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln6011">      } else if (VIsual_mode == 'v') {</a>
<a name="ln6012">        oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln6013">        if (*ml_get_pos(&amp;(oap-&gt;end)) == NUL</a>
<a name="ln6014">            &amp;&amp; (include_line_break || !virtual_op)) {</a>
<a name="ln6015">          oap-&gt;inclusive = false;</a>
<a name="ln6016">          // Try to include the newline, unless it's an operator</a>
<a name="ln6017">          // that works on lines only.</a>
<a name="ln6018">          if (*p_sel != 'o'</a>
<a name="ln6019">              &amp;&amp; !op_on_lines(oap-&gt;op_type)</a>
<a name="ln6020">              &amp;&amp; oap-&gt;end.lnum &lt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6021">            oap-&gt;end.lnum++;</a>
<a name="ln6022">            oap-&gt;end.col = 0;</a>
<a name="ln6023">            oap-&gt;end.coladd = 0;</a>
<a name="ln6024">            oap-&gt;line_count++;</a>
<a name="ln6025">          }</a>
<a name="ln6026">        }</a>
<a name="ln6027">      }</a>
<a name="ln6028"> </a>
<a name="ln6029">      redo_VIsual_busy = false;</a>
<a name="ln6030"> </a>
<a name="ln6031">      // Switch Visual off now, so screen updating does</a>
<a name="ln6032">      // not show inverted text when the screen is redrawn.</a>
<a name="ln6033">      // With OP_YANK and sometimes with OP_COLON and OP_FILTER there is</a>
<a name="ln6034">      // no screen redraw, so it is done here to remove the inverted</a>
<a name="ln6035">      // part.</a>
<a name="ln6036">      if (!gui_yank) {</a>
<a name="ln6037">        VIsual_active = false;</a>
<a name="ln6038">        setmouse();</a>
<a name="ln6039">        mouse_dragging = 0;</a>
<a name="ln6040">        may_clear_cmdline();</a>
<a name="ln6041">        if ((oap-&gt;op_type == OP_YANK</a>
<a name="ln6042">             || oap-&gt;op_type == OP_COLON</a>
<a name="ln6043">             || oap-&gt;op_type == OP_FUNCTION</a>
<a name="ln6044">             || oap-&gt;op_type == OP_FILTER)</a>
<a name="ln6045">            &amp;&amp; oap-&gt;motion_force == NUL) {</a>
<a name="ln6046">          // Make sure redrawing is correct.</a>
<a name="ln6047">          restore_lbr(lbr_saved);</a>
<a name="ln6048">          redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln6049">        }</a>
<a name="ln6050">      }</a>
<a name="ln6051">    }</a>
<a name="ln6052"> </a>
<a name="ln6053">    // Include the trailing byte of a multi-byte char.</a>
<a name="ln6054">    if (oap-&gt;inclusive) {</a>
<a name="ln6055">      const int l = utfc_ptr2len((char *)ml_get_pos(&amp;oap-&gt;end));</a>
<a name="ln6056">      if (l &gt; 1) {</a>
<a name="ln6057">        oap-&gt;end.col += l - 1;</a>
<a name="ln6058">      }</a>
<a name="ln6059">    }</a>
<a name="ln6060">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln6061"> </a>
<a name="ln6062">    // oap-&gt;empty is set when start and end are the same.  The inclusive</a>
<a name="ln6063">    // flag affects this too, unless yanking and the end is on a NUL.</a>
<a name="ln6064">    oap-&gt;empty = (oap-&gt;motion_type != kMTLineWise</a>
<a name="ln6065">                  &amp;&amp; (!oap-&gt;inclusive</a>
<a name="ln6066">                      || (oap-&gt;op_type == OP_YANK</a>
<a name="ln6067">                          &amp;&amp; gchar_pos(&amp;oap-&gt;end) == NUL))</a>
<a name="ln6068">                  &amp;&amp; equalpos(oap-&gt;start, oap-&gt;end)</a>
<a name="ln6069">                  &amp;&amp; !(virtual_op &amp;&amp; oap-&gt;start.coladd != oap-&gt;end.coladd));</a>
<a name="ln6070">    // For delete, change and yank, it's an error to operate on an</a>
<a name="ln6071">    // empty region, when 'E' included in 'cpoptions' (Vi compatible).</a>
<a name="ln6072">    empty_region_error = (oap-&gt;empty</a>
<a name="ln6073">                          &amp;&amp; vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL);</a>
<a name="ln6074"> </a>
<a name="ln6075">    // Force a redraw when operating on an empty Visual region, when</a>
<a name="ln6076">    // 'modifiable is off or creating a fold.</a>
<a name="ln6077">    if (oap-&gt;is_VIsual &amp;&amp; (oap-&gt;empty || !MODIFIABLE(curbuf)</a>
<a name="ln6078">                           || oap-&gt;op_type == OP_FOLD)) {</a>
<a name="ln6079">      restore_lbr(lbr_saved);</a>
<a name="ln6080">      redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln6081">    }</a>
<a name="ln6082"> </a>
<a name="ln6083">    // If the end of an operator is in column one while oap-&gt;motion_type</a>
<a name="ln6084">    // is kMTCharWise and oap-&gt;inclusive is false, we put op_end after the last</a>
<a name="ln6085">    // character in the previous line. If op_start is on or before the</a>
<a name="ln6086">    // first non-blank in the line, the operator becomes linewise</a>
<a name="ln6087">    // (strange, but that's the way vi does it).</a>
<a name="ln6088">    if (oap-&gt;motion_type == kMTCharWise</a>
<a name="ln6089">        &amp;&amp; oap-&gt;inclusive == false</a>
<a name="ln6090">        &amp;&amp; !(cap-&gt;retval &amp; CA_NO_ADJ_OP_END)</a>
<a name="ln6091">        &amp;&amp; oap-&gt;end.col == 0</a>
<a name="ln6092">        &amp;&amp; (!oap-&gt;is_VIsual || *p_sel == 'o')</a>
<a name="ln6093">        &amp;&amp; oap-&gt;line_count &gt; 1) {</a>
<a name="ln6094">      oap-&gt;end_adjusted = true;  // remember that we did this</a>
<a name="ln6095">      oap-&gt;line_count--;</a>
<a name="ln6096">      oap-&gt;end.lnum--;</a>
<a name="ln6097">      if (inindent(0)) {</a>
<a name="ln6098">        oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln6099">      } else {</a>
<a name="ln6100">        oap-&gt;end.col = (colnr_T)strlen(ml_get(oap-&gt;end.lnum));</a>
<a name="ln6101">        if (oap-&gt;end.col) {</a>
<a name="ln6102">          oap-&gt;end.col--;</a>
<a name="ln6103">          oap-&gt;inclusive = true;</a>
<a name="ln6104">        }</a>
<a name="ln6105">      }</a>
<a name="ln6106">    } else {</a>
<a name="ln6107">      oap-&gt;end_adjusted = false;</a>
<a name="ln6108">    }</a>
<a name="ln6109"> </a>
<a name="ln6110">    switch (oap-&gt;op_type) {</a>
<a name="ln6111">    case OP_LSHIFT:</a>
<a name="ln6112">    case OP_RSHIFT:</a>
<a name="ln6113">      op_shift(oap, true, oap-&gt;is_VIsual ? (int)cap-&gt;count1 : 1);</a>
<a name="ln6114">      auto_format(false, true);</a>
<a name="ln6115">      break;</a>
<a name="ln6116"> </a>
<a name="ln6117">    case OP_JOIN_NS:</a>
<a name="ln6118">    case OP_JOIN:</a>
<a name="ln6119">      if (oap-&gt;line_count &lt; 2) {</a>
<a name="ln6120">        oap-&gt;line_count = 2;</a>
<a name="ln6121">      }</a>
<a name="ln6122">      if (curwin-&gt;w_cursor.lnum + oap-&gt;line_count - 1 &gt;</a>
<a name="ln6123">          curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6124">        beep_flush();</a>
<a name="ln6125">      } else {</a>
<a name="ln6126">        do_join((size_t)oap-&gt;line_count, oap-&gt;op_type == OP_JOIN,</a>
<a name="ln6127">                true, true, true);</a>
<a name="ln6128">        auto_format(false, true);</a>
<a name="ln6129">      }</a>
<a name="ln6130">      break;</a>
<a name="ln6131"> </a>
<a name="ln6132">    case OP_DELETE:</a>
<a name="ln6133">      VIsual_reselect = false;              // don't reselect now</a>
<a name="ln6134">      if (empty_region_error) {</a>
<a name="ln6135">        vim_beep(BO_OPER);</a>
<a name="ln6136">        CancelRedo();</a>
<a name="ln6137">      } else {</a>
<a name="ln6138">        (void)op_delete(oap);</a>
<a name="ln6139">        // save cursor line for undo if it wasn't saved yet</a>
<a name="ln6140">        if (oap-&gt;motion_type == kMTLineWise</a>
<a name="ln6141">            &amp;&amp; has_format_option(FO_AUTO)</a>
<a name="ln6142">            &amp;&amp; u_save_cursor() == OK) {</a>
<a name="ln6143">          auto_format(false, true);</a>
<a name="ln6144">        }</a>
<a name="ln6145">      }</a>
<a name="ln6146">      break;</a>
<a name="ln6147"> </a>
<a name="ln6148">    case OP_YANK:</a>
<a name="ln6149">      if (empty_region_error) {</a>
<a name="ln6150">        if (!gui_yank) {</a>
<a name="ln6151">          vim_beep(BO_OPER);</a>
<a name="ln6152">          CancelRedo();</a>
<a name="ln6153">        }</a>
<a name="ln6154">      } else {</a>
<a name="ln6155">        restore_lbr(lbr_saved);</a>
<a name="ln6156">        oap-&gt;excl_tr_ws = cap-&gt;cmdchar == 'z';</a>
<a name="ln6157">        (void)op_yank(oap, !gui_yank);</a>
<a name="ln6158">      }</a>
<a name="ln6159">      check_cursor_col();</a>
<a name="ln6160">      break;</a>
<a name="ln6161"> </a>
<a name="ln6162">    case OP_CHANGE:</a>
<a name="ln6163">      VIsual_reselect = false;              // don't reselect now</a>
<a name="ln6164">      if (empty_region_error) {</a>
<a name="ln6165">        vim_beep(BO_OPER);</a>
<a name="ln6166">        CancelRedo();</a>
<a name="ln6167">      } else {</a>
<a name="ln6168">        // This is a new edit command, not a restart.  Need to</a>
<a name="ln6169">        // remember it to make i_CTRL-O work with mappings for</a>
<a name="ln6170">        // Visual mode.  But do this only once and not when typed.</a>
<a name="ln6171">        if (!KeyTyped) {</a>
<a name="ln6172">          restart_edit_save = restart_edit;</a>
<a name="ln6173">        } else {</a>
<a name="ln6174">          restart_edit_save = 0;</a>
<a name="ln6175">        }</a>
<a name="ln6176">        restart_edit = 0;</a>
<a name="ln6177"> </a>
<a name="ln6178">        // Restore linebreak, so that when the user edits it looks as before.</a>
<a name="ln6179">        restore_lbr(lbr_saved);</a>
<a name="ln6180"> </a>
<a name="ln6181">        // Reset finish_op now, don't want it set inside edit().</a>
<a name="ln6182">        finish_op = false;</a>
<a name="ln6183">        if (op_change(oap)) {           // will call edit()</a>
<a name="ln6184">          cap-&gt;retval |= CA_COMMAND_BUSY;</a>
<a name="ln6185">        }</a>
<a name="ln6186">        if (restart_edit == 0) {</a>
<a name="ln6187">          restart_edit = restart_edit_save;</a>
<a name="ln6188">        }</a>
<a name="ln6189">      }</a>
<a name="ln6190">      break;</a>
<a name="ln6191"> </a>
<a name="ln6192">    case OP_FILTER:</a>
<a name="ln6193">      if (vim_strchr(p_cpo, CPO_FILTER) != NULL) {</a>
<a name="ln6194">        AppendToRedobuff(&quot;!\r&quot;);  // Use any last used !cmd.</a>
<a name="ln6195">      } else {</a>
<a name="ln6196">        bangredo = true;  // do_bang() will put cmd in redo buffer.</a>
<a name="ln6197">      }</a>
<a name="ln6198">      FALLTHROUGH;</a>
<a name="ln6199"> </a>
<a name="ln6200">    case OP_INDENT:</a>
<a name="ln6201">    case OP_COLON:</a>
<a name="ln6202"> </a>
<a name="ln6203">      // If 'equalprg' is empty, do the indenting internally.</a>
<a name="ln6204">      if (oap-&gt;op_type == OP_INDENT &amp;&amp; *get_equalprg() == NUL) {</a>
<a name="ln6205">        if (curbuf-&gt;b_p_lisp) {</a>
<a name="ln6206">          op_reindent(oap, get_lisp_indent);</a>
<a name="ln6207">          break;</a>
<a name="ln6208">        }</a>
<a name="ln6209">        op_reindent(oap,</a>
<a name="ln6210">                    *curbuf-&gt;b_p_inde != NUL ? get_expr_indent :</a>
<a name="ln6211">                    get_c_indent);</a>
<a name="ln6212">        break;</a>
<a name="ln6213">      }</a>
<a name="ln6214"> </a>
<a name="ln6215">      op_colon(oap);</a>
<a name="ln6216">      break;</a>
<a name="ln6217"> </a>
<a name="ln6218">    case OP_TILDE:</a>
<a name="ln6219">    case OP_UPPER:</a>
<a name="ln6220">    case OP_LOWER:</a>
<a name="ln6221">    case OP_ROT13:</a>
<a name="ln6222">      if (empty_region_error) {</a>
<a name="ln6223">        vim_beep(BO_OPER);</a>
<a name="ln6224">        CancelRedo();</a>
<a name="ln6225">      } else {</a>
<a name="ln6226">        op_tilde(oap);</a>
<a name="ln6227">      }</a>
<a name="ln6228">      check_cursor_col();</a>
<a name="ln6229">      break;</a>
<a name="ln6230"> </a>
<a name="ln6231">    case OP_FORMAT:</a>
<a name="ln6232">      if (*curbuf-&gt;b_p_fex != NUL) {</a>
<a name="ln6233">        op_formatexpr(oap);             // use expression</a>
<a name="ln6234">      } else {</a>
<a name="ln6235">        if (*p_fp != NUL || *curbuf-&gt;b_p_fp != NUL) {</a>
<a name="ln6236">          op_colon(oap);                // use external command</a>
<a name="ln6237">        } else {</a>
<a name="ln6238">          op_format(oap, false);        // use internal function</a>
<a name="ln6239">        }</a>
<a name="ln6240">      }</a>
<a name="ln6241">      break;</a>
<a name="ln6242"> </a>
<a name="ln6243">    case OP_FORMAT2:</a>
<a name="ln6244">      op_format(oap, true);             // use internal function</a>
<a name="ln6245">      break;</a>
<a name="ln6246"> </a>
<a name="ln6247">    case OP_FUNCTION: {</a>
<a name="ln6248">      redo_VIsual_T save_redo_VIsual = redo_VIsual;</a>
<a name="ln6249"> </a>
<a name="ln6250">      // Restore linebreak, so that when the user edits it looks as before.</a>
<a name="ln6251">      restore_lbr(lbr_saved);</a>
<a name="ln6252">      // call 'operatorfunc'</a>
<a name="ln6253">      op_function(oap);</a>
<a name="ln6254"> </a>
<a name="ln6255">      // Restore the info for redoing Visual mode, the function may</a>
<a name="ln6256">      // invoke another operator and unintentionally change it.</a>
<a name="ln6257">      redo_VIsual = save_redo_VIsual;</a>
<a name="ln6258">      break;</a>
<a name="ln6259">    }</a>
<a name="ln6260"> </a>
<a name="ln6261">    case OP_INSERT:</a>
<a name="ln6262">    case OP_APPEND:</a>
<a name="ln6263">      VIsual_reselect = false;          // don't reselect now</a>
<a name="ln6264">      if (empty_region_error) {</a>
<a name="ln6265">        vim_beep(BO_OPER);</a>
<a name="ln6266">        CancelRedo();</a>
<a name="ln6267">      } else {</a>
<a name="ln6268">        // This is a new edit command, not a restart.  Need to</a>
<a name="ln6269">        // remember it to make i_CTRL-O work with mappings for</a>
<a name="ln6270">        // Visual mode.  But do this only once.</a>
<a name="ln6271">        restart_edit_save = restart_edit;</a>
<a name="ln6272">        restart_edit = 0;</a>
<a name="ln6273"> </a>
<a name="ln6274">        // Restore linebreak, so that when the user edits it looks as before.</a>
<a name="ln6275">        restore_lbr(lbr_saved);</a>
<a name="ln6276"> </a>
<a name="ln6277">        op_insert(oap, cap-&gt;count1);</a>
<a name="ln6278"> </a>
<a name="ln6279">        // Reset linebreak, so that formatting works correctly.</a>
<a name="ln6280">        (void)reset_lbr();</a>
<a name="ln6281"> </a>
<a name="ln6282">        // TODO(brammool): when inserting in several lines, should format all</a>
<a name="ln6283">        // the lines.</a>
<a name="ln6284">        auto_format(false, true);</a>
<a name="ln6285"> </a>
<a name="ln6286">        if (restart_edit == 0) {</a>
<a name="ln6287">          restart_edit = restart_edit_save;</a>
<a name="ln6288">        } else {</a>
<a name="ln6289">          cap-&gt;retval |= CA_COMMAND_BUSY;</a>
<a name="ln6290">        }</a>
<a name="ln6291">      }</a>
<a name="ln6292">      break;</a>
<a name="ln6293"> </a>
<a name="ln6294">    case OP_REPLACE:</a>
<a name="ln6295">      VIsual_reselect = false;          // don't reselect now</a>
<a name="ln6296">      if (empty_region_error) {</a>
<a name="ln6297">        vim_beep(BO_OPER);</a>
<a name="ln6298">        CancelRedo();</a>
<a name="ln6299">      } else {</a>
<a name="ln6300">        // Restore linebreak, so that when the user edits it looks as before.</a>
<a name="ln6301">        restore_lbr(lbr_saved);</a>
<a name="ln6302"> </a>
<a name="ln6303">        op_replace(oap, cap-&gt;nchar);</a>
<a name="ln6304">      }</a>
<a name="ln6305">      break;</a>
<a name="ln6306"> </a>
<a name="ln6307">    case OP_FOLD:</a>
<a name="ln6308">      VIsual_reselect = false;          // don't reselect now</a>
<a name="ln6309">      foldCreate(curwin, oap-&gt;start, oap-&gt;end);</a>
<a name="ln6310">      break;</a>
<a name="ln6311"> </a>
<a name="ln6312">    case OP_FOLDOPEN:</a>
<a name="ln6313">    case OP_FOLDOPENREC:</a>
<a name="ln6314">    case OP_FOLDCLOSE:</a>
<a name="ln6315">    case OP_FOLDCLOSEREC:</a>
<a name="ln6316">      VIsual_reselect = false;          // don't reselect now</a>
<a name="ln6317">      opFoldRange(oap-&gt;start, oap-&gt;end,</a>
<a name="ln6318">                  oap-&gt;op_type == OP_FOLDOPEN</a>
<a name="ln6319">                  || oap-&gt;op_type == OP_FOLDOPENREC,</a>
<a name="ln6320">                  oap-&gt;op_type == OP_FOLDOPENREC</a>
<a name="ln6321">                  || oap-&gt;op_type == OP_FOLDCLOSEREC,</a>
<a name="ln6322">                  oap-&gt;is_VIsual);</a>
<a name="ln6323">      break;</a>
<a name="ln6324"> </a>
<a name="ln6325">    case OP_FOLDDEL:</a>
<a name="ln6326">    case OP_FOLDDELREC:</a>
<a name="ln6327">      VIsual_reselect = false;          // don't reselect now</a>
<a name="ln6328">      deleteFold(curwin, oap-&gt;start.lnum, oap-&gt;end.lnum,</a>
<a name="ln6329">                 oap-&gt;op_type == OP_FOLDDELREC, oap-&gt;is_VIsual);</a>
<a name="ln6330">      break;</a>
<a name="ln6331"> </a>
<a name="ln6332">    case OP_NR_ADD:</a>
<a name="ln6333">    case OP_NR_SUB:</a>
<a name="ln6334">      if (empty_region_error) {</a>
<a name="ln6335">        vim_beep(BO_OPER);</a>
<a name="ln6336">        CancelRedo();</a>
<a name="ln6337">      } else {</a>
<a name="ln6338">        VIsual_active = true;</a>
<a name="ln6339">        restore_lbr(lbr_saved);</a>
<a name="ln6340">        op_addsub(oap, (linenr_T)cap-&gt;count1, redo_VIsual.rv_arg);</a>
<a name="ln6341">        VIsual_active = false;</a>
<a name="ln6342">      }</a>
<a name="ln6343">      check_cursor_col();</a>
<a name="ln6344">      break;</a>
<a name="ln6345">    default:</a>
<a name="ln6346">      clearopbeep(oap);</a>
<a name="ln6347">    }</a>
<a name="ln6348">    virtual_op = kNone;</a>
<a name="ln6349">    if (!gui_yank) {</a>
<a name="ln6350">      // if 'sol' not set, go back to old column for some commands</a>
<a name="ln6351">      if (!p_sol &amp;&amp; oap-&gt;motion_type == kMTLineWise &amp;&amp; !oap-&gt;end_adjusted</a>
<a name="ln6352">          &amp;&amp; (oap-&gt;op_type == OP_LSHIFT || oap-&gt;op_type == OP_RSHIFT</a>
<a name="ln6353">              || oap-&gt;op_type == OP_DELETE)) {</a>
<a name="ln6354">        (void)reset_lbr();</a>
<a name="ln6355">        coladvance(curwin-&gt;w_curswant = old_col);</a>
<a name="ln6356">      }</a>
<a name="ln6357">    } else {</a>
<a name="ln6358">      curwin-&gt;w_cursor = old_cursor;</a>
<a name="ln6359">    }</a>
<a name="ln6360">    clearop(oap);</a>
<a name="ln6361">    motion_force = NUL;</a>
<a name="ln6362">  }</a>
<a name="ln6363">  restore_lbr(lbr_saved);</a>
<a name="ln6364">}</a>
<a name="ln6365"> </a>
<a name="ln6366">/// Check if the default register (used in an unnamed paste) should be a</a>
<a name="ln6367">/// clipboard register. This happens when `clipboard=unnamed[plus]` is set</a>
<a name="ln6368">/// and a provider is available.</a>
<a name="ln6369">///</a>
<a name="ln6370">/// @returns the name of of a clipboard register that should be used, or `NUL` if none.</a>
<a name="ln6371">int get_default_register_name(void)</a>
<a name="ln6372">{</a>
<a name="ln6373">  int name = NUL;</a>
<a name="ln6374">  adjust_clipboard_name(&amp;name, true, false);</a>
<a name="ln6375">  return name;</a>
<a name="ln6376">}</a>
<a name="ln6377"> </a>
<a name="ln6378">/// Determine if register `*name` should be used as a clipboard.</a>
<a name="ln6379">/// In an unnamed operation, `*name` is `NUL` and will be adjusted to */+ if</a>
<a name="ln6380">/// `clipboard=unnamed[plus]` is set.</a>
<a name="ln6381">///</a>
<a name="ln6382">/// @param name The name of register, or `NUL` if unnamed.</a>
<a name="ln6383">/// @param quiet Suppress error messages</a>
<a name="ln6384">/// @param writing if we're setting the contents of the clipboard</a>
<a name="ln6385">///</a>
<a name="ln6386">/// @returns the yankreg that should be written into, or `NULL`</a>
<a name="ln6387">/// if the register isn't a clipboard or provider isn't available.</a>
<a name="ln6388">static yankreg_T *adjust_clipboard_name(int *name, bool quiet, bool writing)</a>
<a name="ln6389">{</a>
<a name="ln6390">#define MSG_NO_CLIP &quot;clipboard: No provider. &quot; \</a>
<a name="ln6391">  &quot;Try \&quot;:checkhealth\&quot; or \&quot;:h clipboard\&quot;.&quot;</a>
<a name="ln6392"> </a>
<a name="ln6393">  yankreg_T *target = NULL;</a>
<a name="ln6394">  bool explicit_cb_reg = (*name == '*' || *name == '+');</a>
<a name="ln6395">  bool implicit_cb_reg = (*name == NUL) &amp;&amp; (cb_flags &amp; CB_UNNAMEDMASK);</a>
<a name="ln6396">  if (!explicit_cb_reg &amp;&amp; !implicit_cb_reg) {</a>
<a name="ln6397">    goto end;</a>
<a name="ln6398">  }</a>
<a name="ln6399"> </a>
<a name="ln6400">  if (!eval_has_provider(&quot;clipboard&quot;)) {</a>
<a name="ln6401">    if (batch_change_count == 1 &amp;&amp; !quiet</a>
<a name="ln6402">        &amp;&amp; (!clipboard_didwarn || (explicit_cb_reg &amp;&amp; !redirecting()))) {</a>
<a name="ln6403">      clipboard_didwarn = true;</a>
<a name="ln6404">      // Do NOT error (emsg()) here--if it interrupts :redir we get into</a>
<a name="ln6405">      // a weird state, stuck in &quot;redirect mode&quot;.</a>
<a name="ln6406">      msg(MSG_NO_CLIP);</a>
<a name="ln6407">    }</a>
<a name="ln6408">    // ... else, be silent (don't flood during :while, :redir, etc.).</a>
<a name="ln6409">    goto end;</a>
<a name="ln6410">  }</a>
<a name="ln6411"> </a>
<a name="ln6412">  if (explicit_cb_reg) {</a>
<a name="ln6413">    target = &amp;y_regs[*name == '*' ? STAR_REGISTER : PLUS_REGISTER];</a>
<a name="ln6414">    if (writing &amp;&amp; (cb_flags &amp; (*name == '*' ? CB_UNNAMED : CB_UNNAMEDPLUS))) {</a>
<a name="ln6415">      clipboard_needs_update = false;</a>
<a name="ln6416">    }</a>
<a name="ln6417">    goto end;</a>
<a name="ln6418">  } else {  // unnamed register: &quot;implicit&quot; clipboard</a>
<a name="ln6419">    if (writing &amp;&amp; clipboard_delay_update) {</a>
<a name="ln6420">      // For &quot;set&quot; (copy), defer the clipboard call.</a>
<a name="ln6421">      clipboard_needs_update = true;</a>
<a name="ln6422">      goto end;</a>
<a name="ln6423">    } else if (!writing &amp;&amp; clipboard_needs_update) {</a>
<a name="ln6424">      // For &quot;get&quot; (paste), use the internal value.</a>
<a name="ln6425">      goto end;</a>
<a name="ln6426">    }</a>
<a name="ln6427"> </a>
<a name="ln6428">    if (cb_flags &amp; CB_UNNAMEDPLUS) {</a>
<a name="ln6429">      *name = (cb_flags &amp; CB_UNNAMED &amp;&amp; writing) ? '&quot;': '+';</a>
<a name="ln6430">      target = &amp;y_regs[PLUS_REGISTER];</a>
<a name="ln6431">    } else {</a>
<a name="ln6432">      *name = '*';</a>
<a name="ln6433">      target = &amp;y_regs[STAR_REGISTER];</a>
<a name="ln6434">    }</a>
<a name="ln6435">    goto end;</a>
<a name="ln6436">  }</a>
<a name="ln6437"> </a>
<a name="ln6438">end:</a>
<a name="ln6439">  return target;</a>
<a name="ln6440">}</a>
<a name="ln6441"> </a>
<a name="ln6442">/// @param[out] reg Expected to be empty</a>
<a name="ln6443">bool prepare_yankreg_from_object(yankreg_T *reg, String regtype, size_t lines)</a>
<a name="ln6444">{</a>
<a name="ln6445">  char type = regtype.data ? regtype.data[0] : NUL;</a>
<a name="ln6446"> </a>
<a name="ln6447">  switch (type) {</a>
<a name="ln6448">  case 0:</a>
<a name="ln6449">    reg-&gt;y_type = kMTUnknown;</a>
<a name="ln6450">    break;</a>
<a name="ln6451">  case 'v':</a>
<a name="ln6452">  case 'c':</a>
<a name="ln6453">    reg-&gt;y_type = kMTCharWise;</a>
<a name="ln6454">    break;</a>
<a name="ln6455">  case 'V':</a>
<a name="ln6456">  case 'l':</a>
<a name="ln6457">    reg-&gt;y_type = kMTLineWise;</a>
<a name="ln6458">    break;</a>
<a name="ln6459">  case 'b':</a>
<a name="ln6460">  case Ctrl_V:</a>
<a name="ln6461">    reg-&gt;y_type = kMTBlockWise;</a>
<a name="ln6462">    break;</a>
<a name="ln6463">  default:</a>
<a name="ln6464">    return false;</a>
<a name="ln6465">  }</a>
<a name="ln6466"> </a>
<a name="ln6467">  reg-&gt;y_width = 0;</a>
<a name="ln6468">  if (regtype.size &gt; 1) {</a>
<a name="ln6469">    if (reg-&gt;y_type != kMTBlockWise) {</a>
<a name="ln6470">      return false;</a>
<a name="ln6471">    }</a>
<a name="ln6472"> </a>
<a name="ln6473">    // allow &quot;b7&quot; for a block at least 7 spaces wide</a>
<a name="ln6474">    if (!ascii_isdigit(regtype.data[1])) {</a>
<a name="ln6475">      return false;</a>
<a name="ln6476">    }</a>
<a name="ln6477">    const char *p = regtype.data + 1;</a>
<a name="ln6478">    reg-&gt;y_width = getdigits_int((char **)&amp;p, false, 1) - 1;</a>
<a name="ln6479">    if (regtype.size &gt; (size_t)(p - regtype.data)) {</a>
<a name="ln6480">      return false;</a>
<a name="ln6481">    }</a>
<a name="ln6482">  }</a>
<a name="ln6483"> </a>
<a name="ln6484">  reg-&gt;y_array = xcalloc(lines, sizeof(uint8_t *));</a>
<a name="ln6485">  reg-&gt;y_size = lines;</a>
<a name="ln6486">  reg-&gt;additional_data = NULL;</a>
<a name="ln6487">  reg-&gt;timestamp = 0;</a>
<a name="ln6488">  return true;</a>
<a name="ln6489">}</a>
<a name="ln6490"> </a>
<a name="ln6491">void finish_yankreg_from_object(yankreg_T *reg, bool clipboard_adjust)</a>
<a name="ln6492">{</a>
<a name="ln6493">  if (reg-&gt;y_size &gt; 0 &amp;&amp; strlen(reg-&gt;y_array[reg-&gt;y_size - 1]) == 0) {</a>
<a name="ln6494">    // a known-to-be charwise yank might have a final linebreak</a>
<a name="ln6495">    // but otherwise there is no line after the final newline</a>
<a name="ln6496">    if (reg-&gt;y_type != kMTCharWise) {</a>
<a name="ln6497">      if (reg-&gt;y_type == kMTUnknown || clipboard_adjust) {</a>
<a name="ln6498">        xfree(reg-&gt;y_array[reg-&gt;y_size - 1]);</a>
<a name="ln6499">        reg-&gt;y_size--;</a>
<a name="ln6500">      }</a>
<a name="ln6501">      if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln6502">        reg-&gt;y_type = kMTLineWise;</a>
<a name="ln6503">      }</a>
<a name="ln6504">    }</a>
<a name="ln6505">  } else {</a>
<a name="ln6506">    if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln6507">      reg-&gt;y_type = kMTCharWise;</a>
<a name="ln6508">    }</a>
<a name="ln6509">  }</a>
<a name="ln6510"> </a>
<a name="ln6511">  if (reg-&gt;y_type == kMTBlockWise) {</a>
<a name="ln6512">    size_t maxlen = 0;</a>
<a name="ln6513">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6514">      size_t rowlen = strlen(reg-&gt;y_array[i]);</a>
<a name="ln6515">      if (rowlen &gt; maxlen) {</a>
<a name="ln6516">        maxlen = rowlen;</a>
<a name="ln6517">      }</a>
<a name="ln6518">    }</a>
<a name="ln6519">    assert(maxlen &lt;= INT_MAX);</a>
<a name="ln6520">    reg-&gt;y_width = MAX(reg-&gt;y_width, (int)maxlen - 1);</a>
<a name="ln6521">  }</a>
<a name="ln6522">}</a>
<a name="ln6523"> </a>
<a name="ln6524">static bool get_clipboard(int name, yankreg_T **target, bool quiet)</a>
<a name="ln6525">{</a>
<a name="ln6526">  // show message on error</a>
<a name="ln6527">  bool errmsg = true;</a>
<a name="ln6528"> </a>
<a name="ln6529">  yankreg_T *reg = adjust_clipboard_name(&amp;name, quiet, false);</a>
<a name="ln6530">  if (reg == NULL) {</a>
<a name="ln6531">    return false;</a>
<a name="ln6532">  }</a>
<a name="ln6533">  free_register(reg);</a>
<a name="ln6534"> </a>
<a name="ln6535">  list_T *const args = tv_list_alloc(1);</a>
<a name="ln6536">  const char regname = (char)name;</a>
<a name="ln6537">  tv_list_append_string(args, &amp;regname, 1);</a>
<a name="ln6538"> </a>
<a name="ln6539">  typval_T result = eval_call_provider(&quot;clipboard&quot;, &quot;get&quot;, args, false);</a>
<a name="ln6540"> </a>
<a name="ln6541">  if (result.v_type != VAR_LIST) {</a>
<a name="ln6542">    if (result.v_type == VAR_NUMBER &amp;&amp; result.vval.v_number == 0) {</a>
<a name="ln6543">      // failure has already been indicated by provider</a>
<a name="ln6544">      errmsg = false;</a>
<a name="ln6545">    }</a>
<a name="ln6546">    goto err;</a>
<a name="ln6547">  }</a>
<a name="ln6548"> </a>
<a name="ln6549">  list_T *res = result.vval.v_list;</a>
<a name="ln6550">  list_T *lines = NULL;</a>
<a name="ln6551">  if (tv_list_len(res) == 2</a>
<a name="ln6552">      &amp;&amp; TV_LIST_ITEM_TV(tv_list_first(res))-&gt;v_type == VAR_LIST) {</a>
<a name="ln6553">    lines = TV_LIST_ITEM_TV(tv_list_first(res))-&gt;vval.v_list;</a>
<a name="ln6554">    if (TV_LIST_ITEM_TV(tv_list_last(res))-&gt;v_type != VAR_STRING) {</a>
<a name="ln6555">      goto err;</a>
<a name="ln6556">    }</a>
<a name="ln6557">    char_u *regtype = (char_u *)TV_LIST_ITEM_TV(tv_list_last(res))-&gt;vval.v_string;</a>
<a name="ln6558">    if (regtype == NULL || STRLEN(regtype) &gt; 1) {</a>
<a name="ln6559">      goto err;</a>
<a name="ln6560">    }</a>
<a name="ln6561">    switch (regtype[0]) {</a>
<a name="ln6562">    case 0:</a>
<a name="ln6563">      reg-&gt;y_type = kMTUnknown;</a>
<a name="ln6564">      break;</a>
<a name="ln6565">    case 'v':</a>
<a name="ln6566">    case 'c':</a>
<a name="ln6567">      reg-&gt;y_type = kMTCharWise;</a>
<a name="ln6568">      break;</a>
<a name="ln6569">    case 'V':</a>
<a name="ln6570">    case 'l':</a>
<a name="ln6571">      reg-&gt;y_type = kMTLineWise;</a>
<a name="ln6572">      break;</a>
<a name="ln6573">    case 'b':</a>
<a name="ln6574">    case Ctrl_V:</a>
<a name="ln6575">      reg-&gt;y_type = kMTBlockWise;</a>
<a name="ln6576">      break;</a>
<a name="ln6577">    default:</a>
<a name="ln6578">      goto err;</a>
<a name="ln6579">    }</a>
<a name="ln6580">  } else {</a>
<a name="ln6581">    lines = res;</a>
<a name="ln6582">    // provider did not specify regtype, calculate it below</a>
<a name="ln6583">    reg-&gt;y_type = kMTUnknown;</a>
<a name="ln6584">  }</a>
<a name="ln6585"> </a>
<a name="ln6586">  reg-&gt;y_array = xcalloc((size_t)tv_list_len(lines), sizeof(char *));</a>
<a name="ln6587">  reg-&gt;y_size = (size_t)tv_list_len(lines);</a>
<a name="ln6588">  reg-&gt;additional_data = NULL;</a>
<a name="ln6589">  reg-&gt;timestamp = 0;</a>
<a name="ln6590">  // Timestamp is not saved for clipboard registers because clipboard registers</a>
<a name="ln6591">  // are not saved in the ShaDa file.</a>
<a name="ln6592"> </a>
<a name="ln6593">  size_t tv_idx = 0;</a>
<a name="ln6594">  TV_LIST_ITER_CONST(lines, li, {</a>
<a name="ln6595">    if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_STRING) {</a>
<a name="ln6596">      goto err;</a>
<a name="ln6597">    }</a>
<a name="ln6598">    reg-&gt;y_array[tv_idx++] = xstrdupnul((const char *)TV_LIST_ITEM_TV(li)-&gt;vval.v_string);</a>
<a name="ln6599">  });</a>
<a name="ln6600"> </a>
<a name="ln6601">  if (reg-&gt;y_size &gt; 0 &amp;&amp; strlen(reg-&gt;y_array[reg-&gt;y_size - 1]) == 0) {</a>
<a name="ln6602">    // a known-to-be charwise yank might have a final linebreak</a>
<a name="ln6603">    // but otherwise there is no line after the final newline</a>
<a name="ln6604">    if (reg-&gt;y_type != kMTCharWise) {</a>
<a name="ln6605">      xfree(reg-&gt;y_array[reg-&gt;y_size - 1]);</a>
<a name="ln6606">      reg-&gt;y_size--;</a>
<a name="ln6607">      if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln6608">        reg-&gt;y_type = kMTLineWise;</a>
<a name="ln6609">      }</a>
<a name="ln6610">    }</a>
<a name="ln6611">  } else {</a>
<a name="ln6612">    if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln6613">      reg-&gt;y_type = kMTCharWise;</a>
<a name="ln6614">    }</a>
<a name="ln6615">  }</a>
<a name="ln6616"> </a>
<a name="ln6617">  if (reg-&gt;y_type == kMTBlockWise) {</a>
<a name="ln6618">    size_t maxlen = 0;</a>
<a name="ln6619">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6620">      size_t rowlen = strlen(reg-&gt;y_array[i]);</a>
<a name="ln6621">      if (rowlen &gt; maxlen) {</a>
<a name="ln6622">        maxlen = rowlen;</a>
<a name="ln6623">      }</a>
<a name="ln6624">    }</a>
<a name="ln6625">    assert(maxlen &lt;= INT_MAX);</a>
<a name="ln6626">    reg-&gt;y_width = (int)maxlen - 1;</a>
<a name="ln6627">  }</a>
<a name="ln6628"> </a>
<a name="ln6629">  *target = reg;</a>
<a name="ln6630">  return true;</a>
<a name="ln6631"> </a>
<a name="ln6632">err:</a>
<a name="ln6633">  if (reg-&gt;y_array) {</a>
<a name="ln6634">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6635">      xfree(reg-&gt;y_array[i]);</a>
<a name="ln6636">    }</a>
<a name="ln6637">    xfree(reg-&gt;y_array);</a>
<a name="ln6638">  }</a>
<a name="ln6639">  reg-&gt;y_array = NULL;</a>
<a name="ln6640">  reg-&gt;y_size = 0;</a>
<a name="ln6641">  reg-&gt;additional_data = NULL;</a>
<a name="ln6642">  reg-&gt;timestamp = 0;</a>
<a name="ln6643">  if (errmsg) {</a>
<a name="ln6644">    emsg(&quot;clipboard: provider returned invalid data&quot;);</a>
<a name="ln6645">  }</a>
<a name="ln6646">  *target = reg;</a>
<a name="ln6647">  return false;</a>
<a name="ln6648">}</a>
<a name="ln6649"> </a>
<a name="ln6650">static void set_clipboard(int name, yankreg_T *reg)</a>
<a name="ln6651">{</a>
<a name="ln6652">  if (!adjust_clipboard_name(&amp;name, false, true)) {</a>
<a name="ln6653">    return;</a>
<a name="ln6654">  }</a>
<a name="ln6655"> </a>
<a name="ln6656">  list_T *const lines = tv_list_alloc((ptrdiff_t)reg-&gt;y_size + (reg-&gt;y_type != kMTCharWise));</a>
<a name="ln6657"> </a>
<a name="ln6658">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6659">    tv_list_append_string(lines, (const char *)reg-&gt;y_array[i], -1);</a>
<a name="ln6660">  }</a>
<a name="ln6661"> </a>
<a name="ln6662">  char regtype;</a>
<a name="ln6663">  switch (reg-&gt;y_type) {</a>
<a name="ln6664">  case kMTLineWise:</a>
<a name="ln6665">    regtype = 'V';</a>
<a name="ln6666">    tv_list_append_string(lines, NULL, 0);</a>
<a name="ln6667">    break;</a>
<a name="ln6668">  case kMTCharWise:</a>
<a name="ln6669">    regtype = 'v';</a>
<a name="ln6670">    break;</a>
<a name="ln6671">  case kMTBlockWise:</a>
<a name="ln6672">    regtype = 'b';</a>
<a name="ln6673">    tv_list_append_string(lines, NULL, 0);</a>
<a name="ln6674">    break;</a>
<a name="ln6675">  case kMTUnknown:</a>
<a name="ln6676">    abort();</a>
<a name="ln6677">  }</a>
<a name="ln6678"> </a>
<a name="ln6679">  list_T *args = tv_list_alloc(3);</a>
<a name="ln6680">  tv_list_append_list(args, lines);</a>
<a name="ln6681">  tv_list_append_string(args, &amp;regtype, 1);  // -V614</a>
<a name="ln6682">  tv_list_append_string(args, ((char[]) { (char)name }), 1);</a>
<a name="ln6683"> </a>
<a name="ln6684">  (void)eval_call_provider(&quot;clipboard&quot;, &quot;set&quot;, args, true);</a>
<a name="ln6685">}</a>
<a name="ln6686"> </a>
<a name="ln6687">/// Avoid slow things (clipboard) during batch operations (while/for-loops).</a>
<a name="ln6688">void start_batch_changes(void)</a>
<a name="ln6689">{</a>
<a name="ln6690">  if (++batch_change_count &gt; 1) {</a>
<a name="ln6691">    return;</a>
<a name="ln6692">  }</a>
<a name="ln6693">  clipboard_delay_update = true;</a>
<a name="ln6694">}</a>
<a name="ln6695"> </a>
<a name="ln6696">/// Counterpart to start_batch_changes().</a>
<a name="ln6697">void end_batch_changes(void)</a>
<a name="ln6698">{</a>
<a name="ln6699">  if (--batch_change_count &gt; 0) {</a>
<a name="ln6700">    // recursive</a>
<a name="ln6701">    return;</a>
<a name="ln6702">  }</a>
<a name="ln6703">  clipboard_delay_update = false;</a>
<a name="ln6704">  if (clipboard_needs_update) {</a>
<a name="ln6705">    // must be before, as set_clipboard will invoke</a>
<a name="ln6706">    // start/end_batch_changes recursively</a>
<a name="ln6707">    clipboard_needs_update = false;</a>
<a name="ln6708">    // unnamed (&quot;implicit&quot; clipboard)</a>
<a name="ln6709">    set_clipboard(NUL, y_previous);</a>
<a name="ln6710">  }</a>
<a name="ln6711">}</a>
<a name="ln6712"> </a>
<a name="ln6713">int save_batch_count(void)</a>
<a name="ln6714">{</a>
<a name="ln6715">  int save_count = batch_change_count;</a>
<a name="ln6716">  batch_change_count = 0;</a>
<a name="ln6717">  clipboard_delay_update = false;</a>
<a name="ln6718">  if (clipboard_needs_update) {</a>
<a name="ln6719">    clipboard_needs_update = false;</a>
<a name="ln6720">    // unnamed (&quot;implicit&quot; clipboard)</a>
<a name="ln6721">    set_clipboard(NUL, y_previous);</a>
<a name="ln6722">  }</a>
<a name="ln6723">  return save_count;</a>
<a name="ln6724">}</a>
<a name="ln6725"> </a>
<a name="ln6726">void restore_batch_count(int save_count)</a>
<a name="ln6727">{</a>
<a name="ln6728">  assert(batch_change_count == 0);</a>
<a name="ln6729">  batch_change_count = save_count;</a>
<a name="ln6730">  if (batch_change_count &gt; 0) {</a>
<a name="ln6731">    clipboard_delay_update = true;</a>
<a name="ln6732">  }</a>
<a name="ln6733">}</a>
<a name="ln6734"> </a>
<a name="ln6735">/// Check whether register is empty</a>
<a name="ln6736">static inline bool reg_empty(const yankreg_T *const reg)</a>
<a name="ln6737">  FUNC_ATTR_PURE</a>
<a name="ln6738">{</a>
<a name="ln6739">  return (reg-&gt;y_array == NULL</a>
<a name="ln6740">          || reg-&gt;y_size == 0</a>
<a name="ln6741">          || (reg-&gt;y_size == 1</a>
<a name="ln6742">              &amp;&amp; reg-&gt;y_type == kMTCharWise</a>
<a name="ln6743">              &amp;&amp; *(reg-&gt;y_array[0]) == NUL));</a>
<a name="ln6744">}</a>
<a name="ln6745"> </a>
<a name="ln6746">/// Iterate over global registers.</a>
<a name="ln6747">///</a>
<a name="ln6748">/// @see op_register_iter</a>
<a name="ln6749">const void *op_global_reg_iter(const void *const iter, char *const name, yankreg_T *const reg,</a>
<a name="ln6750">                               bool *is_unnamed)</a>
<a name="ln6751">  FUNC_ATTR_NONNULL_ARG(2, 3, 4) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6752">{</a>
<a name="ln6753">  return op_reg_iter(iter, y_regs, name, reg, is_unnamed);</a>
<a name="ln6754">}</a>
<a name="ln6755"> </a>
<a name="ln6756">/// Iterate over registers `regs`.</a>
<a name="ln6757">///</a>
<a name="ln6758">/// @param[in]   iter      Iterator. Pass NULL to start iteration.</a>
<a name="ln6759">/// @param[in]   regs      Registers list to be iterated.</a>
<a name="ln6760">/// @param[out]  name      Register name.</a>
<a name="ln6761">/// @param[out]  reg       Register contents.</a>
<a name="ln6762">///</a>
<a name="ln6763">/// @return Pointer that must be passed to next `op_register_iter` call or</a>
<a name="ln6764">///         NULL if iteration is over.</a>
<a name="ln6765">const void *op_reg_iter(const void *const iter, const yankreg_T *const regs, char *const name,</a>
<a name="ln6766">                        yankreg_T *const reg, bool *is_unnamed)</a>
<a name="ln6767">  FUNC_ATTR_NONNULL_ARG(3, 4, 5) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6768">{</a>
<a name="ln6769">  *name = NUL;</a>
<a name="ln6770">  const yankreg_T *iter_reg = (iter == NULL</a>
<a name="ln6771">                               ? &amp;(regs[0])</a>
<a name="ln6772">                               : (const yankreg_T *const)iter);</a>
<a name="ln6773">  while (iter_reg - &amp;(regs[0]) &lt; NUM_SAVED_REGISTERS &amp;&amp; reg_empty(iter_reg)) {</a>
<a name="ln6774">    iter_reg++;</a>
<a name="ln6775">  }</a>
<a name="ln6776">  if (iter_reg - &amp;(regs[0]) == NUM_SAVED_REGISTERS || reg_empty(iter_reg)) {</a>
<a name="ln6777">    return NULL;</a>
<a name="ln6778">  }</a>
<a name="ln6779">  int iter_off = (int)(iter_reg - &amp;(regs[0]));</a>
<a name="ln6780">  *name = (char)get_register_name(iter_off);</a>
<a name="ln6781">  *reg = *iter_reg;</a>
<a name="ln6782">  *is_unnamed = (iter_reg == y_previous);</a>
<a name="ln6783">  while (++iter_reg - &amp;(regs[0]) &lt; NUM_SAVED_REGISTERS) {</a>
<a name="ln6784">    if (!reg_empty(iter_reg)) {</a>
<a name="ln6785">      return (void *)iter_reg;</a>
<a name="ln6786">    }</a>
<a name="ln6787">  }</a>
<a name="ln6788">  return NULL;</a>
<a name="ln6789">}</a>
<a name="ln6790"> </a>
<a name="ln6791">/// Get a number of non-empty registers</a>
<a name="ln6792">size_t op_reg_amount(void)</a>
<a name="ln6793">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6794">{</a>
<a name="ln6795">  size_t ret = 0;</a>
<a name="ln6796">  for (size_t i = 0; i &lt; NUM_SAVED_REGISTERS; i++) {</a>
<a name="ln6797">    if (!reg_empty(y_regs + i)) {</a>
<a name="ln6798">      ret++;</a>
<a name="ln6799">    }</a>
<a name="ln6800">  }</a>
<a name="ln6801">  return ret;</a>
<a name="ln6802">}</a>
<a name="ln6803"> </a>
<a name="ln6804">/// Set register to a given value</a>
<a name="ln6805">///</a>
<a name="ln6806">/// @param[in]  name  Register name.</a>
<a name="ln6807">/// @param[in]  reg  Register value.</a>
<a name="ln6808">/// @param[in]  is_unnamed  Whether to set the unnamed regiseter to reg</a>
<a name="ln6809">///</a>
<a name="ln6810">/// @return true on success, false on failure.</a>
<a name="ln6811">bool op_reg_set(const char name, const yankreg_T reg, bool is_unnamed)</a>
<a name="ln6812">{</a>
<a name="ln6813">  int i = op_reg_index(name);</a>
<a name="ln6814">  if (i == -1) {</a>
<a name="ln6815">    return false;</a>
<a name="ln6816">  }</a>
<a name="ln6817">  free_register(&amp;y_regs[i]);</a>
<a name="ln6818">  y_regs[i] = reg;</a>
<a name="ln6819"> </a>
<a name="ln6820">  if (is_unnamed) {</a>
<a name="ln6821">    y_previous = &amp;y_regs[i];</a>
<a name="ln6822">  }</a>
<a name="ln6823">  return true;</a>
<a name="ln6824">}</a>
<a name="ln6825"> </a>
<a name="ln6826">/// Get register with the given name</a>
<a name="ln6827">///</a>
<a name="ln6828">/// @param[in]  name  Register name.</a>
<a name="ln6829">///</a>
<a name="ln6830">/// @return Pointer to the register contents or NULL.</a>
<a name="ln6831">const yankreg_T *op_reg_get(const char name)</a>
<a name="ln6832">{</a>
<a name="ln6833">  int i = op_reg_index(name);</a>
<a name="ln6834">  if (i == -1) {</a>
<a name="ln6835">    return NULL;</a>
<a name="ln6836">  }</a>
<a name="ln6837">  return &amp;y_regs[i];</a>
<a name="ln6838">}</a>
<a name="ln6839"> </a>
<a name="ln6840">/// Set the previous yank register</a>
<a name="ln6841">///</a>
<a name="ln6842">/// @param[in]  name  Register name.</a>
<a name="ln6843">///</a>
<a name="ln6844">/// @return true on success, false on failure.</a>
<a name="ln6845">bool op_reg_set_previous(const char name)</a>
<a name="ln6846">{</a>
<a name="ln6847">  int i = op_reg_index(name);</a>
<a name="ln6848">  if (i == -1) {</a>
<a name="ln6849">    return false;</a>
<a name="ln6850">  }</a>
<a name="ln6851"> </a>
<a name="ln6852">  y_previous = &amp;y_regs[i];</a>
<a name="ln6853">  return true;</a>
<a name="ln6854">}</a>
<a name="ln6855"> </a>
<a name="ln6856">/// Get the byte count of buffer region. End-exclusive.</a>
<a name="ln6857">///</a>
<a name="ln6858">/// @return number of bytes</a>
<a name="ln6859">bcount_t get_region_bytecount(buf_T *buf, linenr_T start_lnum, linenr_T end_lnum, colnr_T start_col,</a>
<a name="ln6860">                              colnr_T end_col)</a>
<a name="ln6861">{</a>
<a name="ln6862">  linenr_T max_lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln6863">  if (start_lnum &gt; max_lnum) {</a>
<a name="ln6864">    return 0;</a>
<a name="ln6865">  }</a>
<a name="ln6866">  if (start_lnum == end_lnum) {</a>
<a name="ln6867">    return end_col - start_col;</a>
<a name="ln6868">  }</a>
<a name="ln6869">  const char *first = (const char *)ml_get_buf(buf, start_lnum, false);</a>
<a name="ln6870">  bcount_t deleted_bytes = (bcount_t)strlen(first) - start_col + 1;</a>
<a name="ln6871"> </a>
<a name="ln6872">  for (linenr_T i = 1; i &lt;= end_lnum - start_lnum - 1; i++) {</a>
<a name="ln6873">    if (start_lnum + i &gt; max_lnum) {</a>
<a name="ln6874">      return deleted_bytes;</a>
<a name="ln6875">    }</a>
<a name="ln6876">    deleted_bytes += (bcount_t)strlen(ml_get_buf(buf, start_lnum + i, false)) + 1;</a>
<a name="ln6877">  }</a>
<a name="ln6878">  if (end_lnum &gt; max_lnum) {</a>
<a name="ln6879">    return deleted_bytes;</a>
<a name="ln6880">  }</a>
<a name="ln6881">  return deleted_bytes + end_col;</a>
<a name="ln6882">}</a>
</code></pre>
<div class="balloon" rel="4105"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> The value of 'char' type is implicitly cast to a char pointer.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>