<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>highlight.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// highlight.c: low level code for UI and syntax highlighting</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln7">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln8">#include &quot;nvim/decoration_provider.h&quot;</a>
<a name="ln9">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln10">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln11">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln12">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln13">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln14">#include &quot;nvim/map.h&quot;</a>
<a name="ln15">#include &quot;nvim/message.h&quot;</a>
<a name="ln16">#include &quot;nvim/option.h&quot;</a>
<a name="ln17">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln18">#include &quot;nvim/ui.h&quot;</a>
<a name="ln19">#include &quot;nvim/vim.h&quot;</a>
<a name="ln20"> </a>
<a name="ln21">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln22"># include &quot;highlight.c.generated.h&quot;</a>
<a name="ln23">#endif</a>
<a name="ln24"> </a>
<a name="ln25">static bool hlstate_active = false;</a>
<a name="ln26"> </a>
<a name="ln27">static kvec_t(HlEntry) attr_entries = KV_INITIAL_VALUE;</a>
<a name="ln28"> </a>
<a name="ln29">static Map(HlEntry, int) attr_entry_ids = MAP_INIT;</a>
<a name="ln30">static Map(int, int) combine_attr_entries = MAP_INIT;</a>
<a name="ln31">static Map(int, int) blend_attr_entries = MAP_INIT;</a>
<a name="ln32">static Map(int, int) blendthrough_attr_entries = MAP_INIT;</a>
<a name="ln33"> </a>
<a name="ln34">/// highlight entries private to a namespace</a>
<a name="ln35">static Map(ColorKey, ColorItem) ns_hls;</a>
<a name="ln36">typedef int NSHlAttr[HLF_COUNT + 1];</a>
<a name="ln37">static PMap(handle_T) ns_hl_attr;</a>
<a name="ln38"> </a>
<a name="ln39">void highlight_init(void)</a>
<a name="ln40">{</a>
<a name="ln41">  // index 0 is no attribute, add dummy entry:</a>
<a name="ln42">  kv_push(attr_entries, ((HlEntry){ .attr = HLATTRS_INIT, .kind = kHlUnknown,</a>
<a name="ln43">                                    .id1 = 0, .id2 = 0 }));</a>
<a name="ln44">}</a>
<a name="ln45"> </a>
<a name="ln46">/// @return true if hl table was reset</a>
<a name="ln47">bool highlight_use_hlstate(void)</a>
<a name="ln48">{</a>
<a name="ln49">  if (hlstate_active) {</a>
<a name="ln50">    return false;</a>
<a name="ln51">  }</a>
<a name="ln52">  hlstate_active = true;</a>
<a name="ln53">  // hl tables must now be rebuilt.</a>
<a name="ln54">  clear_hl_tables(true);</a>
<a name="ln55">  return true;</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">/// Return the attr number for a set of colors and font, and optionally</a>
<a name="ln59">/// a semantic description (see ext_hlstate documentation).</a>
<a name="ln60">/// Add a new entry to the attr_entries array if the combination is new.</a>
<a name="ln61">/// @return 0 for error.</a>
<a name="ln62">static int get_attr_entry(HlEntry entry)</a>
<a name="ln63">{</a>
<a name="ln64">  if (!hlstate_active) {</a>
<a name="ln65">    // This information will not be used, erase it and reduce the table size.</a>
<a name="ln66">    entry.kind = kHlUnknown;</a>
<a name="ln67">    entry.id1 = 0;</a>
<a name="ln68">    entry.id2 = 0;</a>
<a name="ln69">  }</a>
<a name="ln70"> </a>
<a name="ln71">  int id = map_get(HlEntry, int)(&amp;attr_entry_ids, entry);</a>
<a name="ln72">  if (id &gt; 0) {</a>
<a name="ln73">    return id;</a>
<a name="ln74">  }</a>
<a name="ln75"> </a>
<a name="ln76">  static bool recursive = false;</a>
<a name="ln77">  if (kv_size(attr_entries) &gt; MAX_TYPENR) {</a>
<a name="ln78">    // Running out of attribute entries!  remove all attributes, and</a>
<a name="ln79">    // compute new ones for all groups.</a>
<a name="ln80">    // When called recursively, we are really out of numbers.</a>
<a name="ln81">    if (recursive) {</a>
<a name="ln82">      emsg(_(&quot;E424: Too many different highlighting attributes in use&quot;));</a>
<a name="ln83">      return 0;</a>
<a name="ln84">    }</a>
<a name="ln85">    recursive = true;</a>
<a name="ln86"> </a>
<a name="ln87">    clear_hl_tables(true);</a>
<a name="ln88"> </a>
<a name="ln89">    recursive = false;</a>
<a name="ln90">    if (entry.kind == kHlCombine) {</a>
<a name="ln91">      // This entry is now invalid, don't put it</a>
<a name="ln92">      return 0;</a>
<a name="ln93">    }</a>
<a name="ln94">  }</a>
<a name="ln95"> </a>
<a name="ln96">  size_t next_id = kv_size(attr_entries);</a>
<a name="ln97">  if (next_id &gt; INT_MAX) {</a>
<a name="ln98">    ELOG(&quot;The index on attr_entries has overflowed&quot;);</a>
<a name="ln99">    return 0;</a>
<a name="ln100">  }</a>
<a name="ln101">  id = (int)next_id;</a>
<a name="ln102">  kv_push(attr_entries, entry);</a>
<a name="ln103"> </a>
<a name="ln104">  map_put(HlEntry, int)(&amp;attr_entry_ids, entry, id);</a>
<a name="ln105"> </a>
<a name="ln106">  Array inspect = hl_inspect(id);</a>
<a name="ln107"> </a>
<a name="ln108">  // Note: internally we don't distinguish between cterm and rgb attributes,</a>
<a name="ln109">  // remote_ui_hl_attr_define will however.</a>
<a name="ln110">  ui_call_hl_attr_define(id, entry.attr, entry.attr, inspect);</a>
<a name="ln111">  api_free_array(inspect);</a>
<a name="ln112">  return id;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">/// When a UI connects, we need to send it the table of highlights used so far.</a>
<a name="ln116">void ui_send_all_hls(UI *ui)</a>
<a name="ln117">{</a>
<a name="ln118">  if (ui-&gt;hl_attr_define) {</a>
<a name="ln119">    for (size_t i = 1; i &lt; kv_size(attr_entries); i++) {</a>
<a name="ln120">      Array inspect = hl_inspect((int)i);</a>
<a name="ln121">      ui-&gt;hl_attr_define(ui, (Integer)i, kv_A(attr_entries, i).attr,</a>
<a name="ln122">                         kv_A(attr_entries, i).attr, inspect);</a>
<a name="ln123">      api_free_array(inspect);</a>
<a name="ln124">    }</a>
<a name="ln125">  }</a>
<a name="ln126">  if (ui-&gt;hl_group_set) {</a>
<a name="ln127">    for (size_t hlf = 0; hlf &lt; HLF_COUNT; hlf++) {</a>
<a name="ln128">      ui-&gt;hl_group_set(ui, cstr_as_string((char *)hlf_names[hlf]),</a>
<a name="ln129">                       highlight_attr[hlf]);</a>
<a name="ln130">    }</a>
<a name="ln131">  }</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">/// Get attribute code for a syntax group.</a>
<a name="ln135">int hl_get_syn_attr(int ns_id, int idx, HlAttrs at_en)</a>
<a name="ln136">{</a>
<a name="ln137">  // TODO(bfredl): should we do this unconditionally</a>
<a name="ln138">  if (at_en.cterm_fg_color != 0 || at_en.cterm_bg_color != 0</a>
<a name="ln139">      || at_en.rgb_fg_color != -1 || at_en.rgb_bg_color != -1</a>
<a name="ln140">      || at_en.rgb_sp_color != -1 || at_en.cterm_ae_attr != 0</a>
<a name="ln141">      || at_en.rgb_ae_attr != 0 || ns_id != 0) {</a>
<a name="ln142">    return get_attr_entry((HlEntry){ .attr = at_en, .kind = kHlSyntax,</a>
<a name="ln143">                                     .id1 = idx, .id2 = ns_id });</a>
<a name="ln144">  } else {</a>
<a name="ln145">    // If all the fields are cleared, clear the attr field back to default value</a>
<a name="ln146">    return 0;</a>
<a name="ln147">  }</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">void ns_hl_def(NS ns_id, int hl_id, HlAttrs attrs, int link_id, Dict(highlight) *dict)</a>
<a name="ln151">{</a>
<a name="ln152">  if (ns_id == 0) {</a>
<a name="ln153">    assert(dict);</a>
<a name="ln154">    // set in global (':highlight') namespace</a>
<a name="ln155">    set_hl_group(hl_id, attrs, dict, link_id);</a>
<a name="ln156">    return;</a>
<a name="ln157">  }</a>
<a name="ln158">  if ((attrs.rgb_ae_attr &amp; HL_DEFAULT)</a>
<a name="ln159">      &amp;&amp; map_has(ColorKey, ColorItem)(&amp;ns_hls, ColorKey(ns_id, hl_id))) {</a>
<a name="ln160">    return;</a>
<a name="ln161">  }</a>
<a name="ln162">  DecorProvider *p = get_decor_provider(ns_id, true);</a>
<a name="ln163">  int attr_id = link_id &gt; 0 ? -1 : hl_get_syn_attr(ns_id, hl_id, attrs);</a>
<a name="ln164">  ColorItem it = { .attr_id = attr_id,</a>
<a name="ln165">                   .link_id = link_id,</a>
<a name="ln166">                   .version = p-&gt;hl_valid,</a>
<a name="ln167">                   .is_default = (attrs.rgb_ae_attr &amp; HL_DEFAULT),</a>
<a name="ln168">                   .link_global = (attrs.rgb_ae_attr &amp; HL_GLOBAL) };</a>
<a name="ln169">  map_put(ColorKey, ColorItem)(&amp;ns_hls, ColorKey(ns_id, hl_id), it);</a>
<a name="ln170">  p-&gt;hl_cached = false;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">int ns_get_hl(NS *ns_hl, int hl_id, bool link, bool nodefault)</a>
<a name="ln174">{</a>
<a name="ln175">  static int recursive = 0;</a>
<a name="ln176"> </a>
<a name="ln177">  if (*ns_hl == 0) {</a>
<a name="ln178">    // ns=0 (the default namespace) does not have a provider so stop here</a>
<a name="ln179">    return -1;</a>
<a name="ln180">  }</a>
<a name="ln181"> </a>
<a name="ln182">  if (*ns_hl &lt; 0) {</a>
<a name="ln183">    if (ns_hl_active &lt;= 0) {</a>
<a name="ln184">      return -1;</a>
<a name="ln185">    }</a>
<a name="ln186">    *ns_hl = ns_hl_active;</a>
<a name="ln187">  }</a>
<a name="ln188"> </a>
<a name="ln189">  int ns_id = *ns_hl;</a>
<a name="ln190"> </a>
<a name="ln191">  DecorProvider *p = get_decor_provider(ns_id, true);</a>
<a name="ln192">  ColorItem it = map_get(ColorKey, ColorItem)(&amp;ns_hls, ColorKey(ns_id, hl_id));</a>
<a name="ln193">  // TODO(bfredl): map_ref true even this?</a>
<a name="ln194">  bool valid_item = it.version &gt;= p-&gt;hl_valid;</a>
<a name="ln195"> </a>
<a name="ln196">  if (!valid_item &amp;&amp; p-&gt;hl_def != LUA_NOREF &amp;&amp; !recursive) {</a>
<a name="ln197">    MAXSIZE_TEMP_ARRAY(args, 3);</a>
<a name="ln198">    ADD_C(args, INTEGER_OBJ((Integer)ns_id));</a>
<a name="ln199">    ADD_C(args, STRING_OBJ(cstr_to_string((char *)syn_id2name(hl_id))));</a>
<a name="ln200">    ADD_C(args, BOOLEAN_OBJ(link));</a>
<a name="ln201">    // TODO(bfredl): preload the &quot;global&quot; attr dict?</a>
<a name="ln202"> </a>
<a name="ln203">    Error err = ERROR_INIT;</a>
<a name="ln204">    recursive++;</a>
<a name="ln205">    Object ret = nlua_call_ref(p-&gt;hl_def, &quot;hl_def&quot;, args, true, &amp;err);</a>
<a name="ln206">    recursive--;</a>
<a name="ln207"> </a>
<a name="ln208">    // TODO(bfredl): or &quot;inherit&quot;, combine with global value?</a>
<a name="ln209">    bool fallback = true;</a>
<a name="ln210">    int tmp = false;</a>
<a name="ln211">    HlAttrs attrs = HLATTRS_INIT;</a>
<a name="ln212">    if (ret.type == kObjectTypeDictionary) {</a>
<a name="ln213">      fallback = false;</a>
<a name="ln214">      Dict(highlight) dict = { 0 };</a>
<a name="ln215">      if (api_dict_to_keydict(&amp;dict, KeyDict_highlight_get_field,</a>
<a name="ln216">                              ret.data.dictionary, &amp;err)) {</a>
<a name="ln217">        attrs = dict2hlattrs(&amp;dict, true, &amp;it.link_id, &amp;err);</a>
<a name="ln218">        fallback = api_object_to_bool(dict.fallback, &quot;fallback&quot;, true, &amp;err);</a>
<a name="ln219">        tmp = api_object_to_bool(dict.fallback, &quot;tmp&quot;, false, &amp;err);</a>
<a name="ln220">        if (it.link_id &gt;= 0) {</a>
<a name="ln221">          fallback = true;</a>
<a name="ln222">        }</a>
<a name="ln223">      }</a>
<a name="ln224">    }</a>
<a name="ln225"> </a>
<a name="ln226">    it.attr_id = fallback ? -1 : hl_get_syn_attr(ns_id, hl_id, attrs);</a>
<a name="ln227">    it.version = p-&gt;hl_valid - tmp;</a>
<a name="ln228">    it.is_default = attrs.rgb_ae_attr &amp; HL_DEFAULT;</a>
<a name="ln229">    it.link_global = attrs.rgb_ae_attr &amp; HL_GLOBAL;</a>
<a name="ln230">    map_put(ColorKey, ColorItem)(&amp;ns_hls, ColorKey(ns_id, hl_id), it);</a>
<a name="ln231">    valid_item = true;</a>
<a name="ln232">  }</a>
<a name="ln233"> </a>
<a name="ln234">  if ((it.is_default &amp;&amp; nodefault) || !valid_item) {</a>
<a name="ln235">    return -1;</a>
<a name="ln236">  }</a>
<a name="ln237"> </a>
<a name="ln238">  if (link) {</a>
<a name="ln239">    if (it.attr_id &gt;= 0) {</a>
<a name="ln240">      return 0;</a>
<a name="ln241">    } else {</a>
<a name="ln242">      if (it.link_global) {</a>
<a name="ln243">        *ns_hl = 0;</a>
<a name="ln244">      }</a>
<a name="ln245">      return it.link_id;</a>
<a name="ln246">    }</a>
<a name="ln247">  } else {</a>
<a name="ln248">    return it.attr_id;</a>
<a name="ln249">  }</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">bool hl_check_ns(void)</a>
<a name="ln253">{</a>
<a name="ln254">  int ns = 0;</a>
<a name="ln255">  if (ns_hl_fast &gt; 0) {</a>
<a name="ln256">    ns = ns_hl_fast;</a>
<a name="ln257">  } else if (ns_hl_win &gt;= 0) {</a>
<a name="ln258">    ns = ns_hl_win;</a>
<a name="ln259">  } else {</a>
<a name="ln260">    ns = ns_hl_global;</a>
<a name="ln261">  }</a>
<a name="ln262">  if (ns_hl_active == ns) {</a>
<a name="ln263">    return false;</a>
<a name="ln264">  }</a>
<a name="ln265"> </a>
<a name="ln266">  ns_hl_active = ns;</a>
<a name="ln267">  hl_attr_active = highlight_attr;</a>
<a name="ln268">  if (ns &gt; 0) {</a>
<a name="ln269">    update_ns_hl(ns);</a>
<a name="ln270">    NSHlAttr *hl_def = (NSHlAttr *)pmap_get(handle_T)(&amp;ns_hl_attr, ns);</a>
<a name="ln271">    if (hl_def) {</a>
<a name="ln272">      hl_attr_active = *hl_def;</a>
<a name="ln273">    }</a>
<a name="ln274">  }</a>
<a name="ln275">  need_highlight_changed = true;</a>
<a name="ln276">  return true;</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">/// prepare for drawing window `wp` or global elements if NULL</a>
<a name="ln280">///</a>
<a name="ln281">/// Note: pum should be drawn in the context of the current window!</a>
<a name="ln282">bool win_check_ns_hl(win_T *wp)</a>
<a name="ln283">{</a>
<a name="ln284">  ns_hl_win = wp ? wp-&gt;w_ns_hl : -1;</a>
<a name="ln285">  return hl_check_ns();</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">/// Get attribute code for a builtin highlight group.</a>
<a name="ln289">///</a>
<a name="ln290">/// The final syntax group could be modified by hi-link or 'winhighlight'.</a>
<a name="ln291">int hl_get_ui_attr(int ns_id, int idx, int final_id, bool optional)</a>
<a name="ln292">{</a>
<a name="ln293">  HlAttrs attrs = HLATTRS_INIT;</a>
<a name="ln294">  bool available = false;</a>
<a name="ln295"> </a>
<a name="ln296">  if (final_id &gt; 0) {</a>
<a name="ln297">    int syn_attr = syn_ns_id2attr(ns_id, final_id, optional);</a>
<a name="ln298">    if (syn_attr &gt; 0) {</a>
<a name="ln299">      attrs = syn_attr2entry(syn_attr);</a>
<a name="ln300">      available = true;</a>
<a name="ln301">    }</a>
<a name="ln302">  }</a>
<a name="ln303"> </a>
<a name="ln304">  if (HLF_PNI &lt;= idx &amp;&amp; idx &lt;= HLF_PST) {</a>
<a name="ln305">    if (attrs.hl_blend == -1 &amp;&amp; p_pb &gt; 0) {</a>
<a name="ln306">      attrs.hl_blend = (int)p_pb;</a>
<a name="ln307">    }</a>
<a name="ln308">    if (pum_drawn()) {</a>
<a name="ln309">      must_redraw_pum = true;</a>
<a name="ln310">    }</a>
<a name="ln311">  }</a>
<a name="ln312"> </a>
<a name="ln313">  if (optional &amp;&amp; !available) {</a>
<a name="ln314">    return 0;</a>
<a name="ln315">  }</a>
<a name="ln316">  return get_attr_entry((HlEntry){ .attr = attrs, .kind = kHlUI,</a>
<a name="ln317">                                   .id1 = idx, .id2 = final_id });</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">void update_window_hl(win_T *wp, bool invalid)</a>
<a name="ln321">{</a>
<a name="ln322">  int ns_id = wp-&gt;w_ns_hl;</a>
<a name="ln323"> </a>
<a name="ln324">  update_ns_hl(ns_id);</a>
<a name="ln325">  if (ns_id != wp-&gt;w_ns_hl_active || wp-&gt;w_ns_hl_attr == NULL) {</a>
<a name="ln326">    wp-&gt;w_ns_hl_active = ns_id;</a>
<a name="ln327"> </a>
<a name="ln328">    wp-&gt;w_ns_hl_attr = *(NSHlAttr *)pmap_get(handle_T)(&amp;ns_hl_attr, ns_id);</a>
<a name="ln329">    if (!wp-&gt;w_ns_hl_attr) {</a>
<a name="ln330">      // No specific highlights, use the defaults.</a>
<a name="ln331">      wp-&gt;w_ns_hl_attr = highlight_attr;</a>
<a name="ln332">    }</a>
<a name="ln333">  }</a>
<a name="ln334"> </a>
<a name="ln335">  int *hl_def = wp-&gt;w_ns_hl_attr;</a>
<a name="ln336"> </a>
<a name="ln337">  if (!wp-&gt;w_hl_needs_update &amp;&amp; !invalid) {</a>
<a name="ln338">    return;</a>
<a name="ln339">  }</a>
<a name="ln340">  wp-&gt;w_hl_needs_update = false;</a>
<a name="ln341"> </a>
<a name="ln342">  // If a floating window is blending it always have a named</a>
<a name="ln343">  // wp-&gt;w_hl_attr_normal group. HL_ATTR(HLF_NFLOAT) is always named.</a>
<a name="ln344"> </a>
<a name="ln345">  // determine window specific background set in 'winhighlight'</a>
<a name="ln346">  bool float_win = wp-&gt;w_floating &amp;&amp; !wp-&gt;w_float_config.external;</a>
<a name="ln347">  if (float_win &amp;&amp; hl_def[HLF_NFLOAT] != 0) {</a>
<a name="ln348">    wp-&gt;w_hl_attr_normal = hl_def[HLF_NFLOAT];</a>
<a name="ln349">  } else if (hl_def[HLF_COUNT] &gt; 0) {</a>
<a name="ln350">    wp-&gt;w_hl_attr_normal = hl_def[HLF_COUNT];</a>
<a name="ln351">  } else {</a>
<a name="ln352">    wp-&gt;w_hl_attr_normal = float_win ? HL_ATTR(HLF_NFLOAT) : 0;</a>
<a name="ln353">  }</a>
<a name="ln354"> </a>
<a name="ln355">  // if blend= attribute is not set, 'winblend' value overrides it.</a>
<a name="ln356">  if (wp-&gt;w_floating &amp;&amp; wp-&gt;w_p_winbl &gt; 0) {</a>
<a name="ln357">    HlEntry entry = kv_A(attr_entries, wp-&gt;w_hl_attr_normal);</a>
<a name="ln358">    if (entry.attr.hl_blend == -1) {</a>
<a name="ln359">      entry.attr.hl_blend = (int)wp-&gt;w_p_winbl;</a>
<a name="ln360">      wp-&gt;w_hl_attr_normal = get_attr_entry(entry);</a>
<a name="ln361">    }</a>
<a name="ln362">  }</a>
<a name="ln363"> </a>
<a name="ln364">  wp-&gt;w_float_config.shadow = false;</a>
<a name="ln365">  if (wp-&gt;w_floating &amp;&amp; wp-&gt;w_float_config.border) {</a>
<a name="ln366">    for (int i = 0; i &lt; 8; i++) {</a>
<a name="ln367">      int attr = hl_def[HLF_BORDER];</a>
<a name="ln368">      if (wp-&gt;w_float_config.border_hl_ids[i]) {</a>
<a name="ln369">        attr = hl_get_ui_attr(ns_id, HLF_BORDER,</a>
<a name="ln370">                              wp-&gt;w_float_config.border_hl_ids[i], false);</a>
<a name="ln371">        HlAttrs a = syn_attr2entry(attr);</a>
<a name="ln372">        if (a.hl_blend) {</a>
<a name="ln373">          wp-&gt;w_float_config.shadow = true;</a>
<a name="ln374">        }</a>
<a name="ln375">      }</a>
<a name="ln376">      wp-&gt;w_float_config.border_attr[i] = attr;</a>
<a name="ln377">    }</a>
<a name="ln378">  }</a>
<a name="ln379"> </a>
<a name="ln380">  // shadow might cause blending</a>
<a name="ln381">  check_blending(wp);</a>
<a name="ln382"> </a>
<a name="ln383">  // TODO(bfredl): this a bit ad-hoc. move it from highlight ns logic to 'winhl'</a>
<a name="ln384">  // implementation?</a>
<a name="ln385">  if (hl_def[HLF_INACTIVE] == 0) {</a>
<a name="ln386">    wp-&gt;w_hl_attr_normalnc = hl_combine_attr(HL_ATTR(HLF_INACTIVE),</a>
<a name="ln387">                                             wp-&gt;w_hl_attr_normal);</a>
<a name="ln388">  } else {</a>
<a name="ln389">    wp-&gt;w_hl_attr_normalnc = hl_def[HLF_INACTIVE];</a>
<a name="ln390">  }</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">void update_ns_hl(int ns_id)</a>
<a name="ln394">{</a>
<a name="ln395">  if (ns_id &lt;= 0) {</a>
<a name="ln396">    return;</a>
<a name="ln397">  }</a>
<a name="ln398">  DecorProvider *p = get_decor_provider(ns_id, true);</a>
<a name="ln399">  if (p-&gt;hl_cached) {</a>
<a name="ln400">    return;</a>
<a name="ln401">  }</a>
<a name="ln402"> </a>
<a name="ln403">  NSHlAttr **alloc = (NSHlAttr **)pmap_ref(handle_T)(&amp;ns_hl_attr, ns_id, true);</a>
<a name="ln404">  if (*alloc == NULL) {</a>
<a name="ln405">    *alloc = xmalloc(sizeof(**alloc));</a>
<a name="ln406">  }</a>
<a name="ln407">  int *hl_attrs = **alloc;</a>
<a name="ln408"> </a>
<a name="ln409">  for (int hlf = 0; hlf &lt; HLF_COUNT; hlf++) {</a>
<a name="ln410">    int id = syn_check_group(hlf_names[hlf], strlen(hlf_names[hlf]));</a>
<a name="ln411">    bool optional = (hlf == HLF_INACTIVE || hlf == HLF_NFLOAT);</a>
<a name="ln412">    hl_attrs[hlf] = hl_get_ui_attr(ns_id, hlf, id, optional);</a>
<a name="ln413">  }</a>
<a name="ln414"> </a>
<a name="ln415">  // NOOOO! You cannot just pretend that &quot;Normal&quot; is just like any other</a>
<a name="ln416">  // syntax group! It needs at least 10 layers of special casing! Noooooo!</a>
<a name="ln417">  //</a>
<a name="ln418">  // haha, tema engine go brrr</a>
<a name="ln419">  int normality = syn_check_group(S_LEN(&quot;Normal&quot;));</a>
<a name="ln420">  hl_attrs[HLF_COUNT] = hl_get_ui_attr(ns_id, -1, normality, true);</a>
<a name="ln421"> </a>
<a name="ln422">  // hl_get_ui_attr might have invalidated the decor provider</a>
<a name="ln423">  p = get_decor_provider(ns_id, true);</a>
<a name="ln424">  p-&gt;hl_cached = true;</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427">int win_bg_attr(win_T *wp)</a>
<a name="ln428">{</a>
<a name="ln429">  if (ns_hl_fast &lt; 0) {</a>
<a name="ln430">    int local = (wp == curwin) ? wp-&gt;w_hl_attr_normal : wp-&gt;w_hl_attr_normalnc;</a>
<a name="ln431">    if (local) {</a>
<a name="ln432">      return local;</a>
<a name="ln433">    }</a>
<a name="ln434">  }</a>
<a name="ln435"> </a>
<a name="ln436">  if (wp == curwin || hl_attr_active[HLF_INACTIVE] == 0) {</a>
<a name="ln437">    return hl_attr_active[HLF_COUNT];</a>
<a name="ln438">  } else {</a>
<a name="ln439">    return hl_attr_active[HLF_INACTIVE];</a>
<a name="ln440">  }</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">/// Gets HL_UNDERLINE highlight.</a>
<a name="ln444">int hl_get_underline(void)</a>
<a name="ln445">{</a>
<a name="ln446">  return get_attr_entry((HlEntry){</a>
<a name="ln447">    .attr = (HlAttrs){</a>
<a name="ln448">      .cterm_ae_attr = (int16_t)HL_UNDERLINE,</a>
<a name="ln449">      .cterm_fg_color = 0,</a>
<a name="ln450">      .cterm_bg_color = 0,</a>
<a name="ln451">      .rgb_ae_attr = (int16_t)HL_UNDERLINE,</a>
<a name="ln452">      .rgb_fg_color = -1,</a>
<a name="ln453">      .rgb_bg_color = -1,</a>
<a name="ln454">      .rgb_sp_color = -1,</a>
<a name="ln455">      .hl_blend = -1,</a>
<a name="ln456">    },</a>
<a name="ln457">    .kind = kHlUI,</a>
<a name="ln458">    .id1 = 0,</a>
<a name="ln459">    .id2 = 0,</a>
<a name="ln460">  });</a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463">/// Get attribute code for forwarded :terminal highlights.</a>
<a name="ln464">int hl_get_term_attr(HlAttrs *aep)</a>
<a name="ln465">{</a>
<a name="ln466">  return get_attr_entry((HlEntry){ .attr= *aep, .kind = kHlTerminal,</a>
<a name="ln467">                                   .id1 = 0, .id2 = 0 });</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">/// Clear all highlight tables.</a>
<a name="ln471">void clear_hl_tables(bool reinit)</a>
<a name="ln472">{</a>
<a name="ln473">  if (reinit) {</a>
<a name="ln474">    kv_size(attr_entries) = 1;</a>
<a name="ln475">    map_clear(HlEntry, int)(&amp;attr_entry_ids);</a>
<a name="ln476">    map_clear(int, int)(&amp;combine_attr_entries);</a>
<a name="ln477">    map_clear(int, int)(&amp;blend_attr_entries);</a>
<a name="ln478">    map_clear(int, int)(&amp;blendthrough_attr_entries);</a>
<a name="ln479">    memset(highlight_attr_last, -1, sizeof(highlight_attr_last));</a>
<a name="ln480">    highlight_attr_set_all();</a>
<a name="ln481">    highlight_changed();</a>
<a name="ln482">    screen_invalidate_highlights();</a>
<a name="ln483">  } else {</a>
<a name="ln484">    kv_destroy(attr_entries);</a>
<a name="ln485">    map_destroy(HlEntry, int)(&amp;attr_entry_ids);</a>
<a name="ln486">    map_destroy(int, int)(&amp;combine_attr_entries);</a>
<a name="ln487">    map_destroy(int, int)(&amp;blend_attr_entries);</a>
<a name="ln488">    map_destroy(int, int)(&amp;blendthrough_attr_entries);</a>
<a name="ln489">    map_destroy(ColorKey, ColorItem)(&amp;ns_hls);</a>
<a name="ln490">  }</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">void hl_invalidate_blends(void)</a>
<a name="ln494">{</a>
<a name="ln495">  map_clear(int, int)(&amp;blend_attr_entries);</a>
<a name="ln496">  map_clear(int, int)(&amp;blendthrough_attr_entries);</a>
<a name="ln497">  highlight_changed();</a>
<a name="ln498">  update_window_hl(curwin, true);</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">// Combine special attributes (e.g., for spelling) with other attributes</a>
<a name="ln502">// (e.g., for syntax highlighting).</a>
<a name="ln503">// &quot;prim_attr&quot; overrules &quot;char_attr&quot;.</a>
<a name="ln504">// This creates a new group when required.</a>
<a name="ln505">// Since we expect there to be a lot of spelling mistakes we cache the result.</a>
<a name="ln506">// Return the resulting attributes.</a>
<a name="ln507">int hl_combine_attr(int char_attr, int prim_attr)</a>
<a name="ln508">{</a>
<a name="ln509">  if (char_attr == 0) {</a>
<a name="ln510">    return prim_attr;</a>
<a name="ln511">  } else if (prim_attr == 0) {</a>
<a name="ln512">    return char_attr;</a>
<a name="ln513">  }</a>
<a name="ln514"> </a>
<a name="ln515">  // TODO(bfredl): could use a struct for clearer intent.</a>
<a name="ln516">  int combine_tag = (char_attr &lt;&lt; 16) + prim_attr;</a>
<a name="ln517">  int id = map_get(int, int)(&amp;combine_attr_entries, combine_tag);</a>
<a name="ln518">  if (id &gt; 0) {</a>
<a name="ln519">    return id;</a>
<a name="ln520">  }</a>
<a name="ln521"> </a>
<a name="ln522">  HlAttrs char_aep = syn_attr2entry(char_attr);</a>
<a name="ln523">  HlAttrs prim_aep = syn_attr2entry(prim_attr);</a>
<a name="ln524"> </a>
<a name="ln525">  // start with low-priority attribute, and override colors if present below.</a>
<a name="ln526">  HlAttrs new_en = char_aep;</a>
<a name="ln527"> </a>
<a name="ln528">  if (prim_aep.cterm_ae_attr &amp; HL_NOCOMBINE) {</a>
<a name="ln529">    new_en.cterm_ae_attr = prim_aep.cterm_ae_attr;</a>
<a name="ln530">  } else {</a>
<a name="ln531">    new_en.cterm_ae_attr |= prim_aep.cterm_ae_attr;</a>
<a name="ln532">  }</a>
<a name="ln533">  if (prim_aep.rgb_ae_attr &amp; HL_NOCOMBINE) {</a>
<a name="ln534">    new_en.rgb_ae_attr = prim_aep.rgb_ae_attr;</a>
<a name="ln535">  } else {</a>
<a name="ln536">    new_en.rgb_ae_attr |= prim_aep.rgb_ae_attr;</a>
<a name="ln537">  }</a>
<a name="ln538"> </a>
<a name="ln539">  if (prim_aep.cterm_fg_color &gt; 0) {</a>
<a name="ln540">    new_en.cterm_fg_color = prim_aep.cterm_fg_color;</a>
<a name="ln541">    new_en.rgb_ae_attr &amp;= ((~HL_FG_INDEXED)</a>
<a name="ln542">                           | (prim_aep.rgb_ae_attr &amp; HL_FG_INDEXED));</a>
<a name="ln543">  }</a>
<a name="ln544"> </a>
<a name="ln545">  if (prim_aep.cterm_bg_color &gt; 0) {</a>
<a name="ln546">    new_en.cterm_bg_color = prim_aep.cterm_bg_color;</a>
<a name="ln547">    new_en.rgb_ae_attr &amp;= ((~HL_BG_INDEXED)</a>
<a name="ln548">                           | (prim_aep.rgb_ae_attr &amp; HL_BG_INDEXED));</a>
<a name="ln549">  }</a>
<a name="ln550"> </a>
<a name="ln551">  if (prim_aep.rgb_fg_color &gt;= 0) {</a>
<a name="ln552">    new_en.rgb_fg_color = prim_aep.rgb_fg_color;</a>
<a name="ln553">    new_en.rgb_ae_attr &amp;= ((~HL_FG_INDEXED)</a>
<a name="ln554">                           | (prim_aep.rgb_ae_attr &amp; HL_FG_INDEXED));</a>
<a name="ln555">  }</a>
<a name="ln556"> </a>
<a name="ln557">  if (prim_aep.rgb_bg_color &gt;= 0) {</a>
<a name="ln558">    new_en.rgb_bg_color = prim_aep.rgb_bg_color;</a>
<a name="ln559">    new_en.rgb_ae_attr &amp;= ((~HL_BG_INDEXED)</a>
<a name="ln560">                           | (prim_aep.rgb_ae_attr &amp; HL_BG_INDEXED));</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">  if (prim_aep.rgb_sp_color &gt;= 0) {</a>
<a name="ln564">    new_en.rgb_sp_color = prim_aep.rgb_sp_color;</a>
<a name="ln565">  }</a>
<a name="ln566"> </a>
<a name="ln567">  if (prim_aep.hl_blend &gt;= 0) {</a>
<a name="ln568">    new_en.hl_blend = prim_aep.hl_blend;</a>
<a name="ln569">  }</a>
<a name="ln570"> </a>
<a name="ln571">  id = get_attr_entry((HlEntry){ .attr = new_en, .kind = kHlCombine,</a>
<a name="ln572">                                 .id1 = char_attr, .id2 = prim_attr });</a>
<a name="ln573">  if (id &gt; 0) {</a>
<a name="ln574">    map_put(int, int)(&amp;combine_attr_entries, combine_tag, id);</a>
<a name="ln575">  }</a>
<a name="ln576"> </a>
<a name="ln577">  return id;</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">/// Get the used rgb colors for an attr group.</a>
<a name="ln581">///</a>
<a name="ln582">/// If colors are unset, use builtin default colors. Never returns -1</a>
<a name="ln583">/// Cterm colors are unchanged.</a>
<a name="ln584">static HlAttrs get_colors_force(int attr)</a>
<a name="ln585">{</a>
<a name="ln586">  HlAttrs attrs = syn_attr2entry(attr);</a>
<a name="ln587">  if (attrs.rgb_bg_color == -1) {</a>
<a name="ln588">    attrs.rgb_bg_color = normal_bg;</a>
<a name="ln589">  }</a>
<a name="ln590">  if (attrs.rgb_fg_color == -1) {</a>
<a name="ln591">    attrs.rgb_fg_color = normal_fg;</a>
<a name="ln592">  }</a>
<a name="ln593">  if (attrs.rgb_sp_color == -1) {</a>
<a name="ln594">    attrs.rgb_sp_color = normal_sp;</a>
<a name="ln595">  }</a>
<a name="ln596">  HL_SET_DEFAULT_COLORS(attrs.rgb_fg_color, attrs.rgb_bg_color,</a>
<a name="ln597">                        attrs.rgb_sp_color);</a>
<a name="ln598"> </a>
<a name="ln599">  if (attrs.rgb_ae_attr &amp; HL_INVERSE) {</a>
<a name="ln600">    int temp = attrs.rgb_bg_color;</a>
<a name="ln601">    attrs.rgb_bg_color = attrs.rgb_fg_color;</a>
<a name="ln602">    attrs.rgb_fg_color = temp;</a>
<a name="ln603">    attrs.rgb_ae_attr &amp;= ~HL_INVERSE;</a>
<a name="ln604">  }</a>
<a name="ln605"> </a>
<a name="ln606">  return attrs;</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">/// Blend overlay attributes (for popupmenu) with other attributes</a>
<a name="ln610">///</a>
<a name="ln611">/// This creates a new group when required.</a>
<a name="ln612">/// This is called per-cell, so cache the result.</a>
<a name="ln613">///</a>
<a name="ln614">/// @return the resulting attributes.</a>
<a name="ln615">int hl_blend_attrs(int back_attr, int front_attr, bool *through)</a>
<a name="ln616">{</a>
<a name="ln617">  if (front_attr &lt; 0 || back_attr &lt; 0) {</a>
<a name="ln618">    return -1;</a>
<a name="ln619">  }</a>
<a name="ln620"> </a>
<a name="ln621">  HlAttrs fattrs = get_colors_force(front_attr);</a>
<a name="ln622">  int ratio = fattrs.hl_blend;</a>
<a name="ln623">  if (ratio &lt;= 0) {</a>
<a name="ln624">    *through = false;</a>
<a name="ln625">    return front_attr;</a>
<a name="ln626">  }</a>
<a name="ln627"> </a>
<a name="ln628">  int combine_tag = (back_attr &lt;&lt; 16) + front_attr;</a>
<a name="ln629">  Map(int, int) *map = (*through</a>
<a name="ln630">                        ? &amp;blendthrough_attr_entries</a>
<a name="ln631">                        : &amp;blend_attr_entries);</a>
<a name="ln632">  int id = map_get(int, int)(map, combine_tag);</a>
<a name="ln633">  if (id &gt; 0) {</a>
<a name="ln634">    return id;</a>
<a name="ln635">  }</a>
<a name="ln636"> </a>
<a name="ln637">  HlAttrs battrs = get_colors_force(back_attr);</a>
<a name="ln638">  HlAttrs cattrs;</a>
<a name="ln639"> </a>
<a name="ln640">  if (*through) {</a>
<a name="ln641">    cattrs = battrs;</a>
<a name="ln642">    cattrs.rgb_fg_color = rgb_blend(ratio, battrs.rgb_fg_color,</a>
<a name="ln643">                                    fattrs.rgb_bg_color);</a>
<a name="ln644">    if (cattrs.rgb_ae_attr &amp; (HL_ANY_UNDERLINE)) {</a>
<a name="ln645">      cattrs.rgb_sp_color = rgb_blend(ratio, battrs.rgb_sp_color,</a>
<a name="ln646">                                      fattrs.rgb_bg_color);</a>
<a name="ln647">    } else {</a>
<a name="ln648">      cattrs.rgb_sp_color = -1;</a>
<a name="ln649">    }</a>
<a name="ln650"> </a>
<a name="ln651">    cattrs.cterm_bg_color = fattrs.cterm_bg_color;</a>
<a name="ln652">    cattrs.cterm_fg_color = cterm_blend(ratio, battrs.cterm_fg_color,</a>
<a name="ln653">                                        fattrs.cterm_bg_color);</a>
<a name="ln654">    cattrs.rgb_ae_attr &amp;= ~(HL_FG_INDEXED | HL_BG_INDEXED);</a>
<a name="ln655">  } else {</a>
<a name="ln656">    cattrs = fattrs;</a>
<a name="ln657">    if (ratio &gt;= 50) {</a>
<a name="ln658">      cattrs.rgb_ae_attr |= battrs.rgb_ae_attr;</a>
<a name="ln659">    }</a>
<a name="ln660">    cattrs.rgb_fg_color = rgb_blend(ratio/2, battrs.rgb_fg_color,</a>
<a name="ln661">                                    fattrs.rgb_fg_color);</a>
<a name="ln662">    if (cattrs.rgb_ae_attr &amp; (HL_ANY_UNDERLINE)) {</a>
<a name="ln663">      cattrs.rgb_sp_color = rgb_blend(ratio/2, battrs.rgb_bg_color,</a>
<a name="ln664">                                      fattrs.rgb_sp_color);</a>
<a name="ln665">    } else {</a>
<a name="ln666">      cattrs.rgb_sp_color = -1;</a>
<a name="ln667">    }</a>
<a name="ln668"> </a>
<a name="ln669">    cattrs.rgb_ae_attr &amp;= ~HL_BG_INDEXED;</a>
<a name="ln670">  }</a>
<a name="ln671">  cattrs.rgb_bg_color = rgb_blend(ratio, battrs.rgb_bg_color,</a>
<a name="ln672">                                  fattrs.rgb_bg_color);</a>
<a name="ln673"> </a>
<a name="ln674">  cattrs.hl_blend = -1;  // blend property was consumed</a>
<a name="ln675"> </a>
<a name="ln676">  HlKind kind = *through ? kHlBlendThrough : kHlBlend;</a>
<a name="ln677">  id = get_attr_entry((HlEntry){ .attr = cattrs, .kind = kind,</a>
<a name="ln678">                                 .id1 = back_attr, .id2 = front_attr });</a>
<a name="ln679">  if (id &gt; 0) {</a>
<a name="ln680">    map_put(int, int)(map, combine_tag, id);</a>
<a name="ln681">  }</a>
<a name="ln682">  return id;</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">static int rgb_blend(int ratio, int rgb1, int rgb2)</a>
<a name="ln686">{</a>
<a name="ln687">  int a = ratio, b = 100 - ratio;</a>
<a name="ln688">  int r1 = (rgb1 &amp; 0xFF0000) &gt;&gt; 16;</a>
<a name="ln689">  int g1 = (rgb1 &amp; 0x00FF00) &gt;&gt; 8;</a>
<a name="ln690">  int b1 = (rgb1 &amp; 0x0000FF) &gt;&gt; 0;</a>
<a name="ln691">  int r2 = (rgb2 &amp; 0xFF0000) &gt;&gt; 16;</a>
<a name="ln692">  int g2 = (rgb2 &amp; 0x00FF00) &gt;&gt; 8;</a>
<a name="ln693">  int b2 = (rgb2 &amp; 0x0000FF) &gt;&gt; 0;</a>
<a name="ln694">  int mr = (a * r1 + b * r2)/100;</a>
<a name="ln695">  int mg = (a * g1 + b * g2)/100;</a>
<a name="ln696">  int mb = (a * b1 + b * b2)/100;</a>
<a name="ln697">  return (mr &lt;&lt; 16) + (mg &lt;&lt; 8) + mb;</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">static int cterm_blend(int ratio, int c1, int c2)</a>
<a name="ln701">{</a>
<a name="ln702">  // 1. Convert cterm color numbers to RGB.</a>
<a name="ln703">  // 2. Blend the RGB colors.</a>
<a name="ln704">  // 3. Convert the RGB result to a cterm color.</a>
<a name="ln705">  int rgb1 = hl_cterm2rgb_color(c1);</a>
<a name="ln706">  int rgb2 = hl_cterm2rgb_color(c2);</a>
<a name="ln707">  int rgb_blended = rgb_blend(ratio, rgb1, rgb2);</a>
<a name="ln708">  return hl_rgb2cterm_color(rgb_blended);</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">/// Converts RGB color to 8-bit color (0-255).</a>
<a name="ln712">static int hl_rgb2cterm_color(int rgb)</a>
<a name="ln713">{</a>
<a name="ln714">  int r = (rgb &amp; 0xFF0000) &gt;&gt; 16;</a>
<a name="ln715">  int g = (rgb &amp; 0x00FF00) &gt;&gt; 8;</a>
<a name="ln716">  int b = (rgb &amp; 0x0000FF) &gt;&gt; 0;</a>
<a name="ln717"> </a>
<a name="ln718">  return (r * 6 / 256) * 36 + (g * 6 / 256) * 6 + (b * 6 / 256);</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721">/// Converts 8-bit color (0-255) to RGB color.</a>
<a name="ln722">/// This is compatible with xterm.</a>
<a name="ln723">static int hl_cterm2rgb_color(int nr)</a>
<a name="ln724">{</a>
<a name="ln725">  static int cube_value[] = {</a>
<a name="ln726">    0x00, 0x5F, 0x87, 0xAF, 0xD7, 0xFF</a>
<a name="ln727">  };</a>
<a name="ln728">  static int grey_ramp[] = {</a>
<a name="ln729">    0x08, 0x12, 0x1C, 0x26, 0x30, 0x3A, 0x44, 0x4E, 0x58, 0x62, 0x6C, 0x76,</a>
<a name="ln730">    0x80, 0x8A, 0x94, 0x9E, 0xA8, 0xB2, 0xBC, 0xC6, 0xD0, 0xDA, 0xE4, 0xEE</a>
<a name="ln731">  };</a>
<a name="ln732">  static uint8_t ansi_table[16][4] = {</a>
<a name="ln733">    //  R    G    B   idx</a>
<a name="ln734">    {   0,   0,   0,  1 },  // black</a>
<a name="ln735">    { 224,   0,   0,  2 },  // dark red</a>
<a name="ln736">    {   0, 224,   0,  3 },  // dark green</a>
<a name="ln737">    { 224, 224,   0,  4 },  // dark yellow / brown</a>
<a name="ln738">    {   0,   0, 224,  5 },  // dark blue</a>
<a name="ln739">    { 224,   0, 224,  6 },  // dark magenta</a>
<a name="ln740">    {   0, 224, 224,  7 },  // dark cyan</a>
<a name="ln741">    { 224, 224, 224,  8 },  // light grey</a>
<a name="ln742"> </a>
<a name="ln743">    { 128, 128, 128,  9 },  // dark grey</a>
<a name="ln744">    { 255,  64,  64, 10 },  // light red</a>
<a name="ln745">    {  64, 255,  64, 11 },  // light green</a>
<a name="ln746">    { 255, 255,  64, 12 },  // yellow</a>
<a name="ln747">    {  64,  64, 255, 13 },  // light blue</a>
<a name="ln748">    { 255,  64, 255, 14 },  // light magenta</a>
<a name="ln749">    {  64, 255, 255, 15 },  // light cyan</a>
<a name="ln750">    { 255, 255, 255, 16 },  // white</a>
<a name="ln751">  };</a>
<a name="ln752"> </a>
<a name="ln753">  int r = 0;</a>
<a name="ln754">  int g = 0;</a>
<a name="ln755">  int b = 0;</a>
<a name="ln756">  int idx;</a>
<a name="ln757">  // *ansi_idx = 0;</a>
<a name="ln758"> </a>
<a name="ln759">  if (nr &lt; 16) {</a>
<a name="ln760">    r = ansi_table[nr][0];</a>
<a name="ln761">    g = ansi_table[nr][1];</a>
<a name="ln762">    b = ansi_table[nr][2];</a>
<a name="ln763">    // *ansi_idx = ansi_table[nr][3];</a>
<a name="ln764">  } else if (nr &lt; 232) {  // 216 color-cube</a>
<a name="ln765">    idx = nr - 16;</a>
<a name="ln766">    r = cube_value[idx / 36 % 6];</a>
<a name="ln767">    g = cube_value[idx / 6  % 6];</a>
<a name="ln768">    b = cube_value[idx      % 6];</a>
<a name="ln769">    // *ansi_idx = -1;</a>
<a name="ln770">  } else if (nr &lt; 256) {  // 24 greyscale ramp</a>
<a name="ln771">    idx = nr - 232;</a>
<a name="ln772">    r = grey_ramp[idx];</a>
<a name="ln773">    g = grey_ramp[idx];</a>
<a name="ln774">    b = grey_ramp[idx];</a>
<a name="ln775">    // *ansi_idx = -1;</a>
<a name="ln776">  }</a>
<a name="ln777">  return (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780">/// Get highlight attributes for a attribute code</a>
<a name="ln781">HlAttrs syn_attr2entry(int attr)</a>
<a name="ln782">{</a>
<a name="ln783">  if (attr &lt;= 0 || attr &gt;= (int)kv_size(attr_entries)) {</a>
<a name="ln784">    // invalid attribute code, or the tables were cleared</a>
<a name="ln785">    return HLATTRS_INIT;</a>
<a name="ln786">  }</a>
<a name="ln787">  return kv_A(attr_entries, attr).attr;</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790">/// Gets highlight description for id `attr_id` as a map.</a>
<a name="ln791">Dictionary hl_get_attr_by_id(Integer attr_id, Boolean rgb, Arena *arena, Error *err)</a>
<a name="ln792">{</a>
<a name="ln793">  Dictionary dic = ARRAY_DICT_INIT;</a>
<a name="ln794"> </a>
<a name="ln795">  if (attr_id == 0) {</a>
<a name="ln796">    return dic;</a>
<a name="ln797">  }</a>
<a name="ln798"> </a>
<a name="ln799">  if (attr_id &lt;= 0 || attr_id &gt;= (int)kv_size(attr_entries)) {</a>
<a name="ln800">    api_set_error(err, kErrorTypeException,</a>
<a name="ln801">                  &quot;Invalid attribute id: %&quot; PRId64, attr_id);</a>
<a name="ln802">    return dic;</a>
<a name="ln803">  }</a>
<a name="ln804">  Dictionary retval = arena_dict(arena, HLATTRS_DICT_SIZE);</a>
<a name="ln805">  hlattrs2dict(&amp;retval, syn_attr2entry((int)attr_id), rgb);</a>
<a name="ln806">  return retval;</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809">/// Converts an HlAttrs into Dictionary</a>
<a name="ln810">///</a>
<a name="ln811">/// @param[in/out] hl Dictionary with pre-allocated space for HLATTRS_DICT_SIZE elements</a>
<a name="ln812">/// @param[in] aep data to convert</a>
<a name="ln813">/// @param use_rgb use 'gui*' settings if true, else resorts to 'cterm*'</a>
<a name="ln814">void hlattrs2dict(Dictionary *dict, HlAttrs ae, bool use_rgb)</a>
<a name="ln815">{</a>
<a name="ln816">  assert(dict-&gt;capacity &gt;= HLATTRS_DICT_SIZE);  // at most 16 items</a>
<a name="ln817">  Dictionary hl = *dict;</a>
<a name="ln818">  int mask  = use_rgb ? ae.rgb_ae_attr : ae.cterm_ae_attr;</a>
<a name="ln819"> </a>
<a name="ln820">  if (mask &amp; HL_BOLD) {</a>
<a name="ln821">    PUT_C(hl, &quot;bold&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln822">  }</a>
<a name="ln823"> </a>
<a name="ln824">  if (mask &amp; HL_STANDOUT) {</a>
<a name="ln825">    PUT_C(hl, &quot;standout&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln826">  }</a>
<a name="ln827"> </a>
<a name="ln828">  if (mask &amp; HL_UNDERLINE) {</a>
<a name="ln829">    PUT_C(hl, &quot;underline&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln830">  }</a>
<a name="ln831"> </a>
<a name="ln832">  if (mask &amp; HL_UNDERCURL) {</a>
<a name="ln833">    PUT_C(hl, &quot;undercurl&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln834">  }</a>
<a name="ln835"> </a>
<a name="ln836">  if (mask &amp; HL_UNDERDOUBLE) {</a>
<a name="ln837">    PUT_C(hl, &quot;underdouble&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln838">  }</a>
<a name="ln839"> </a>
<a name="ln840">  if (mask &amp; HL_UNDERDOTTED) {</a>
<a name="ln841">    PUT_C(hl, &quot;underdotted&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln842">  }</a>
<a name="ln843"> </a>
<a name="ln844">  if (mask &amp; HL_UNDERDASHED) {</a>
<a name="ln845">    PUT_C(hl, &quot;underdashed&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln846">  }</a>
<a name="ln847"> </a>
<a name="ln848">  if (mask &amp; HL_ITALIC) {</a>
<a name="ln849">    PUT_C(hl, &quot;italic&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln850">  }</a>
<a name="ln851"> </a>
<a name="ln852">  if (mask &amp; HL_INVERSE) {</a>
<a name="ln853">    PUT_C(hl, &quot;reverse&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln854">  }</a>
<a name="ln855"> </a>
<a name="ln856">  if (mask &amp; HL_STRIKETHROUGH) {</a>
<a name="ln857">    PUT_C(hl, &quot;strikethrough&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln858">  }</a>
<a name="ln859"> </a>
<a name="ln860">  if (mask &amp; HL_NOCOMBINE) {</a>
<a name="ln861">    PUT_C(hl, &quot;nocombine&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln862">  }</a>
<a name="ln863"> </a>
<a name="ln864">  if (use_rgb) {</a>
<a name="ln865">    if (mask &amp; HL_FG_INDEXED) {</a>
<a name="ln866">      PUT_C(hl, &quot;fg_indexed&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln867">    }</a>
<a name="ln868"> </a>
<a name="ln869">    if (mask &amp; HL_BG_INDEXED) {</a>
<a name="ln870">      PUT_C(hl, &quot;bg_indexed&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln871">    }</a>
<a name="ln872"> </a>
<a name="ln873">    if (ae.rgb_fg_color != -1) {</a>
<a name="ln874">      PUT_C(hl, &quot;foreground&quot;, INTEGER_OBJ(ae.rgb_fg_color));</a>
<a name="ln875">    }</a>
<a name="ln876"> </a>
<a name="ln877">    if (ae.rgb_bg_color != -1) {</a>
<a name="ln878">      PUT_C(hl, &quot;background&quot;, INTEGER_OBJ(ae.rgb_bg_color));</a>
<a name="ln879">    }</a>
<a name="ln880"> </a>
<a name="ln881">    if (ae.rgb_sp_color != -1) {</a>
<a name="ln882">      PUT_C(hl, &quot;special&quot;, INTEGER_OBJ(ae.rgb_sp_color));</a>
<a name="ln883">    }</a>
<a name="ln884">  } else {</a>
<a name="ln885">    if (ae.cterm_fg_color != 0) {</a>
<a name="ln886">      PUT_C(hl, &quot;foreground&quot;, INTEGER_OBJ(ae.cterm_fg_color - 1));</a>
<a name="ln887">    }</a>
<a name="ln888"> </a>
<a name="ln889">    if (ae.cterm_bg_color != 0) {</a>
<a name="ln890">      PUT_C(hl, &quot;background&quot;, INTEGER_OBJ(ae.cterm_bg_color - 1));</a>
<a name="ln891">    }</a>
<a name="ln892">  }</a>
<a name="ln893"> </a>
<a name="ln894">  if (ae.hl_blend &gt; -1) {</a>
<a name="ln895">    PUT_C(hl, &quot;blend&quot;, INTEGER_OBJ(ae.hl_blend));</a>
<a name="ln896">  }</a>
<a name="ln897"> </a>
<a name="ln898">  *dict = hl;</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901">HlAttrs dict2hlattrs(Dict(highlight) *dict, bool use_rgb, int *link_id, Error *err)</a>
<a name="ln902">{</a>
<a name="ln903">  HlAttrs hlattrs = HLATTRS_INIT;</a>
<a name="ln904">  int32_t fg = -1, bg = -1, ctermfg = -1, ctermbg = -1, sp = -1;</a>
<a name="ln905">  int blend = -1;</a>
<a name="ln906">  int16_t mask = 0;</a>
<a name="ln907">  int16_t cterm_mask = 0;</a>
<a name="ln908">  bool cterm_mask_provided = false;</a>
<a name="ln909"> </a>
<a name="ln910">#define CHECK_FLAG(d, m, name, extra, flag) \</a>
<a name="ln911">  if (api_object_to_bool(d-&gt;name##extra, #name, false, err)) { \</a>
<a name="ln912">    m = m | flag; \</a>
<a name="ln913">  }</a>
<a name="ln914"> </a>
<a name="ln915">  CHECK_FLAG(dict, mask, bold, , HL_BOLD);</a>
<a name="ln916">  CHECK_FLAG(dict, mask, standout, , HL_STANDOUT);</a>
<a name="ln917">  CHECK_FLAG(dict, mask, underline, , HL_UNDERLINE);</a>
<a name="ln918">  CHECK_FLAG(dict, mask, undercurl, , HL_UNDERCURL);</a>
<a name="ln919">  CHECK_FLAG(dict, mask, underdouble, , HL_UNDERDOUBLE);</a>
<a name="ln920">  CHECK_FLAG(dict, mask, underdotted, , HL_UNDERDOTTED);</a>
<a name="ln921">  CHECK_FLAG(dict, mask, underdashed, , HL_UNDERDASHED);</a>
<a name="ln922">  CHECK_FLAG(dict, mask, italic, , HL_ITALIC);</a>
<a name="ln923">  CHECK_FLAG(dict, mask, reverse, , HL_INVERSE);</a>
<a name="ln924">  CHECK_FLAG(dict, mask, strikethrough, , HL_STRIKETHROUGH);</a>
<a name="ln925">  CHECK_FLAG(dict, mask, nocombine, , HL_NOCOMBINE);</a>
<a name="ln926">  CHECK_FLAG(dict, mask, default, _, HL_DEFAULT);</a>
<a name="ln927"> </a>
<a name="ln928">  if (HAS_KEY(dict-&gt;fg)) {</a>
<a name="ln929">    fg = object_to_color(dict-&gt;fg, &quot;fg&quot;, true, err);</a>
<a name="ln930">  } else if (HAS_KEY(dict-&gt;foreground)) {</a>
<a name="ln931">    fg = object_to_color(dict-&gt;foreground, &quot;foreground&quot;, true, err);</a>
<a name="ln932">  }</a>
<a name="ln933">  if (ERROR_SET(err)) {</a>
<a name="ln934">    return hlattrs;</a>
<a name="ln935">  }</a>
<a name="ln936"> </a>
<a name="ln937">  if (HAS_KEY(dict-&gt;bg)) {</a>
<a name="ln938">    bg = object_to_color(dict-&gt;bg, &quot;bg&quot;, true, err);</a>
<a name="ln939">  } else if (HAS_KEY(dict-&gt;background)) {</a>
<a name="ln940">    bg = object_to_color(dict-&gt;background, &quot;background&quot;, true, err);</a>
<a name="ln941">  }</a>
<a name="ln942">  if (ERROR_SET(err)) {</a>
<a name="ln943">    return hlattrs;</a>
<a name="ln944">  }</a>
<a name="ln945"> </a>
<a name="ln946">  if (HAS_KEY(dict-&gt;sp)) {</a>
<a name="ln947">    sp = object_to_color(dict-&gt;sp, &quot;sp&quot;, true, err);</a>
<a name="ln948">  } else if (HAS_KEY(dict-&gt;special)) {</a>
<a name="ln949">    sp = object_to_color(dict-&gt;special, &quot;special&quot;, true, err);</a>
<a name="ln950">  }</a>
<a name="ln951">  if (ERROR_SET(err)) {</a>
<a name="ln952">    return hlattrs;</a>
<a name="ln953">  }</a>
<a name="ln954"> </a>
<a name="ln955">  if (dict-&gt;blend.type == kObjectTypeInteger) {</a>
<a name="ln956">    Integer blend0 = dict-&gt;blend.data.integer;</a>
<a name="ln957">    if (blend0 &lt; 0 || blend0 &gt; 100) {</a>
<a name="ln958">      api_set_error(err, kErrorTypeValidation, &quot;'blend' is not between 0 to 100&quot;);</a>
<a name="ln959">    } else {</a>
<a name="ln960">      blend = (int)blend0;</a>
<a name="ln961">    }</a>
<a name="ln962">  } else if (HAS_KEY(dict-&gt;blend)) {</a>
<a name="ln963">    api_set_error(err, kErrorTypeValidation, &quot;'blend' must be an integer&quot;);</a>
<a name="ln964">  }</a>
<a name="ln965">  if (ERROR_SET(err)) {</a>
<a name="ln966">    return hlattrs;</a>
<a name="ln967">  }</a>
<a name="ln968"> </a>
<a name="ln969">  if (HAS_KEY(dict-&gt;link) || HAS_KEY(dict-&gt;global_link)) {</a>
<a name="ln970">    if (link_id) {</a>
<a name="ln971">      if (HAS_KEY(dict-&gt;global_link)) {</a>
<a name="ln972">        *link_id = object_to_hl_id(dict-&gt;global_link, &quot;link&quot;, err);</a>
<a name="ln973">        mask |= HL_GLOBAL;</a>
<a name="ln974">      } else {</a>
<a name="ln975">        *link_id = object_to_hl_id(dict-&gt;link, &quot;link&quot;, err);</a>
<a name="ln976">      }</a>
<a name="ln977"> </a>
<a name="ln978">      if (ERROR_SET(err)) {</a>
<a name="ln979">        return hlattrs;</a>
<a name="ln980">      }</a>
<a name="ln981">    } else {</a>
<a name="ln982">      api_set_error(err, kErrorTypeValidation, &quot;Invalid Key: '%s'&quot;,</a>
<a name="ln983">                    HAS_KEY(dict-&gt;global_link) ? &quot;global_link&quot; : &quot;link&quot;);</a>
<a name="ln984">    }</a>
<a name="ln985">  }</a>
<a name="ln986"> </a>
<a name="ln987">  // Handle cterm attrs</a>
<a name="ln988">  if (dict-&gt;cterm.type == kObjectTypeDictionary) {</a>
<a name="ln989">    Dict(highlight_cterm) cterm[1] = { 0 };</a>
<a name="ln990">    if (!api_dict_to_keydict(cterm, KeyDict_highlight_cterm_get_field,</a>
<a name="ln991">                             dict-&gt;cterm.data.dictionary, err)) {</a>
<a name="ln992">      return hlattrs;</a>
<a name="ln993">    }</a>
<a name="ln994"> </a>
<a name="ln995">    cterm_mask_provided = true;</a>
<a name="ln996">    CHECK_FLAG(cterm, cterm_mask, bold, , HL_BOLD);</a>
<a name="ln997">    CHECK_FLAG(cterm, cterm_mask, standout, , HL_STANDOUT);</a>
<a name="ln998">    CHECK_FLAG(cterm, cterm_mask, underline, , HL_UNDERLINE);</a>
<a name="ln999">    CHECK_FLAG(cterm, cterm_mask, undercurl, , HL_UNDERCURL);</a>
<a name="ln1000">    CHECK_FLAG(cterm, cterm_mask, italic, , HL_ITALIC);</a>
<a name="ln1001">    CHECK_FLAG(cterm, cterm_mask, reverse, , HL_INVERSE);</a>
<a name="ln1002">    CHECK_FLAG(cterm, cterm_mask, strikethrough, , HL_STRIKETHROUGH);</a>
<a name="ln1003">    CHECK_FLAG(cterm, cterm_mask, nocombine, , HL_NOCOMBINE);</a>
<a name="ln1004">  } else if (dict-&gt;cterm.type == kObjectTypeArray &amp;&amp; dict-&gt;cterm.data.array.size == 0) {</a>
<a name="ln1005">    // empty list from Lua API should clear all cterm attributes</a>
<a name="ln1006">    // TODO(clason): handle via gen_api_dispatch</a>
<a name="ln1007">    cterm_mask_provided = true;</a>
<a name="ln1008">  } else if (HAS_KEY(dict-&gt;cterm)) {</a>
<a name="ln1009">    api_set_error(err, kErrorTypeValidation, &quot;'cterm' must be a Dictionary.&quot;);</a>
<a name="ln1010">  }</a>
<a name="ln1011">#undef CHECK_FLAG</a>
<a name="ln1012"> </a>
<a name="ln1013">  if (HAS_KEY(dict-&gt;ctermfg)) {</a>
<a name="ln1014">    ctermfg = object_to_color(dict-&gt;ctermfg, &quot;ctermfg&quot;, false, err);</a>
<a name="ln1015">    if (ERROR_SET(err)) {</a>
<a name="ln1016">      return hlattrs;</a>
<a name="ln1017">    }</a>
<a name="ln1018">  }</a>
<a name="ln1019"> </a>
<a name="ln1020">  if (HAS_KEY(dict-&gt;ctermbg)) {</a>
<a name="ln1021">    ctermbg = object_to_color(dict-&gt;ctermbg, &quot;ctermbg&quot;, false, err);</a>
<a name="ln1022">    if (ERROR_SET(err)) {</a>
<a name="ln1023">      return hlattrs;</a>
<a name="ln1024">    }</a>
<a name="ln1025">  }</a>
<a name="ln1026"> </a>
<a name="ln1027">  // apply gui mask as default for cterm mask</a>
<a name="ln1028">  if (!cterm_mask_provided) {</a>
<a name="ln1029">    cterm_mask = mask;</a>
<a name="ln1030">  }</a>
<a name="ln1031">  if (use_rgb) {</a>
<a name="ln1032">    hlattrs.rgb_ae_attr = mask;</a>
<a name="ln1033">    hlattrs.rgb_bg_color = bg;</a>
<a name="ln1034">    hlattrs.rgb_fg_color = fg;</a>
<a name="ln1035">    hlattrs.rgb_sp_color = sp;</a>
<a name="ln1036">    hlattrs.hl_blend = blend;</a>
<a name="ln1037">    hlattrs.cterm_bg_color = ctermbg == -1 ? 0 : ctermbg + 1;</a>
<a name="ln1038">    hlattrs.cterm_fg_color = ctermfg == -1 ? 0 : ctermfg + 1;</a>
<a name="ln1039">    hlattrs.cterm_ae_attr = cterm_mask;</a>
<a name="ln1040">  } else {</a>
<a name="ln1041">    hlattrs.cterm_bg_color = ctermbg == -1 ? 0 : ctermbg + 1;</a>
<a name="ln1042">    hlattrs.cterm_fg_color = ctermfg == -1 ? 0 : ctermfg + 1;</a>
<a name="ln1043">    hlattrs.cterm_ae_attr = cterm_mask;</a>
<a name="ln1044">  }</a>
<a name="ln1045"> </a>
<a name="ln1046">  return hlattrs;</a>
<a name="ln1047">}</a>
<a name="ln1048"> </a>
<a name="ln1049">int object_to_color(Object val, char *key, bool rgb, Error *err)</a>
<a name="ln1050">{</a>
<a name="ln1051">  if (val.type == kObjectTypeInteger) {</a>
<a name="ln1052">    return (int)val.data.integer;</a>
<a name="ln1053">  } else if (val.type == kObjectTypeString) {</a>
<a name="ln1054">    String str = val.data.string;</a>
<a name="ln1055">    // TODO(bfredl): be more fancy with &quot;bg&quot;, &quot;fg&quot; etc</a>
<a name="ln1056">    if (!str.size || STRICMP(str.data, &quot;NONE&quot;) == 0) {</a>
<a name="ln1057">      return -1;</a>
<a name="ln1058">    }</a>
<a name="ln1059">    int color;</a>
<a name="ln1060">    if (rgb) {</a>
<a name="ln1061">      int dummy;</a>
<a name="ln1062">      color = name_to_color(str.data, &amp;dummy);</a>
<a name="ln1063">    } else {</a>
<a name="ln1064">      color = name_to_ctermcolor(str.data);</a>
<a name="ln1065">    }</a>
<a name="ln1066">    if (color &lt; 0) {</a>
<a name="ln1067">      api_set_error(err, kErrorTypeValidation, &quot;'%s' is not a valid color&quot;, str.data);</a>
<a name="ln1068">    }</a>
<a name="ln1069">    return color;</a>
<a name="ln1070">  } else {</a>
<a name="ln1071">    api_set_error(err, kErrorTypeValidation, &quot;'%s' must be string or integer&quot;, key);</a>
<a name="ln1072">    return 0;</a>
<a name="ln1073">  }</a>
<a name="ln1074">}</a>
<a name="ln1075"> </a>
<a name="ln1076">Array hl_inspect(int attr)</a>
<a name="ln1077">{</a>
<a name="ln1078">  // TODO(bfredl): use arena allocation</a>
<a name="ln1079">  Array ret = ARRAY_DICT_INIT;</a>
<a name="ln1080">  if (hlstate_active) {</a>
<a name="ln1081">    hl_inspect_impl(&amp;ret, attr);</a>
<a name="ln1082">  }</a>
<a name="ln1083">  return ret;</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086">static void hl_inspect_impl(Array *arr, int attr)</a>
<a name="ln1087">{</a>
<a name="ln1088">  Dictionary item = ARRAY_DICT_INIT;</a>
<a name="ln1089">  if (attr &lt;= 0 || attr &gt;= (int)kv_size(attr_entries)) {</a>
<a name="ln1090">    return;</a>
<a name="ln1091">  }</a>
<a name="ln1092"> </a>
<a name="ln1093">  HlEntry e = kv_A(attr_entries, attr);</a>
<a name="ln1094">  switch (e.kind) {</a>
<a name="ln1095">  case kHlSyntax:</a>
<a name="ln1096">    PUT(item, &quot;kind&quot;, STRING_OBJ(cstr_to_string(&quot;syntax&quot;)));</a>
<a name="ln1097">    PUT(item, &quot;hi_name&quot;,</a>
<a name="ln1098">        STRING_OBJ(cstr_to_string((char *)syn_id2name(e.id1))));</a>
<a name="ln1099">    break;</a>
<a name="ln1100"> </a>
<a name="ln1101">  case kHlUI:</a>
<a name="ln1102">    PUT(item, &quot;kind&quot;, STRING_OBJ(cstr_to_string(&quot;ui&quot;)));</a>
<a name="ln1103">    const char *ui_name = (e.id1 == -1) ? &quot;Normal&quot; : hlf_names[e.id1];</a>
<a name="ln1104">    PUT(item, &quot;ui_name&quot;, STRING_OBJ(cstr_to_string(ui_name)));</a>
<a name="ln1105">    PUT(item, &quot;hi_name&quot;,</a>
<a name="ln1106">        STRING_OBJ(cstr_to_string((char *)syn_id2name(e.id2))));</a>
<a name="ln1107">    break;</a>
<a name="ln1108"> </a>
<a name="ln1109">  case kHlTerminal:</a>
<a name="ln1110">    PUT(item, &quot;kind&quot;, STRING_OBJ(cstr_to_string(&quot;term&quot;)));</a>
<a name="ln1111">    break;</a>
<a name="ln1112"> </a>
<a name="ln1113">  case kHlCombine:</a>
<a name="ln1114">  case kHlBlend:</a>
<a name="ln1115">  case kHlBlendThrough:</a>
<a name="ln1116">    // attribute combination is associative, so flatten to an array</a>
<a name="ln1117">    hl_inspect_impl(arr, e.id1);</a>
<a name="ln1118">    hl_inspect_impl(arr, e.id2);</a>
<a name="ln1119">    return;</a>
<a name="ln1120"> </a>
<a name="ln1121">  case kHlUnknown:</a>
<a name="ln1122">    return;</a>
<a name="ln1123">  }</a>
<a name="ln1124">  PUT(item, &quot;id&quot;, INTEGER_OBJ(attr));</a>
<a name="ln1125">  ADD(*arr, DICTIONARY_OBJ(item));</a>
<a name="ln1126">}</a>
</code></pre>
<div class="balloon" rel="329"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression '!wp-&gt;w_ns_hl_attr' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>