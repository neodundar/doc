<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>typval.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;stdbool.h&gt;</a>
<a name="ln6">#include &lt;stddef.h&gt;</a>
<a name="ln7">#include &lt;stdio.h&gt;</a>
<a name="ln8">#include &lt;stdlib.h&gt;</a>
<a name="ln9">#include &lt;string.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;lauxlib.h&quot;</a>
<a name="ln12">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln13">#include &quot;nvim/assert.h&quot;</a>
<a name="ln14">#include &quot;nvim/charset.h&quot;</a>
<a name="ln15">#include &quot;nvim/eval.h&quot;</a>
<a name="ln16">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln17">#include &quot;nvim/eval/executor.h&quot;</a>
<a name="ln18">#include &quot;nvim/eval/gc.h&quot;</a>
<a name="ln19">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln20">#include &quot;nvim/eval/typval_encode.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/vars.h&quot;</a>
<a name="ln23">#include &quot;nvim/garray.h&quot;</a>
<a name="ln24">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln25">#include &quot;nvim/globals.h&quot;</a>
<a name="ln26">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln27">#include &quot;nvim/lib/queue.h&quot;</a>
<a name="ln28">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln29">#include &quot;nvim/macros.h&quot;</a>
<a name="ln30">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln31">#include &quot;nvim/memory.h&quot;</a>
<a name="ln32">#include &quot;nvim/message.h&quot;</a>
<a name="ln33">#include &quot;nvim/os/fileio.h&quot;</a>
<a name="ln34">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln35">#include &quot;nvim/pos.h&quot;</a>
<a name="ln36">#include &quot;nvim/types.h&quot;</a>
<a name="ln37">#include &quot;nvim/vim.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln40"># include &quot;eval/typval.c.generated.h&quot;</a>
<a name="ln41">#endif</a>
<a name="ln42"> </a>
<a name="ln43">static char e_string_required_for_argument_nr[]</a>
<a name="ln44">  = N_(&quot;E1174: String required for argument %d&quot;);</a>
<a name="ln45">static char e_non_empty_string_required_for_argument_nr[]</a>
<a name="ln46">  = N_(&quot;E1142: Non-empty string required for argument %d&quot;);</a>
<a name="ln47">static char e_number_required_for_argument_nr[]</a>
<a name="ln48">  = N_(&quot;E1210: Number required for argument %d&quot;);</a>
<a name="ln49"> </a>
<a name="ln50">bool tv_in_free_unref_items = false;</a>
<a name="ln51"> </a>
<a name="ln52">// TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead</a>
<a name="ln53"> </a>
<a name="ln54">#define DICT_MAXNEST 100</a>
<a name="ln55"> </a>
<a name="ln56">const char *const tv_empty_string = &quot;&quot;;</a>
<a name="ln57"> </a>
<a name="ln58">//{{{1 Lists</a>
<a name="ln59">//{{{2 List log</a>
<a name="ln60">#ifdef LOG_LIST_ACTIONS</a>
<a name="ln61">ListLog *list_log_first = NULL;</a>
<a name="ln62">ListLog *list_log_last = NULL;</a>
<a name="ln63"> </a>
<a name="ln64">/// Write list log to the given file</a>
<a name="ln65">///</a>
<a name="ln66">/// @param[in]  fname  File to write log to. Will be appended to if already</a>
<a name="ln67">///                    present.</a>
<a name="ln68">void list_write_log(const char *const fname)</a>
<a name="ln69">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln70">{</a>
<a name="ln71">  FileDescriptor fp;</a>
<a name="ln72">  const int fo_ret = file_open(&amp;fp, fname, kFileCreate|kFileAppend, 0600);</a>
<a name="ln73">  if (fo_ret != 0) {</a>
<a name="ln74">    semsg(_(&quot;E5142: Failed to open file %s: %s&quot;), fname, os_strerror(fo_ret));</a>
<a name="ln75">    return;</a>
<a name="ln76">  }</a>
<a name="ln77">  for (ListLog *chunk = list_log_first; chunk != NULL;) {</a>
<a name="ln78">    for (size_t i = 0; i &lt; chunk-&gt;size; i++) {</a>
<a name="ln79">      char buf[10 + 1 + ((16 + 3) * 3) + (8 + 2) + 2];</a>
<a name="ln80">      //       act  :     hex  &quot; c:&quot;      len &quot;[]&quot; &quot;\n\0&quot;</a>
<a name="ln81">      const ListLogEntry entry = chunk-&gt;entries[i];</a>
<a name="ln82">      const size_t snp_len = (size_t)snprintf(buf, sizeof(buf),</a>
<a name="ln83">                                              &quot;%-10.10s: l:%016&quot; PRIxPTR &quot;[%08d] 1:%016&quot; PRIxPTR &quot; 2:%016&quot; PRIxPTR</a>
<a name="ln84">                                              &quot;\n&quot;,</a>
<a name="ln85">                                              entry.action, entry.l, entry.len, entry.li1,</a>
<a name="ln86">                                              entry.li2);</a>
<a name="ln87">      assert(snp_len + 1 == sizeof(buf));</a>
<a name="ln88">      const ptrdiff_t fw_ret = file_write(&amp;fp, buf, snp_len);</a>
<a name="ln89">      if (fw_ret != (ptrdiff_t)snp_len) {</a>
<a name="ln90">        assert(fw_ret &lt; 0);</a>
<a name="ln91">        if (i) {</a>
<a name="ln92">          memmove(chunk-&gt;entries, chunk-&gt;entries + i,</a>
<a name="ln93">                  sizeof(chunk-&gt;entries[0]) * (chunk-&gt;size - i));</a>
<a name="ln94">          chunk-&gt;size -= i;</a>
<a name="ln95">        }</a>
<a name="ln96">        semsg(_(&quot;E5143: Failed to write to file %s: %s&quot;),</a>
<a name="ln97">              fname, os_strerror((int)fw_ret));</a>
<a name="ln98">        return;</a>
<a name="ln99">      }</a>
<a name="ln100">    }</a>
<a name="ln101">    list_log_first = chunk-&gt;next;</a>
<a name="ln102">    xfree(chunk);</a>
<a name="ln103">    chunk = list_log_first;</a>
<a name="ln104">  }</a>
<a name="ln105">  const int fc_ret = file_close(&amp;fp, true);</a>
<a name="ln106">  if (fc_ret != 0) {</a>
<a name="ln107">    semsg(_(&quot;E5144: Failed to close file %s: %s&quot;), fname, os_strerror(fc_ret));</a>
<a name="ln108">  }</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111"># ifdef EXITFREE</a>
<a name="ln112">/// Free list log</a>
<a name="ln113">void list_free_log(void)</a>
<a name="ln114">{</a>
<a name="ln115">  for (ListLog *chunk = list_log_first; chunk != NULL;) {</a>
<a name="ln116">    list_log_first = chunk-&gt;next;</a>
<a name="ln117">    xfree(chunk);</a>
<a name="ln118">    chunk = list_log_first;</a>
<a name="ln119">  }</a>
<a name="ln120">}</a>
<a name="ln121"># endif</a>
<a name="ln122">#endif</a>
<a name="ln123">//{{{2 List item</a>
<a name="ln124"> </a>
<a name="ln125">/// Allocate a list item</a>
<a name="ln126">///</a>
<a name="ln127">/// @warning Allocated item is not initialized, do not forget to initialize it</a>
<a name="ln128">///          and specifically set lv_lock.</a>
<a name="ln129">///</a>
<a name="ln130">/// @return [allocated] new list item.</a>
<a name="ln131">static listitem_T *tv_list_item_alloc(void)</a>
<a name="ln132">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC</a>
<a name="ln133">{</a>
<a name="ln134">  return xmalloc(sizeof(listitem_T));</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">/// Remove a list item from a List and free it</a>
<a name="ln138">///</a>
<a name="ln139">/// Also clears the value.</a>
<a name="ln140">///</a>
<a name="ln141">/// @param[out]  l  List to remove item from.</a>
<a name="ln142">/// @param[in,out]  item  Item to remove.</a>
<a name="ln143">///</a>
<a name="ln144">/// @return Pointer to the list item just after removed one, NULL if removed</a>
<a name="ln145">///         item was the last one.</a>
<a name="ln146">listitem_T *tv_list_item_remove(list_T *const l, listitem_T *const item)</a>
<a name="ln147">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln148">{</a>
<a name="ln149">  listitem_T *const next_item = TV_LIST_ITEM_NEXT(l, item);</a>
<a name="ln150">  tv_list_drop_items(l, item, item);</a>
<a name="ln151">  tv_clear(TV_LIST_ITEM_TV(item));</a>
<a name="ln152">  xfree(item);</a>
<a name="ln153">  return next_item;</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">//{{{2 List watchers</a>
<a name="ln157"> </a>
<a name="ln158">/// Add a watcher to a list</a>
<a name="ln159">///</a>
<a name="ln160">/// @param[out]  l  List to add watcher to.</a>
<a name="ln161">/// @param[in]  lw  Watcher to add.</a>
<a name="ln162">void tv_list_watch_add(list_T *const l, listwatch_T *const lw)</a>
<a name="ln163">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln164">{</a>
<a name="ln165">  lw-&gt;lw_next = l-&gt;lv_watch;</a>
<a name="ln166">  l-&gt;lv_watch = lw;</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">/// Remove a watcher from a list</a>
<a name="ln170">///</a>
<a name="ln171">/// Does not give a warning if watcher was not found.</a>
<a name="ln172">///</a>
<a name="ln173">/// @param[out]  l  List to remove watcher from.</a>
<a name="ln174">/// @param[in]  lwrem  Watcher to remove.</a>
<a name="ln175">void tv_list_watch_remove(list_T *const l, listwatch_T *const lwrem)</a>
<a name="ln176">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln177">{</a>
<a name="ln178">  listwatch_T **lwp = &amp;l-&gt;lv_watch;</a>
<a name="ln179">  for (listwatch_T *lw = l-&gt;lv_watch; lw != NULL; lw = lw-&gt;lw_next) {</a>
<a name="ln180">    if (lw == lwrem) {</a>
<a name="ln181">      *lwp = lw-&gt;lw_next;</a>
<a name="ln182">      break;</a>
<a name="ln183">    }</a>
<a name="ln184">    lwp = &amp;lw-&gt;lw_next;</a>
<a name="ln185">  }</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">/// Advance watchers to the next item</a>
<a name="ln189">///</a>
<a name="ln190">/// Used just before removing an item from a list.</a>
<a name="ln191">///</a>
<a name="ln192">/// @param[out]  l  List from which item is removed.</a>
<a name="ln193">/// @param[in]  item  List item being removed.</a>
<a name="ln194">void tv_list_watch_fix(list_T *const l, const listitem_T *const item)</a>
<a name="ln195">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln196">{</a>
<a name="ln197">  for (listwatch_T *lw = l-&gt;lv_watch; lw != NULL; lw = lw-&gt;lw_next) {</a>
<a name="ln198">    if (lw-&gt;lw_item == item) {</a>
<a name="ln199">      lw-&gt;lw_item = item-&gt;li_next;</a>
<a name="ln200">    }</a>
<a name="ln201">  }</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">//{{{2 Alloc/free</a>
<a name="ln205"> </a>
<a name="ln206">/// Allocate an empty list</a>
<a name="ln207">///</a>
<a name="ln208">/// Caller should take care of the reference count.</a>
<a name="ln209">///</a>
<a name="ln210">/// @param[in]  len  Expected number of items to be populated before list</a>
<a name="ln211">///                  becomes accessible from VimL. It is still valid to</a>
<a name="ln212">///                  underpopulate a list, value only controls how many elements</a>
<a name="ln213">///                  will be allocated in advance. Currently does nothing.</a>
<a name="ln214">///                  @see ListLenSpecials.</a>
<a name="ln215">///</a>
<a name="ln216">/// @return [allocated] new list.</a>
<a name="ln217">list_T *tv_list_alloc(const ptrdiff_t len)</a>
<a name="ln218">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln219">{</a>
<a name="ln220">  list_T *const list = xcalloc(1, sizeof(list_T));</a>
<a name="ln221"> </a>
<a name="ln222">  // Prepend the list to the list of lists for garbage collection.</a>
<a name="ln223">  if (gc_first_list != NULL) {</a>
<a name="ln224">    gc_first_list-&gt;lv_used_prev = list;</a>
<a name="ln225">  }</a>
<a name="ln226">  list-&gt;lv_used_prev = NULL;</a>
<a name="ln227">  list-&gt;lv_used_next = gc_first_list;</a>
<a name="ln228">  gc_first_list = list;</a>
<a name="ln229">  list_log(list, NULL, (void *)(uintptr_t)len, &quot;alloc&quot;);</a>
<a name="ln230">  list-&gt;lua_table_ref = LUA_NOREF;</a>
<a name="ln231">  return list;</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234">/// Initialize a static list with 10 items</a>
<a name="ln235">///</a>
<a name="ln236">/// @param[out]  sl  Static list to initialize.</a>
<a name="ln237">void tv_list_init_static10(staticList10_T *const sl)</a>
<a name="ln238">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln239">{</a>
<a name="ln240">#define SL_SIZE ARRAY_SIZE(sl-&gt;sl_items)</a>
<a name="ln241">  list_T *const l = &amp;sl-&gt;sl_list;</a>
<a name="ln242"> </a>
<a name="ln243">  CLEAR_POINTER(sl);</a>
<a name="ln244">  l-&gt;lv_first = &amp;sl-&gt;sl_items[0];</a>
<a name="ln245">  l-&gt;lv_last = &amp;sl-&gt;sl_items[SL_SIZE - 1];</a>
<a name="ln246">  l-&gt;lv_refcount = DO_NOT_FREE_CNT;</a>
<a name="ln247">  tv_list_set_lock(l, VAR_FIXED);</a>
<a name="ln248">  sl-&gt;sl_list.lv_len = 10;</a>
<a name="ln249"> </a>
<a name="ln250">  sl-&gt;sl_items[0].li_prev = NULL;</a>
<a name="ln251">  sl-&gt;sl_items[0].li_next = &amp;sl-&gt;sl_items[1];</a>
<a name="ln252">  sl-&gt;sl_items[SL_SIZE - 1].li_prev = &amp;sl-&gt;sl_items[SL_SIZE - 2];</a>
<a name="ln253">  sl-&gt;sl_items[SL_SIZE - 1].li_next = NULL;</a>
<a name="ln254"> </a>
<a name="ln255">  for (size_t i = 1; i &lt; SL_SIZE - 1; i++) {</a>
<a name="ln256">    listitem_T *const li = &amp;sl-&gt;sl_items[i];</a>
<a name="ln257">    li-&gt;li_prev = li - 1;</a>
<a name="ln258">    li-&gt;li_next = li + 1;</a>
<a name="ln259">  }</a>
<a name="ln260">  list_log((const list_T *)sl, &amp;sl-&gt;sl_items[0], &amp;sl-&gt;sl_items[SL_SIZE - 1],</a>
<a name="ln261">           &quot;s10init&quot;);</a>
<a name="ln262">#undef SL_SIZE</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">/// Initialize static list with undefined number of elements</a>
<a name="ln266">///</a>
<a name="ln267">/// @param[out]  l  List to initialize.</a>
<a name="ln268">void tv_list_init_static(list_T *const l)</a>
<a name="ln269">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln270">{</a>
<a name="ln271">  CLEAR_POINTER(l);</a>
<a name="ln272">  l-&gt;lv_refcount = DO_NOT_FREE_CNT;</a>
<a name="ln273">  list_log(l, NULL, NULL, &quot;sinit&quot;);</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">/// Free items contained in a list</a>
<a name="ln277">///</a>
<a name="ln278">/// @param[in,out]  l  List to clear.</a>
<a name="ln279">void tv_list_free_contents(list_T *const l)</a>
<a name="ln280">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln281">{</a>
<a name="ln282">  list_log(l, NULL, NULL, &quot;freecont&quot;);</a>
<a name="ln283">  for (listitem_T *item = l-&gt;lv_first; item != NULL; item = l-&gt;lv_first) {</a>
<a name="ln284">    // Remove the item before deleting it.</a>
<a name="ln285">    l-&gt;lv_first = item-&gt;li_next;</a>
<a name="ln286">    tv_clear(&amp;item-&gt;li_tv);</a>
<a name="ln287">    xfree(item);</a>
<a name="ln288">  }</a>
<a name="ln289">  l-&gt;lv_len = 0;</a>
<a name="ln290">  l-&gt;lv_idx_item = NULL;</a>
<a name="ln291">  l-&gt;lv_last = NULL;</a>
<a name="ln292">  assert(l-&gt;lv_watch == NULL);</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295">/// Free a list itself, ignoring items it contains</a>
<a name="ln296">///</a>
<a name="ln297">/// Ignores the reference count.</a>
<a name="ln298">///</a>
<a name="ln299">/// @param[in,out]  l  List to free.</a>
<a name="ln300">void tv_list_free_list(list_T *const l)</a>
<a name="ln301">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln302">{</a>
<a name="ln303">  // Remove the list from the list of lists for garbage collection.</a>
<a name="ln304">  if (l-&gt;lv_used_prev == NULL) {</a>
<a name="ln305">    gc_first_list = l-&gt;lv_used_next;</a>
<a name="ln306">  } else {</a>
<a name="ln307">    l-&gt;lv_used_prev-&gt;lv_used_next = l-&gt;lv_used_next;</a>
<a name="ln308">  }</a>
<a name="ln309">  if (l-&gt;lv_used_next != NULL) {</a>
<a name="ln310">    l-&gt;lv_used_next-&gt;lv_used_prev = l-&gt;lv_used_prev;</a>
<a name="ln311">  }</a>
<a name="ln312">  list_log(l, NULL, NULL, &quot;freelist&quot;);</a>
<a name="ln313"> </a>
<a name="ln314">  NLUA_CLEAR_REF(l-&gt;lua_table_ref);</a>
<a name="ln315">  xfree(l);</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">/// Free a list, including all items it points to</a>
<a name="ln319">///</a>
<a name="ln320">/// Ignores the reference count. Does not do anything if</a>
<a name="ln321">/// tv_in_free_unref_items is true.</a>
<a name="ln322">///</a>
<a name="ln323">/// @param[in,out]  l  List to free.</a>
<a name="ln324">void tv_list_free(list_T *const l)</a>
<a name="ln325">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln326">{</a>
<a name="ln327">  if (!tv_in_free_unref_items) {</a>
<a name="ln328">    tv_list_free_contents(l);</a>
<a name="ln329">    tv_list_free_list(l);</a>
<a name="ln330">  }</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333">/// Unreference a list</a>
<a name="ln334">///</a>
<a name="ln335">/// Decrements the reference count and frees when it becomes zero or less.</a>
<a name="ln336">///</a>
<a name="ln337">/// @param[in,out]  l  List to unreference.</a>
<a name="ln338">void tv_list_unref(list_T *const l)</a>
<a name="ln339">{</a>
<a name="ln340">  if (l != NULL &amp;&amp; --l-&gt;lv_refcount &lt;= 0) {</a>
<a name="ln341">    tv_list_free(l);</a>
<a name="ln342">  }</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">//{{{2 Add/remove</a>
<a name="ln346"> </a>
<a name="ln347">/// Remove items &quot;item&quot; to &quot;item2&quot; from list &quot;l&quot;</a>
<a name="ln348">///</a>
<a name="ln349">/// @warning Does not free the listitem or the value!</a>
<a name="ln350">///</a>
<a name="ln351">/// @param[out]  l  List to remove from.</a>
<a name="ln352">/// @param[in]  item  First item to remove.</a>
<a name="ln353">/// @param[in]  item2  Last item to remove.</a>
<a name="ln354">void tv_list_drop_items(list_T *const l, listitem_T *const item, listitem_T *const item2)</a>
<a name="ln355">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln356">{</a>
<a name="ln357">  list_log(l, item, item2, &quot;drop&quot;);</a>
<a name="ln358">  // Notify watchers.</a>
<a name="ln359">  for (listitem_T *ip = item; ip != item2-&gt;li_next; ip = ip-&gt;li_next) {</a>
<a name="ln360">    l-&gt;lv_len--;</a>
<a name="ln361">    tv_list_watch_fix(l, ip);</a>
<a name="ln362">  }</a>
<a name="ln363"> </a>
<a name="ln364">  if (item2-&gt;li_next == NULL) {</a>
<a name="ln365">    l-&gt;lv_last = item-&gt;li_prev;</a>
<a name="ln366">  } else {</a>
<a name="ln367">    item2-&gt;li_next-&gt;li_prev = item-&gt;li_prev;</a>
<a name="ln368">  }</a>
<a name="ln369">  if (item-&gt;li_prev == NULL) {</a>
<a name="ln370">    l-&gt;lv_first = item2-&gt;li_next;</a>
<a name="ln371">  } else {</a>
<a name="ln372">    item-&gt;li_prev-&gt;li_next = item2-&gt;li_next;</a>
<a name="ln373">  }</a>
<a name="ln374">  l-&gt;lv_idx_item = NULL;</a>
<a name="ln375">  list_log(l, l-&gt;lv_first, l-&gt;lv_last, &quot;afterdrop&quot;);</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">/// Like tv_list_drop_items, but also frees all removed items</a>
<a name="ln379">void tv_list_remove_items(list_T *const l, listitem_T *const item, listitem_T *const item2)</a>
<a name="ln380">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln381">{</a>
<a name="ln382">  list_log(l, item, item2, &quot;remove&quot;);</a>
<a name="ln383">  tv_list_drop_items(l, item, item2);</a>
<a name="ln384">  for (listitem_T *li = item;;) {</a>
<a name="ln385">    tv_clear(TV_LIST_ITEM_TV(li));</a>
<a name="ln386">    listitem_T *const nli = li-&gt;li_next;</a>
<a name="ln387">    xfree(li);</a>
<a name="ln388">    if (li == item2) {</a>
<a name="ln389">      break;</a>
<a name="ln390">    }</a>
<a name="ln391">    li = nli;</a>
<a name="ln392">  }</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">/// Move items &quot;item&quot; to &quot;item2&quot; from list &quot;l&quot; to the end of the list &quot;tgt_l&quot;</a>
<a name="ln396">///</a>
<a name="ln397">/// @param[out]  l  List to move from.</a>
<a name="ln398">/// @param[in]  item  First item to move.</a>
<a name="ln399">/// @param[in]  item2  Last item to move.</a>
<a name="ln400">/// @param[out]  tgt_l  List to move to.</a>
<a name="ln401">/// @param[in]  cnt  Number of items moved.</a>
<a name="ln402">void tv_list_move_items(list_T *const l, listitem_T *const item, listitem_T *const item2,</a>
<a name="ln403">                        list_T *const tgt_l, const int cnt)</a>
<a name="ln404">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln405">{</a>
<a name="ln406">  list_log(l, item, item2, &quot;move&quot;);</a>
<a name="ln407">  tv_list_drop_items(l, item, item2);</a>
<a name="ln408">  item-&gt;li_prev = tgt_l-&gt;lv_last;</a>
<a name="ln409">  item2-&gt;li_next = NULL;</a>
<a name="ln410">  if (tgt_l-&gt;lv_last == NULL) {</a>
<a name="ln411">    tgt_l-&gt;lv_first = item;</a>
<a name="ln412">  } else {</a>
<a name="ln413">    tgt_l-&gt;lv_last-&gt;li_next = item;</a>
<a name="ln414">  }</a>
<a name="ln415">  tgt_l-&gt;lv_last = item2;</a>
<a name="ln416">  tgt_l-&gt;lv_len += cnt;</a>
<a name="ln417">  list_log(tgt_l, tgt_l-&gt;lv_first, tgt_l-&gt;lv_last, &quot;movetgt&quot;);</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">/// Insert list item</a>
<a name="ln421">///</a>
<a name="ln422">/// @param[out]  l  List to insert to.</a>
<a name="ln423">/// @param[in,out]  ni  Item to insert.</a>
<a name="ln424">/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the</a>
<a name="ln425">///                   list.</a>
<a name="ln426">void tv_list_insert(list_T *const l, listitem_T *const ni, listitem_T *const item)</a>
<a name="ln427">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln428">{</a>
<a name="ln429">  if (item == NULL) {</a>
<a name="ln430">    // Append new item at end of list.</a>
<a name="ln431">    tv_list_append(l, ni);</a>
<a name="ln432">  } else {</a>
<a name="ln433">    // Insert new item before existing item.</a>
<a name="ln434">    ni-&gt;li_prev = item-&gt;li_prev;</a>
<a name="ln435">    ni-&gt;li_next = item;</a>
<a name="ln436">    if (item-&gt;li_prev == NULL) {</a>
<a name="ln437">      l-&gt;lv_first = ni;</a>
<a name="ln438">      l-&gt;lv_idx++;</a>
<a name="ln439">    } else {</a>
<a name="ln440">      item-&gt;li_prev-&gt;li_next = ni;</a>
<a name="ln441">      l-&gt;lv_idx_item = NULL;</a>
<a name="ln442">    }</a>
<a name="ln443">    item-&gt;li_prev = ni;</a>
<a name="ln444">    l-&gt;lv_len++;</a>
<a name="ln445">    list_log(l, ni, item, &quot;insert&quot;);</a>
<a name="ln446">  }</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">/// Insert VimL value into a list</a>
<a name="ln450">///</a>
<a name="ln451">/// @param[out]  l  List to insert to.</a>
<a name="ln452">/// @param[in,out]  tv  Value to insert. Is copied (@see tv_copy()) to an</a>
<a name="ln453">///                     allocated listitem_T and inserted.</a>
<a name="ln454">/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the</a>
<a name="ln455">///                   list.</a>
<a name="ln456">void tv_list_insert_tv(list_T *const l, typval_T *const tv, listitem_T *const item)</a>
<a name="ln457">{</a>
<a name="ln458">  listitem_T *const ni = tv_list_item_alloc();</a>
<a name="ln459"> </a>
<a name="ln460">  tv_copy(tv, &amp;ni-&gt;li_tv);</a>
<a name="ln461">  tv_list_insert(l, ni, item);</a>
<a name="ln462">}</a>
<a name="ln463"> </a>
<a name="ln464">/// Append item to the end of list</a>
<a name="ln465">///</a>
<a name="ln466">/// @param[out]  l  List to append to.</a>
<a name="ln467">/// @param[in,out]  item  Item to append.</a>
<a name="ln468">void tv_list_append(list_T *const l, listitem_T *const item)</a>
<a name="ln469">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln470">{</a>
<a name="ln471">  list_log(l, item, NULL, &quot;append&quot;);</a>
<a name="ln472">  if (l-&gt;lv_last == NULL) {</a>
<a name="ln473">    // empty list</a>
<a name="ln474">    l-&gt;lv_first = item;</a>
<a name="ln475">    l-&gt;lv_last = item;</a>
<a name="ln476">    item-&gt;li_prev = NULL;</a>
<a name="ln477">  } else {</a>
<a name="ln478">    l-&gt;lv_last-&gt;li_next = item;</a>
<a name="ln479">    item-&gt;li_prev = l-&gt;lv_last;</a>
<a name="ln480">    l-&gt;lv_last = item;</a>
<a name="ln481">  }</a>
<a name="ln482">  l-&gt;lv_len++;</a>
<a name="ln483">  item-&gt;li_next = NULL;</a>
<a name="ln484">}</a>
<a name="ln485"> </a>
<a name="ln486">/// Append VimL value to the end of list</a>
<a name="ln487">///</a>
<a name="ln488">/// @param[out]  l  List to append to.</a>
<a name="ln489">/// @param[in,out]  tv  Value to append. Is copied (@see tv_copy()) to an</a>
<a name="ln490">///                     allocated listitem_T.</a>
<a name="ln491">void tv_list_append_tv(list_T *const l, typval_T *const tv)</a>
<a name="ln492">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln493">{</a>
<a name="ln494">  listitem_T *const li = tv_list_item_alloc();</a>
<a name="ln495">  tv_copy(tv, TV_LIST_ITEM_TV(li));</a>
<a name="ln496">  tv_list_append(l, li);</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">/// Like tv_list_append_tv(), but tv is moved to a list</a>
<a name="ln500">///</a>
<a name="ln501">/// This means that it is no longer valid to use contents of the typval_T after</a>
<a name="ln502">/// function exits.</a>
<a name="ln503">void tv_list_append_owned_tv(list_T *const l, typval_T tv)</a>
<a name="ln504">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln505">{</a>
<a name="ln506">  listitem_T *const li = tv_list_item_alloc();</a>
<a name="ln507">  *TV_LIST_ITEM_TV(li) = tv;</a>
<a name="ln508">  tv_list_append(l, li);</a>
<a name="ln509">}</a>
<a name="ln510"> </a>
<a name="ln511">/// Append a list to a list as one item</a>
<a name="ln512">///</a>
<a name="ln513">/// @param[out]  l  List to append to.</a>
<a name="ln514">/// @param[in,out]  itemlist  List to append. Reference count is increased.</a>
<a name="ln515">void tv_list_append_list(list_T *const l, list_T *const itemlist)</a>
<a name="ln516">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln517">{</a>
<a name="ln518">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln519">    .v_type = VAR_LIST,</a>
<a name="ln520">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln521">    .vval.v_list = itemlist,</a>
<a name="ln522">  });</a>
<a name="ln523">  tv_list_ref(itemlist);</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526">/// Append a dictionary to a list</a>
<a name="ln527">///</a>
<a name="ln528">/// @param[out]  l  List to append to.</a>
<a name="ln529">/// @param[in,out]  dict  Dictionary to append. Reference count is increased.</a>
<a name="ln530">void tv_list_append_dict(list_T *const l, dict_T *const dict)</a>
<a name="ln531">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln532">{</a>
<a name="ln533">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln534">    .v_type = VAR_DICT,</a>
<a name="ln535">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln536">    .vval.v_dict = dict,</a>
<a name="ln537">  });</a>
<a name="ln538">  if (dict != NULL) {</a>
<a name="ln539">    dict-&gt;dv_refcount++;</a>
<a name="ln540">  }</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543">/// Make a copy of &quot;str&quot; and append it as an item to list &quot;l&quot;</a>
<a name="ln544">///</a>
<a name="ln545">/// @param[out]  l  List to append to.</a>
<a name="ln546">/// @param[in]  str  String to append.</a>
<a name="ln547">/// @param[in]  len  Length of the appended string. May be -1, in this</a>
<a name="ln548">///                  case string is considered to be usual zero-terminated</a>
<a name="ln549">///                  string or NULL “empty” string.</a>
<a name="ln550">void tv_list_append_string(list_T *const l, const char *const str, const ssize_t len)</a>
<a name="ln551">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln552">{</a>
<a name="ln553">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln554">    .v_type = VAR_STRING,</a>
<a name="ln555">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln556">    .vval.v_string = (str == NULL</a>
<a name="ln557">                      ? NULL</a>
<a name="ln558">                      : (len &gt;= 0</a>
<a name="ln559">                         ? xmemdupz(str, (size_t)len)</a>
<a name="ln560">                         : xstrdup(str))),</a>
<a name="ln561">  });</a>
<a name="ln562">}</a>
<a name="ln563"> </a>
<a name="ln564">/// Append given string to the list</a>
<a name="ln565">///</a>
<a name="ln566">/// Unlike list_append_string this function does not copy the string.</a>
<a name="ln567">///</a>
<a name="ln568">/// @param[out]  l    List to append to.</a>
<a name="ln569">/// @param[in]   str  String to append.</a>
<a name="ln570">void tv_list_append_allocated_string(list_T *const l, char *const str)</a>
<a name="ln571">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln572">{</a>
<a name="ln573">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln574">    .v_type = VAR_STRING,</a>
<a name="ln575">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln576">    .vval.v_string = str,</a>
<a name="ln577">  });</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">/// Append number to the list</a>
<a name="ln581">///</a>
<a name="ln582">/// @param[out]  l  List to append to.</a>
<a name="ln583">/// @param[in]  n  Number to append. Will be recorded in the allocated</a>
<a name="ln584">///                listitem_T.</a>
<a name="ln585">void tv_list_append_number(list_T *const l, const varnumber_T n)</a>
<a name="ln586">{</a>
<a name="ln587">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln588">    .v_type = VAR_NUMBER,</a>
<a name="ln589">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln590">    .vval.v_number = n,</a>
<a name="ln591">  });</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594">//{{{2 Operations on the whole list</a>
<a name="ln595"> </a>
<a name="ln596">/// Make a copy of list</a>
<a name="ln597">///</a>
<a name="ln598">/// @param[in]  conv  If non-NULL, then all internal strings will be converted.</a>
<a name="ln599">///                   Only used when `deep` is true.</a>
<a name="ln600">/// @param[in]  orig  Original list to copy.</a>
<a name="ln601">/// @param[in]  deep  If false, then shallow copy will be done.</a>
<a name="ln602">/// @param[in]  copyID  See var_item_copy().</a>
<a name="ln603">///</a>
<a name="ln604">/// @return Copied list. May be NULL in case original list is NULL or some</a>
<a name="ln605">///         failure happens. The refcount of the new list is set to 1.</a>
<a name="ln606">list_T *tv_list_copy(const vimconv_T *const conv, list_T *const orig, const bool deep,</a>
<a name="ln607">                     const int copyID)</a>
<a name="ln608">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln609">{</a>
<a name="ln610">  if (orig == NULL) {</a>
<a name="ln611">    return NULL;</a>
<a name="ln612">  }</a>
<a name="ln613"> </a>
<a name="ln614">  list_T *copy = tv_list_alloc(tv_list_len(orig));</a>
<a name="ln615">  tv_list_ref(copy);</a>
<a name="ln616">  if (copyID != 0) {</a>
<a name="ln617">    // Do this before adding the items, because one of the items may</a>
<a name="ln618">    // refer back to this list.</a>
<a name="ln619">    orig-&gt;lv_copyID = copyID;</a>
<a name="ln620">    orig-&gt;lv_copylist = copy;</a>
<a name="ln621">  }</a>
<a name="ln622">  TV_LIST_ITER(orig, item, {</a>
<a name="ln623">    if (got_int) {</a>
<a name="ln624">      break;</a>
<a name="ln625">    }</a>
<a name="ln626">    listitem_T *const ni = tv_list_item_alloc();</a>
<a name="ln627">    if (deep) {</a>
<a name="ln628">      if (var_item_copy(conv, TV_LIST_ITEM_TV(item), TV_LIST_ITEM_TV(ni),</a>
<a name="ln629">                        deep, copyID) == FAIL) {</a>
<a name="ln630">        xfree(ni);</a>
<a name="ln631">        goto tv_list_copy_error;</a>
<a name="ln632">      }</a>
<a name="ln633">    } else {</a>
<a name="ln634">      tv_copy(TV_LIST_ITEM_TV(item), TV_LIST_ITEM_TV(ni));</a>
<a name="ln635">    }</a>
<a name="ln636">    tv_list_append(copy, ni);</a>
<a name="ln637">  });</a>
<a name="ln638"> </a>
<a name="ln639">  return copy;</a>
<a name="ln640"> </a>
<a name="ln641">tv_list_copy_error:</a>
<a name="ln642">  tv_list_unref(copy);</a>
<a name="ln643">  return NULL;</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">/// Flatten &quot;list&quot; in place to depth &quot;maxdepth&quot;.</a>
<a name="ln647">/// Does nothing if &quot;maxdepth&quot; is 0.</a>
<a name="ln648">///</a>
<a name="ln649">/// @param[in,out] list   List to flatten</a>
<a name="ln650">/// @param[in] maxdepth   Maximum depth that will be flattened</a>
<a name="ln651">///</a>
<a name="ln652">/// @return OK or FAIL</a>
<a name="ln653">int tv_list_flatten(list_T *list, long maxdepth)</a>
<a name="ln654">  FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln655">{</a>
<a name="ln656">  listitem_T *item;</a>
<a name="ln657">  listitem_T *to_free;</a>
<a name="ln658">  int n;</a>
<a name="ln659">  if (maxdepth == 0) {</a>
<a name="ln660">    return OK;</a>
<a name="ln661">  }</a>
<a name="ln662"> </a>
<a name="ln663">  n = 0;</a>
<a name="ln664">  item = list-&gt;lv_first;</a>
<a name="ln665">  while (item != NULL) {</a>
<a name="ln666">    fast_breakcheck();</a>
<a name="ln667">    if (got_int) {</a>
<a name="ln668">      return FAIL;</a>
<a name="ln669">    }</a>
<a name="ln670">    if (item-&gt;li_tv.v_type == VAR_LIST) {</a>
<a name="ln671">      listitem_T *next = item-&gt;li_next;</a>
<a name="ln672"> </a>
<a name="ln673">      tv_list_drop_items(list, item, item);</a>
<a name="ln674">      tv_list_extend(list, item-&gt;li_tv.vval.v_list, next);</a>
<a name="ln675">      tv_clear(&amp;item-&gt;li_tv);</a>
<a name="ln676">      to_free = item;</a>
<a name="ln677"> </a>
<a name="ln678">      if (item-&gt;li_prev == NULL) {</a>
<a name="ln679">        item = list-&gt;lv_first;</a>
<a name="ln680">      } else {</a>
<a name="ln681">        item = item-&gt;li_prev-&gt;li_next;</a>
<a name="ln682">      }</a>
<a name="ln683">      xfree(to_free);</a>
<a name="ln684"> </a>
<a name="ln685">      if (++n &gt;= maxdepth) {</a>
<a name="ln686">        n = 0;</a>
<a name="ln687">        item = next;</a>
<a name="ln688">      }</a>
<a name="ln689">    } else {</a>
<a name="ln690">      n = 0;</a>
<a name="ln691">      item = item-&gt;li_next;</a>
<a name="ln692">    }</a>
<a name="ln693">  }</a>
<a name="ln694">  return OK;</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">/// Extend first list with the second</a>
<a name="ln698">///</a>
<a name="ln699">/// @param[out]  l1  List to extend.</a>
<a name="ln700">/// @param[in]  l2  List to extend with.</a>
<a name="ln701">/// @param[in]  bef  If not NULL, extends before this item.</a>
<a name="ln702">void tv_list_extend(list_T *const l1, list_T *const l2, listitem_T *const bef)</a>
<a name="ln703">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln704">{</a>
<a name="ln705">  int todo = tv_list_len(l2);</a>
<a name="ln706">  listitem_T *const befbef = (bef == NULL ? NULL : bef-&gt;li_prev);</a>
<a name="ln707">  listitem_T *const saved_next = (befbef == NULL ? NULL : befbef-&gt;li_next);</a>
<a name="ln708">  // We also quit the loop when we have inserted the original item count of</a>
<a name="ln709">  // the list, avoid a hang when we extend a list with itself.</a>
<a name="ln710">  for (listitem_T *item = tv_list_first(l2)</a>
<a name="ln711">       ; item != NULL &amp;&amp; todo--</a>
<a name="ln712">       ; item = (item == befbef ? saved_next : item-&gt;li_next)) {</a>
<a name="ln713">    tv_list_insert_tv(l1, TV_LIST_ITEM_TV(item), bef);</a>
<a name="ln714">  }</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717">/// Concatenate lists into a new list</a>
<a name="ln718">///</a>
<a name="ln719">/// @param[in]  l1  First list.</a>
<a name="ln720">/// @param[in]  l2  Second list.</a>
<a name="ln721">/// @param[out]  ret_tv  Location where new list is saved.</a>
<a name="ln722">///</a>
<a name="ln723">/// @return OK or FAIL.</a>
<a name="ln724">int tv_list_concat(list_T *const l1, list_T *const l2, typval_T *const tv)</a>
<a name="ln725">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln726">{</a>
<a name="ln727">  list_T *l;</a>
<a name="ln728"> </a>
<a name="ln729">  tv-&gt;v_type = VAR_LIST;</a>
<a name="ln730">  tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln731">  if (l1 == NULL &amp;&amp; l2 == NULL) {</a>
<a name="ln732">    l = NULL;</a>
<a name="ln733">  } else if (l1 == NULL) {</a>
<a name="ln734">    l = tv_list_copy(NULL, l2, false, 0);</a>
<a name="ln735">  } else {</a>
<a name="ln736">    l = tv_list_copy(NULL, l1, false, 0);</a>
<a name="ln737">    if (l != NULL &amp;&amp; l2 != NULL) {</a>
<a name="ln738">      tv_list_extend(l, l2, NULL);</a>
<a name="ln739">    }</a>
<a name="ln740">  }</a>
<a name="ln741">  if (l == NULL &amp;&amp; !(l1 == NULL &amp;&amp; l2 == NULL)) {</a>
<a name="ln742">    return FAIL;</a>
<a name="ln743">  }</a>
<a name="ln744"> </a>
<a name="ln745">  tv-&gt;vval.v_list = l;</a>
<a name="ln746">  return OK;</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">typedef struct {</a>
<a name="ln750">  char_u *s;</a>
<a name="ln751">  char_u *tofree;</a>
<a name="ln752">} Join;</a>
<a name="ln753"> </a>
<a name="ln754">/// Join list into a string, helper function</a>
<a name="ln755">///</a>
<a name="ln756">/// @param[out]  gap  Garray where result will be saved.</a>
<a name="ln757">/// @param[in]  l  List to join.</a>
<a name="ln758">/// @param[in]  sep  Used separator.</a>
<a name="ln759">/// @param[in]  join_gap  Garray to keep each list item string.</a>
<a name="ln760">///</a>
<a name="ln761">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln762">static int list_join_inner(garray_T *const gap, list_T *const l, const char *const sep,</a>
<a name="ln763">                           garray_T *const join_gap)</a>
<a name="ln764">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln765">{</a>
<a name="ln766">  size_t sumlen = 0;</a>
<a name="ln767">  bool first = true;</a>
<a name="ln768"> </a>
<a name="ln769">  // Stringify each item in the list.</a>
<a name="ln770">  TV_LIST_ITER(l, item, {</a>
<a name="ln771">    if (got_int) {</a>
<a name="ln772">      break;</a>
<a name="ln773">    }</a>
<a name="ln774">    char *s;</a>
<a name="ln775">    size_t len;</a>
<a name="ln776">    s = encode_tv2echo(TV_LIST_ITEM_TV(item), &amp;len);</a>
<a name="ln777">    if (s == NULL) {</a>
<a name="ln778">      return FAIL;</a>
<a name="ln779">    }</a>
<a name="ln780"> </a>
<a name="ln781">    sumlen += len;</a>
<a name="ln782"> </a>
<a name="ln783">    Join *const p = GA_APPEND_VIA_PTR(Join, join_gap);</a>
<a name="ln784">    p-&gt;tofree = p-&gt;s = (char_u *)s;</a>
<a name="ln785"> </a>
<a name="ln786">    line_breakcheck();</a>
<a name="ln787">  });</a>
<a name="ln788"> </a>
<a name="ln789">  // Allocate result buffer with its total size, avoid re-allocation and</a>
<a name="ln790">  // multiple copy operations.  Add 2 for a tailing ']' and NUL.</a>
<a name="ln791">  if (join_gap-&gt;ga_len &gt;= 2) {</a>
<a name="ln792">    sumlen += strlen(sep) * (size_t)(join_gap-&gt;ga_len - 1);</a>
<a name="ln793">  }</a>
<a name="ln794">  ga_grow(gap, (int)sumlen + 2);</a>
<a name="ln795"> </a>
<a name="ln796">  for (int i = 0; i &lt; join_gap-&gt;ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln797">    if (first) {</a>
<a name="ln798">      first = false;</a>
<a name="ln799">    } else {</a>
<a name="ln800">      ga_concat(gap, sep);</a>
<a name="ln801">    }</a>
<a name="ln802">    const Join *const p = ((const Join *)join_gap-&gt;ga_data) + i;</a>
<a name="ln803"> </a>
<a name="ln804">    if (p-&gt;s != NULL) {</a>
<a name="ln805">      ga_concat(gap, (char *)p-&gt;s);</a>
<a name="ln806">    }</a>
<a name="ln807">    line_breakcheck();</a>
<a name="ln808">  }</a>
<a name="ln809"> </a>
<a name="ln810">  return OK;</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">/// Join list into a string using given separator</a>
<a name="ln814">///</a>
<a name="ln815">/// @param[out]  gap  Garray where result will be saved.</a>
<a name="ln816">/// @param[in]  l  Joined list.</a>
<a name="ln817">/// @param[in]  sep  Separator.</a>
<a name="ln818">///</a>
<a name="ln819">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln820">int tv_list_join(garray_T *const gap, list_T *const l, const char *const sep)</a>
<a name="ln821">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln822">{</a>
<a name="ln823">  if (!tv_list_len(l)) {</a>
<a name="ln824">    return OK;</a>
<a name="ln825">  }</a>
<a name="ln826"> </a>
<a name="ln827">  garray_T join_ga;</a>
<a name="ln828">  int retval;</a>
<a name="ln829"> </a>
<a name="ln830">  ga_init(&amp;join_ga, (int)sizeof(Join), tv_list_len(l));</a>
<a name="ln831">  retval = list_join_inner(gap, l, sep, &amp;join_ga);</a>
<a name="ln832"> </a>
<a name="ln833">#define FREE_JOIN_TOFREE(join) xfree((join)-&gt;tofree)</a>
<a name="ln834">  GA_DEEP_CLEAR(&amp;join_ga, Join, FREE_JOIN_TOFREE);</a>
<a name="ln835">#undef FREE_JOIN_TOFREE</a>
<a name="ln836"> </a>
<a name="ln837">  return retval;</a>
<a name="ln838">}</a>
<a name="ln839"> </a>
<a name="ln840">/// &quot;join()&quot; function</a>
<a name="ln841">void f_join(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln842">{</a>
<a name="ln843">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln844">    emsg(_(e_listreq));</a>
<a name="ln845">    return;</a>
<a name="ln846">  }</a>
<a name="ln847">  const char *const sep = (argvars[1].v_type == VAR_UNKNOWN</a>
<a name="ln848">                           ? &quot; &quot;</a>
<a name="ln849">                           : tv_get_string_chk(&amp;argvars[1]));</a>
<a name="ln850"> </a>
<a name="ln851">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln852"> </a>
<a name="ln853">  if (sep != NULL) {</a>
<a name="ln854">    garray_T ga;</a>
<a name="ln855">    ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln856">    tv_list_join(&amp;ga, argvars[0].vval.v_list, sep);</a>
<a name="ln857">    ga_append(&amp;ga, NUL);</a>
<a name="ln858">    rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln859">  } else {</a>
<a name="ln860">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln861">  }</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864">/// &quot;list2str()&quot; function</a>
<a name="ln865">void f_list2str(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln866">{</a>
<a name="ln867">  garray_T ga;</a>
<a name="ln868"> </a>
<a name="ln869">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln870">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln871">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln872">    emsg(_(e_invarg));</a>
<a name="ln873">    return;</a>
<a name="ln874">  }</a>
<a name="ln875"> </a>
<a name="ln876">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln877">  if (l == NULL) {</a>
<a name="ln878">    return;  // empty list results in empty string</a>
<a name="ln879">  }</a>
<a name="ln880"> </a>
<a name="ln881">  ga_init(&amp;ga, 1, 80);</a>
<a name="ln882">  char buf[MB_MAXBYTES + 1];</a>
<a name="ln883"> </a>
<a name="ln884">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln885">    buf[utf_char2bytes((int)tv_get_number(TV_LIST_ITEM_TV(li)), (char *)buf)] = NUL;</a>
<a name="ln886">    ga_concat(&amp;ga, (char *)buf);</a>
<a name="ln887">  });</a>
<a name="ln888">  ga_append(&amp;ga, NUL);</a>
<a name="ln889"> </a>
<a name="ln890">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln891">}</a>
<a name="ln892"> </a>
<a name="ln893">/// &quot;remove({list})&quot; function</a>
<a name="ln894">void tv_list_remove(typval_T *argvars, typval_T *rettv, const char *arg_errmsg)</a>
<a name="ln895">{</a>
<a name="ln896">  list_T *l;</a>
<a name="ln897">  bool error = false;</a>
<a name="ln898"> </a>
<a name="ln899">  if (var_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln900">                     arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln901">    return;</a>
<a name="ln902">  }</a>
<a name="ln903"> </a>
<a name="ln904">  long idx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln905"> </a>
<a name="ln906">  listitem_T *item;</a>
<a name="ln907"> </a>
<a name="ln908">  if (error) {</a>
<a name="ln909">    // Type error: do nothing, errmsg already given.</a>
<a name="ln910">  } else if ((item = tv_list_find(l, (int)idx)) == NULL) {</a>
<a name="ln911">    semsg(_(e_listidx), (int64_t)idx);</a>
<a name="ln912">  } else {</a>
<a name="ln913">    if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln914">      // Remove one item, return its value.</a>
<a name="ln915">      tv_list_drop_items(l, item, item);</a>
<a name="ln916">      *rettv = *TV_LIST_ITEM_TV(item);</a>
<a name="ln917">      xfree(item);</a>
<a name="ln918">    } else {</a>
<a name="ln919">      listitem_T *item2;</a>
<a name="ln920">      // Remove range of items, return list with values.</a>
<a name="ln921">      long end = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln922">      if (error) {</a>
<a name="ln923">        // Type error: do nothing.</a>
<a name="ln924">      } else if ((item2 = tv_list_find(l, (int)end)) == NULL) {</a>
<a name="ln925">        semsg(_(e_listidx), (int64_t)end);</a>
<a name="ln926">      } else {</a>
<a name="ln927">        int cnt = 0;</a>
<a name="ln928"> </a>
<a name="ln929">        listitem_T *li;</a>
<a name="ln930">        for (li = item; li != NULL; li = TV_LIST_ITEM_NEXT(l, li)) {</a>
<a name="ln931">          cnt++;</a>
<a name="ln932">          if (li == item2) {</a>
<a name="ln933">            break;</a>
<a name="ln934">          }</a>
<a name="ln935">        }</a>
<a name="ln936">        if (li == NULL) {  // Didn't find &quot;item2&quot; after &quot;item&quot;.</a>
<a name="ln937">          emsg(_(e_invrange));</a>
<a name="ln938">        } else {</a>
<a name="ln939">          tv_list_move_items(l, item, item2, tv_list_alloc_ret(rettv, cnt),</a>
<a name="ln940">                             cnt);</a>
<a name="ln941">        }</a>
<a name="ln942">      }</a>
<a name="ln943">    }</a>
<a name="ln944">  }</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">/// struct storing information about current sort</a>
<a name="ln948">typedef struct {</a>
<a name="ln949">  int item_compare_ic;</a>
<a name="ln950">  bool item_compare_lc;</a>
<a name="ln951">  bool item_compare_numeric;</a>
<a name="ln952">  bool item_compare_numbers;</a>
<a name="ln953">  bool item_compare_float;</a>
<a name="ln954">  const char *item_compare_func;</a>
<a name="ln955">  partial_T *item_compare_partial;</a>
<a name="ln956">  dict_T *item_compare_selfdict;</a>
<a name="ln957">  bool item_compare_func_err;</a>
<a name="ln958">} sortinfo_T;</a>
<a name="ln959">static sortinfo_T *sortinfo = NULL;</a>
<a name="ln960"> </a>
<a name="ln961">#define ITEM_COMPARE_FAIL 999</a>
<a name="ln962"> </a>
<a name="ln963">/// Compare functions for f_sort() and f_uniq() below.</a>
<a name="ln964">static int item_compare(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln965">{</a>
<a name="ln966">  ListSortItem *const si1 = (ListSortItem *)s1;</a>
<a name="ln967">  ListSortItem *const si2 = (ListSortItem *)s2;</a>
<a name="ln968"> </a>
<a name="ln969">  typval_T *const tv1 = TV_LIST_ITEM_TV(si1-&gt;item);</a>
<a name="ln970">  typval_T *const tv2 = TV_LIST_ITEM_TV(si2-&gt;item);</a>
<a name="ln971"> </a>
<a name="ln972">  int res;</a>
<a name="ln973"> </a>
<a name="ln974">  if (sortinfo-&gt;item_compare_numbers) {</a>
<a name="ln975">    const varnumber_T v1 = tv_get_number(tv1);</a>
<a name="ln976">    const varnumber_T v2 = tv_get_number(tv2);</a>
<a name="ln977"> </a>
<a name="ln978">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln979">    goto item_compare_end;</a>
<a name="ln980">  }</a>
<a name="ln981"> </a>
<a name="ln982">  if (sortinfo-&gt;item_compare_float) {</a>
<a name="ln983">    const float_T v1 = tv_get_float(tv1);</a>
<a name="ln984">    const float_T v2 = tv_get_float(tv2);</a>
<a name="ln985"> </a>
<a name="ln986">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln987">    goto item_compare_end;</a>
<a name="ln988">  }</a>
<a name="ln989"> </a>
<a name="ln990">  char *tofree1 = NULL;</a>
<a name="ln991">  char *tofree2 = NULL;</a>
<a name="ln992">  char *p1;</a>
<a name="ln993">  char *p2;</a>
<a name="ln994"> </a>
<a name="ln995">  // encode_tv2string() puts quotes around a string and allocates memory.  Don't</a>
<a name="ln996">  // do that for string variables. Use a single quote when comparing with</a>
<a name="ln997">  // a non-string to do what the docs promise.</a>
<a name="ln998">  if (tv1-&gt;v_type == VAR_STRING) {</a>
<a name="ln999">    if (tv2-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln1000">      p1 = &quot;'&quot;;</a>
<a name="ln1001">    } else {</a>
<a name="ln1002">      p1 = tv1-&gt;vval.v_string;</a>
<a name="ln1003">    }</a>
<a name="ln1004">  } else {</a>
<a name="ln1005">    tofree1 = p1 = encode_tv2string(tv1, NULL);</a>
<a name="ln1006">  }</a>
<a name="ln1007">  if (tv2-&gt;v_type == VAR_STRING) {</a>
<a name="ln1008">    if (tv1-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln1009">      p2 = &quot;'&quot;;</a>
<a name="ln1010">    } else {</a>
<a name="ln1011">      p2 = tv2-&gt;vval.v_string;</a>
<a name="ln1012">    }</a>
<a name="ln1013">  } else {</a>
<a name="ln1014">    tofree2 = p2 = encode_tv2string(tv2, NULL);</a>
<a name="ln1015">  }</a>
<a name="ln1016">  if (p1 == NULL) {</a>
<a name="ln1017">    p1 = &quot;&quot;;</a>
<a name="ln1018">  }</a>
<a name="ln1019">  if (p2 == NULL) {</a>
<a name="ln1020">    p2 = &quot;&quot;;</a>
<a name="ln1021">  }</a>
<a name="ln1022">  if (!sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln1023">    if (sortinfo-&gt;item_compare_lc) {</a>
<a name="ln1024">      res = strcoll(p1, p2);</a>
<a name="ln1025">    } else {</a>
<a name="ln1026">      res = sortinfo-&gt;item_compare_ic ? STRICMP(p1, p2): strcmp(p1, p2);</a>
<a name="ln1027">    }</a>
<a name="ln1028">  } else {</a>
<a name="ln1029">    double n1, n2;</a>
<a name="ln1030">    n1 = strtod(p1, &amp;p1);</a>
<a name="ln1031">    n2 = strtod(p2, &amp;p2);</a>
<a name="ln1032">    res = n1 == n2 ? 0 : n1 &gt; n2 ? 1 : -1;</a>
<a name="ln1033">  }</a>
<a name="ln1034"> </a>
<a name="ln1035">  xfree(tofree1);</a>
<a name="ln1036">  xfree(tofree2);</a>
<a name="ln1037"> </a>
<a name="ln1038">item_compare_end:</a>
<a name="ln1039">  // When the result would be zero, compare the item indexes.  Makes the</a>
<a name="ln1040">  // sort stable.</a>
<a name="ln1041">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln1042">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln1043">    // indexes are there.</a>
<a name="ln1044">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln1045">  }</a>
<a name="ln1046">  return res;</a>
<a name="ln1047">}</a>
<a name="ln1048"> </a>
<a name="ln1049">static int item_compare_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln1050">{</a>
<a name="ln1051">  return item_compare(s1, s2, true);</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054">static int item_compare_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln1055">{</a>
<a name="ln1056">  return item_compare(s1, s2, false);</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059">static int item_compare2(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln1060">{</a>
<a name="ln1061">  ListSortItem *si1, *si2;</a>
<a name="ln1062">  int res;</a>
<a name="ln1063">  typval_T rettv;</a>
<a name="ln1064">  typval_T argv[3];</a>
<a name="ln1065">  const char *func_name;</a>
<a name="ln1066">  partial_T *partial = sortinfo-&gt;item_compare_partial;</a>
<a name="ln1067"> </a>
<a name="ln1068">  // shortcut after failure in previous call; compare all items equal</a>
<a name="ln1069">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln1070">    return 0;</a>
<a name="ln1071">  }</a>
<a name="ln1072"> </a>
<a name="ln1073">  si1 = (ListSortItem *)s1;</a>
<a name="ln1074">  si2 = (ListSortItem *)s2;</a>
<a name="ln1075"> </a>
<a name="ln1076">  if (partial == NULL) {</a>
<a name="ln1077">    func_name = sortinfo-&gt;item_compare_func;</a>
<a name="ln1078">  } else {</a>
<a name="ln1079">    func_name = (const char *)partial_name(partial);</a>
<a name="ln1080">  }</a>
<a name="ln1081"> </a>
<a name="ln1082">  // Copy the values.  This is needed to be able to set v_lock to VAR_FIXED</a>
<a name="ln1083">  // in the copy without changing the original list items.</a>
<a name="ln1084">  tv_copy(TV_LIST_ITEM_TV(si1-&gt;item), &amp;argv[0]);</a>
<a name="ln1085">  tv_copy(TV_LIST_ITEM_TV(si2-&gt;item), &amp;argv[1]);</a>
<a name="ln1086"> </a>
<a name="ln1087">  rettv.v_type = VAR_UNKNOWN;  // tv_clear() uses this</a>
<a name="ln1088">  funcexe_T funcexe = FUNCEXE_INIT;</a>
<a name="ln1089">  funcexe.fe_evaluate = true;</a>
<a name="ln1090">  funcexe.fe_partial = partial;</a>
<a name="ln1091">  funcexe.fe_selfdict = sortinfo-&gt;item_compare_selfdict;</a>
<a name="ln1092">  res = call_func(func_name, -1, &amp;rettv, 2, argv, &amp;funcexe);</a>
<a name="ln1093">  tv_clear(&amp;argv[0]);</a>
<a name="ln1094">  tv_clear(&amp;argv[1]);</a>
<a name="ln1095"> </a>
<a name="ln1096">  if (res == FAIL) {</a>
<a name="ln1097">    res = ITEM_COMPARE_FAIL;</a>
<a name="ln1098">  } else {</a>
<a name="ln1099">    res = (int)tv_get_number_chk(&amp;rettv, &amp;sortinfo-&gt;item_compare_func_err);</a>
<a name="ln1100">    if (res &gt; 0) {</a>
<a name="ln1101">      res = 1;</a>
<a name="ln1102">    } else if (res &lt; 0) {</a>
<a name="ln1103">      res = -1;</a>
<a name="ln1104">    }</a>
<a name="ln1105">  }</a>
<a name="ln1106">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln1107">    res = ITEM_COMPARE_FAIL;  // return value has wrong type</a>
<a name="ln1108">  }</a>
<a name="ln1109">  tv_clear(&amp;rettv);</a>
<a name="ln1110"> </a>
<a name="ln1111">  // When the result would be zero, compare the pointers themselves.  Makes</a>
<a name="ln1112">  // the sort stable.</a>
<a name="ln1113">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln1114">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln1115">    // indexes are there.</a>
<a name="ln1116">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln1117">  }</a>
<a name="ln1118"> </a>
<a name="ln1119">  return res;</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122">static int item_compare2_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln1123">{</a>
<a name="ln1124">  return item_compare2(s1, s2, true);</a>
<a name="ln1125">}</a>
<a name="ln1126"> </a>
<a name="ln1127">static int item_compare2_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln1128">{</a>
<a name="ln1129">  return item_compare2(s1, s2, false);</a>
<a name="ln1130">}</a>
<a name="ln1131"> </a>
<a name="ln1132">/// &quot;sort({list})&quot; function</a>
<a name="ln1133">static void do_sort_uniq(typval_T *argvars, typval_T *rettv, bool sort)</a>
<a name="ln1134">{</a>
<a name="ln1135">  ListSortItem *ptrs;</a>
<a name="ln1136">  long len;</a>
<a name="ln1137">  long i;</a>
<a name="ln1138"> </a>
<a name="ln1139">  // Pointer to current info struct used in compare function. Save and restore</a>
<a name="ln1140">  // the current one for nested calls.</a>
<a name="ln1141">  sortinfo_T info;</a>
<a name="ln1142">  sortinfo_T *old_sortinfo = sortinfo;</a>
<a name="ln1143">  sortinfo = &amp;info;</a>
<a name="ln1144"> </a>
<a name="ln1145">  const char *const arg_errmsg = (sort</a>
<a name="ln1146">                                  ? N_(&quot;sort() argument&quot;)</a>
<a name="ln1147">                                  : N_(&quot;uniq() argument&quot;));</a>
<a name="ln1148"> </a>
<a name="ln1149">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln1150">    semsg(_(e_listarg), sort ? &quot;sort()&quot; : &quot;uniq()&quot;);</a>
<a name="ln1151">  } else {</a>
<a name="ln1152">    list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln1153">    if (var_check_lock(tv_list_locked(l), arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln1154">      goto theend;</a>
<a name="ln1155">    }</a>
<a name="ln1156">    tv_list_set_ret(rettv, l);</a>
<a name="ln1157"> </a>
<a name="ln1158">    len = tv_list_len(l);</a>
<a name="ln1159">    if (len &lt;= 1) {</a>
<a name="ln1160">      goto theend;  // short list sorts pretty quickly</a>
<a name="ln1161">    }</a>
<a name="ln1162"> </a>
<a name="ln1163">    info.item_compare_ic = false;</a>
<a name="ln1164">    info.item_compare_lc = false;</a>
<a name="ln1165">    info.item_compare_numeric = false;</a>
<a name="ln1166">    info.item_compare_numbers = false;</a>
<a name="ln1167">    info.item_compare_float = false;</a>
<a name="ln1168">    info.item_compare_func = NULL;</a>
<a name="ln1169">    info.item_compare_partial = NULL;</a>
<a name="ln1170">    info.item_compare_selfdict = NULL;</a>
<a name="ln1171"> </a>
<a name="ln1172">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1173">      // optional second argument: {func}</a>
<a name="ln1174">      if (argvars[1].v_type == VAR_FUNC) {</a>
<a name="ln1175">        info.item_compare_func = (const char *)argvars[1].vval.v_string;</a>
<a name="ln1176">      } else if (argvars[1].v_type == VAR_PARTIAL) {</a>
<a name="ln1177">        info.item_compare_partial = argvars[1].vval.v_partial;</a>
<a name="ln1178">      } else {</a>
<a name="ln1179">        bool error = false;</a>
<a name="ln1180"> </a>
<a name="ln1181">        i = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln1182">        if (error) {</a>
<a name="ln1183">          goto theend;  // type error; errmsg already given</a>
<a name="ln1184">        }</a>
<a name="ln1185">        if (i == 1) {</a>
<a name="ln1186">          info.item_compare_ic = true;</a>
<a name="ln1187">        } else if (argvars[1].v_type != VAR_NUMBER) {</a>
<a name="ln1188">          info.item_compare_func = tv_get_string(&amp;argvars[1]);</a>
<a name="ln1189">        } else if (i != 0) {</a>
<a name="ln1190">          emsg(_(e_invarg));</a>
<a name="ln1191">          goto theend;</a>
<a name="ln1192">        }</a>
<a name="ln1193">        if (info.item_compare_func != NULL) {</a>
<a name="ln1194">          if (*info.item_compare_func == NUL) {</a>
<a name="ln1195">            // empty string means default sort</a>
<a name="ln1196">            info.item_compare_func = NULL;</a>
<a name="ln1197">          } else if (strcmp(info.item_compare_func, &quot;n&quot;) == 0) {</a>
<a name="ln1198">            info.item_compare_func = NULL;</a>
<a name="ln1199">            info.item_compare_numeric = true;</a>
<a name="ln1200">          } else if (strcmp(info.item_compare_func, &quot;N&quot;) == 0) {</a>
<a name="ln1201">            info.item_compare_func = NULL;</a>
<a name="ln1202">            info.item_compare_numbers = true;</a>
<a name="ln1203">          } else if (strcmp(info.item_compare_func, &quot;f&quot;) == 0) {</a>
<a name="ln1204">            info.item_compare_func = NULL;</a>
<a name="ln1205">            info.item_compare_float = true;</a>
<a name="ln1206">          } else if (strcmp(info.item_compare_func, &quot;i&quot;) == 0) {</a>
<a name="ln1207">            info.item_compare_func = NULL;</a>
<a name="ln1208">            info.item_compare_ic = true;</a>
<a name="ln1209">          } else if (strcmp(info.item_compare_func, &quot;l&quot;) == 0) {</a>
<a name="ln1210">            info.item_compare_func = NULL;</a>
<a name="ln1211">            info.item_compare_lc = true;</a>
<a name="ln1212">          }</a>
<a name="ln1213">        }</a>
<a name="ln1214">      }</a>
<a name="ln1215"> </a>
<a name="ln1216">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1217">        // optional third argument: {dict}</a>
<a name="ln1218">        if (argvars[2].v_type != VAR_DICT) {</a>
<a name="ln1219">          emsg(_(e_dictreq));</a>
<a name="ln1220">          goto theend;</a>
<a name="ln1221">        }</a>
<a name="ln1222">        info.item_compare_selfdict = argvars[2].vval.v_dict;</a>
<a name="ln1223">      }</a>
<a name="ln1224">    }</a>
<a name="ln1225"> </a>
<a name="ln1226">    // Make an array with each entry pointing to an item in the List.</a>
<a name="ln1227">    ptrs = xmalloc((size_t)((unsigned)len * sizeof(ListSortItem)));</a>
<a name="ln1228"> </a>
<a name="ln1229">    if (sort) {</a>
<a name="ln1230">      info.item_compare_func_err = false;</a>
<a name="ln1231">      tv_list_item_sort(l, ptrs,</a>
<a name="ln1232">                        ((info.item_compare_func == NULL</a>
<a name="ln1233">                          &amp;&amp; info.item_compare_partial == NULL)</a>
<a name="ln1234">                         ? item_compare_not_keeping_zero</a>
<a name="ln1235">                         : item_compare2_not_keeping_zero),</a>
<a name="ln1236">                        &amp;info.item_compare_func_err);</a>
<a name="ln1237">      if (info.item_compare_func_err) {</a>
<a name="ln1238">        emsg(_(&quot;E702: Sort compare function failed&quot;));</a>
<a name="ln1239">      }</a>
<a name="ln1240">    } else {</a>
<a name="ln1241">      ListSorter item_compare_func_ptr;</a>
<a name="ln1242"> </a>
<a name="ln1243">      // f_uniq(): ptrs will be a stack of items to remove.</a>
<a name="ln1244">      info.item_compare_func_err = false;</a>
<a name="ln1245">      if (info.item_compare_func != NULL</a>
<a name="ln1246">          || info.item_compare_partial != NULL) {</a>
<a name="ln1247">        item_compare_func_ptr = item_compare2_keeping_zero;</a>
<a name="ln1248">      } else {</a>
<a name="ln1249">        item_compare_func_ptr = item_compare_keeping_zero;</a>
<a name="ln1250">      }</a>
<a name="ln1251"> </a>
<a name="ln1252">      for (listitem_T *li = TV_LIST_ITEM_NEXT(l, tv_list_first(l))</a>
<a name="ln1253">           ; li != NULL;) {</a>
<a name="ln1254">        listitem_T *const prev_li = TV_LIST_ITEM_PREV(l, li);</a>
<a name="ln1255">        if (item_compare_func_ptr(&amp;prev_li, &amp;li) == 0) {</a>
<a name="ln1256">          li = tv_list_item_remove(l, li);</a>
<a name="ln1257">        } else {</a>
<a name="ln1258">          li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln1259">        }</a>
<a name="ln1260">        if (info.item_compare_func_err) {  // -V547</a>
<a name="ln1261">          emsg(_(&quot;E882: Uniq compare function failed&quot;));</a>
<a name="ln1262">          break;</a>
<a name="ln1263">        }</a>
<a name="ln1264">      }</a>
<a name="ln1265">    }</a>
<a name="ln1266"> </a>
<a name="ln1267">    xfree(ptrs);</a>
<a name="ln1268">  }</a>
<a name="ln1269"> </a>
<a name="ln1270">theend:</a>
<a name="ln1271">  sortinfo = old_sortinfo;</a>
<a name="ln1272">}</a>
<a name="ln1273"> </a>
<a name="ln1274">/// &quot;sort&quot;({list})&quot; function</a>
<a name="ln1275">void f_sort(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1276">{</a>
<a name="ln1277">  do_sort_uniq(argvars, rettv, true);</a>
<a name="ln1278">}</a>
<a name="ln1279"> </a>
<a name="ln1280">/// &quot;uniq({list})&quot; function</a>
<a name="ln1281">void f_uniq(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1282">{</a>
<a name="ln1283">  do_sort_uniq(argvars, rettv, false);</a>
<a name="ln1284">}</a>
<a name="ln1285"> </a>
<a name="ln1286">/// Check whether two lists are equal</a>
<a name="ln1287">///</a>
<a name="ln1288">/// @param[in]  l1  First list to compare.</a>
<a name="ln1289">/// @param[in]  l2  Second list to compare.</a>
<a name="ln1290">/// @param[in]  ic  True if case is to be ignored.</a>
<a name="ln1291">/// @param[in]  recursive  True when used recursively.</a>
<a name="ln1292">///</a>
<a name="ln1293">/// @return True if lists are equal, false otherwise.</a>
<a name="ln1294">bool tv_list_equal(list_T *const l1, list_T *const l2, const bool ic, const bool recursive)</a>
<a name="ln1295">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1296">{</a>
<a name="ln1297">  if (l1 == l2) {</a>
<a name="ln1298">    return true;</a>
<a name="ln1299">  }</a>
<a name="ln1300">  if (tv_list_len(l1) != tv_list_len(l2)) {</a>
<a name="ln1301">    return false;</a>
<a name="ln1302">  }</a>
<a name="ln1303">  if (tv_list_len(l1) == 0) {</a>
<a name="ln1304">    // empty and NULL list are considered equal</a>
<a name="ln1305">    return true;</a>
<a name="ln1306">  }</a>
<a name="ln1307">  if (l1 == NULL || l2 == NULL) {</a>
<a name="ln1308">    return false;</a>
<a name="ln1309">  }</a>
<a name="ln1310"> </a>
<a name="ln1311">  listitem_T *item1 = tv_list_first(l1);</a>
<a name="ln1312">  listitem_T *item2 = tv_list_first(l2);</a>
<a name="ln1313">  for (; item1 != NULL &amp;&amp; item2 != NULL</a>
<a name="ln1314">       ; (item1 = TV_LIST_ITEM_NEXT(l1, item1),</a>
<a name="ln1315">          item2 = TV_LIST_ITEM_NEXT(l2, item2))) {</a>
<a name="ln1316">    if (!tv_equal(TV_LIST_ITEM_TV(item1), TV_LIST_ITEM_TV(item2), ic,</a>
<a name="ln1317">                  recursive)) {</a>
<a name="ln1318">      return false;</a>
<a name="ln1319">    }</a>
<a name="ln1320">  }</a>
<a name="ln1321">  assert(item1 == NULL &amp;&amp; item2 == NULL);</a>
<a name="ln1322">  return true;</a>
<a name="ln1323">}</a>
<a name="ln1324"> </a>
<a name="ln1325">/// Reverse list in-place</a>
<a name="ln1326">///</a>
<a name="ln1327">/// @param[in,out]  l  List to reverse.</a>
<a name="ln1328">void tv_list_reverse(list_T *const l)</a>
<a name="ln1329">{</a>
<a name="ln1330">  if (tv_list_len(l) &lt;= 1) {</a>
<a name="ln1331">    return;</a>
<a name="ln1332">  }</a>
<a name="ln1333">  list_log(l, NULL, NULL, &quot;reverse&quot;);</a>
<a name="ln1334">#define SWAP(a, b) \</a>
<a name="ln1335">  do { \</a>
<a name="ln1336">    tmp = (a); \</a>
<a name="ln1337">    (a) = (b); \</a>
<a name="ln1338">    (b) = tmp; \</a>
<a name="ln1339">  } while (0)</a>
<a name="ln1340">  listitem_T *tmp;</a>
<a name="ln1341"> </a>
<a name="ln1342">  SWAP(l-&gt;lv_first, l-&gt;lv_last);</a>
<a name="ln1343">  for (listitem_T *li = l-&gt;lv_first; li != NULL; li = li-&gt;li_next) {</a>
<a name="ln1344">    SWAP(li-&gt;li_next, li-&gt;li_prev);</a>
<a name="ln1345">  }</a>
<a name="ln1346">#undef SWAP</a>
<a name="ln1347"> </a>
<a name="ln1348">  l-&gt;lv_idx = l-&gt;lv_len - l-&gt;lv_idx - 1;</a>
<a name="ln1349">}</a>
<a name="ln1350"> </a>
<a name="ln1351">// FIXME Add unit tests for tv_list_item_sort().</a>
<a name="ln1352"> </a>
<a name="ln1353">/// Sort list using libc qsort</a>
<a name="ln1354">///</a>
<a name="ln1355">/// @param[in,out]  l  List to sort, will be sorted in-place.</a>
<a name="ln1356">/// @param  ptrs  Preallocated array of items to sort, must have at least</a>
<a name="ln1357">///               tv_list_len(l) entries. Should not be initialized.</a>
<a name="ln1358">/// @param[in]  item_compare_func  Function used to compare list items.</a>
<a name="ln1359">/// @param  errp  Location where information about whether error occurred is</a>
<a name="ln1360">///               saved by item_compare_func. If boolean there appears to be</a>
<a name="ln1361">///               true list will not be modified. Must be initialized to false</a>
<a name="ln1362">///               by the caller.</a>
<a name="ln1363">void tv_list_item_sort(list_T *const l, ListSortItem *const ptrs,</a>
<a name="ln1364">                       const ListSorter item_compare_func, const bool *errp)</a>
<a name="ln1365">  FUNC_ATTR_NONNULL_ARG(3, 4)</a>
<a name="ln1366">{</a>
<a name="ln1367">  const int len = tv_list_len(l);</a>
<a name="ln1368">  if (len &lt;= 1) {</a>
<a name="ln1369">    return;</a>
<a name="ln1370">  }</a>
<a name="ln1371">  list_log(l, NULL, NULL, &quot;sort&quot;);</a>
<a name="ln1372">  int i = 0;</a>
<a name="ln1373">  TV_LIST_ITER(l, li, {</a>
<a name="ln1374">    ptrs[i].item = li;</a>
<a name="ln1375">    ptrs[i].idx = i;</a>
<a name="ln1376">    i++;</a>
<a name="ln1377">  });</a>
<a name="ln1378">  // Sort the array with item pointers.</a>
<a name="ln1379">  qsort(ptrs, (size_t)len, sizeof(ListSortItem), item_compare_func);</a>
<a name="ln1380">  if (!(*errp)) {</a>
<a name="ln1381">    // Clear the list and append the items in the sorted order.</a>
<a name="ln1382">    l-&gt;lv_first    = NULL;</a>
<a name="ln1383">    l-&gt;lv_last     = NULL;</a>
<a name="ln1384">    l-&gt;lv_idx_item = NULL;</a>
<a name="ln1385">    l-&gt;lv_len      = 0;</a>
<a name="ln1386">    for (i = 0; i &lt; len; i++) {</a>
<a name="ln1387">      tv_list_append(l, ptrs[i].item);</a>
<a name="ln1388">    }</a>
<a name="ln1389">  }</a>
<a name="ln1390">}</a>
<a name="ln1391"> </a>
<a name="ln1392">//{{{2 Indexing/searching</a>
<a name="ln1393"> </a>
<a name="ln1394">/// Locate item with a given index in a list and return it</a>
<a name="ln1395">///</a>
<a name="ln1396">/// @param[in]  l  List to index.</a>
<a name="ln1397">/// @param[in]  n  Index. Negative index is counted from the end, -1 is the last</a>
<a name="ln1398">///                item.</a>
<a name="ln1399">///</a>
<a name="ln1400">/// @return Item at the given index or NULL if `n` is out of range.</a>
<a name="ln1401">listitem_T *tv_list_find(list_T *const l, int n)</a>
<a name="ln1402">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1403">{</a>
<a name="ln1404">  STATIC_ASSERT(sizeof(n) == sizeof(l-&gt;lv_idx),</a>
<a name="ln1405">                &quot;n and lv_idx sizes do not match&quot;);</a>
<a name="ln1406">  if (l == NULL) {</a>
<a name="ln1407">    return NULL;</a>
<a name="ln1408">  }</a>
<a name="ln1409"> </a>
<a name="ln1410">  n = tv_list_uidx(l, n);</a>
<a name="ln1411">  if (n == -1) {</a>
<a name="ln1412">    return NULL;</a>
<a name="ln1413">  }</a>
<a name="ln1414"> </a>
<a name="ln1415">  int idx;</a>
<a name="ln1416">  listitem_T *item;</a>
<a name="ln1417"> </a>
<a name="ln1418">  // When there is a cached index may start search from there.</a>
<a name="ln1419">  if (l-&gt;lv_idx_item != NULL) {</a>
<a name="ln1420">    if (n &lt; l-&gt;lv_idx / 2) {</a>
<a name="ln1421">      // Closest to the start of the list.</a>
<a name="ln1422">      item = l-&gt;lv_first;</a>
<a name="ln1423">      idx = 0;</a>
<a name="ln1424">    } else if (n &gt; (l-&gt;lv_idx + l-&gt;lv_len) / 2) {</a>
<a name="ln1425">      // Closest to the end of the list.</a>
<a name="ln1426">      item = l-&gt;lv_last;</a>
<a name="ln1427">      idx = l-&gt;lv_len - 1;</a>
<a name="ln1428">    } else {</a>
<a name="ln1429">      // Closest to the cached index.</a>
<a name="ln1430">      item = l-&gt;lv_idx_item;</a>
<a name="ln1431">      idx = l-&gt;lv_idx;</a>
<a name="ln1432">    }</a>
<a name="ln1433">  } else {</a>
<a name="ln1434">    if (n &lt; l-&gt;lv_len / 2) {</a>
<a name="ln1435">      // Closest to the start of the list.</a>
<a name="ln1436">      item = l-&gt;lv_first;</a>
<a name="ln1437">      idx = 0;</a>
<a name="ln1438">    } else {</a>
<a name="ln1439">      // Closest to the end of the list.</a>
<a name="ln1440">      item = l-&gt;lv_last;</a>
<a name="ln1441">      idx = l-&gt;lv_len - 1;</a>
<a name="ln1442">    }</a>
<a name="ln1443">  }</a>
<a name="ln1444"> </a>
<a name="ln1445">  while (n &gt; idx) {</a>
<a name="ln1446">    // Search forward.</a>
<a name="ln1447">    item = item-&gt;li_next;</a>
<a name="ln1448">    idx++;</a>
<a name="ln1449">  }</a>
<a name="ln1450">  while (n &lt; idx) {</a>
<a name="ln1451">    // Search backward.</a>
<a name="ln1452">    item = item-&gt;li_prev;</a>
<a name="ln1453">    idx--;</a>
<a name="ln1454">  }</a>
<a name="ln1455"> </a>
<a name="ln1456">  assert(idx == n);</a>
<a name="ln1457">  // Cache the used index.</a>
<a name="ln1458">  l-&gt;lv_idx = idx;</a>
<a name="ln1459">  l-&gt;lv_idx_item = item;</a>
<a name="ln1460">  list_log(l, l-&gt;lv_idx_item, (void *)(uintptr_t)l-&gt;lv_idx, &quot;find&quot;);</a>
<a name="ln1461"> </a>
<a name="ln1462">  return item;</a>
<a name="ln1463">}</a>
<a name="ln1464"> </a>
<a name="ln1465">/// Get list item l[n] as a number</a>
<a name="ln1466">///</a>
<a name="ln1467">/// @param[in]  l  List to index.</a>
<a name="ln1468">/// @param[in]  n  Index in a list.</a>
<a name="ln1469">/// @param[out]  ret_error  Location where 1 will be saved if index was not</a>
<a name="ln1470">///                         found. May be NULL. If everything is OK,</a>
<a name="ln1471">///                         `*ret_error` is not touched.</a>
<a name="ln1472">///</a>
<a name="ln1473">/// @return Integer value at the given index or -1.</a>
<a name="ln1474">varnumber_T tv_list_find_nr(list_T *const l, const int n, bool *const ret_error)</a>
<a name="ln1475">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1476">{</a>
<a name="ln1477">  const listitem_T *const li = tv_list_find(l, n);</a>
<a name="ln1478">  if (li == NULL) {</a>
<a name="ln1479">    if (ret_error != NULL) {</a>
<a name="ln1480">      *ret_error = true;</a>
<a name="ln1481">    }</a>
<a name="ln1482">    return -1;</a>
<a name="ln1483">  }</a>
<a name="ln1484">  return tv_get_number_chk(TV_LIST_ITEM_TV(li), ret_error);</a>
<a name="ln1485">}</a>
<a name="ln1486"> </a>
<a name="ln1487">/// Get list item l[n] as a string</a>
<a name="ln1488">///</a>
<a name="ln1489">/// @param[in]  l  List to index.</a>
<a name="ln1490">/// @param[in]  n  Index in a list.</a>
<a name="ln1491">///</a>
<a name="ln1492">/// @return List item string value or NULL in case of error.</a>
<a name="ln1493">const char *tv_list_find_str(list_T *const l, const int n)</a>
<a name="ln1494">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1495">{</a>
<a name="ln1496">  const listitem_T *const li = tv_list_find(l, n);</a>
<a name="ln1497">  if (li == NULL) {</a>
<a name="ln1498">    semsg(_(e_listidx), (int64_t)n);</a>
<a name="ln1499">    return NULL;</a>
<a name="ln1500">  }</a>
<a name="ln1501">  return tv_get_string(TV_LIST_ITEM_TV(li));</a>
<a name="ln1502">}</a>
<a name="ln1503"> </a>
<a name="ln1504">/// Locate item in a list and return its index</a>
<a name="ln1505">///</a>
<a name="ln1506">/// @param[in]  l  List to search.</a>
<a name="ln1507">/// @param[in]  item  Item to search for.</a>
<a name="ln1508">///</a>
<a name="ln1509">/// @return Index of an item or -1 if item is not in the list.</a>
<a name="ln1510">long tv_list_idx_of_item(const list_T *const l, const listitem_T *const item)</a>
<a name="ln1511">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln1512">{</a>
<a name="ln1513">  if (l == NULL) {</a>
<a name="ln1514">    return -1;</a>
<a name="ln1515">  }</a>
<a name="ln1516">  int idx = 0;</a>
<a name="ln1517">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln1518">    if (li == item) {</a>
<a name="ln1519">      return idx;</a>
<a name="ln1520">    }</a>
<a name="ln1521">    idx++;</a>
<a name="ln1522">  });</a>
<a name="ln1523">  return -1;</a>
<a name="ln1524">}</a>
<a name="ln1525"> </a>
<a name="ln1526">//{{{1 Dictionaries</a>
<a name="ln1527">//{{{2 Dictionary watchers</a>
<a name="ln1528"> </a>
<a name="ln1529">/// Perform all necessary cleanup for a `DictWatcher` instance</a>
<a name="ln1530">///</a>
<a name="ln1531">/// @param  watcher  Watcher to free.</a>
<a name="ln1532">static void tv_dict_watcher_free(DictWatcher *watcher)</a>
<a name="ln1533">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1534">{</a>
<a name="ln1535">  callback_free(&amp;watcher-&gt;callback);</a>
<a name="ln1536">  xfree(watcher-&gt;key_pattern);</a>
<a name="ln1537">  xfree(watcher);</a>
<a name="ln1538">}</a>
<a name="ln1539"> </a>
<a name="ln1540">/// Add watcher to a dictionary</a>
<a name="ln1541">///</a>
<a name="ln1542">/// @param[in]  dict  Dictionary to add watcher to.</a>
<a name="ln1543">/// @param[in]  key_pattern  Pattern to watch for.</a>
<a name="ln1544">/// @param[in]  key_pattern_len  Key pattern length.</a>
<a name="ln1545">/// @param  callback  Function to be called on events.</a>
<a name="ln1546">void tv_dict_watcher_add(dict_T *const dict, const char *const key_pattern,</a>
<a name="ln1547">                         const size_t key_pattern_len, Callback callback)</a>
<a name="ln1548">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln1549">{</a>
<a name="ln1550">  if (dict == NULL) {</a>
<a name="ln1551">    return;</a>
<a name="ln1552">  }</a>
<a name="ln1553">  DictWatcher *const watcher = xmalloc(sizeof(DictWatcher));</a>
<a name="ln1554">  watcher-&gt;key_pattern = xmemdupz(key_pattern, key_pattern_len);</a>
<a name="ln1555">  watcher-&gt;key_pattern_len = key_pattern_len;</a>
<a name="ln1556">  watcher-&gt;callback = callback;</a>
<a name="ln1557">  watcher-&gt;busy = false;</a>
<a name="ln1558">  watcher-&gt;needs_free = false;</a>
<a name="ln1559">  QUEUE_INSERT_TAIL(&amp;dict-&gt;watchers, &amp;watcher-&gt;node);</a>
<a name="ln1560">}</a>
<a name="ln1561"> </a>
<a name="ln1562">/// Check whether two callbacks are equal</a>
<a name="ln1563">///</a>
<a name="ln1564">/// @param[in]  cb1  First callback to check.</a>
<a name="ln1565">/// @param[in]  cb2  Second callback to check.</a>
<a name="ln1566">///</a>
<a name="ln1567">/// @return True if they are equal, false otherwise.</a>
<a name="ln1568">bool tv_callback_equal(const Callback *cb1, const Callback *cb2)</a>
<a name="ln1569">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1570">{</a>
<a name="ln1571">  if (cb1-&gt;type != cb2-&gt;type) {</a>
<a name="ln1572">    return false;</a>
<a name="ln1573">  }</a>
<a name="ln1574">  switch (cb1-&gt;type) {</a>
<a name="ln1575">  case kCallbackFuncref:</a>
<a name="ln1576">    return strcmp(cb1-&gt;data.funcref, cb2-&gt;data.funcref) == 0;</a>
<a name="ln1577">  case kCallbackPartial:</a>
<a name="ln1578">    // FIXME: this is inconsistent with tv_equal but is needed for precision</a>
<a name="ln1579">    // maybe change dictwatcheradd to return a watcher id instead?</a>
<a name="ln1580">    return cb1-&gt;data.partial == cb2-&gt;data.partial;</a>
<a name="ln1581">  case kCallbackLua:</a>
<a name="ln1582">    return cb1-&gt;data.luaref == cb2-&gt;data.luaref;</a>
<a name="ln1583">  case kCallbackNone:</a>
<a name="ln1584">    return true;</a>
<a name="ln1585">  }</a>
<a name="ln1586">  abort();</a>
<a name="ln1587">  return false;</a>
<a name="ln1588">}</a>
<a name="ln1589"> </a>
<a name="ln1590">/// Unref/free callback</a>
<a name="ln1591">void callback_free(Callback *callback)</a>
<a name="ln1592">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1593">{</a>
<a name="ln1594">  switch (callback-&gt;type) {</a>
<a name="ln1595">  case kCallbackFuncref:</a>
<a name="ln1596">    func_unref((char_u *)callback-&gt;data.funcref);</a>
<a name="ln1597">    xfree(callback-&gt;data.funcref);</a>
<a name="ln1598">    break;</a>
<a name="ln1599">  case kCallbackPartial:</a>
<a name="ln1600">    partial_unref(callback-&gt;data.partial);</a>
<a name="ln1601">    break;</a>
<a name="ln1602">  case kCallbackLua:</a>
<a name="ln1603">    NLUA_CLEAR_REF(callback-&gt;data.luaref);</a>
<a name="ln1604">    break;</a>
<a name="ln1605">  case kCallbackNone:</a>
<a name="ln1606">    break;</a>
<a name="ln1607">  }</a>
<a name="ln1608">  callback-&gt;type = kCallbackNone;</a>
<a name="ln1609">  callback-&gt;data.funcref = NULL;</a>
<a name="ln1610">}</a>
<a name="ln1611"> </a>
<a name="ln1612">/// Copy a callback into a typval_T.</a>
<a name="ln1613">void callback_put(Callback *cb, typval_T *tv)</a>
<a name="ln1614">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1615">{</a>
<a name="ln1616">  switch (cb-&gt;type) {</a>
<a name="ln1617">  case kCallbackPartial:</a>
<a name="ln1618">    tv-&gt;v_type = VAR_PARTIAL;</a>
<a name="ln1619">    tv-&gt;vval.v_partial = cb-&gt;data.partial;</a>
<a name="ln1620">    cb-&gt;data.partial-&gt;pt_refcount++;</a>
<a name="ln1621">    break;</a>
<a name="ln1622">  case kCallbackFuncref:</a>
<a name="ln1623">    tv-&gt;v_type = VAR_FUNC;</a>
<a name="ln1624">    tv-&gt;vval.v_string = xstrdup(cb-&gt;data.funcref);</a>
<a name="ln1625">    func_ref((char_u *)cb-&gt;data.funcref);</a>
<a name="ln1626">    break;</a>
<a name="ln1627">  case kCallbackLua:</a>
<a name="ln1628">  // TODO(tjdevries): Unified Callback.</a>
<a name="ln1629">  // At this point this isn't possible, but it'd be nice to put</a>
<a name="ln1630">  // these handled more neatly in one place.</a>
<a name="ln1631">  // So instead, we just do the default and put nil</a>
<a name="ln1632">  default:</a>
<a name="ln1633">    tv-&gt;v_type = VAR_SPECIAL;</a>
<a name="ln1634">    tv-&gt;vval.v_special = kSpecialVarNull;</a>
<a name="ln1635">    break;</a>
<a name="ln1636">  }</a>
<a name="ln1637">}</a>
<a name="ln1638"> </a>
<a name="ln1639">// Copy callback from &quot;src&quot; to &quot;dest&quot;, incrementing the refcounts.</a>
<a name="ln1640">void callback_copy(Callback *dest, Callback *src)</a>
<a name="ln1641">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1642">{</a>
<a name="ln1643">  dest-&gt;type = src-&gt;type;</a>
<a name="ln1644">  switch (src-&gt;type) {</a>
<a name="ln1645">  case kCallbackPartial:</a>
<a name="ln1646">    dest-&gt;data.partial = src-&gt;data.partial;</a>
<a name="ln1647">    dest-&gt;data.partial-&gt;pt_refcount++;</a>
<a name="ln1648">    break;</a>
<a name="ln1649">  case kCallbackFuncref:</a>
<a name="ln1650">    dest-&gt;data.funcref = xstrdup(src-&gt;data.funcref);</a>
<a name="ln1651">    func_ref((char_u *)src-&gt;data.funcref);</a>
<a name="ln1652">    break;</a>
<a name="ln1653">  case kCallbackLua:</a>
<a name="ln1654">    dest-&gt;data.luaref = api_new_luaref(src-&gt;data.luaref);</a>
<a name="ln1655">    break;</a>
<a name="ln1656">  default:</a>
<a name="ln1657">    dest-&gt;data.funcref = NULL;</a>
<a name="ln1658">    break;</a>
<a name="ln1659">  }</a>
<a name="ln1660">}</a>
<a name="ln1661"> </a>
<a name="ln1662">/// Generate a string description of a callback</a>
<a name="ln1663">char *callback_to_string(Callback *cb)</a>
<a name="ln1664">{</a>
<a name="ln1665">  if (cb-&gt;type == kCallbackLua) {</a>
<a name="ln1666">    return nlua_funcref_str(cb-&gt;data.luaref);</a>
<a name="ln1667">  }</a>
<a name="ln1668"> </a>
<a name="ln1669">  const size_t msglen = 100;</a>
<a name="ln1670">  char *msg = (char *)xmallocz(msglen);</a>
<a name="ln1671"> </a>
<a name="ln1672">  switch (cb-&gt;type) {</a>
<a name="ln1673">  case kCallbackFuncref:</a>
<a name="ln1674">    // TODO(tjdevries): Is this enough space for this?</a>
<a name="ln1675">    snprintf(msg, msglen, &quot;&lt;vim function: %s&gt;&quot;, cb-&gt;data.funcref);</a>
<a name="ln1676">    break;</a>
<a name="ln1677">  case kCallbackPartial:</a>
<a name="ln1678">    snprintf(msg, msglen, &quot;&lt;vim partial: %s&gt;&quot;, cb-&gt;data.partial-&gt;pt_name);</a>
<a name="ln1679">    break;</a>
<a name="ln1680">  default:</a>
<a name="ln1681">    *msg = '\0';</a>
<a name="ln1682">    break;</a>
<a name="ln1683">  }</a>
<a name="ln1684">  return msg;</a>
<a name="ln1685">}</a>
<a name="ln1686"> </a>
<a name="ln1687">/// Remove watcher from a dictionary</a>
<a name="ln1688">///</a>
<a name="ln1689">/// @param  dict  Dictionary to remove watcher from.</a>
<a name="ln1690">/// @param[in]  key_pattern  Pattern to remove watcher for.</a>
<a name="ln1691">/// @param[in]  key_pattern_len  Pattern length.</a>
<a name="ln1692">/// @param  callback  Callback to remove watcher for.</a>
<a name="ln1693">///</a>
<a name="ln1694">/// @return True on success, false if relevant watcher was not found.</a>
<a name="ln1695">bool tv_dict_watcher_remove(dict_T *const dict, const char *const key_pattern,</a>
<a name="ln1696">                            const size_t key_pattern_len, Callback callback)</a>
<a name="ln1697">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln1698">{</a>
<a name="ln1699">  if (dict == NULL) {</a>
<a name="ln1700">    return false;</a>
<a name="ln1701">  }</a>
<a name="ln1702"> </a>
<a name="ln1703">  QUEUE *w = NULL;</a>
<a name="ln1704">  DictWatcher *watcher = NULL;</a>
<a name="ln1705">  bool matched = false;</a>
<a name="ln1706">  bool queue_is_busy = false;</a>
<a name="ln1707">  QUEUE_FOREACH(w, &amp;dict-&gt;watchers, {</a>
<a name="ln1708">    watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1709">    if (watcher-&gt;busy) {</a>
<a name="ln1710">      queue_is_busy = true;</a>
<a name="ln1711">    }</a>
<a name="ln1712">    if (tv_callback_equal(&amp;watcher-&gt;callback, &amp;callback)</a>
<a name="ln1713">        &amp;&amp; watcher-&gt;key_pattern_len == key_pattern_len</a>
<a name="ln1714">        &amp;&amp; memcmp(watcher-&gt;key_pattern, key_pattern, key_pattern_len) == 0) {</a>
<a name="ln1715">      matched = true;</a>
<a name="ln1716">      break;</a>
<a name="ln1717">    }</a>
<a name="ln1718">  })</a>
<a name="ln1719"> </a>
<a name="ln1720">  if (!matched) {</a>
<a name="ln1721">    return false;</a>
<a name="ln1722">  }</a>
<a name="ln1723"> </a>
<a name="ln1724">  if (queue_is_busy) {</a>
<a name="ln1725">    watcher-&gt;needs_free = true;</a>
<a name="ln1726">  } else {</a>
<a name="ln1727">    QUEUE_REMOVE(w);</a>
<a name="ln1728">    tv_dict_watcher_free(watcher);</a>
<a name="ln1729">  }</a>
<a name="ln1730">  return true;</a>
<a name="ln1731">}</a>
<a name="ln1732"> </a>
<a name="ln1733">/// Test if `key` matches with with `watcher-&gt;key_pattern`</a>
<a name="ln1734">///</a>
<a name="ln1735">/// @param[in]  watcher  Watcher to check key pattern from.</a>
<a name="ln1736">/// @param[in]  key  Key to check.</a>
<a name="ln1737">///</a>
<a name="ln1738">/// @return true if key matches, false otherwise.</a>
<a name="ln1739">static bool tv_dict_watcher_matches(DictWatcher *watcher, const char *const key)</a>
<a name="ln1740">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln1741">{</a>
<a name="ln1742">  // For now only allow very simple globbing in key patterns: a '*' at the end</a>
<a name="ln1743">  // of the string means it should match everything up to the '*' instead of the</a>
<a name="ln1744">  // whole string.</a>
<a name="ln1745">  const size_t len = watcher-&gt;key_pattern_len;</a>
<a name="ln1746">  if (len &amp;&amp; watcher-&gt;key_pattern[len - 1] == '*') {</a>
<a name="ln1747">    return strncmp(key, watcher-&gt;key_pattern, len - 1) == 0;</a>
<a name="ln1748">  } else {</a>
<a name="ln1749">    return strcmp(key, watcher-&gt;key_pattern) == 0;</a>
<a name="ln1750">  }</a>
<a name="ln1751">}</a>
<a name="ln1752"> </a>
<a name="ln1753">/// Send a change notification to all dictionary watchers that match given key</a>
<a name="ln1754">///</a>
<a name="ln1755">/// @param[in]  dict  Dictionary which was modified.</a>
<a name="ln1756">/// @param[in]  key  Key which was modified.</a>
<a name="ln1757">/// @param[in]  newtv  New key value.</a>
<a name="ln1758">/// @param[in]  oldtv  Old key value.</a>
<a name="ln1759">void tv_dict_watcher_notify(dict_T *const dict, const char *const key, typval_T *const newtv,</a>
<a name="ln1760">                            typval_T *const oldtv)</a>
<a name="ln1761">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln1762">{</a>
<a name="ln1763">  typval_T argv[3];</a>
<a name="ln1764"> </a>
<a name="ln1765">  argv[0].v_type = VAR_DICT;</a>
<a name="ln1766">  argv[0].v_lock = VAR_UNLOCKED;</a>
<a name="ln1767">  argv[0].vval.v_dict = dict;</a>
<a name="ln1768">  argv[1].v_type = VAR_STRING;</a>
<a name="ln1769">  argv[1].v_lock = VAR_UNLOCKED;</a>
<a name="ln1770">  argv[1].vval.v_string = xstrdup(key);</a>
<a name="ln1771">  argv[2].v_type = VAR_DICT;</a>
<a name="ln1772">  argv[2].v_lock = VAR_UNLOCKED;</a>
<a name="ln1773">  argv[2].vval.v_dict = tv_dict_alloc();</a>
<a name="ln1774">  argv[2].vval.v_dict-&gt;dv_refcount++;</a>
<a name="ln1775"> </a>
<a name="ln1776">  if (newtv) {</a>
<a name="ln1777">    dictitem_T *const v = tv_dict_item_alloc_len(S_LEN(&quot;new&quot;));</a>
<a name="ln1778">    tv_copy(newtv, &amp;v-&gt;di_tv);</a>
<a name="ln1779">    tv_dict_add(argv[2].vval.v_dict, v);</a>
<a name="ln1780">  }</a>
<a name="ln1781"> </a>
<a name="ln1782">  if (oldtv &amp;&amp; oldtv-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln1783">    dictitem_T *const v = tv_dict_item_alloc_len(S_LEN(&quot;old&quot;));</a>
<a name="ln1784">    tv_copy(oldtv, &amp;v-&gt;di_tv);</a>
<a name="ln1785">    tv_dict_add(argv[2].vval.v_dict, v);</a>
<a name="ln1786">  }</a>
<a name="ln1787"> </a>
<a name="ln1788">  typval_T rettv;</a>
<a name="ln1789"> </a>
<a name="ln1790">  bool any_needs_free = false;</a>
<a name="ln1791">  dict-&gt;dv_refcount++;</a>
<a name="ln1792">  QUEUE *w;</a>
<a name="ln1793">  QUEUE_FOREACH(w, &amp;dict-&gt;watchers, {</a>
<a name="ln1794">    DictWatcher *watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1795">    if (!watcher-&gt;busy &amp;&amp; tv_dict_watcher_matches(watcher, key)) {</a>
<a name="ln1796">      rettv = TV_INITIAL_VALUE;</a>
<a name="ln1797">      watcher-&gt;busy = true;</a>
<a name="ln1798">      callback_call(&amp;watcher-&gt;callback, 3, argv, &amp;rettv);</a>
<a name="ln1799">      watcher-&gt;busy = false;</a>
<a name="ln1800">      tv_clear(&amp;rettv);</a>
<a name="ln1801">      if (watcher-&gt;needs_free) {</a>
<a name="ln1802">        any_needs_free = true;</a>
<a name="ln1803">      }</a>
<a name="ln1804">    }</a>
<a name="ln1805">  })</a>
<a name="ln1806">  if (any_needs_free) {</a>
<a name="ln1807">    QUEUE_FOREACH(w, &amp;dict-&gt;watchers, {</a>
<a name="ln1808">      DictWatcher *watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1809">      if (watcher-&gt;needs_free) {</a>
<a name="ln1810">        QUEUE_REMOVE(w);</a>
<a name="ln1811">        tv_dict_watcher_free(watcher);</a>
<a name="ln1812">      }</a>
<a name="ln1813">    })</a>
<a name="ln1814">  }</a>
<a name="ln1815">  tv_dict_unref(dict);</a>
<a name="ln1816"> </a>
<a name="ln1817">  for (size_t i = 1; i &lt; ARRAY_SIZE(argv); i++) {</a>
<a name="ln1818">    tv_clear(argv + i);</a>
<a name="ln1819">  }</a>
<a name="ln1820">}</a>
<a name="ln1821"> </a>
<a name="ln1822">//{{{2 Dictionary item</a>
<a name="ln1823"> </a>
<a name="ln1824">/// Allocate a dictionary item</a>
<a name="ln1825">///</a>
<a name="ln1826">/// @note that the type and value of the item (-&gt;di_tv) still needs to</a>
<a name="ln1827">///       be initialized.</a>
<a name="ln1828">///</a>
<a name="ln1829">/// @param[in]  key  Key, is copied to the new item.</a>
<a name="ln1830">/// @param[in]  key_len  Key length.</a>
<a name="ln1831">///</a>
<a name="ln1832">/// @return [allocated] new dictionary item.</a>
<a name="ln1833">dictitem_T *tv_dict_item_alloc_len(const char *const key, const size_t key_len)</a>
<a name="ln1834">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1835">  FUNC_ATTR_MALLOC</a>
<a name="ln1836">{</a>
<a name="ln1837">  dictitem_T *const di = xmalloc(offsetof(dictitem_T, di_key) + key_len + 1);</a>
<a name="ln1838">  memcpy(di-&gt;di_key, key, key_len);</a>
<a name="ln1839">  di-&gt;di_key[key_len] = NUL;</a>
<a name="ln1840">  di-&gt;di_flags = DI_FLAGS_ALLOC;</a>
<a name="ln1841">  di-&gt;di_tv.v_lock = VAR_UNLOCKED;</a>
<a name="ln1842">  return di;</a>
<a name="ln1843">}</a>
<a name="ln1844"> </a>
<a name="ln1845">/// Allocate a dictionary item</a>
<a name="ln1846">///</a>
<a name="ln1847">/// @note that the type and value of the item (-&gt;di_tv) still needs to</a>
<a name="ln1848">///       be initialized.</a>
<a name="ln1849">///</a>
<a name="ln1850">/// @param[in]  key  Key, is copied to the new item.</a>
<a name="ln1851">///</a>
<a name="ln1852">/// @return [allocated] new dictionary item.</a>
<a name="ln1853">dictitem_T *tv_dict_item_alloc(const char *const key)</a>
<a name="ln1854">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1855">  FUNC_ATTR_MALLOC</a>
<a name="ln1856">{</a>
<a name="ln1857">  return tv_dict_item_alloc_len(key, strlen(key));</a>
<a name="ln1858">}</a>
<a name="ln1859"> </a>
<a name="ln1860">/// Free a dictionary item, also clearing the value</a>
<a name="ln1861">///</a>
<a name="ln1862">/// @param  item  Item to free.</a>
<a name="ln1863">void tv_dict_item_free(dictitem_T *const item)</a>
<a name="ln1864">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1865">{</a>
<a name="ln1866">  tv_clear(&amp;item-&gt;di_tv);</a>
<a name="ln1867">  if (item-&gt;di_flags &amp; DI_FLAGS_ALLOC) {</a>
<a name="ln1868">    xfree(item);</a>
<a name="ln1869">  }</a>
<a name="ln1870">}</a>
<a name="ln1871"> </a>
<a name="ln1872">/// Make a copy of a dictionary item</a>
<a name="ln1873">///</a>
<a name="ln1874">/// @param[in]  di  Item to copy.</a>
<a name="ln1875">///</a>
<a name="ln1876">/// @return [allocated] new dictionary item.</a>
<a name="ln1877">dictitem_T *tv_dict_item_copy(dictitem_T *const di)</a>
<a name="ln1878">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1879">{</a>
<a name="ln1880">  dictitem_T *const new_di = tv_dict_item_alloc((const char *)di-&gt;di_key);</a>
<a name="ln1881">  tv_copy(&amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv);</a>
<a name="ln1882">  return new_di;</a>
<a name="ln1883">}</a>
<a name="ln1884"> </a>
<a name="ln1885">/// Remove item from dictionary and free it</a>
<a name="ln1886">///</a>
<a name="ln1887">/// @param  dict  Dictionary to remove item from.</a>
<a name="ln1888">/// @param  item  Item to remove.</a>
<a name="ln1889">void tv_dict_item_remove(dict_T *const dict, dictitem_T *const item)</a>
<a name="ln1890">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1891">{</a>
<a name="ln1892">  hashitem_T *const hi = hash_find(&amp;dict-&gt;dv_hashtab, (char *)item-&gt;di_key);</a>
<a name="ln1893">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln1894">    semsg(_(e_intern2), &quot;tv_dict_item_remove()&quot;);</a>
<a name="ln1895">  } else {</a>
<a name="ln1896">    hash_remove(&amp;dict-&gt;dv_hashtab, hi);</a>
<a name="ln1897">  }</a>
<a name="ln1898">  tv_dict_item_free(item);</a>
<a name="ln1899">}</a>
<a name="ln1900"> </a>
<a name="ln1901">//{{{2 Alloc/free</a>
<a name="ln1902"> </a>
<a name="ln1903">/// Allocate an empty dictionary.</a>
<a name="ln1904">/// Caller should take care of the reference count.</a>
<a name="ln1905">///</a>
<a name="ln1906">/// @return [allocated] new dictionary.</a>
<a name="ln1907">dict_T *tv_dict_alloc(void)</a>
<a name="ln1908">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1909">{</a>
<a name="ln1910">  dict_T *const d = xcalloc(1, sizeof(dict_T));</a>
<a name="ln1911"> </a>
<a name="ln1912">  // Add the dict to the list of dicts for garbage collection.</a>
<a name="ln1913">  if (gc_first_dict != NULL) {</a>
<a name="ln1914">    gc_first_dict-&gt;dv_used_prev = d;</a>
<a name="ln1915">  }</a>
<a name="ln1916">  d-&gt;dv_used_next = gc_first_dict;</a>
<a name="ln1917">  d-&gt;dv_used_prev = NULL;</a>
<a name="ln1918">  gc_first_dict = d;</a>
<a name="ln1919"> </a>
<a name="ln1920">  hash_init(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1921">  d-&gt;dv_lock = VAR_UNLOCKED;</a>
<a name="ln1922">  d-&gt;dv_scope = VAR_NO_SCOPE;</a>
<a name="ln1923">  d-&gt;dv_refcount = 0;</a>
<a name="ln1924">  d-&gt;dv_copyID = 0;</a>
<a name="ln1925">  QUEUE_INIT(&amp;d-&gt;watchers);</a>
<a name="ln1926"> </a>
<a name="ln1927">  d-&gt;lua_table_ref = LUA_NOREF;</a>
<a name="ln1928"> </a>
<a name="ln1929">  return d;</a>
<a name="ln1930">}</a>
<a name="ln1931"> </a>
<a name="ln1932">/// Free items contained in a dictionary</a>
<a name="ln1933">///</a>
<a name="ln1934">/// @param[in,out]  d  Dictionary to clear.</a>
<a name="ln1935">void tv_dict_free_contents(dict_T *const d)</a>
<a name="ln1936">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1937">{</a>
<a name="ln1938">  // Lock the hashtab, we don't want it to resize while freeing items.</a>
<a name="ln1939">  hash_lock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1940">  assert(d-&gt;dv_hashtab.ht_locked &gt; 0);</a>
<a name="ln1941">  HASHTAB_ITER(&amp;d-&gt;dv_hashtab, hi, {</a>
<a name="ln1942">    // Remove the item before deleting it, just in case there is</a>
<a name="ln1943">    // something recursive causing trouble.</a>
<a name="ln1944">    dictitem_T *const di = TV_DICT_HI2DI(hi);</a>
<a name="ln1945">    hash_remove(&amp;d-&gt;dv_hashtab, hi);</a>
<a name="ln1946">    tv_dict_item_free(di);</a>
<a name="ln1947">  });</a>
<a name="ln1948"> </a>
<a name="ln1949">  while (!QUEUE_EMPTY(&amp;d-&gt;watchers)) {</a>
<a name="ln1950">    QUEUE *w = QUEUE_HEAD(&amp;d-&gt;watchers);</a>
<a name="ln1951">    QUEUE_REMOVE(w);</a>
<a name="ln1952">    DictWatcher *watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1953">    tv_dict_watcher_free(watcher);</a>
<a name="ln1954">  }</a>
<a name="ln1955"> </a>
<a name="ln1956">  hash_clear(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1957">  d-&gt;dv_hashtab.ht_locked--;</a>
<a name="ln1958">  hash_init(&amp;d-&gt;dv_hashtab);</a>
<a name="ln1959">}</a>
<a name="ln1960"> </a>
<a name="ln1961">/// Free a dictionary itself, ignoring items it contains</a>
<a name="ln1962">///</a>
<a name="ln1963">/// Ignores the reference count.</a>
<a name="ln1964">///</a>
<a name="ln1965">/// @param[in,out]  d  Dictionary to free.</a>
<a name="ln1966">void tv_dict_free_dict(dict_T *const d)</a>
<a name="ln1967">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1968">{</a>
<a name="ln1969">  // Remove the dict from the list of dicts for garbage collection.</a>
<a name="ln1970">  if (d-&gt;dv_used_prev == NULL) {</a>
<a name="ln1971">    gc_first_dict = d-&gt;dv_used_next;</a>
<a name="ln1972">  } else {</a>
<a name="ln1973">    d-&gt;dv_used_prev-&gt;dv_used_next = d-&gt;dv_used_next;</a>
<a name="ln1974">  }</a>
<a name="ln1975">  if (d-&gt;dv_used_next != NULL) {</a>
<a name="ln1976">    d-&gt;dv_used_next-&gt;dv_used_prev = d-&gt;dv_used_prev;</a>
<a name="ln1977">  }</a>
<a name="ln1978"> </a>
<a name="ln1979">  NLUA_CLEAR_REF(d-&gt;lua_table_ref);</a>
<a name="ln1980">  xfree(d);</a>
<a name="ln1981">}</a>
<a name="ln1982"> </a>
<a name="ln1983">/// Free a dictionary, including all items it contains</a>
<a name="ln1984">///</a>
<a name="ln1985">/// Ignores the reference count.</a>
<a name="ln1986">///</a>
<a name="ln1987">/// @param  d  Dictionary to free.</a>
<a name="ln1988">void tv_dict_free(dict_T *const d)</a>
<a name="ln1989">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1990">{</a>
<a name="ln1991">  if (!tv_in_free_unref_items) {</a>
<a name="ln1992">    tv_dict_free_contents(d);</a>
<a name="ln1993">    tv_dict_free_dict(d);</a>
<a name="ln1994">  }</a>
<a name="ln1995">}</a>
<a name="ln1996"> </a>
<a name="ln1997">/// Unreference a dictionary</a>
<a name="ln1998">///</a>
<a name="ln1999">/// Decrements the reference count and frees dictionary when it becomes zero.</a>
<a name="ln2000">///</a>
<a name="ln2001">/// @param[in]  d  Dictionary to operate on.</a>
<a name="ln2002">void tv_dict_unref(dict_T *const d)</a>
<a name="ln2003">{</a>
<a name="ln2004">  if (d != NULL &amp;&amp; --d-&gt;dv_refcount &lt;= 0) {</a>
<a name="ln2005">    tv_dict_free(d);</a>
<a name="ln2006">  }</a>
<a name="ln2007">}</a>
<a name="ln2008"> </a>
<a name="ln2009">//{{{2 Indexing/searching</a>
<a name="ln2010"> </a>
<a name="ln2011">/// Find item in dictionary</a>
<a name="ln2012">///</a>
<a name="ln2013">/// @param[in]  d  Dictionary to check.</a>
<a name="ln2014">/// @param[in]  key  Dictionary key.</a>
<a name="ln2015">/// @param[in]  len  Key length. If negative, then strlen(key) is used.</a>
<a name="ln2016">///</a>
<a name="ln2017">/// @return found item or NULL if nothing was found.</a>
<a name="ln2018">dictitem_T *tv_dict_find(const dict_T *const d, const char *const key, const ptrdiff_t len)</a>
<a name="ln2019">  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2020">{</a>
<a name="ln2021">  if (d == NULL) {</a>
<a name="ln2022">    return NULL;</a>
<a name="ln2023">  }</a>
<a name="ln2024">  hashitem_T *const hi = (len &lt; 0</a>
<a name="ln2025">                          ? hash_find(&amp;d-&gt;dv_hashtab, key)</a>
<a name="ln2026">                          : hash_find_len(&amp;d-&gt;dv_hashtab, key, (size_t)len));</a>
<a name="ln2027">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln2028">    return NULL;</a>
<a name="ln2029">  }</a>
<a name="ln2030">  return TV_DICT_HI2DI(hi);</a>
<a name="ln2031">}</a>
<a name="ln2032"> </a>
<a name="ln2033">/// Get a typval item from a dictionary and copy it into &quot;rettv&quot;.</a>
<a name="ln2034">///</a>
<a name="ln2035">/// @param[in]  d  Dictionary to check.</a>
<a name="ln2036">/// @param[in]  key  Dictionary key.</a>
<a name="ln2037">/// @param[in]  rettv  Return value.</a>
<a name="ln2038">/// @return OK in case of success or FAIL if nothing was found.</a>
<a name="ln2039">int tv_dict_get_tv(dict_T *d, const char *const key, typval_T *rettv)</a>
<a name="ln2040">{</a>
<a name="ln2041">  dictitem_T *const di = tv_dict_find(d, key, -1);</a>
<a name="ln2042">  if (di == NULL) {</a>
<a name="ln2043">    return FAIL;</a>
<a name="ln2044">  }</a>
<a name="ln2045"> </a>
<a name="ln2046">  tv_copy(&amp;di-&gt;di_tv, rettv);</a>
<a name="ln2047">  return OK;</a>
<a name="ln2048">}</a>
<a name="ln2049"> </a>
<a name="ln2050">/// Get a number item from a dictionary</a>
<a name="ln2051">///</a>
<a name="ln2052">/// Returns 0 if the entry does not exist.</a>
<a name="ln2053">///</a>
<a name="ln2054">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln2055">/// @param[in]  key  Key to find in dictionary.</a>
<a name="ln2056">///</a>
<a name="ln2057">/// @return Dictionary item.</a>
<a name="ln2058">varnumber_T tv_dict_get_number(const dict_T *const d, const char *const key)</a>
<a name="ln2059">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2060">{</a>
<a name="ln2061">  dictitem_T *const di = tv_dict_find(d, key, -1);</a>
<a name="ln2062">  if (di == NULL) {</a>
<a name="ln2063">    return 0;</a>
<a name="ln2064">  }</a>
<a name="ln2065">  return tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln2066">}</a>
<a name="ln2067"> </a>
<a name="ln2068">/// Converts a dict to an environment</a>
<a name="ln2069">char **tv_dict_to_env(dict_T *denv)</a>
<a name="ln2070">{</a>
<a name="ln2071">  size_t env_size = (size_t)tv_dict_len(denv);</a>
<a name="ln2072"> </a>
<a name="ln2073">  size_t i = 0;</a>
<a name="ln2074">  char **env = NULL;</a>
<a name="ln2075"> </a>
<a name="ln2076">  // + 1 for NULL</a>
<a name="ln2077">  env = xmalloc((env_size + 1) * sizeof(*env));</a>
<a name="ln2078"> </a>
<a name="ln2079">  TV_DICT_ITER(denv, var, {</a>
<a name="ln2080">    const char *str = tv_get_string(&amp;var-&gt;di_tv);</a>
<a name="ln2081">    assert(str);</a>
<a name="ln2082">    size_t len = STRLEN(var-&gt;di_key) + strlen(str) + strlen(&quot;=&quot;) + 1;</a>
<a name="ln2083">    env[i] = xmalloc(len);</a>
<a name="ln2084">    snprintf(env[i], len, &quot;%s=%s&quot;, (char *)var-&gt;di_key, str);</a>
<a name="ln2085">    i++;</a>
<a name="ln2086">  });</a>
<a name="ln2087"> </a>
<a name="ln2088">  // must be null terminated</a>
<a name="ln2089">  env[env_size] = NULL;</a>
<a name="ln2090">  return env;</a>
<a name="ln2091">}</a>
<a name="ln2092"> </a>
<a name="ln2093">/// Get a string item from a dictionary</a>
<a name="ln2094">///</a>
<a name="ln2095">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln2096">/// @param[in]  key  Dictionary key.</a>
<a name="ln2097">/// @param[in]  save  If true, returned string will be placed in the allocated</a>
<a name="ln2098">///                   memory.</a>
<a name="ln2099">///</a>
<a name="ln2100">/// @return NULL if key does not exist, empty string in case of type error,</a>
<a name="ln2101">///         string item value otherwise. If returned value is not NULL, it may</a>
<a name="ln2102">///         be allocated depending on `save` argument.</a>
<a name="ln2103">char *tv_dict_get_string(const dict_T *const d, const char *const key, const bool save)</a>
<a name="ln2104">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2105">{</a>
<a name="ln2106">  static char numbuf[NUMBUFLEN];</a>
<a name="ln2107">  const char *const s = tv_dict_get_string_buf(d, key, numbuf);</a>
<a name="ln2108">  if (save &amp;&amp; s != NULL) {</a>
<a name="ln2109">    return xstrdup(s);</a>
<a name="ln2110">  }</a>
<a name="ln2111">  return (char *)s;</a>
<a name="ln2112">}</a>
<a name="ln2113"> </a>
<a name="ln2114">/// Get a string item from a dictionary</a>
<a name="ln2115">///</a>
<a name="ln2116">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln2117">/// @param[in]  key  Dictionary key.</a>
<a name="ln2118">/// @param[in]  numbuf  Buffer for non-string items converted to strings, at</a>
<a name="ln2119">///                     least of #NUMBUFLEN length.</a>
<a name="ln2120">///</a>
<a name="ln2121">/// @return NULL if key does not exist, empty string in case of type error,</a>
<a name="ln2122">///         string item value otherwise.</a>
<a name="ln2123">const char *tv_dict_get_string_buf(const dict_T *const d, const char *const key, char *const numbuf)</a>
<a name="ln2124">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2125">{</a>
<a name="ln2126">  const dictitem_T *const di = tv_dict_find(d, key, -1);</a>
<a name="ln2127">  if (di == NULL) {</a>
<a name="ln2128">    return NULL;</a>
<a name="ln2129">  }</a>
<a name="ln2130">  return tv_get_string_buf(&amp;di-&gt;di_tv, numbuf);</a>
<a name="ln2131">}</a>
<a name="ln2132"> </a>
<a name="ln2133">/// Get a string item from a dictionary</a>
<a name="ln2134">///</a>
<a name="ln2135">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln2136">/// @param[in]  key  Dictionary key.</a>
<a name="ln2137">/// @param[in]  key_len  Key length.</a>
<a name="ln2138">/// @param[in]  numbuf  Buffer for non-string items converted to strings, at</a>
<a name="ln2139">///                     least of #NUMBUFLEN length.</a>
<a name="ln2140">/// @param[in]  def  Default return when key does not exist.</a>
<a name="ln2141">///</a>
<a name="ln2142">/// @return `def` when key does not exist,</a>
<a name="ln2143">///         NULL in case of type error,</a>
<a name="ln2144">///         string item value in case of success.</a>
<a name="ln2145">const char *tv_dict_get_string_buf_chk(const dict_T *const d, const char *const key,</a>
<a name="ln2146">                                       const ptrdiff_t key_len, char *const numbuf,</a>
<a name="ln2147">                                       const char *const def)</a>
<a name="ln2148">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2149">{</a>
<a name="ln2150">  const dictitem_T *const di = tv_dict_find(d, key, key_len);</a>
<a name="ln2151">  if (di == NULL) {</a>
<a name="ln2152">    return def;</a>
<a name="ln2153">  }</a>
<a name="ln2154">  return tv_get_string_buf_chk(&amp;di-&gt;di_tv, numbuf);</a>
<a name="ln2155">}</a>
<a name="ln2156"> </a>
<a name="ln2157">/// Get a function from a dictionary</a>
<a name="ln2158">///</a>
<a name="ln2159">/// @param[in]  d  Dictionary to get callback from.</a>
<a name="ln2160">/// @param[in]  key  Dictionary key.</a>
<a name="ln2161">/// @param[in]  key_len  Key length, may be -1 to use strlen().</a>
<a name="ln2162">/// @param[out]  result  The address where a pointer to the wanted callback</a>
<a name="ln2163">///                      will be left.</a>
<a name="ln2164">///</a>
<a name="ln2165">/// @return true/false on success/failure.</a>
<a name="ln2166">bool tv_dict_get_callback(dict_T *const d, const char *const key, const ptrdiff_t key_len,</a>
<a name="ln2167">                          Callback *const result)</a>
<a name="ln2168">  FUNC_ATTR_NONNULL_ARG(2, 4) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2169">{</a>
<a name="ln2170">  result-&gt;type = kCallbackNone;</a>
<a name="ln2171"> </a>
<a name="ln2172">  dictitem_T *const di = tv_dict_find(d, key, key_len);</a>
<a name="ln2173"> </a>
<a name="ln2174">  if (di == NULL) {</a>
<a name="ln2175">    return true;</a>
<a name="ln2176">  }</a>
<a name="ln2177"> </a>
<a name="ln2178">  if (!tv_is_func(di-&gt;di_tv) &amp;&amp; di-&gt;di_tv.v_type != VAR_STRING) {</a>
<a name="ln2179">    emsg(_(&quot;E6000: Argument is not a function or function name&quot;));</a>
<a name="ln2180">    return false;</a>
<a name="ln2181">  }</a>
<a name="ln2182"> </a>
<a name="ln2183">  typval_T tv;</a>
<a name="ln2184">  tv_copy(&amp;di-&gt;di_tv, &amp;tv);</a>
<a name="ln2185">  set_selfdict(&amp;tv, d);</a>
<a name="ln2186">  const bool res = callback_from_typval(result, &amp;tv);</a>
<a name="ln2187">  tv_clear(&amp;tv);</a>
<a name="ln2188">  return res;</a>
<a name="ln2189">}</a>
<a name="ln2190"> </a>
<a name="ln2191">//{{{2 dict_add*</a>
<a name="ln2192"> </a>
<a name="ln2193">/// Add item to dictionary</a>
<a name="ln2194">///</a>
<a name="ln2195">/// @param[out]  d  Dictionary to add to.</a>
<a name="ln2196">/// @param[in]  item  Item to add.</a>
<a name="ln2197">///</a>
<a name="ln2198">/// @return FAIL if key already exists.</a>
<a name="ln2199">int tv_dict_add(dict_T *const d, dictitem_T *const item)</a>
<a name="ln2200">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2201">{</a>
<a name="ln2202">  return hash_add(&amp;d-&gt;dv_hashtab, item-&gt;di_key);</a>
<a name="ln2203">}</a>
<a name="ln2204"> </a>
<a name="ln2205">/// Add a list entry to dictionary</a>
<a name="ln2206">///</a>
<a name="ln2207">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2208">/// @param[in]  key  Key to add.</a>
<a name="ln2209">/// @param[in]  key_len  Key length.</a>
<a name="ln2210">/// @param  list  List to add. Will have reference count incremented.</a>
<a name="ln2211">///</a>
<a name="ln2212">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2213">int tv_dict_add_list(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2214">                     list_T *const list)</a>
<a name="ln2215">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2216">{</a>
<a name="ln2217">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2218"> </a>
<a name="ln2219">  item-&gt;di_tv.v_type = VAR_LIST;</a>
<a name="ln2220">  item-&gt;di_tv.vval.v_list = list;</a>
<a name="ln2221">  tv_list_ref(list);</a>
<a name="ln2222">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2223">    tv_dict_item_free(item);</a>
<a name="ln2224">    return FAIL;</a>
<a name="ln2225">  }</a>
<a name="ln2226">  return OK;</a>
<a name="ln2227">}</a>
<a name="ln2228"> </a>
<a name="ln2229">/// Add a typval entry to dictionary.</a>
<a name="ln2230">///</a>
<a name="ln2231">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2232">/// @param[in]  key  Key to add.</a>
<a name="ln2233">/// @param[in]  key_len  Key length.</a>
<a name="ln2234">///</a>
<a name="ln2235">/// @return FAIL if out of memory or key already exists.</a>
<a name="ln2236">int tv_dict_add_tv(dict_T *d, const char *key, const size_t key_len, typval_T *tv)</a>
<a name="ln2237">{</a>
<a name="ln2238">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2239"> </a>
<a name="ln2240">  tv_copy(tv, &amp;item-&gt;di_tv);</a>
<a name="ln2241">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2242">    tv_dict_item_free(item);</a>
<a name="ln2243">    return FAIL;</a>
<a name="ln2244">  }</a>
<a name="ln2245">  return OK;</a>
<a name="ln2246">}</a>
<a name="ln2247"> </a>
<a name="ln2248">/// Add a dictionary entry to dictionary</a>
<a name="ln2249">///</a>
<a name="ln2250">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2251">/// @param[in]  key  Key to add.</a>
<a name="ln2252">/// @param[in]  key_len  Key length.</a>
<a name="ln2253">/// @param  dict  Dictionary to add. Will have reference count incremented.</a>
<a name="ln2254">///</a>
<a name="ln2255">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2256">int tv_dict_add_dict(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2257">                     dict_T *const dict)</a>
<a name="ln2258">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2259">{</a>
<a name="ln2260">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2261"> </a>
<a name="ln2262">  item-&gt;di_tv.v_type = VAR_DICT;</a>
<a name="ln2263">  item-&gt;di_tv.vval.v_dict = dict;</a>
<a name="ln2264">  dict-&gt;dv_refcount++;</a>
<a name="ln2265">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2266">    tv_dict_item_free(item);</a>
<a name="ln2267">    return FAIL;</a>
<a name="ln2268">  }</a>
<a name="ln2269">  return OK;</a>
<a name="ln2270">}</a>
<a name="ln2271"> </a>
<a name="ln2272">/// Add a number entry to dictionary</a>
<a name="ln2273">///</a>
<a name="ln2274">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2275">/// @param[in]  key  Key to add.</a>
<a name="ln2276">/// @param[in]  key_len  Key length.</a>
<a name="ln2277">/// @param[in]  nr  Number to add.</a>
<a name="ln2278">///</a>
<a name="ln2279">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2280">int tv_dict_add_nr(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2281">                   const varnumber_T nr)</a>
<a name="ln2282">{</a>
<a name="ln2283">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2284"> </a>
<a name="ln2285">  item-&gt;di_tv.v_type = VAR_NUMBER;</a>
<a name="ln2286">  item-&gt;di_tv.vval.v_number = nr;</a>
<a name="ln2287">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2288">    tv_dict_item_free(item);</a>
<a name="ln2289">    return FAIL;</a>
<a name="ln2290">  }</a>
<a name="ln2291">  return OK;</a>
<a name="ln2292">}</a>
<a name="ln2293"> </a>
<a name="ln2294">/// Add a floating point number entry to dictionary</a>
<a name="ln2295">///</a>
<a name="ln2296">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2297">/// @param[in]  key  Key to add.</a>
<a name="ln2298">/// @param[in]  key_len  Key length.</a>
<a name="ln2299">/// @param[in]  nr  Floating point number to add.</a>
<a name="ln2300">///</a>
<a name="ln2301">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2302">int tv_dict_add_float(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2303">                      const float_T nr)</a>
<a name="ln2304">{</a>
<a name="ln2305">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2306"> </a>
<a name="ln2307">  item-&gt;di_tv.v_type = VAR_FLOAT;</a>
<a name="ln2308">  item-&gt;di_tv.vval.v_float = nr;</a>
<a name="ln2309">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2310">    tv_dict_item_free(item);</a>
<a name="ln2311">    return FAIL;</a>
<a name="ln2312">  }</a>
<a name="ln2313">  return OK;</a>
<a name="ln2314">}</a>
<a name="ln2315"> </a>
<a name="ln2316">/// Add a boolean entry to dictionary</a>
<a name="ln2317">///</a>
<a name="ln2318">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2319">/// @param[in]  key  Key to add.</a>
<a name="ln2320">/// @param[in]  key_len  Key length.</a>
<a name="ln2321">/// @param[in]  val BoolVarValue to add.</a>
<a name="ln2322">///</a>
<a name="ln2323">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2324">int tv_dict_add_bool(dict_T *const d, const char *const key, const size_t key_len, BoolVarValue val)</a>
<a name="ln2325">{</a>
<a name="ln2326">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2327"> </a>
<a name="ln2328">  item-&gt;di_tv.v_type = VAR_BOOL;</a>
<a name="ln2329">  item-&gt;di_tv.vval.v_bool = val;</a>
<a name="ln2330">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2331">    tv_dict_item_free(item);</a>
<a name="ln2332">    return FAIL;</a>
<a name="ln2333">  }</a>
<a name="ln2334">  return OK;</a>
<a name="ln2335">}</a>
<a name="ln2336"> </a>
<a name="ln2337">/// Add a string entry to dictionary</a>
<a name="ln2338">///</a>
<a name="ln2339">/// @see tv_dict_add_allocated_str</a>
<a name="ln2340">int tv_dict_add_str(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2341">                    const char *const val)</a>
<a name="ln2342">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln2343">{</a>
<a name="ln2344">  return tv_dict_add_str_len(d, key, key_len, val, -1);</a>
<a name="ln2345">}</a>
<a name="ln2346"> </a>
<a name="ln2347">/// Add a string entry to dictionary</a>
<a name="ln2348">///</a>
<a name="ln2349">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2350">/// @param[in]  key  Key to add.</a>
<a name="ln2351">/// @param[in]  key_len  Key length.</a>
<a name="ln2352">/// @param[in]  val  String to add. NULL adds empty string.</a>
<a name="ln2353">/// @param[in]  len  Use this many bytes from `val`, or -1 for whole string.</a>
<a name="ln2354">///</a>
<a name="ln2355">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2356">int tv_dict_add_str_len(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2357">                        const char *const val, int len)</a>
<a name="ln2358">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln2359">{</a>
<a name="ln2360">  char *s = NULL;</a>
<a name="ln2361">  if (val != NULL) {</a>
<a name="ln2362">    s = (len &lt; 0) ? xstrdup(val) : xstrndup(val, (size_t)len);</a>
<a name="ln2363">  }</a>
<a name="ln2364">  return tv_dict_add_allocated_str(d, key, key_len, s);</a>
<a name="ln2365">}</a>
<a name="ln2366"> </a>
<a name="ln2367">/// Add a string entry to dictionary</a>
<a name="ln2368">///</a>
<a name="ln2369">/// Unlike tv_dict_add_str() saves val to the new dictionary item in place of</a>
<a name="ln2370">/// creating a new copy.</a>
<a name="ln2371">///</a>
<a name="ln2372">/// @warning String will be freed even in case addition fails.</a>
<a name="ln2373">///</a>
<a name="ln2374">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2375">/// @param[in]  key  Key to add.</a>
<a name="ln2376">/// @param[in]  key_len  Key length.</a>
<a name="ln2377">/// @param[in]  val  String to add.</a>
<a name="ln2378">///</a>
<a name="ln2379">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2380">int tv_dict_add_allocated_str(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2381">                              char *const val)</a>
<a name="ln2382">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln2383">{</a>
<a name="ln2384">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2385"> </a>
<a name="ln2386">  item-&gt;di_tv.v_type = VAR_STRING;</a>
<a name="ln2387">  item-&gt;di_tv.vval.v_string = val;</a>
<a name="ln2388">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2389">    tv_dict_item_free(item);</a>
<a name="ln2390">    return FAIL;</a>
<a name="ln2391">  }</a>
<a name="ln2392">  return OK;</a>
<a name="ln2393">}</a>
<a name="ln2394"> </a>
<a name="ln2395">//{{{2 Operations on the whole dict</a>
<a name="ln2396"> </a>
<a name="ln2397">/// Clear all the keys of a Dictionary. &quot;d&quot; remains a valid empty Dictionary.</a>
<a name="ln2398">///</a>
<a name="ln2399">/// @param  d  The Dictionary to clear</a>
<a name="ln2400">void tv_dict_clear(dict_T *const d)</a>
<a name="ln2401">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2402">{</a>
<a name="ln2403">  hash_lock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln2404">  assert(d-&gt;dv_hashtab.ht_locked &gt; 0);</a>
<a name="ln2405"> </a>
<a name="ln2406">  HASHTAB_ITER(&amp;d-&gt;dv_hashtab, hi, {</a>
<a name="ln2407">    tv_dict_item_free(TV_DICT_HI2DI(hi));</a>
<a name="ln2408">    hash_remove(&amp;d-&gt;dv_hashtab, hi);</a>
<a name="ln2409">  });</a>
<a name="ln2410"> </a>
<a name="ln2411">  hash_unlock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln2412">}</a>
<a name="ln2413"> </a>
<a name="ln2414">/// Extend dictionary with items from another dictionary</a>
<a name="ln2415">///</a>
<a name="ln2416">/// @param  d1  Dictionary to extend.</a>
<a name="ln2417">/// @param[in]  d2  Dictionary to extend with.</a>
<a name="ln2418">/// @param[in]  action  &quot;error&quot;, &quot;force&quot;, &quot;keep&quot;:</a>
<a name="ln2419">///</a>
<a name="ln2420">///                     e*, including &quot;error&quot;: duplicate key gives an error.</a>
<a name="ln2421">///                     f*, including &quot;force&quot;: duplicate d2 keys override d1.</a>
<a name="ln2422">///                     other, including &quot;keep&quot;: duplicate d2 keys ignored.</a>
<a name="ln2423">void tv_dict_extend(dict_T *const d1, dict_T *const d2, const char *const action)</a>
<a name="ln2424">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2425">{</a>
<a name="ln2426">  const bool watched = tv_dict_is_watched(d1);</a>
<a name="ln2427">  const char *const arg_errmsg = _(&quot;extend() argument&quot;);</a>
<a name="ln2428">  const size_t arg_errmsg_len = strlen(arg_errmsg);</a>
<a name="ln2429"> </a>
<a name="ln2430">  TV_DICT_ITER(d2, di2, {</a>
<a name="ln2431">    dictitem_T *const di1 = tv_dict_find(d1, (const char *)di2-&gt;di_key, -1);</a>
<a name="ln2432">    if (d1-&gt;dv_scope != VAR_NO_SCOPE) {</a>
<a name="ln2433">      // Disallow replacing a builtin function in l: and g:.</a>
<a name="ln2434">      // Check the key to be valid when adding to any scope.</a>
<a name="ln2435">      if (d1-&gt;dv_scope == VAR_DEF_SCOPE</a>
<a name="ln2436">          &amp;&amp; tv_is_func(di2-&gt;di_tv)</a>
<a name="ln2437">          &amp;&amp; !var_check_func_name((const char *)di2-&gt;di_key, di1 == NULL)) {</a>
<a name="ln2438">        break;</a>
<a name="ln2439">      }</a>
<a name="ln2440">      if (!valid_varname((const char *)di2-&gt;di_key)) {</a>
<a name="ln2441">        break;</a>
<a name="ln2442">      }</a>
<a name="ln2443">    }</a>
<a name="ln2444">    if (di1 == NULL) {</a>
<a name="ln2445">      dictitem_T *const new_di = tv_dict_item_copy(di2);</a>
<a name="ln2446">      if (tv_dict_add(d1, new_di) == FAIL) {</a>
<a name="ln2447">        tv_dict_item_free(new_di);</a>
<a name="ln2448">      } else if (watched) {</a>
<a name="ln2449">        tv_dict_watcher_notify(d1, (const char *)new_di-&gt;di_key, &amp;new_di-&gt;di_tv,</a>
<a name="ln2450">                               NULL);</a>
<a name="ln2451">      }</a>
<a name="ln2452">    } else if (*action == 'e') {</a>
<a name="ln2453">      semsg(_(&quot;E737: Key already exists: %s&quot;), di2-&gt;di_key);</a>
<a name="ln2454">      break;</a>
<a name="ln2455">    } else if (*action == 'f' &amp;&amp; di2 != di1) {</a>
<a name="ln2456">      typval_T oldtv;</a>
<a name="ln2457"> </a>
<a name="ln2458">      if (var_check_lock(di1-&gt;di_tv.v_lock, arg_errmsg, arg_errmsg_len)</a>
<a name="ln2459">          || var_check_ro(di1-&gt;di_flags, arg_errmsg, arg_errmsg_len)) {</a>
<a name="ln2460">        break;</a>
<a name="ln2461">      }</a>
<a name="ln2462"> </a>
<a name="ln2463">      if (watched) {</a>
<a name="ln2464">        tv_copy(&amp;di1-&gt;di_tv, &amp;oldtv);</a>
<a name="ln2465">      }</a>
<a name="ln2466"> </a>
<a name="ln2467">      tv_clear(&amp;di1-&gt;di_tv);</a>
<a name="ln2468">      tv_copy(&amp;di2-&gt;di_tv, &amp;di1-&gt;di_tv);</a>
<a name="ln2469"> </a>
<a name="ln2470">      if (watched) {</a>
<a name="ln2471">        tv_dict_watcher_notify(d1, (const char *)di1-&gt;di_key, &amp;di1-&gt;di_tv,</a>
<a name="ln2472">                               &amp;oldtv);</a>
<a name="ln2473">        tv_clear(&amp;oldtv);</a>
<a name="ln2474">      }</a>
<a name="ln2475">    }</a>
<a name="ln2476">  });</a>
<a name="ln2477">}</a>
<a name="ln2478"> </a>
<a name="ln2479">/// Compare two dictionaries</a>
<a name="ln2480">///</a>
<a name="ln2481">/// @param[in]  d1  First dictionary.</a>
<a name="ln2482">/// @param[in]  d2  Second dictionary.</a>
<a name="ln2483">/// @param[in]  ic  True if case is to be ignored.</a>
<a name="ln2484">/// @param[in]  recursive  True when used recursively.</a>
<a name="ln2485">bool tv_dict_equal(dict_T *const d1, dict_T *const d2, const bool ic, const bool recursive)</a>
<a name="ln2486">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2487">{</a>
<a name="ln2488">  if (d1 == d2) {</a>
<a name="ln2489">    return true;</a>
<a name="ln2490">  }</a>
<a name="ln2491">  if (d1 == NULL || d2 == NULL) {</a>
<a name="ln2492">    return false;</a>
<a name="ln2493">  }</a>
<a name="ln2494">  if (tv_dict_len(d1) != tv_dict_len(d2)) {</a>
<a name="ln2495">    return false;</a>
<a name="ln2496">  }</a>
<a name="ln2497"> </a>
<a name="ln2498">  TV_DICT_ITER(d1, di1, {</a>
<a name="ln2499">    dictitem_T *const di2 = tv_dict_find(d2, (const char *)di1-&gt;di_key, -1);</a>
<a name="ln2500">    if (di2 == NULL) {</a>
<a name="ln2501">      return false;</a>
<a name="ln2502">    }</a>
<a name="ln2503">    if (!tv_equal(&amp;di1-&gt;di_tv, &amp;di2-&gt;di_tv, ic, recursive)) {</a>
<a name="ln2504">      return false;</a>
<a name="ln2505">    }</a>
<a name="ln2506">  });</a>
<a name="ln2507">  return true;</a>
<a name="ln2508">}</a>
<a name="ln2509"> </a>
<a name="ln2510">/// Make a copy of dictionary</a>
<a name="ln2511">///</a>
<a name="ln2512">/// @param[in]  conv  If non-NULL, then all internal strings will be converted.</a>
<a name="ln2513">/// @param[in]  orig  Original dictionary to copy.</a>
<a name="ln2514">/// @param[in]  deep  If false, then shallow copy will be done.</a>
<a name="ln2515">/// @param[in]  copyID  See var_item_copy().</a>
<a name="ln2516">///</a>
<a name="ln2517">/// @return Copied dictionary. May be NULL in case original dictionary is NULL</a>
<a name="ln2518">///         or some failure happens. The refcount of the new dictionary is set</a>
<a name="ln2519">///         to 1.</a>
<a name="ln2520">dict_T *tv_dict_copy(const vimconv_T *const conv, dict_T *const orig, const bool deep,</a>
<a name="ln2521">                     const int copyID)</a>
<a name="ln2522">{</a>
<a name="ln2523">  if (orig == NULL) {</a>
<a name="ln2524">    return NULL;</a>
<a name="ln2525">  }</a>
<a name="ln2526"> </a>
<a name="ln2527">  dict_T *copy = tv_dict_alloc();</a>
<a name="ln2528">  if (copyID != 0) {</a>
<a name="ln2529">    orig-&gt;dv_copyID = copyID;</a>
<a name="ln2530">    orig-&gt;dv_copydict = copy;</a>
<a name="ln2531">  }</a>
<a name="ln2532">  TV_DICT_ITER(orig, di, {</a>
<a name="ln2533">    if (got_int) {</a>
<a name="ln2534">      break;</a>
<a name="ln2535">    }</a>
<a name="ln2536">    dictitem_T *new_di;</a>
<a name="ln2537">    if (conv == NULL || conv-&gt;vc_type == CONV_NONE) {</a>
<a name="ln2538">      new_di = tv_dict_item_alloc((const char *)di-&gt;di_key);</a>
<a name="ln2539">    } else {</a>
<a name="ln2540">      size_t len = STRLEN(di-&gt;di_key);</a>
<a name="ln2541">      char *const key = (char *)string_convert(conv, (char *)di-&gt;di_key, &amp;len);</a>
<a name="ln2542">      if (key == NULL) {</a>
<a name="ln2543">        new_di = tv_dict_item_alloc_len((const char *)di-&gt;di_key, len);</a>
<a name="ln2544">      } else {</a>
<a name="ln2545">        new_di = tv_dict_item_alloc_len(key, len);</a>
<a name="ln2546">        xfree(key);</a>
<a name="ln2547">      }</a>
<a name="ln2548">    }</a>
<a name="ln2549">    if (deep) {</a>
<a name="ln2550">      if (var_item_copy(conv, &amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv, deep,</a>
<a name="ln2551">                        copyID) == FAIL) {</a>
<a name="ln2552">        xfree(new_di);</a>
<a name="ln2553">        break;</a>
<a name="ln2554">      }</a>
<a name="ln2555">    } else {</a>
<a name="ln2556">      tv_copy(&amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv);</a>
<a name="ln2557">    }</a>
<a name="ln2558">    if (tv_dict_add(copy, new_di) == FAIL) {</a>
<a name="ln2559">      tv_dict_item_free(new_di);</a>
<a name="ln2560">      break;</a>
<a name="ln2561">    }</a>
<a name="ln2562">  });</a>
<a name="ln2563"> </a>
<a name="ln2564">  copy-&gt;dv_refcount++;</a>
<a name="ln2565">  if (got_int) {</a>
<a name="ln2566">    tv_dict_unref(copy);</a>
<a name="ln2567">    copy = NULL;</a>
<a name="ln2568">  }</a>
<a name="ln2569"> </a>
<a name="ln2570">  return copy;</a>
<a name="ln2571">}</a>
<a name="ln2572"> </a>
<a name="ln2573">/// Set all existing keys in &quot;dict&quot; as read-only.</a>
<a name="ln2574">///</a>
<a name="ln2575">/// This does not protect against adding new keys to the Dictionary.</a>
<a name="ln2576">///</a>
<a name="ln2577">/// @param  dict  The dict whose keys should be frozen.</a>
<a name="ln2578">void tv_dict_set_keys_readonly(dict_T *const dict)</a>
<a name="ln2579">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2580">{</a>
<a name="ln2581">  TV_DICT_ITER(dict, di, {</a>
<a name="ln2582">    di-&gt;di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln2583">  });</a>
<a name="ln2584">}</a>
<a name="ln2585"> </a>
<a name="ln2586">//{{{1 Blobs</a>
<a name="ln2587">//{{{2 Alloc/free</a>
<a name="ln2588"> </a>
<a name="ln2589">/// Allocate an empty blob.</a>
<a name="ln2590">///</a>
<a name="ln2591">/// Caller should take care of the reference count.</a>
<a name="ln2592">///</a>
<a name="ln2593">/// @return [allocated] new blob.</a>
<a name="ln2594">blob_T *tv_blob_alloc(void)</a>
<a name="ln2595">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln2596">{</a>
<a name="ln2597">  blob_T *const blob = xcalloc(1, sizeof(blob_T));</a>
<a name="ln2598">  ga_init(&amp;blob-&gt;bv_ga, 1, 100);</a>
<a name="ln2599">  return blob;</a>
<a name="ln2600">}</a>
<a name="ln2601"> </a>
<a name="ln2602">/// Free a blob. Ignores the reference count.</a>
<a name="ln2603">///</a>
<a name="ln2604">/// @param[in,out]  b  Blob to free.</a>
<a name="ln2605">void tv_blob_free(blob_T *const b)</a>
<a name="ln2606">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2607">{</a>
<a name="ln2608">  ga_clear(&amp;b-&gt;bv_ga);</a>
<a name="ln2609">  xfree(b);</a>
<a name="ln2610">}</a>
<a name="ln2611"> </a>
<a name="ln2612">/// Unreference a blob.</a>
<a name="ln2613">///</a>
<a name="ln2614">/// Decrements the reference count and frees blob when it becomes zero.</a>
<a name="ln2615">///</a>
<a name="ln2616">/// @param[in,out]  b  Blob to operate on.</a>
<a name="ln2617">void tv_blob_unref(blob_T *const b)</a>
<a name="ln2618">{</a>
<a name="ln2619">  if (b != NULL &amp;&amp; --b-&gt;bv_refcount &lt;= 0) {</a>
<a name="ln2620">    tv_blob_free(b);</a>
<a name="ln2621">  }</a>
<a name="ln2622">}</a>
<a name="ln2623"> </a>
<a name="ln2624">//{{{2 Operations on the whole blob</a>
<a name="ln2625"> </a>
<a name="ln2626">/// Check whether two blobs are equal.</a>
<a name="ln2627">///</a>
<a name="ln2628">/// @param[in]  b1  First blob.</a>
<a name="ln2629">/// @param[in]  b2  Second blob.</a>
<a name="ln2630">///</a>
<a name="ln2631">/// @return true if blobs are equal, false otherwise.</a>
<a name="ln2632">bool tv_blob_equal(const blob_T *const b1, const blob_T *const b2)</a>
<a name="ln2633">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2634">{</a>
<a name="ln2635">  const int len1 = tv_blob_len(b1);</a>
<a name="ln2636">  const int len2 = tv_blob_len(b2);</a>
<a name="ln2637"> </a>
<a name="ln2638">  // empty and NULL are considered the same</a>
<a name="ln2639">  if (len1 == 0 &amp;&amp; len2 == 0) {</a>
<a name="ln2640">    return true;</a>
<a name="ln2641">  }</a>
<a name="ln2642">  if (b1 == b2) {</a>
<a name="ln2643">    return true;</a>
<a name="ln2644">  }</a>
<a name="ln2645">  if (len1 != len2) {</a>
<a name="ln2646">    return false;</a>
<a name="ln2647">  }</a>
<a name="ln2648"> </a>
<a name="ln2649">  for (int i = 0; i &lt; b1-&gt;bv_ga.ga_len; i++) {</a>
<a name="ln2650">    if (tv_blob_get(b1, i) != tv_blob_get(b2, i)) {</a>
<a name="ln2651">      return false;</a>
<a name="ln2652">    }</a>
<a name="ln2653">  }</a>
<a name="ln2654">  return true;</a>
<a name="ln2655">}</a>
<a name="ln2656"> </a>
<a name="ln2657">/// &quot;remove({blob})&quot; function</a>
<a name="ln2658">void tv_blob_remove(typval_T *argvars, typval_T *rettv, const char *arg_errmsg)</a>
<a name="ln2659">{</a>
<a name="ln2660">  blob_T *const b = argvars[0].vval.v_blob;</a>
<a name="ln2661"> </a>
<a name="ln2662">  if (b != NULL &amp;&amp; var_check_lock(b-&gt;bv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2663">    return;</a>
<a name="ln2664">  }</a>
<a name="ln2665"> </a>
<a name="ln2666">  bool error = false;</a>
<a name="ln2667">  long idx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln2668"> </a>
<a name="ln2669">  if (!error) {</a>
<a name="ln2670">    const int len = tv_blob_len(b);</a>
<a name="ln2671"> </a>
<a name="ln2672">    if (idx &lt; 0) {</a>
<a name="ln2673">      // count from the end</a>
<a name="ln2674">      idx = len + idx;</a>
<a name="ln2675">    }</a>
<a name="ln2676">    if (idx &lt; 0 || idx &gt;= len) {</a>
<a name="ln2677">      semsg(_(e_blobidx), (int64_t)idx);</a>
<a name="ln2678">      return;</a>
<a name="ln2679">    }</a>
<a name="ln2680">    if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln2681">      // Remove one item, return its value.</a>
<a name="ln2682">      char_u *const p = (char_u *)b-&gt;bv_ga.ga_data;</a>
<a name="ln2683">      rettv-&gt;vval.v_number = (varnumber_T)(*(p + idx));</a>
<a name="ln2684">      memmove(p + idx, p + idx + 1, (size_t)(len - idx - 1));</a>
<a name="ln2685">      b-&gt;bv_ga.ga_len--;</a>
<a name="ln2686">    } else {</a>
<a name="ln2687">      // Remove range of items, return blob with values.</a>
<a name="ln2688">      long end = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2689">      if (error) {</a>
<a name="ln2690">        return;</a>
<a name="ln2691">      }</a>
<a name="ln2692">      if (end &lt; 0) {</a>
<a name="ln2693">        // count from the end</a>
<a name="ln2694">        end = len + end;</a>
<a name="ln2695">      }</a>
<a name="ln2696">      if (end &gt;= len || idx &gt; end) {</a>
<a name="ln2697">        semsg(_(e_blobidx), (int64_t)end);</a>
<a name="ln2698">        return;</a>
<a name="ln2699">      }</a>
<a name="ln2700">      blob_T *const blob = tv_blob_alloc();</a>
<a name="ln2701">      blob-&gt;bv_ga.ga_len = (int)(end - idx + 1);</a>
<a name="ln2702">      ga_grow(&amp;blob-&gt;bv_ga, (int)(end - idx + 1));</a>
<a name="ln2703"> </a>
<a name="ln2704">      char_u *const p = (char_u *)b-&gt;bv_ga.ga_data;</a>
<a name="ln2705">      memmove((char_u *)blob-&gt;bv_ga.ga_data, p + idx,</a>
<a name="ln2706">              (size_t)(end - idx + 1));</a>
<a name="ln2707">      tv_blob_set_ret(rettv, blob);</a>
<a name="ln2708"> </a>
<a name="ln2709">      if (len - end - 1 &gt; 0) {</a>
<a name="ln2710">        memmove(p + idx, p + end + 1, (size_t)(len - end - 1));</a>
<a name="ln2711">      }</a>
<a name="ln2712">      b-&gt;bv_ga.ga_len -= (int)(end - idx + 1);</a>
<a name="ln2713">    }</a>
<a name="ln2714">  }</a>
<a name="ln2715">}</a>
<a name="ln2716"> </a>
<a name="ln2717">//{{{1 Generic typval operations</a>
<a name="ln2718">//{{{2 Init/alloc/clear</a>
<a name="ln2719">//{{{3 Alloc</a>
<a name="ln2720"> </a>
<a name="ln2721">/// Allocate an empty list for a return value</a>
<a name="ln2722">///</a>
<a name="ln2723">/// Also sets reference count.</a>
<a name="ln2724">///</a>
<a name="ln2725">/// @param[out]  ret_tv  Structure where list is saved.</a>
<a name="ln2726">/// @param[in]  len  Expected number of items to be populated before list</a>
<a name="ln2727">///                  becomes accessible from VimL. It is still valid to</a>
<a name="ln2728">///                  underpopulate a list, value only controls how many elements</a>
<a name="ln2729">///                  will be allocated in advance. @see ListLenSpecials.</a>
<a name="ln2730">///</a>
<a name="ln2731">/// @return [allocated] pointer to the created list.</a>
<a name="ln2732">list_T *tv_list_alloc_ret(typval_T *const ret_tv, const ptrdiff_t len)</a>
<a name="ln2733">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln2734">{</a>
<a name="ln2735">  list_T *const l = tv_list_alloc(len);</a>
<a name="ln2736">  tv_list_set_ret(ret_tv, l);</a>
<a name="ln2737">  ret_tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2738">  return l;</a>
<a name="ln2739">}</a>
<a name="ln2740"> </a>
<a name="ln2741">dict_T *tv_dict_alloc_lock(VarLockStatus lock)</a>
<a name="ln2742">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln2743">{</a>
<a name="ln2744">  dict_T *const d = tv_dict_alloc();</a>
<a name="ln2745">  d-&gt;dv_lock = lock;</a>
<a name="ln2746">  return d;</a>
<a name="ln2747">}</a>
<a name="ln2748"> </a>
<a name="ln2749">/// Allocate an empty dictionary for a return value</a>
<a name="ln2750">///</a>
<a name="ln2751">/// Also sets reference count.</a>
<a name="ln2752">///</a>
<a name="ln2753">/// @param[out]  ret_tv  Structure where dictionary is saved.</a>
<a name="ln2754">void tv_dict_alloc_ret(typval_T *const ret_tv)</a>
<a name="ln2755">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2756">{</a>
<a name="ln2757">  dict_T *const d = tv_dict_alloc_lock(VAR_UNLOCKED);</a>
<a name="ln2758">  tv_dict_set_ret(ret_tv, d);</a>
<a name="ln2759">}</a>
<a name="ln2760"> </a>
<a name="ln2761">/// Turn a dictionary into a list</a>
<a name="ln2762">///</a>
<a name="ln2763">/// @param[in] tv      Dictionary to convert. Is checked for actually being</a>
<a name="ln2764">///                    a dictionary, will give an error if not.</a>
<a name="ln2765">/// @param[out] rettv  Location where result will be saved.</a>
<a name="ln2766">/// @param[in] what    What to save in rettv.</a>
<a name="ln2767">static void tv_dict_list(typval_T *const tv, typval_T *const rettv, const DictListType what)</a>
<a name="ln2768">{</a>
<a name="ln2769">  if (tv-&gt;v_type != VAR_DICT) {</a>
<a name="ln2770">    emsg(_(e_dictreq));</a>
<a name="ln2771">    return;</a>
<a name="ln2772">  }</a>
<a name="ln2773">  if (tv-&gt;vval.v_dict == NULL) {</a>
<a name="ln2774">    return;</a>
<a name="ln2775">  }</a>
<a name="ln2776"> </a>
<a name="ln2777">  tv_list_alloc_ret(rettv, tv_dict_len(tv-&gt;vval.v_dict));</a>
<a name="ln2778"> </a>
<a name="ln2779">  TV_DICT_ITER(tv-&gt;vval.v_dict, di, {</a>
<a name="ln2780">    typval_T tv_item = { .v_lock = VAR_UNLOCKED };</a>
<a name="ln2781"> </a>
<a name="ln2782">    switch (what) {</a>
<a name="ln2783">      case kDictListKeys:</a>
<a name="ln2784">        tv_item.v_type = VAR_STRING;</a>
<a name="ln2785">        tv_item.vval.v_string = xstrdup((char *)di-&gt;di_key);</a>
<a name="ln2786">        break;</a>
<a name="ln2787">      case kDictListValues:</a>
<a name="ln2788">        tv_copy(&amp;di-&gt;di_tv, &amp;tv_item);</a>
<a name="ln2789">        break;</a>
<a name="ln2790">      case kDictListItems: {</a>
<a name="ln2791">        // items()</a>
<a name="ln2792">        list_T *const sub_l = tv_list_alloc(2);</a>
<a name="ln2793">        tv_item.v_type = VAR_LIST;</a>
<a name="ln2794">        tv_item.vval.v_list = sub_l;</a>
<a name="ln2795">        tv_list_ref(sub_l);</a>
<a name="ln2796"> </a>
<a name="ln2797">        tv_list_append_owned_tv(sub_l, (typval_T) {</a>
<a name="ln2798">          .v_type = VAR_STRING,</a>
<a name="ln2799">          .v_lock = VAR_UNLOCKED,</a>
<a name="ln2800">          .vval.v_string = xstrdup((const char *)di-&gt;di_key),</a>
<a name="ln2801">        });</a>
<a name="ln2802"> </a>
<a name="ln2803">        tv_list_append_tv(sub_l, &amp;di-&gt;di_tv);</a>
<a name="ln2804"> </a>
<a name="ln2805">        break;</a>
<a name="ln2806">      }</a>
<a name="ln2807">    }</a>
<a name="ln2808"> </a>
<a name="ln2809">    tv_list_append_owned_tv(rettv-&gt;vval.v_list, tv_item);</a>
<a name="ln2810">  });</a>
<a name="ln2811">}</a>
<a name="ln2812"> </a>
<a name="ln2813">/// &quot;items(dict)&quot; function</a>
<a name="ln2814">void f_items(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2815">{</a>
<a name="ln2816">  tv_dict_list(argvars, rettv, 2);</a>
<a name="ln2817">}</a>
<a name="ln2818"> </a>
<a name="ln2819">/// &quot;keys()&quot; function</a>
<a name="ln2820">void f_keys(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2821">{</a>
<a name="ln2822">  tv_dict_list(argvars, rettv, 0);</a>
<a name="ln2823">}</a>
<a name="ln2824"> </a>
<a name="ln2825">/// &quot;values(dict)&quot; function</a>
<a name="ln2826">void f_values(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2827">{</a>
<a name="ln2828">  tv_dict_list(argvars, rettv, 1);</a>
<a name="ln2829">}</a>
<a name="ln2830"> </a>
<a name="ln2831">/// &quot;has_key()&quot; function</a>
<a name="ln2832">void f_has_key(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2833">{</a>
<a name="ln2834">  if (argvars[0].v_type != VAR_DICT) {</a>
<a name="ln2835">    emsg(_(e_dictreq));</a>
<a name="ln2836">    return;</a>
<a name="ln2837">  }</a>
<a name="ln2838">  if (argvars[0].vval.v_dict == NULL) {</a>
<a name="ln2839">    return;</a>
<a name="ln2840">  }</a>
<a name="ln2841"> </a>
<a name="ln2842">  rettv-&gt;vval.v_number = tv_dict_find(argvars[0].vval.v_dict,</a>
<a name="ln2843">                                      tv_get_string(&amp;argvars[1]),</a>
<a name="ln2844">                                      -1) != NULL;</a>
<a name="ln2845">}</a>
<a name="ln2846"> </a>
<a name="ln2847">/// &quot;remove({dict})&quot; function</a>
<a name="ln2848">void tv_dict_remove(typval_T *argvars, typval_T *rettv, const char *arg_errmsg)</a>
<a name="ln2849">{</a>
<a name="ln2850">  dict_T *d;</a>
<a name="ln2851">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2852">    semsg(_(e_toomanyarg), &quot;remove()&quot;);</a>
<a name="ln2853">  } else if ((d = argvars[0].vval.v_dict) != NULL</a>
<a name="ln2854">             &amp;&amp; !var_check_lock(d-&gt;dv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2855">    const char *key = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln2856">    if (key != NULL) {</a>
<a name="ln2857">      dictitem_T *di = tv_dict_find(d, key, -1);</a>
<a name="ln2858">      if (di == NULL) {</a>
<a name="ln2859">        semsg(_(e_dictkey), key);</a>
<a name="ln2860">      } else if (!var_check_fixed(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)</a>
<a name="ln2861">                 &amp;&amp; !var_check_ro(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2862">        *rettv = di-&gt;di_tv;</a>
<a name="ln2863">        di-&gt;di_tv = TV_INITIAL_VALUE;</a>
<a name="ln2864">        tv_dict_item_remove(d, di);</a>
<a name="ln2865">        if (tv_dict_is_watched(d)) {</a>
<a name="ln2866">          tv_dict_watcher_notify(d, key, NULL, rettv);</a>
<a name="ln2867">        }</a>
<a name="ln2868">      }</a>
<a name="ln2869">    }</a>
<a name="ln2870">  }</a>
<a name="ln2871">}</a>
<a name="ln2872"> </a>
<a name="ln2873">/// Allocate an empty blob for a return value.</a>
<a name="ln2874">///</a>
<a name="ln2875">/// Also sets reference count.</a>
<a name="ln2876">///</a>
<a name="ln2877">/// @param[out]  ret_tv  Structure where blob is saved.</a>
<a name="ln2878">void tv_blob_alloc_ret(typval_T *const ret_tv)</a>
<a name="ln2879">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2880">{</a>
<a name="ln2881">  blob_T *const b = tv_blob_alloc();</a>
<a name="ln2882">  tv_blob_set_ret(ret_tv, b);</a>
<a name="ln2883">}</a>
<a name="ln2884"> </a>
<a name="ln2885">/// Copy a blob typval to a different typval.</a>
<a name="ln2886">///</a>
<a name="ln2887">/// @param[in]  from  Blob object to copy from.</a>
<a name="ln2888">/// @param[out]  to  Blob object to copy to.</a>
<a name="ln2889">void tv_blob_copy(typval_T *const from, typval_T *const to)</a>
<a name="ln2890">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2891">{</a>
<a name="ln2892">  assert(from-&gt;v_type == VAR_BLOB);</a>
<a name="ln2893"> </a>
<a name="ln2894">  to-&gt;v_type = VAR_BLOB;</a>
<a name="ln2895">  to-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2896">  if (from-&gt;vval.v_blob == NULL) {</a>
<a name="ln2897">    to-&gt;vval.v_blob = NULL;</a>
<a name="ln2898">  } else {</a>
<a name="ln2899">    tv_blob_alloc_ret(to);</a>
<a name="ln2900">    int len = from-&gt;vval.v_blob-&gt;bv_ga.ga_len;</a>
<a name="ln2901"> </a>
<a name="ln2902">    if (len &gt; 0) {</a>
<a name="ln2903">      to-&gt;vval.v_blob-&gt;bv_ga.ga_data</a>
<a name="ln2904">        = xmemdup(from-&gt;vval.v_blob-&gt;bv_ga.ga_data, (size_t)len);</a>
<a name="ln2905">    }</a>
<a name="ln2906">    to-&gt;vval.v_blob-&gt;bv_ga.ga_len = len;</a>
<a name="ln2907">    to-&gt;vval.v_blob-&gt;bv_ga.ga_maxlen = len;</a>
<a name="ln2908">  }</a>
<a name="ln2909">}</a>
<a name="ln2910"> </a>
<a name="ln2911">//{{{3 Clear</a>
<a name="ln2912">#define TYPVAL_ENCODE_ALLOW_SPECIALS false</a>
<a name="ln2913"> </a>
<a name="ln2914">#define TYPVAL_ENCODE_CONV_NIL(tv) \</a>
<a name="ln2915">  do { \</a>
<a name="ln2916">    (tv)-&gt;vval.v_special = kSpecialVarNull; \</a>
<a name="ln2917">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2918">  } while (0)</a>
<a name="ln2919"> </a>
<a name="ln2920">#define TYPVAL_ENCODE_CONV_BOOL(tv, num) \</a>
<a name="ln2921">  do { \</a>
<a name="ln2922">    (tv)-&gt;vval.v_bool = kBoolVarFalse; \</a>
<a name="ln2923">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2924">  } while (0)</a>
<a name="ln2925"> </a>
<a name="ln2926">#define TYPVAL_ENCODE_CONV_NUMBER(tv, num) \</a>
<a name="ln2927">  do { \</a>
<a name="ln2928">    (void)(num); \</a>
<a name="ln2929">    (tv)-&gt;vval.v_number = 0; \</a>
<a name="ln2930">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2931">  } while (0)</a>
<a name="ln2932"> </a>
<a name="ln2933">#define TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER(tv, num)</a>
<a name="ln2934"> </a>
<a name="ln2935">#define TYPVAL_ENCODE_CONV_FLOAT(tv, flt) \</a>
<a name="ln2936">  do { \</a>
<a name="ln2937">    (tv)-&gt;vval.v_float = 0; \</a>
<a name="ln2938">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2939">  } while (0)</a>
<a name="ln2940"> </a>
<a name="ln2941">#define TYPVAL_ENCODE_CONV_STRING(tv, buf, len) \</a>
<a name="ln2942">  do { \</a>
<a name="ln2943">    xfree(buf); \</a>
<a name="ln2944">    (tv)-&gt;vval.v_string = NULL; \</a>
<a name="ln2945">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2946">  } while (0)</a>
<a name="ln2947"> </a>
<a name="ln2948">#define TYPVAL_ENCODE_CONV_STR_STRING(tv, buf, len)</a>
<a name="ln2949"> </a>
<a name="ln2950">#define TYPVAL_ENCODE_CONV_EXT_STRING(tv, buf, len, type)</a>
<a name="ln2951"> </a>
<a name="ln2952">#define TYPVAL_ENCODE_CONV_BLOB(tv, blob, len) \</a>
<a name="ln2953">  do { \</a>
<a name="ln2954">    tv_blob_unref((tv)-&gt;vval.v_blob); \</a>
<a name="ln2955">    (tv)-&gt;vval.v_blob = NULL; \</a>
<a name="ln2956">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln2957">  } while (0)</a>
<a name="ln2958"> </a>
<a name="ln2959">static inline int _nothing_conv_func_start(typval_T *const tv, char_u *const fun)</a>
<a name="ln2960">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2961">{</a>
<a name="ln2962">  tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln2963">  if (tv-&gt;v_type == VAR_PARTIAL) {</a>
<a name="ln2964">    partial_T *const pt_ = tv-&gt;vval.v_partial;</a>
<a name="ln2965">    if (pt_ != NULL &amp;&amp; pt_-&gt;pt_refcount &gt; 1) {</a>
<a name="ln2966">      pt_-&gt;pt_refcount--;</a>
<a name="ln2967">      tv-&gt;vval.v_partial = NULL;</a>
<a name="ln2968">      return OK;</a>
<a name="ln2969">    }</a>
<a name="ln2970">  } else {</a>
<a name="ln2971">    func_unref(fun);</a>
<a name="ln2972">    if ((const char *)fun != tv_empty_string) {</a>
<a name="ln2973">      xfree(fun);</a>
<a name="ln2974">    }</a>
<a name="ln2975">    tv-&gt;vval.v_string = NULL;</a>
<a name="ln2976">  }</a>
<a name="ln2977">  return NOTDONE;</a>
<a name="ln2978">}</a>
<a name="ln2979">#define TYPVAL_ENCODE_CONV_FUNC_START(tv, fun) \</a>
<a name="ln2980">  do { \</a>
<a name="ln2981">    if (_nothing_conv_func_start(tv, fun) != NOTDONE) { \</a>
<a name="ln2982">      return OK; \</a>
<a name="ln2983">    } \</a>
<a name="ln2984">  } while (0)</a>
<a name="ln2985"> </a>
<a name="ln2986">#define TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS(tv, len)</a>
<a name="ln2987">#define TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF(tv, len)</a>
<a name="ln2988"> </a>
<a name="ln2989">static inline void _nothing_conv_func_end(typval_T *const tv, const int copyID)</a>
<a name="ln2990">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2991">{</a>
<a name="ln2992">  if (tv-&gt;v_type == VAR_PARTIAL) {</a>
<a name="ln2993">    partial_T *const pt = tv-&gt;vval.v_partial;</a>
<a name="ln2994">    if (pt == NULL) {</a>
<a name="ln2995">      return;</a>
<a name="ln2996">    }</a>
<a name="ln2997">    // Dictionary should already be freed by the time.</a>
<a name="ln2998">    // If it was not freed then it is a part of the reference cycle.</a>
<a name="ln2999">    assert(pt-&gt;pt_dict == NULL || pt-&gt;pt_dict-&gt;dv_copyID == copyID);</a>
<a name="ln3000">    pt-&gt;pt_dict = NULL;</a>
<a name="ln3001">    // As well as all arguments.</a>
<a name="ln3002">    pt-&gt;pt_argc = 0;</a>
<a name="ln3003">    assert(pt-&gt;pt_refcount &lt;= 1);</a>
<a name="ln3004">    partial_unref(pt);</a>
<a name="ln3005">    tv-&gt;vval.v_partial = NULL;</a>
<a name="ln3006">    assert(tv-&gt;v_lock == VAR_UNLOCKED);</a>
<a name="ln3007">  }</a>
<a name="ln3008">}</a>
<a name="ln3009">#define TYPVAL_ENCODE_CONV_FUNC_END(tv) _nothing_conv_func_end(tv, copyID)</a>
<a name="ln3010"> </a>
<a name="ln3011">#define TYPVAL_ENCODE_CONV_EMPTY_LIST(tv) \</a>
<a name="ln3012">  do { \</a>
<a name="ln3013">    tv_list_unref((tv)-&gt;vval.v_list); \</a>
<a name="ln3014">    (tv)-&gt;vval.v_list = NULL; \</a>
<a name="ln3015">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln3016">  } while (0)</a>
<a name="ln3017"> </a>
<a name="ln3018">static inline void _nothing_conv_empty_dict(typval_T *const tv, dict_T **const dictp)</a>
<a name="ln3019">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln3020">{</a>
<a name="ln3021">  tv_dict_unref(*dictp);</a>
<a name="ln3022">  *dictp = NULL;</a>
<a name="ln3023">  if (tv != NULL) {</a>
<a name="ln3024">    tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln3025">  }</a>
<a name="ln3026">}</a>
<a name="ln3027">#define TYPVAL_ENCODE_CONV_EMPTY_DICT(tv, dict) \</a>
<a name="ln3028">  do { \</a>
<a name="ln3029">    assert((void *)&amp;(dict) != (void *)&amp;TYPVAL_ENCODE_NODICT_VAR); \</a>
<a name="ln3030">    _nothing_conv_empty_dict(tv, ((dict_T **)&amp;(dict))); \</a>
<a name="ln3031">  } while (0)</a>
<a name="ln3032"> </a>
<a name="ln3033">static inline int _nothing_conv_real_list_after_start(typval_T *const tv,</a>
<a name="ln3034">                                                      MPConvStackVal *const mpsv)</a>
<a name="ln3035">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3036">{</a>
<a name="ln3037">  assert(tv != NULL);</a>
<a name="ln3038">  tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln3039">  if (tv-&gt;vval.v_list-&gt;lv_refcount &gt; 1) {</a>
<a name="ln3040">    tv-&gt;vval.v_list-&gt;lv_refcount--;</a>
<a name="ln3041">    tv-&gt;vval.v_list = NULL;</a>
<a name="ln3042">    mpsv-&gt;data.l.li = NULL;</a>
<a name="ln3043">    return OK;</a>
<a name="ln3044">  }</a>
<a name="ln3045">  return NOTDONE;</a>
<a name="ln3046">}</a>
<a name="ln3047">#define TYPVAL_ENCODE_CONV_LIST_START(tv, len)</a>
<a name="ln3048"> </a>
<a name="ln3049">#define TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START(tv, mpsv) \</a>
<a name="ln3050">  do { \</a>
<a name="ln3051">    if (_nothing_conv_real_list_after_start(tv, &amp;(mpsv)) != NOTDONE) { \</a>
<a name="ln3052">      goto typval_encode_stop_converting_one_item; \</a>
<a name="ln3053">    } \</a>
<a name="ln3054">  } while (0)</a>
<a name="ln3055"> </a>
<a name="ln3056">#define TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS(tv)</a>
<a name="ln3057"> </a>
<a name="ln3058">static inline void _nothing_conv_list_end(typval_T *const tv)</a>
<a name="ln3059">  FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln3060">{</a>
<a name="ln3061">  if (tv == NULL) {</a>
<a name="ln3062">    return;</a>
<a name="ln3063">  }</a>
<a name="ln3064">  assert(tv-&gt;v_type == VAR_LIST);</a>
<a name="ln3065">  list_T *const list = tv-&gt;vval.v_list;</a>
<a name="ln3066">  tv_list_unref(list);</a>
<a name="ln3067">  tv-&gt;vval.v_list = NULL;</a>
<a name="ln3068">}</a>
<a name="ln3069">#define TYPVAL_ENCODE_CONV_LIST_END(tv) _nothing_conv_list_end(tv)</a>
<a name="ln3070"> </a>
<a name="ln3071">static inline int _nothing_conv_real_dict_after_start(typval_T *const tv, dict_T **const dictp,</a>
<a name="ln3072">                                                      const void *const nodictvar,</a>
<a name="ln3073">                                                      MPConvStackVal *const mpsv)</a>
<a name="ln3074">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3075">{</a>
<a name="ln3076">  if (tv != NULL) {</a>
<a name="ln3077">    tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln3078">  }</a>
<a name="ln3079">  if ((const void *)dictp != nodictvar &amp;&amp; (*dictp)-&gt;dv_refcount &gt; 1) {</a>
<a name="ln3080">    (*dictp)-&gt;dv_refcount--;</a>
<a name="ln3081">    *dictp = NULL;</a>
<a name="ln3082">    mpsv-&gt;data.d.todo = 0;</a>
<a name="ln3083">    return OK;</a>
<a name="ln3084">  }</a>
<a name="ln3085">  return NOTDONE;</a>
<a name="ln3086">}</a>
<a name="ln3087">#define TYPVAL_ENCODE_CONV_DICT_START(tv, dict, len)</a>
<a name="ln3088"> </a>
<a name="ln3089">#define TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START(tv, dict, mpsv) \</a>
<a name="ln3090">  do { \</a>
<a name="ln3091">    if (_nothing_conv_real_dict_after_start(tv, (dict_T **)&amp;(dict), \</a>
<a name="ln3092">                                            (void *)&amp;TYPVAL_ENCODE_NODICT_VAR, &amp;(mpsv)) \</a>
<a name="ln3093">        != NOTDONE) { \</a>
<a name="ln3094">      goto typval_encode_stop_converting_one_item; \</a>
<a name="ln3095">    } \</a>
<a name="ln3096">  } while (0)</a>
<a name="ln3097"> </a>
<a name="ln3098">#define TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK(tv, dict)</a>
<a name="ln3099">#define TYPVAL_ENCODE_CONV_DICT_AFTER_KEY(tv, dict)</a>
<a name="ln3100">#define TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS(tv, dict)</a>
<a name="ln3101"> </a>
<a name="ln3102">static inline void _nothing_conv_dict_end(typval_T *const tv, dict_T **const dictp,</a>
<a name="ln3103">                                          const void *const nodictvar)</a>
<a name="ln3104">  FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln3105">{</a>
<a name="ln3106">  if ((const void *)dictp != nodictvar) {</a>
<a name="ln3107">    tv_dict_unref(*dictp);</a>
<a name="ln3108">    *dictp = NULL;</a>
<a name="ln3109">  }</a>
<a name="ln3110">}</a>
<a name="ln3111">#define TYPVAL_ENCODE_CONV_DICT_END(tv, dict) \</a>
<a name="ln3112">  _nothing_conv_dict_end(tv, (dict_T **)&amp;(dict), \</a>
<a name="ln3113">                         (void *)&amp;TYPVAL_ENCODE_NODICT_VAR)</a>
<a name="ln3114"> </a>
<a name="ln3115">#define TYPVAL_ENCODE_CONV_RECURSE(val, conv_type)</a>
<a name="ln3116"> </a>
<a name="ln3117">#define TYPVAL_ENCODE_SCOPE static</a>
<a name="ln3118">#define TYPVAL_ENCODE_NAME nothing</a>
<a name="ln3119">#define TYPVAL_ENCODE_FIRST_ARG_TYPE const void *const</a>
<a name="ln3120">#define TYPVAL_ENCODE_FIRST_ARG_NAME ignored</a>
<a name="ln3121">#include &quot;nvim/eval/typval_encode.c.h&quot;</a>
<a name="ln3122">#undef TYPVAL_ENCODE_SCOPE</a>
<a name="ln3123">#undef TYPVAL_ENCODE_NAME</a>
<a name="ln3124">#undef TYPVAL_ENCODE_FIRST_ARG_TYPE</a>
<a name="ln3125">#undef TYPVAL_ENCODE_FIRST_ARG_NAME</a>
<a name="ln3126"> </a>
<a name="ln3127">#undef TYPVAL_ENCODE_ALLOW_SPECIALS</a>
<a name="ln3128">#undef TYPVAL_ENCODE_CONV_NIL</a>
<a name="ln3129">#undef TYPVAL_ENCODE_CONV_BOOL</a>
<a name="ln3130">#undef TYPVAL_ENCODE_CONV_NUMBER</a>
<a name="ln3131">#undef TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</a>
<a name="ln3132">#undef TYPVAL_ENCODE_CONV_FLOAT</a>
<a name="ln3133">#undef TYPVAL_ENCODE_CONV_STRING</a>
<a name="ln3134">#undef TYPVAL_ENCODE_CONV_STR_STRING</a>
<a name="ln3135">#undef TYPVAL_ENCODE_CONV_EXT_STRING</a>
<a name="ln3136">#undef TYPVAL_ENCODE_CONV_BLOB</a>
<a name="ln3137">#undef TYPVAL_ENCODE_CONV_FUNC_START</a>
<a name="ln3138">#undef TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS</a>
<a name="ln3139">#undef TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF</a>
<a name="ln3140">#undef TYPVAL_ENCODE_CONV_FUNC_END</a>
<a name="ln3141">#undef TYPVAL_ENCODE_CONV_EMPTY_LIST</a>
<a name="ln3142">#undef TYPVAL_ENCODE_CONV_EMPTY_DICT</a>
<a name="ln3143">#undef TYPVAL_ENCODE_CONV_LIST_START</a>
<a name="ln3144">#undef TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START</a>
<a name="ln3145">#undef TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS</a>
<a name="ln3146">#undef TYPVAL_ENCODE_CONV_LIST_END</a>
<a name="ln3147">#undef TYPVAL_ENCODE_CONV_DICT_START</a>
<a name="ln3148">#undef TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START</a>
<a name="ln3149">#undef TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</a>
<a name="ln3150">#undef TYPVAL_ENCODE_CONV_DICT_AFTER_KEY</a>
<a name="ln3151">#undef TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS</a>
<a name="ln3152">#undef TYPVAL_ENCODE_CONV_DICT_END</a>
<a name="ln3153">#undef TYPVAL_ENCODE_CONV_RECURSE</a>
<a name="ln3154"> </a>
<a name="ln3155">/// Free memory for a variable value and set the value to NULL or 0</a>
<a name="ln3156">///</a>
<a name="ln3157">/// @param[in,out]  tv  Value to free.</a>
<a name="ln3158">void tv_clear(typval_T *const tv)</a>
<a name="ln3159">{</a>
<a name="ln3160">  if (tv != NULL &amp;&amp; tv-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln3161">    // WARNING: do not translate the string here, gettext is slow and function</a>
<a name="ln3162">    // is used *very* often. At the current state encode_vim_to_nothing() does</a>
<a name="ln3163">    // not error out and does not use the argument anywhere.</a>
<a name="ln3164">    //</a>
<a name="ln3165">    // If situation changes and this argument will be used, translate it in the</a>
<a name="ln3166">    // place where it is used.</a>
<a name="ln3167">    const int evn_ret = encode_vim_to_nothing(NULL, tv, &quot;tv_clear() argument&quot;);</a>
<a name="ln3168">    (void)evn_ret;</a>
<a name="ln3169">    assert(evn_ret == OK);</a>
<a name="ln3170">  }</a>
<a name="ln3171">}</a>
<a name="ln3172"> </a>
<a name="ln3173">//{{{3 Free</a>
<a name="ln3174"> </a>
<a name="ln3175">/// Free allocated VimL object and value stored inside</a>
<a name="ln3176">///</a>
<a name="ln3177">/// @param  tv  Object to free.</a>
<a name="ln3178">void tv_free(typval_T *tv)</a>
<a name="ln3179">{</a>
<a name="ln3180">  if (tv != NULL) {</a>
<a name="ln3181">    switch (tv-&gt;v_type) {</a>
<a name="ln3182">    case VAR_PARTIAL:</a>
<a name="ln3183">      partial_unref(tv-&gt;vval.v_partial);</a>
<a name="ln3184">      break;</a>
<a name="ln3185">    case VAR_FUNC:</a>
<a name="ln3186">      func_unref((char_u *)tv-&gt;vval.v_string);</a>
<a name="ln3187">      FALLTHROUGH;</a>
<a name="ln3188">    case VAR_STRING:</a>
<a name="ln3189">      xfree(tv-&gt;vval.v_string);</a>
<a name="ln3190">      break;</a>
<a name="ln3191">    case VAR_BLOB:</a>
<a name="ln3192">      tv_blob_unref(tv-&gt;vval.v_blob);</a>
<a name="ln3193">      break;</a>
<a name="ln3194">    case VAR_LIST:</a>
<a name="ln3195">      tv_list_unref(tv-&gt;vval.v_list);</a>
<a name="ln3196">      break;</a>
<a name="ln3197">    case VAR_DICT:</a>
<a name="ln3198">      tv_dict_unref(tv-&gt;vval.v_dict);</a>
<a name="ln3199">      break;</a>
<a name="ln3200">    case VAR_BOOL:</a>
<a name="ln3201">    case VAR_SPECIAL:</a>
<a name="ln3202">    case VAR_NUMBER:</a>
<a name="ln3203">    case VAR_FLOAT:</a>
<a name="ln3204">    case VAR_UNKNOWN:</a>
<a name="ln3205">      break;</a>
<a name="ln3206">    }</a>
<a name="ln3207">    xfree(tv);</a>
<a name="ln3208">  }</a>
<a name="ln3209">}</a>
<a name="ln3210"> </a>
<a name="ln3211">//{{{3 Copy</a>
<a name="ln3212"> </a>
<a name="ln3213">/// Copy typval from one location to another</a>
<a name="ln3214">///</a>
<a name="ln3215">/// When needed allocates string or increases reference count. Does not make</a>
<a name="ln3216">/// a copy of a container, but copies its reference!</a>
<a name="ln3217">///</a>
<a name="ln3218">/// It is OK for `from` and `to` to point to the same location; this is used to</a>
<a name="ln3219">/// make a copy later.</a>
<a name="ln3220">///</a>
<a name="ln3221">/// @param[in]  from  Location to copy from.</a>
<a name="ln3222">/// @param[out]  to  Location to copy to.</a>
<a name="ln3223">void tv_copy(const typval_T *const from, typval_T *const to)</a>
<a name="ln3224">{</a>
<a name="ln3225">  to-&gt;v_type = from-&gt;v_type;</a>
<a name="ln3226">  to-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln3227">  memmove(&amp;to-&gt;vval, &amp;from-&gt;vval, sizeof(to-&gt;vval));</a>
<a name="ln3228">  switch (from-&gt;v_type) {</a>
<a name="ln3229">  case VAR_NUMBER:</a>
<a name="ln3230">  case VAR_FLOAT:</a>
<a name="ln3231">  case VAR_BOOL:</a>
<a name="ln3232">  case VAR_SPECIAL:</a>
<a name="ln3233">    break;</a>
<a name="ln3234">  case VAR_STRING:</a>
<a name="ln3235">  case VAR_FUNC:</a>
<a name="ln3236">    if (from-&gt;vval.v_string != NULL) {</a>
<a name="ln3237">      to-&gt;vval.v_string = xstrdup(from-&gt;vval.v_string);</a>
<a name="ln3238">      if (from-&gt;v_type == VAR_FUNC) {</a>
<a name="ln3239">        func_ref((char_u *)to-&gt;vval.v_string);</a>
<a name="ln3240">      }</a>
<a name="ln3241">    }</a>
<a name="ln3242">    break;</a>
<a name="ln3243">  case VAR_PARTIAL:</a>
<a name="ln3244">    if (to-&gt;vval.v_partial != NULL) {</a>
<a name="ln3245">      to-&gt;vval.v_partial-&gt;pt_refcount++;</a>
<a name="ln3246">    }</a>
<a name="ln3247">    break;</a>
<a name="ln3248">  case VAR_BLOB:</a>
<a name="ln3249">    if (from-&gt;vval.v_blob != NULL) {</a>
<a name="ln3250">      to-&gt;vval.v_blob-&gt;bv_refcount++;</a>
<a name="ln3251">    }</a>
<a name="ln3252">    break;</a>
<a name="ln3253">  case VAR_LIST:</a>
<a name="ln3254">    tv_list_ref(to-&gt;vval.v_list);</a>
<a name="ln3255">    break;</a>
<a name="ln3256">  case VAR_DICT:</a>
<a name="ln3257">    if (from-&gt;vval.v_dict != NULL) {</a>
<a name="ln3258">      to-&gt;vval.v_dict-&gt;dv_refcount++;</a>
<a name="ln3259">    }</a>
<a name="ln3260">    break;</a>
<a name="ln3261">  case VAR_UNKNOWN:</a>
<a name="ln3262">    semsg(_(e_intern2), &quot;tv_copy(UNKNOWN)&quot;);</a>
<a name="ln3263">    break;</a>
<a name="ln3264">  }</a>
<a name="ln3265">}</a>
<a name="ln3266"> </a>
<a name="ln3267">//{{{2 Locks</a>
<a name="ln3268"> </a>
<a name="ln3269">/// Lock or unlock an item</a>
<a name="ln3270">///</a>
<a name="ln3271">/// @param[out]  tv  Item to (un)lock.</a>
<a name="ln3272">/// @param[in]  deep  Levels to (un)lock, -1 to (un)lock everything.</a>
<a name="ln3273">/// @param[in]  lock  True if it is needed to lock an item, false to unlock.</a>
<a name="ln3274">/// @param[in]  check_refcount  If true, do not lock a list or dict with a</a>
<a name="ln3275">///                             reference count larger than 1.</a>
<a name="ln3276">void tv_item_lock(typval_T *const tv, const int deep, const bool lock, const bool check_refcount)</a>
<a name="ln3277">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3278">{</a>
<a name="ln3279">  // TODO(ZyX-I): Make this not recursive</a>
<a name="ln3280">  static int recurse = 0;</a>
<a name="ln3281"> </a>
<a name="ln3282">  if (recurse &gt;= DICT_MAXNEST) {</a>
<a name="ln3283">    emsg(_(&quot;E743: variable nested too deep for (un)lock&quot;));</a>
<a name="ln3284">    return;</a>
<a name="ln3285">  }</a>
<a name="ln3286">  if (deep == 0) {</a>
<a name="ln3287">    return;</a>
<a name="ln3288">  }</a>
<a name="ln3289">  recurse++;</a>
<a name="ln3290"> </a>
<a name="ln3291">  // lock/unlock the item itself</a>
<a name="ln3292">#define CHANGE_LOCK(lock, var) \</a>
<a name="ln3293">  do { \</a>
<a name="ln3294">    (var) = ((VarLockStatus[]) { \</a>
<a name="ln3295">      [VAR_UNLOCKED] = ((lock) ? VAR_LOCKED : VAR_UNLOCKED), \</a>
<a name="ln3296">      [VAR_LOCKED] = ((lock) ? VAR_LOCKED : VAR_UNLOCKED), \</a>
<a name="ln3297">      [VAR_FIXED] = VAR_FIXED, \</a>
<a name="ln3298">    })[var]; \</a>
<a name="ln3299">  } while (0)</a>
<a name="ln3300">  CHANGE_LOCK(lock, tv-&gt;v_lock);</a>
<a name="ln3301"> </a>
<a name="ln3302">  switch (tv-&gt;v_type) {</a>
<a name="ln3303">  case VAR_BLOB: {</a>
<a name="ln3304">    blob_T *const b = tv-&gt;vval.v_blob;</a>
<a name="ln3305">    if (b != NULL &amp;&amp; !(check_refcount &amp;&amp; b-&gt;bv_refcount &gt; 1)) {</a>
<a name="ln3306">      CHANGE_LOCK(lock, b-&gt;bv_lock);</a>
<a name="ln3307">    }</a>
<a name="ln3308">    break;</a>
<a name="ln3309">  }</a>
<a name="ln3310">  case VAR_LIST: {</a>
<a name="ln3311">    list_T *const l = tv-&gt;vval.v_list;</a>
<a name="ln3312">    if (l != NULL &amp;&amp; !(check_refcount &amp;&amp; l-&gt;lv_refcount &gt; 1)) {</a>
<a name="ln3313">      CHANGE_LOCK(lock, l-&gt;lv_lock);</a>
<a name="ln3314">      if (deep &lt; 0 || deep &gt; 1) {</a>
<a name="ln3315">        // Recursive: lock/unlock the items the List contains.</a>
<a name="ln3316">        TV_LIST_ITER(l, li, {</a>
<a name="ln3317">            tv_item_lock(TV_LIST_ITEM_TV(li), deep - 1, lock, check_refcount);</a>
<a name="ln3318">          });</a>
<a name="ln3319">      }</a>
<a name="ln3320">    }</a>
<a name="ln3321">    break;</a>
<a name="ln3322">  }</a>
<a name="ln3323">  case VAR_DICT: {</a>
<a name="ln3324">    dict_T *const d = tv-&gt;vval.v_dict;</a>
<a name="ln3325">    if (d != NULL &amp;&amp; !(check_refcount &amp;&amp; d-&gt;dv_refcount &gt; 1)) {</a>
<a name="ln3326">      CHANGE_LOCK(lock, d-&gt;dv_lock);</a>
<a name="ln3327">      if (deep &lt; 0 || deep &gt; 1) {</a>
<a name="ln3328">        // recursive: lock/unlock the items the List contains</a>
<a name="ln3329">        TV_DICT_ITER(d, di, {</a>
<a name="ln3330">            tv_item_lock(&amp;di-&gt;di_tv, deep - 1, lock, check_refcount);</a>
<a name="ln3331">          });</a>
<a name="ln3332">      }</a>
<a name="ln3333">    }</a>
<a name="ln3334">    break;</a>
<a name="ln3335">  }</a>
<a name="ln3336">  case VAR_NUMBER:</a>
<a name="ln3337">  case VAR_FLOAT:</a>
<a name="ln3338">  case VAR_STRING:</a>
<a name="ln3339">  case VAR_FUNC:</a>
<a name="ln3340">  case VAR_PARTIAL:</a>
<a name="ln3341">  case VAR_BOOL:</a>
<a name="ln3342">  case VAR_SPECIAL:</a>
<a name="ln3343">    break;</a>
<a name="ln3344">  case VAR_UNKNOWN:</a>
<a name="ln3345">    abort();</a>
<a name="ln3346">  }</a>
<a name="ln3347">#undef CHANGE_LOCK</a>
<a name="ln3348">  recurse--;</a>
<a name="ln3349">}</a>
<a name="ln3350"> </a>
<a name="ln3351">/// Check whether VimL value is locked itself or refers to a locked container</a>
<a name="ln3352">///</a>
<a name="ln3353">/// @warning Fixed container is not the same as locked.</a>
<a name="ln3354">///</a>
<a name="ln3355">/// @param[in]  tv  Value to check.</a>
<a name="ln3356">///</a>
<a name="ln3357">/// @return True if value is locked, false otherwise.</a>
<a name="ln3358">bool tv_islocked(const typval_T *const tv)</a>
<a name="ln3359">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3360">{</a>
<a name="ln3361">  return ((tv-&gt;v_lock == VAR_LOCKED)</a>
<a name="ln3362">          || (tv-&gt;v_type == VAR_LIST</a>
<a name="ln3363">              &amp;&amp; (tv_list_locked(tv-&gt;vval.v_list) == VAR_LOCKED))</a>
<a name="ln3364">          || (tv-&gt;v_type == VAR_DICT</a>
<a name="ln3365">              &amp;&amp; tv-&gt;vval.v_dict != NULL</a>
<a name="ln3366">              &amp;&amp; (tv-&gt;vval.v_dict-&gt;dv_lock == VAR_LOCKED)));</a>
<a name="ln3367">}</a>
<a name="ln3368"> </a>
<a name="ln3369">/// Return true if typval is locked</a>
<a name="ln3370">///</a>
<a name="ln3371">/// Also gives an error message when typval is locked.</a>
<a name="ln3372">///</a>
<a name="ln3373">/// @param[in]  tv  Typval.</a>
<a name="ln3374">/// @param[in]  name  Variable name, used in the error message.</a>
<a name="ln3375">/// @param[in]  name_len  Variable name length. Use #TV_TRANSLATE to translate</a>
<a name="ln3376">///                       variable name and compute the length. Use #TV_CSTRING</a>
<a name="ln3377">///                       to compute the length with strlen() without</a>
<a name="ln3378">///                       translating.</a>
<a name="ln3379">///</a>
<a name="ln3380">///                       Both #TV_… values are used for optimization purposes:</a>
<a name="ln3381">///                       variable name with its length is needed only in case</a>
<a name="ln3382">///                       of error, when no error occurs computing them is</a>
<a name="ln3383">///                       a waste of CPU resources. This especially applies to</a>
<a name="ln3384">///                       gettext.</a>
<a name="ln3385">///</a>
<a name="ln3386">/// @return true if variable is locked, false otherwise.</a>
<a name="ln3387">bool tv_check_lock(const typval_T *tv, const char *name, size_t name_len)</a>
<a name="ln3388">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3389">{</a>
<a name="ln3390">  VarLockStatus lock = VAR_UNLOCKED;</a>
<a name="ln3391"> </a>
<a name="ln3392">  switch (tv-&gt;v_type) {</a>
<a name="ln3393">  case VAR_BLOB:</a>
<a name="ln3394">    if (tv-&gt;vval.v_blob != NULL) {</a>
<a name="ln3395">      lock = tv-&gt;vval.v_blob-&gt;bv_lock;</a>
<a name="ln3396">    }</a>
<a name="ln3397">    break;</a>
<a name="ln3398">  case VAR_LIST:</a>
<a name="ln3399">    if (tv-&gt;vval.v_list != NULL) {</a>
<a name="ln3400">      lock = tv-&gt;vval.v_list-&gt;lv_lock;</a>
<a name="ln3401">    }</a>
<a name="ln3402">    break;</a>
<a name="ln3403">  case VAR_DICT:</a>
<a name="ln3404">    if (tv-&gt;vval.v_dict != NULL) {</a>
<a name="ln3405">      lock = tv-&gt;vval.v_dict-&gt;dv_lock;</a>
<a name="ln3406">    }</a>
<a name="ln3407">    break;</a>
<a name="ln3408">  default:</a>
<a name="ln3409">    break;</a>
<a name="ln3410">  }</a>
<a name="ln3411">  return var_check_lock(tv-&gt;v_lock, name, name_len)</a>
<a name="ln3412">         || (lock != VAR_UNLOCKED &amp;&amp; var_check_lock(lock, name, name_len));</a>
<a name="ln3413">}</a>
<a name="ln3414"> </a>
<a name="ln3415">/// @return true if variable &quot;name&quot; is locked (immutable)</a>
<a name="ln3416">bool var_check_lock(VarLockStatus lock, const char *name, size_t name_len)</a>
<a name="ln3417">{</a>
<a name="ln3418">  const char *error_message = NULL;</a>
<a name="ln3419">  switch (lock) {</a>
<a name="ln3420">  case VAR_UNLOCKED:</a>
<a name="ln3421">    return false;</a>
<a name="ln3422">  case VAR_LOCKED:</a>
<a name="ln3423">    error_message = N_(&quot;E741: Value is locked: %.*s&quot;);</a>
<a name="ln3424">    break;</a>
<a name="ln3425">  case VAR_FIXED:</a>
<a name="ln3426">    error_message = N_(&quot;E742: Cannot change value of %.*s&quot;);</a>
<a name="ln3427">    break;</a>
<a name="ln3428">  }</a>
<a name="ln3429">  assert(error_message != NULL);</a>
<a name="ln3430"> </a>
<a name="ln3431">  if (name == NULL) {</a>
<a name="ln3432">    name = _(&quot;Unknown&quot;);</a>
<a name="ln3433">    name_len = strlen(name);</a>
<a name="ln3434">  } else if (name_len == TV_TRANSLATE) {</a>
<a name="ln3435">    name = _(name);</a>
<a name="ln3436">    name_len = strlen(name);</a>
<a name="ln3437">  } else if (name_len == TV_CSTRING) {</a>
<a name="ln3438">    name_len = strlen(name);</a>
<a name="ln3439">  }</a>
<a name="ln3440"> </a>
<a name="ln3441">  semsg(_(error_message), (int)name_len, name);</a>
<a name="ln3442"> </a>
<a name="ln3443">  return true;</a>
<a name="ln3444">}</a>
<a name="ln3445"> </a>
<a name="ln3446">//{{{2 Comparison</a>
<a name="ln3447"> </a>
<a name="ln3448">static int tv_equal_recurse_limit;</a>
<a name="ln3449"> </a>
<a name="ln3450">/// Compare two VimL values</a>
<a name="ln3451">///</a>
<a name="ln3452">/// Like &quot;==&quot;, but strings and numbers are different, as well as floats and</a>
<a name="ln3453">/// numbers.</a>
<a name="ln3454">///</a>
<a name="ln3455">/// @warning Too nested structures may be considered equal even if they are not.</a>
<a name="ln3456">///</a>
<a name="ln3457">/// @param[in]  tv1  First value to compare.</a>
<a name="ln3458">/// @param[in]  tv2  Second value to compare.</a>
<a name="ln3459">/// @param[in]  ic  True if case is to be ignored.</a>
<a name="ln3460">/// @param[in]  recursive  True when used recursively.</a>
<a name="ln3461">///</a>
<a name="ln3462">/// @return true if values are equal.</a>
<a name="ln3463">bool tv_equal(typval_T *const tv1, typval_T *const tv2, const bool ic, const bool recursive)</a>
<a name="ln3464">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3465">{</a>
<a name="ln3466">  // TODO(ZyX-I): Make this not recursive</a>
<a name="ln3467">  static int recursive_cnt = 0;  // Catch recursive loops.</a>
<a name="ln3468"> </a>
<a name="ln3469">  if (!(tv_is_func(*tv1) &amp;&amp; tv_is_func(*tv2)) &amp;&amp; tv1-&gt;v_type != tv2-&gt;v_type) {</a>
<a name="ln3470">    return false;</a>
<a name="ln3471">  }</a>
<a name="ln3472"> </a>
<a name="ln3473">  // Catch lists and dicts that have an endless loop by limiting</a>
<a name="ln3474">  // recursiveness to a limit.  We guess they are equal then.</a>
<a name="ln3475">  // A fixed limit has the problem of still taking an awful long time.</a>
<a name="ln3476">  // Reduce the limit every time running into it. That should work fine for</a>
<a name="ln3477">  // deeply linked structures that are not recursively linked and catch</a>
<a name="ln3478">  // recursiveness quickly.</a>
<a name="ln3479">  if (!recursive) {</a>
<a name="ln3480">    tv_equal_recurse_limit = 1000;</a>
<a name="ln3481">  }</a>
<a name="ln3482">  if (recursive_cnt &gt;= tv_equal_recurse_limit) {</a>
<a name="ln3483">    tv_equal_recurse_limit--;</a>
<a name="ln3484">    return true;</a>
<a name="ln3485">  }</a>
<a name="ln3486"> </a>
<a name="ln3487">  switch (tv1-&gt;v_type) {</a>
<a name="ln3488">  case VAR_LIST: {</a>
<a name="ln3489">    recursive_cnt++;</a>
<a name="ln3490">    const bool r = tv_list_equal(tv1-&gt;vval.v_list, tv2-&gt;vval.v_list, ic,</a>
<a name="ln3491">                                 true);</a>
<a name="ln3492">    recursive_cnt--;</a>
<a name="ln3493">    return r;</a>
<a name="ln3494">  }</a>
<a name="ln3495">  case VAR_DICT: {</a>
<a name="ln3496">    recursive_cnt++;</a>
<a name="ln3497">    const bool r = tv_dict_equal(tv1-&gt;vval.v_dict, tv2-&gt;vval.v_dict, ic,</a>
<a name="ln3498">                                 true);</a>
<a name="ln3499">    recursive_cnt--;</a>
<a name="ln3500">    return r;</a>
<a name="ln3501">  }</a>
<a name="ln3502">  case VAR_PARTIAL:</a>
<a name="ln3503">  case VAR_FUNC: {</a>
<a name="ln3504">    if ((tv1-&gt;v_type == VAR_PARTIAL &amp;&amp; tv1-&gt;vval.v_partial == NULL)</a>
<a name="ln3505">        || (tv2-&gt;v_type == VAR_PARTIAL &amp;&amp; tv2-&gt;vval.v_partial == NULL)) {</a>
<a name="ln3506">      return false;</a>
<a name="ln3507">    }</a>
<a name="ln3508">    recursive_cnt++;</a>
<a name="ln3509">    const bool r = func_equal(tv1, tv2, ic);</a>
<a name="ln3510">    recursive_cnt--;</a>
<a name="ln3511">    return r;</a>
<a name="ln3512">  }</a>
<a name="ln3513">  case VAR_BLOB:</a>
<a name="ln3514">    return tv_blob_equal(tv1-&gt;vval.v_blob, tv2-&gt;vval.v_blob);</a>
<a name="ln3515">  case VAR_NUMBER:</a>
<a name="ln3516">    return tv1-&gt;vval.v_number == tv2-&gt;vval.v_number;</a>
<a name="ln3517">  case VAR_FLOAT:</a>
<a name="ln3518">    return tv1-&gt;vval.v_float == tv2-&gt;vval.v_float;</a>
<a name="ln3519">  case VAR_STRING: {</a>
<a name="ln3520">    char buf1[NUMBUFLEN];</a>
<a name="ln3521">    char buf2[NUMBUFLEN];</a>
<a name="ln3522">    const char *s1 = tv_get_string_buf(tv1, buf1);</a>
<a name="ln3523">    const char *s2 = tv_get_string_buf(tv2, buf2);</a>
<a name="ln3524">    return mb_strcmp_ic(ic, s1, s2) == 0;</a>
<a name="ln3525">  }</a>
<a name="ln3526">  case VAR_BOOL:</a>
<a name="ln3527">    return tv1-&gt;vval.v_bool == tv2-&gt;vval.v_bool;</a>
<a name="ln3528">  case VAR_SPECIAL:</a>
<a name="ln3529">    return tv1-&gt;vval.v_special == tv2-&gt;vval.v_special;</a>
<a name="ln3530">  case VAR_UNKNOWN:</a>
<a name="ln3531">    // VAR_UNKNOWN can be the result of an invalid expression, let’s say it</a>
<a name="ln3532">    // does not equal anything, not even self.</a>
<a name="ln3533">    return false;</a>
<a name="ln3534">  }</a>
<a name="ln3535"> </a>
<a name="ln3536">  abort();</a>
<a name="ln3537">  return false;</a>
<a name="ln3538">}</a>
<a name="ln3539"> </a>
<a name="ln3540">//{{{2 Type checks</a>
<a name="ln3541"> </a>
<a name="ln3542">/// Check that given value is a number or string</a>
<a name="ln3543">///</a>
<a name="ln3544">/// Error messages are compatible with tv_get_number() previously used for the</a>
<a name="ln3545">/// same purpose in buf*() functions. Special values are not accepted (previous</a>
<a name="ln3546">/// behaviour: silently fail to find buffer).</a>
<a name="ln3547">///</a>
<a name="ln3548">/// @param[in]  tv  Value to check.</a>
<a name="ln3549">///</a>
<a name="ln3550">/// @return true if everything is OK, false otherwise.</a>
<a name="ln3551">bool tv_check_str_or_nr(const typval_T *const tv)</a>
<a name="ln3552">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3553">{</a>
<a name="ln3554">  switch (tv-&gt;v_type) {</a>
<a name="ln3555">  case VAR_NUMBER:</a>
<a name="ln3556">  case VAR_STRING:</a>
<a name="ln3557">    return true;</a>
<a name="ln3558">  case VAR_FLOAT:</a>
<a name="ln3559">    emsg(_(&quot;E805: Expected a Number or a String, Float found&quot;));</a>
<a name="ln3560">    return false;</a>
<a name="ln3561">  case VAR_PARTIAL:</a>
<a name="ln3562">  case VAR_FUNC:</a>
<a name="ln3563">    emsg(_(&quot;E703: Expected a Number or a String, Funcref found&quot;));</a>
<a name="ln3564">    return false;</a>
<a name="ln3565">  case VAR_LIST:</a>
<a name="ln3566">    emsg(_(&quot;E745: Expected a Number or a String, List found&quot;));</a>
<a name="ln3567">    return false;</a>
<a name="ln3568">  case VAR_DICT:</a>
<a name="ln3569">    emsg(_(&quot;E728: Expected a Number or a String, Dictionary found&quot;));</a>
<a name="ln3570">    return false;</a>
<a name="ln3571">  case VAR_BLOB:</a>
<a name="ln3572">    emsg(_(&quot;E974: Expected a Number or a String, Blob found&quot;));</a>
<a name="ln3573">    return false;</a>
<a name="ln3574">  case VAR_BOOL:</a>
<a name="ln3575">    emsg(_(&quot;E5299: Expected a Number or a String, Boolean found&quot;));</a>
<a name="ln3576">    return false;</a>
<a name="ln3577">  case VAR_SPECIAL:</a>
<a name="ln3578">    emsg(_(&quot;E5300: Expected a Number or a String&quot;));</a>
<a name="ln3579">    return false;</a>
<a name="ln3580">  case VAR_UNKNOWN:</a>
<a name="ln3581">    semsg(_(e_intern2), &quot;tv_check_str_or_nr(UNKNOWN)&quot;);</a>
<a name="ln3582">    return false;</a>
<a name="ln3583">  }</a>
<a name="ln3584">  abort();</a>
<a name="ln3585">  return false;</a>
<a name="ln3586">}</a>
<a name="ln3587"> </a>
<a name="ln3588">#define FUNC_ERROR &quot;E703: Using a Funcref as a Number&quot;</a>
<a name="ln3589"> </a>
<a name="ln3590">static const char *const num_errors[] = {</a>
<a name="ln3591">  [VAR_PARTIAL]=N_(FUNC_ERROR),</a>
<a name="ln3592">  [VAR_FUNC]=N_(FUNC_ERROR),</a>
<a name="ln3593">  [VAR_LIST]=N_(&quot;E745: Using a List as a Number&quot;),</a>
<a name="ln3594">  [VAR_DICT]=N_(&quot;E728: Using a Dictionary as a Number&quot;),</a>
<a name="ln3595">  [VAR_FLOAT]=N_(&quot;E805: Using a Float as a Number&quot;),</a>
<a name="ln3596">  [VAR_BLOB]=N_(&quot;E974: Using a Blob as a Number&quot;),</a>
<a name="ln3597">  [VAR_UNKNOWN]=N_(&quot;E685: using an invalid value as a Number&quot;),</a>
<a name="ln3598">};</a>
<a name="ln3599"> </a>
<a name="ln3600">#undef FUNC_ERROR</a>
<a name="ln3601"> </a>
<a name="ln3602">/// Check that given value is a number or can be converted to it</a>
<a name="ln3603">///</a>
<a name="ln3604">/// Error messages are compatible with tv_get_number_chk() previously used for</a>
<a name="ln3605">/// the same purpose.</a>
<a name="ln3606">///</a>
<a name="ln3607">/// @param[in]  tv  Value to check.</a>
<a name="ln3608">///</a>
<a name="ln3609">/// @return true if everything is OK, false otherwise.</a>
<a name="ln3610">bool tv_check_num(const typval_T *const tv)</a>
<a name="ln3611">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3612">{</a>
<a name="ln3613">  switch (tv-&gt;v_type) {</a>
<a name="ln3614">  case VAR_NUMBER:</a>
<a name="ln3615">  case VAR_BOOL:</a>
<a name="ln3616">  case VAR_SPECIAL:</a>
<a name="ln3617">  case VAR_STRING:</a>
<a name="ln3618">    return true;</a>
<a name="ln3619">  case VAR_FUNC:</a>
<a name="ln3620">  case VAR_PARTIAL:</a>
<a name="ln3621">  case VAR_LIST:</a>
<a name="ln3622">  case VAR_DICT:</a>
<a name="ln3623">  case VAR_FLOAT:</a>
<a name="ln3624">  case VAR_BLOB:</a>
<a name="ln3625">  case VAR_UNKNOWN:</a>
<a name="ln3626">    emsg(_(num_errors[tv-&gt;v_type]));</a>
<a name="ln3627">    return false;</a>
<a name="ln3628">  }</a>
<a name="ln3629">  abort();</a>
<a name="ln3630">  return false;</a>
<a name="ln3631">}</a>
<a name="ln3632"> </a>
<a name="ln3633">#define FUNC_ERROR &quot;E729: using Funcref as a String&quot;</a>
<a name="ln3634"> </a>
<a name="ln3635">static const char *const str_errors[] = {</a>
<a name="ln3636">  [VAR_PARTIAL]=N_(FUNC_ERROR),</a>
<a name="ln3637">  [VAR_FUNC]=N_(FUNC_ERROR),</a>
<a name="ln3638">  [VAR_LIST]=N_(&quot;E730: using List as a String&quot;),</a>
<a name="ln3639">  [VAR_DICT]=N_(&quot;E731: using Dictionary as a String&quot;),</a>
<a name="ln3640">  [VAR_FLOAT]=((const char *)e_float_as_string),</a>
<a name="ln3641">  [VAR_BLOB]=N_(&quot;E976: using Blob as a String&quot;),</a>
<a name="ln3642">  [VAR_UNKNOWN]=N_(&quot;E908: using an invalid value as a String&quot;),</a>
<a name="ln3643">};</a>
<a name="ln3644"> </a>
<a name="ln3645">#undef FUNC_ERROR</a>
<a name="ln3646"> </a>
<a name="ln3647">/// Check that given value is a VimL String or can be &quot;cast&quot; to it.</a>
<a name="ln3648">///</a>
<a name="ln3649">/// Error messages are compatible with tv_get_string_chk() previously used for</a>
<a name="ln3650">/// the same purpose.</a>
<a name="ln3651">///</a>
<a name="ln3652">/// @param[in]  tv  Value to check.</a>
<a name="ln3653">///</a>
<a name="ln3654">/// @return true if everything is OK, false otherwise.</a>
<a name="ln3655">bool tv_check_str(const typval_T *const tv)</a>
<a name="ln3656">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3657">{</a>
<a name="ln3658">  switch (tv-&gt;v_type) {</a>
<a name="ln3659">  case VAR_NUMBER:</a>
<a name="ln3660">  case VAR_BOOL:</a>
<a name="ln3661">  case VAR_SPECIAL:</a>
<a name="ln3662">  case VAR_STRING:</a>
<a name="ln3663">    return true;</a>
<a name="ln3664">  case VAR_PARTIAL:</a>
<a name="ln3665">  case VAR_FUNC:</a>
<a name="ln3666">  case VAR_LIST:</a>
<a name="ln3667">  case VAR_DICT:</a>
<a name="ln3668">  case VAR_FLOAT:</a>
<a name="ln3669">  case VAR_BLOB:</a>
<a name="ln3670">  case VAR_UNKNOWN:</a>
<a name="ln3671">    emsg(_(str_errors[tv-&gt;v_type]));</a>
<a name="ln3672">    return false;</a>
<a name="ln3673">  }</a>
<a name="ln3674">  abort();</a>
<a name="ln3675">  return false;</a>
<a name="ln3676">}</a>
<a name="ln3677"> </a>
<a name="ln3678">//{{{2 Get</a>
<a name="ln3679"> </a>
<a name="ln3680">/// Get the number value of a VimL object</a>
<a name="ln3681">///</a>
<a name="ln3682">/// @note Use tv_get_number_chk() if you need to determine whether there was an</a>
<a name="ln3683">///       error.</a>
<a name="ln3684">///</a>
<a name="ln3685">/// @param[in]  tv  Object to get value from.</a>
<a name="ln3686">///</a>
<a name="ln3687">/// @return Number value: vim_str2nr() output for VAR_STRING objects, value</a>
<a name="ln3688">///         for VAR_NUMBER objects, -1 for other types.</a>
<a name="ln3689">varnumber_T tv_get_number(const typval_T *const tv)</a>
<a name="ln3690">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3691">{</a>
<a name="ln3692">  bool error = false;</a>
<a name="ln3693">  return tv_get_number_chk(tv, &amp;error);</a>
<a name="ln3694">}</a>
<a name="ln3695"> </a>
<a name="ln3696">/// Get the number value of a VimL object</a>
<a name="ln3697">///</a>
<a name="ln3698">/// @param[in]  tv  Object to get value from.</a>
<a name="ln3699">/// @param[out]  ret_error  If type error occurred then `true` will be written</a>
<a name="ln3700">///                         to this location. Otherwise it is not touched.</a>
<a name="ln3701">///</a>
<a name="ln3702">///                         @note Needs to be initialized to `false` to be</a>
<a name="ln3703">///                               useful.</a>
<a name="ln3704">///</a>
<a name="ln3705">/// @return Number value: vim_str2nr() output for VAR_STRING objects, value</a>
<a name="ln3706">///         for VAR_NUMBER objects, -1 (ret_error == NULL) or 0 (otherwise) for</a>
<a name="ln3707">///         other types.</a>
<a name="ln3708">varnumber_T tv_get_number_chk(const typval_T *const tv, bool *const ret_error)</a>
<a name="ln3709">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3710">{</a>
<a name="ln3711">  switch (tv-&gt;v_type) {</a>
<a name="ln3712">  case VAR_FUNC:</a>
<a name="ln3713">  case VAR_PARTIAL:</a>
<a name="ln3714">  case VAR_LIST:</a>
<a name="ln3715">  case VAR_DICT:</a>
<a name="ln3716">  case VAR_BLOB:</a>
<a name="ln3717">  case VAR_FLOAT:</a>
<a name="ln3718">    emsg(_(num_errors[tv-&gt;v_type]));</a>
<a name="ln3719">    break;</a>
<a name="ln3720">  case VAR_NUMBER:</a>
<a name="ln3721">    return tv-&gt;vval.v_number;</a>
<a name="ln3722">  case VAR_STRING: {</a>
<a name="ln3723">    varnumber_T n = 0;</a>
<a name="ln3724">    if (tv-&gt;vval.v_string != NULL) {</a>
<a name="ln3725">      vim_str2nr(tv-&gt;vval.v_string, NULL, NULL, STR2NR_ALL, &amp;n, NULL, 0, false);</a>
<a name="ln3726">    }</a>
<a name="ln3727">    return n;</a>
<a name="ln3728">  }</a>
<a name="ln3729">  case VAR_BOOL:</a>
<a name="ln3730">    return tv-&gt;vval.v_bool == kBoolVarTrue ? 1 : 0;</a>
<a name="ln3731">  case VAR_SPECIAL:</a>
<a name="ln3732">    return 0;</a>
<a name="ln3733">  case VAR_UNKNOWN:</a>
<a name="ln3734">    semsg(_(e_intern2), &quot;tv_get_number(UNKNOWN)&quot;);</a>
<a name="ln3735">    break;</a>
<a name="ln3736">  }</a>
<a name="ln3737">  if (ret_error != NULL) {</a>
<a name="ln3738">    *ret_error = true;</a>
<a name="ln3739">  }</a>
<a name="ln3740">  return (ret_error == NULL ? -1 : 0);</a>
<a name="ln3741">}</a>
<a name="ln3742"> </a>
<a name="ln3743">/// Get the line number from VimL object</a>
<a name="ln3744">///</a>
<a name="ln3745">/// @param[in]  tv  Object to get value from. Is expected to be a number or</a>
<a name="ln3746">///                 a special string like &quot;.&quot;, &quot;$&quot;, … (works with current buffer</a>
<a name="ln3747">///                 only).</a>
<a name="ln3748">///</a>
<a name="ln3749">/// @return Line number or -1 or 0.</a>
<a name="ln3750">linenr_T tv_get_lnum(const typval_T *const tv)</a>
<a name="ln3751">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3752">{</a>
<a name="ln3753">  const int did_emsg_before = did_emsg;</a>
<a name="ln3754">  linenr_T lnum = (linenr_T)tv_get_number_chk(tv, NULL);</a>
<a name="ln3755">  if (lnum &lt;= 0 &amp;&amp; did_emsg_before == did_emsg &amp;&amp; tv-&gt;v_type != VAR_NUMBER) {</a>
<a name="ln3756">    int fnum;</a>
<a name="ln3757">    // No valid number, try using same function as line() does.</a>
<a name="ln3758">    pos_T *const fp = var2fpos(tv, true, &amp;fnum, false);</a>
<a name="ln3759">    if (fp != NULL) {</a>
<a name="ln3760">      lnum = fp-&gt;lnum;</a>
<a name="ln3761">    }</a>
<a name="ln3762">  }</a>
<a name="ln3763">  return lnum;</a>
<a name="ln3764">}</a>
<a name="ln3765"> </a>
<a name="ln3766">/// Get the floating-point value of a VimL object</a>
<a name="ln3767">///</a>
<a name="ln3768">/// Raises an error if object is not number or floating-point.</a>
<a name="ln3769">///</a>
<a name="ln3770">/// @param[in]  tv  Object to get value of.</a>
<a name="ln3771">///</a>
<a name="ln3772">/// @return Floating-point value of the variable or zero.</a>
<a name="ln3773">float_T tv_get_float(const typval_T *const tv)</a>
<a name="ln3774">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3775">{</a>
<a name="ln3776">  switch (tv-&gt;v_type) {</a>
<a name="ln3777">  case VAR_NUMBER:</a>
<a name="ln3778">    return (float_T)(tv-&gt;vval.v_number);</a>
<a name="ln3779">  case VAR_FLOAT:</a>
<a name="ln3780">    return tv-&gt;vval.v_float;</a>
<a name="ln3781">  case VAR_PARTIAL:</a>
<a name="ln3782">  case VAR_FUNC:</a>
<a name="ln3783">    emsg(_(&quot;E891: Using a Funcref as a Float&quot;));</a>
<a name="ln3784">    break;</a>
<a name="ln3785">  case VAR_STRING:</a>
<a name="ln3786">    emsg(_(&quot;E892: Using a String as a Float&quot;));</a>
<a name="ln3787">    break;</a>
<a name="ln3788">  case VAR_LIST:</a>
<a name="ln3789">    emsg(_(&quot;E893: Using a List as a Float&quot;));</a>
<a name="ln3790">    break;</a>
<a name="ln3791">  case VAR_DICT:</a>
<a name="ln3792">    emsg(_(&quot;E894: Using a Dictionary as a Float&quot;));</a>
<a name="ln3793">    break;</a>
<a name="ln3794">  case VAR_BOOL:</a>
<a name="ln3795">    emsg(_(&quot;E362: Using a boolean value as a Float&quot;));</a>
<a name="ln3796">    break;</a>
<a name="ln3797">  case VAR_SPECIAL:</a>
<a name="ln3798">    emsg(_(&quot;E907: Using a special value as a Float&quot;));</a>
<a name="ln3799">    break;</a>
<a name="ln3800">  case VAR_BLOB:</a>
<a name="ln3801">    emsg(_(&quot;E975: Using a Blob as a Float&quot;));</a>
<a name="ln3802">    break;</a>
<a name="ln3803">  case VAR_UNKNOWN:</a>
<a name="ln3804">    semsg(_(e_intern2), &quot;tv_get_float(UNKNOWN)&quot;);</a>
<a name="ln3805">    break;</a>
<a name="ln3806">  }</a>
<a name="ln3807">  return 0;</a>
<a name="ln3808">}</a>
<a name="ln3809"> </a>
<a name="ln3810">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a string.</a>
<a name="ln3811">int tv_check_for_string_arg(const typval_T *const args, const int idx)</a>
<a name="ln3812">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln3813">{</a>
<a name="ln3814">  if (args[idx].v_type != VAR_STRING) {</a>
<a name="ln3815">    semsg(_(e_string_required_for_argument_nr), idx + 1);</a>
<a name="ln3816">    return FAIL;</a>
<a name="ln3817">  }</a>
<a name="ln3818">  return OK;</a>
<a name="ln3819">}</a>
<a name="ln3820"> </a>
<a name="ln3821">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a non-empty string.</a>
<a name="ln3822">int tv_check_for_nonempty_string_arg(const typval_T *const args, const int idx)</a>
<a name="ln3823">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln3824">{</a>
<a name="ln3825">  if (tv_check_for_string_arg(args, idx) == FAIL) {</a>
<a name="ln3826">    return FAIL;</a>
<a name="ln3827">  }</a>
<a name="ln3828">  if (args[idx].vval.v_string == NULL || *args[idx].vval.v_string == NUL) {</a>
<a name="ln3829">    semsg(_(e_non_empty_string_required_for_argument_nr), idx + 1);</a>
<a name="ln3830">    return FAIL;</a>
<a name="ln3831">  }</a>
<a name="ln3832">  return OK;</a>
<a name="ln3833">}</a>
<a name="ln3834"> </a>
<a name="ln3835">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a number.</a>
<a name="ln3836">int tv_check_for_number_arg(const typval_T *const args, const int idx)</a>
<a name="ln3837">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln3838">{</a>
<a name="ln3839">  if (args[idx].v_type != VAR_NUMBER) {</a>
<a name="ln3840">    semsg(_(e_number_required_for_argument_nr), idx + 1);</a>
<a name="ln3841">    return FAIL;</a>
<a name="ln3842">  }</a>
<a name="ln3843">  return OK;</a>
<a name="ln3844">}</a>
<a name="ln3845"> </a>
<a name="ln3846">/// Check for an optional number argument at &quot;idx&quot;</a>
<a name="ln3847">int tv_check_for_opt_number_arg(const typval_T *const args, const int idx)</a>
<a name="ln3848">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln3849">{</a>
<a name="ln3850">  return (args[idx].v_type == VAR_UNKNOWN</a>
<a name="ln3851">          || tv_check_for_number_arg(args, idx) != FAIL) ? OK : FAIL;</a>
<a name="ln3852">}</a>
<a name="ln3853"> </a>
<a name="ln3854">/// Get the string value of a &quot;stringish&quot; VimL object.</a>
<a name="ln3855">///</a>
<a name="ln3856">/// @param[in]  tv  Object to get value of.</a>
<a name="ln3857">/// @param  buf  Buffer used to hold numbers and special variables converted to</a>
<a name="ln3858">///              string. When function encounters one of these stringified value</a>
<a name="ln3859">///              will be written to buf and buf will be returned.</a>
<a name="ln3860">///</a>
<a name="ln3861">///              Buffer must have NUMBUFLEN size.</a>
<a name="ln3862">///</a>
<a name="ln3863">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln3864">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or NULL.</a>
<a name="ln3865">const char *tv_get_string_buf_chk(const typval_T *const tv, char *const buf)</a>
<a name="ln3866">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3867">{</a>
<a name="ln3868">  switch (tv-&gt;v_type) {</a>
<a name="ln3869">  case VAR_NUMBER:</a>
<a name="ln3870">    snprintf(buf, NUMBUFLEN, &quot;%&quot; PRIdVARNUMBER, tv-&gt;vval.v_number);  // -V576</a>
<a name="ln3871">    return buf;</a>
<a name="ln3872">  case VAR_STRING:</a>
<a name="ln3873">    if (tv-&gt;vval.v_string != NULL) {</a>
<a name="ln3874">      return (const char *)tv-&gt;vval.v_string;</a>
<a name="ln3875">    }</a>
<a name="ln3876">    return &quot;&quot;;</a>
<a name="ln3877">  case VAR_BOOL:</a>
<a name="ln3878">    STRCPY(buf, encode_bool_var_names[tv-&gt;vval.v_bool]);</a>
<a name="ln3879">    return buf;</a>
<a name="ln3880">  case VAR_SPECIAL:</a>
<a name="ln3881">    STRCPY(buf, encode_special_var_names[tv-&gt;vval.v_special]);</a>
<a name="ln3882">    return buf;</a>
<a name="ln3883">  case VAR_PARTIAL:</a>
<a name="ln3884">  case VAR_FUNC:</a>
<a name="ln3885">  case VAR_LIST:</a>
<a name="ln3886">  case VAR_DICT:</a>
<a name="ln3887">  case VAR_FLOAT:</a>
<a name="ln3888">  case VAR_BLOB:</a>
<a name="ln3889">  case VAR_UNKNOWN:</a>
<a name="ln3890">    emsg(_(str_errors[tv-&gt;v_type]));</a>
<a name="ln3891">    return NULL;</a>
<a name="ln3892">  }</a>
<a name="ln3893">  abort();</a>
<a name="ln3894">  return NULL;</a>
<a name="ln3895">}</a>
<a name="ln3896"> </a>
<a name="ln3897">/// Get the string value of a &quot;stringish&quot; VimL object.</a>
<a name="ln3898">///</a>
<a name="ln3899">/// @warning For number and special values it uses a single, static buffer. It</a>
<a name="ln3900">///          may be used only once, next call to tv_get_string may reuse it. Use</a>
<a name="ln3901">///          tv_get_string_buf() if you need to use tv_get_string() output after</a>
<a name="ln3902">///          calling it again.</a>
<a name="ln3903">///</a>
<a name="ln3904">/// @param[in]  tv  Object to get value of.</a>
<a name="ln3905">///</a>
<a name="ln3906">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln3907">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or NULL.</a>
<a name="ln3908">const char *tv_get_string_chk(const typval_T *const tv)</a>
<a name="ln3909">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3910">{</a>
<a name="ln3911">  static char mybuf[NUMBUFLEN];</a>
<a name="ln3912"> </a>
<a name="ln3913">  return tv_get_string_buf_chk(tv, mybuf);</a>
<a name="ln3914">}</a>
<a name="ln3915"> </a>
<a name="ln3916">/// Get the string value of a &quot;stringish&quot; VimL object.</a>
<a name="ln3917">///</a>
<a name="ln3918">/// @warning For number and special values it uses a single, static buffer. It</a>
<a name="ln3919">///          may be used only once, next call to tv_get_string may reuse it. Use</a>
<a name="ln3920">///          tv_get_string_buf() if you need to use tv_get_string() output after</a>
<a name="ln3921">///          calling it again.</a>
<a name="ln3922">///</a>
<a name="ln3923">/// @note tv_get_string_chk() and tv_get_string_buf_chk() are similar, but</a>
<a name="ln3924">///       return NULL on error.</a>
<a name="ln3925">///</a>
<a name="ln3926">/// @param[in]  tv  Object to get value of.</a>
<a name="ln3927">///</a>
<a name="ln3928">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln3929">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or empty</a>
<a name="ln3930">///         string.</a>
<a name="ln3931">const char *tv_get_string(const typval_T *const tv)</a>
<a name="ln3932">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3933">{</a>
<a name="ln3934">  static char mybuf[NUMBUFLEN];</a>
<a name="ln3935">  return tv_get_string_buf((typval_T *)tv, mybuf);</a>
<a name="ln3936">}</a>
<a name="ln3937"> </a>
<a name="ln3938">/// Get the string value of a &quot;stringish&quot; VimL object.</a>
<a name="ln3939">///</a>
<a name="ln3940">/// @note tv_get_string_chk() and tv_get_string_buf_chk() are similar, but</a>
<a name="ln3941">///       return NULL on error.</a>
<a name="ln3942">///</a>
<a name="ln3943">/// @param[in]  tv  Object to get value of.</a>
<a name="ln3944">/// @param  buf  Buffer used to hold numbers and special variables converted to</a>
<a name="ln3945">///              string. When function encounters one of these stringified value</a>
<a name="ln3946">///              will be written to buf and buf will be returned.</a>
<a name="ln3947">///</a>
<a name="ln3948">///              Buffer must have NUMBUFLEN size.</a>
<a name="ln3949">///</a>
<a name="ln3950">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln3951">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or empty</a>
<a name="ln3952">///         string.</a>
<a name="ln3953">const char *tv_get_string_buf(const typval_T *const tv, char *const buf)</a>
<a name="ln3954">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3955">{</a>
<a name="ln3956">  const char *const res = tv_get_string_buf_chk(tv, buf);</a>
<a name="ln3957"> </a>
<a name="ln3958">  return res != NULL ? res : &quot;&quot;;</a>
<a name="ln3959">}</a>
</code></pre>
<div class="balloon" rel="1237"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'info.item_compare_func_err' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>